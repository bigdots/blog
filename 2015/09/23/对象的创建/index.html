<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        yzg的个人站
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            对象的创建
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。每个对象都是基于一个引用类型创建的，这个引用类型可以是第5 章讨论的原生类型，也可以是开发人员定义的类型。</p>
<span id="more"></span>

<h3 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1. 字面量"></a>1. 字面量</h3><pre><code>var Person=&#123;
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function()&#123;
            alert(this.name);
        &#125;
    &#125;;
</code></pre>
<h3 id="2-通过new创建"><a href="#2-通过new创建" class="headerlink" title="2. 通过new创建"></a>2. 通过new创建</h3><pre><code>var Person = new object();

    Person.name = name;
    Person.age = age;
    Person.job = job;
    Person.sayName = function()&#123;
        alert(this.name);
    &#125;
   
</code></pre>
<h3 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3.工厂模式"></a>3.工厂模式</h3><p>工厂模式解决了创建多个相似对象的问题，但存在对象识别的问题。</p>
<pre><code>function person(name, age, job)&#123;
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function()&#123;
    alert(this.name);
  &#125;;
  return o;
&#125;
var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
</code></pre>
<h3 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4.构造函数"></a>4.构造函数</h3><p>直接将属性和方法赋给了this 对象；<br>构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</p>
<p>构造函数解决l了对象识别的问题，但它的每个方法都要在每个实例上重新创建一遍。</p>
<pre><code>function Person(name, age, job)&#123;
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function()&#123;
        alert(this.name);
    &#125;;
&#125;
var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);  //实例化
</code></pre>
<h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h3><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<p>原型模式实现了共享，但是所有属性都是共享的，牵一发而动全身，一个实例的变化会导致所有实例的变化。</p>
<pre><code>function Person()&#123;

&#125;
 
Person.prototype.name = &quot;Nicholas&quot;;
Person.prototype.age = 29;
Person.prototype.job = &quot;Software Engineer&quot;;
Person.prototype.sayName = function()&#123;
    alert(this.name);
&#125;;
var person1 = new Person();
person1.sayName();
</code></pre>
<p>或者</p>
<pre><code>function Person()&#123;

&#125;

Person.prototype = &#123;
　　name : &quot;Nicholas&quot;,
　　age : 29,
　　job: &quot;Software Engineer&quot;,
　　sayName : function () &#123;
　　    alert(this.name);
    &#125;
&#125;;
</code></pre>
<h3 id="6-原型-构造函数"><a href="#6-原型-构造函数" class="headerlink" title="6.原型+构造函数"></a>6.原型+构造函数</h3><pre><code>function Person(name, age, job)&#123;
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];
&#125;
Person.prototype = &#123;
    constructor : Person,
    sayName : function()&#123;
    alert(this.name);
    &#125;
&#125;
</code></pre>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="cbTPc8u7ho07U6TmlFC0RjK7">
<input type="hidden" id="valine_appKey" value="4hH8asmBIHG3iSVSUt8Hu5OP">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>