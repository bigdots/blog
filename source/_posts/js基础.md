---
title: javascript 基础
date: 2016-01-12 15:40:43
tags:
description:
categories: [js]
---

## [内存](http://www.jianshu.com/p/996671d4dcc4)

### 堆与栈

1. 堆内存类似书架，无关顺序，按地址取。

2. 栈内存类似羽毛球桶，先进后出。

### javascript中的内存
1. 严格意义上来说，javascript只有堆内存，基本类型值储存在变量对象中。而变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。

### 数据类型
1. 引用类型值： （对象），长度不固定，是按引用访问的。
2. 基本类型值：（Undefined、Null、Boolean、Number、String），长度固定，按值访问。

### 内存管理

1. 分配内存  （定义变量时）
2. 使用分配到的内存（数据处理等读、写操作）
3. 不需要时将其释放、归还 （简单方法是将null赋值给变量）

## 垃圾回收：
1. 在局部作用域中，当函数执行完毕，回收局部变量的值。
2. 在全局作用域中，当一个值不再有变量引用它时，会进行回收。

### 深浅拷贝

对象的简单赋值，只是浅拷贝，只是把引用拷贝给了新变量，并没有生成一个全新的对象值。


## [执行上下文（Execution Context）](http://www.jianshu.com/p/a6d37c77e8db)

一个执行上下文会形成一个作用域。一个JavaScript程序中，会有一个全局的执行上下文，并且遇到函数和eval都会生成一个新的执行上下文。

JavaScript引擎以堆栈的方式来处理执行上下文，这个堆栈，我们称其为**函数调用栈(call stack)**。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。每个执行上下文中的代码执行完毕后，这个执行上下文就会从从栈中弹出。

过程： 
1. 生成全局执行上下文，将其放入栈底
2. 执行栈顶上下文中的代码（一开始是全局执行上下文），遇到函数或者eval从而生成新的执行上下文，放入栈顶，并执行其中代码。
3. 当前执行上下文中的代码执行完毕，当前执行上下文从栈中弹出，继续步骤2，直至栈中只剩下全局上下文
4. 全局上下文只有唯一的一个，在应用关闭时出栈

### 执行上下文的生命周期
+ 创建阶段
    + 创建变量对象
    + 建立作用域链
    + 以及确定this的指向
+ 代码执行阶段（此时变量对象成为活动对象）
    + 变量赋值
    + 函数引用
    + 执行其他代码

## [变量对象](http://www.jianshu.com/p/330b1505e41d)

1. 变量对象的创建: （理解变量提升）
    + 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。
    + 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。
    + 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。

全局执行上下文的变量对象在浏览器中是window对象。

## 作用域链

作用域是引擎根据标识符名称进行变量查找的规则。（标识符，指的是变量名或者函数名）

> 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。


### 作用域与执行上下文

JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段**作用域**会确定。执行阶段由引擎完成，主要任务是执行可执行代码，**执行上下文**在这个阶段创建。

作用域在编译阶段生成，执行上下文在执行阶段生成，作用域链是在执行上下文的创建阶段生成的。

当前作用域与上层作用域不是包含关系。作用域链就是一个形似糖葫芦的单方向通道。


## this

this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的，指向当前执行上下文。

如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。


call，apply指定this指向的对象。

## 构造函数
通过new操作符调用构造函数，会经历以下4个阶段。

+ 创建一个新的对象；
+ 将构造函数的this指向这个新对象；
+ 为这个对象添加属性，方法等；
+ 返回新对象。


## 模块化

一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。

可以通过闭包来实现公有变量和公有方法。


## 隐式转换

当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString/vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。其中valueOf会比toString后执行