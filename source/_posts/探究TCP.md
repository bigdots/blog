title: 探究TCP
tags: [计算机网络]
date: 2016-03-16 11:00:52
description: TCP

---

我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)

## OSI
> OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

<!-- more -->

![](/images/201601/osi.jpg)

其中TCP处理transport层，主要是用来建立可靠的连接。 而建立连接的基础


## TCP
>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议

应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。

![](/images/201601/TCP.jpg)

+ Source Port / Destination Port:这个就是客户端口(源端口)和服务器端口(目的端口).端口就是用来区别主机中的不同进程，通过结合源IP和目的IP结合，得出唯一的TCP连接。

+ Sequence Number(seqNumber): 一般由客户端发送，用来表示报文段中第一个数据字节在数据流中的序号，主要用来解决网络包乱序的问题。

+ Acknowledgment Number(ACK): 即就是用来存放客户端发来的seqNumber的下一个信号(seqNumber+1). 只有当TCP flags中的ACK为1时才有效. 主要是用来解决不丢包的问题。

+ TCP flags: TCP中有6个首部，用来控制TCP连接的状态.取值为0,1.这6个有:URG，ACK，PSH，RST，SYN，FIN.

    + URG 当为1时，用来保证TCP连接不被中断, 并且将该次TCP内容数据的紧急程度提升(就是告诉电脑，你丫赶快把这个给resolve了)

    + ACK 通常是服务器端返回的。 用来表示应答是否有效。 1为有效，0为无效

    + PSH 表示，当数据包得到后，立马给应用程序使用(PUSH到最顶端)

    + RST 用来确保TCP连接的安全。 该flag用来表示 一个连接复位的请求。如果发生错误连接，则reset一次，重新连。当然也可以用来拒绝非法数据包。

    + SYN 同步的意思,通常是由客户端发送，用来建立连接的。第一次握手时: SYN:1 , ACK:0. 第二次握手时: SYN:1 ACK:1

    + FIN 用来表示是否结束该次TCP连接。 通常当你的数据发送完后，会自动带上FIN 然后断开连接

## TCP三次握手——建立链接

![](/images/201601/tcp_3.jpg)

(图中flag说明:SYN包表示标志位syn=1,ACK包表示标志位ack=1,SYN+ACK包表示标志位syn=1,ack=1)

现在，我们来正式进入3次握手环节。

+ 第一次握手. 客户端向服务器发送一个SYN包，并且添加上seqNumber(假设为x),然后进入SYN_SEND状态，并且等待服务器的确认。

+ 第二次握手: 服务器接受SYN包，并且进行确认，如果该请求有效，则将TCP flags中的ACK 标志位置1，然后将AckNumber置为(seqNumber+1)，并且再添加上自己的seqNumber(y),完成后，返回给客户端.服务器进入SYN_RECV状态.(这里服务端是发送SYN+ACK包)

+ 第三次握手 客户端接受ACK+SYN报文后，获取到服务器发送AckNumber(y), 并且将新头部的AckNumber变为(y+1).然后发送给服务器，完成TCP3次连接。此时服务器和客户端都进入ESTABLISHED状态.

## 为什么只有3次握手，而不是4次，或者2次?

假如是2次的话， 可能会出现这样一个情况。

当客户端发送一次请求A后，但是A在网络延迟了很久， 接着客户端又发送了一次B，但是此时A已经无效了。接着服务器相应了B，并返回TCP连接头，建立连接(这里就2次哈)。 然后，A 历经千山万水终于到服务器了，服务器一看有请求来了，则接受，由于一开始A带着的TCP格式都是正确的，那么服务器，理所应当的也返回成功连接的flag，但是，此时客户端已经判断该次请求无效，废弃了。然后服务器，就这么一直挂着(浪费资源)，造成的一个问题是，md, 这个锅是谁的?所以，为了保险起见，再补充一次连接就可以了。所以3次是最合适的。在Chinese中，以3为起称为多，如果你用4，5，6，7，8...次的话，这不更浪费吗?

## TCP四次握手——关闭链接
由于TCP连 接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

+ TCP客 户端发送一个FIN，用来关闭客户到服务器的数据传送。
+ 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
+ 服务器关闭客户端的连接，发送一个FIN给客户端。
+ 客户段发回ACK报文确认，并将确认序号设置为收到序号加1。

参考文章：[《让你升级的网络知识》](http://mp.weixin.qq.com/s?__biz=MjM5OTkwOTA5Mw==&mid=409908127&idx=1&sn=56a1110d6c22571c04ce13e889aeac87&scene=0#wechat_redirect)

如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！
