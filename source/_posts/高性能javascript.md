# 高性能javascript

### 加载和运行

JavaScript 的阻塞特征：大多数浏览器使用单进程处理UI更新和 JavaScript运行等多个任务,而同一时间只能有一个任务被执行，这意味着`<script>`标签的出现使整个页面因脚本解析、运行而出现等待。

由此而得来的几个优化点：

1. 脚本位置
	
	由于浏览器在遇到`<body>`标签之前,不会渲染页面的任何部分，所以
	将脚本放在底部
	
2. 合并脚本

	将脚本成组打包。页面的`<script>`标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。

3. 非阻塞脚本（推荐使用[lazyLoad库](https://github.com/rgrove/lazyload/)）
	- 延迟脚本
	
		为`<script>`标签添加 defer 属性
		
	- 动态脚本
	
		动态创建`<script>`标签,并添加到页面中，用它下载并执行代码
		
	- xhr脚本注入
		
		用 XHR 对象下载代码,并注入到页面中

### 数据访问

在 JavaScript 中,数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型:直接量,变 量,数组项,对象成员。

1. 直接量和局部变量访问速度非常快,数组项和对象成员需要更长时间。

2. 局部变量比域外变量快,因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深,访问所需的时间就越长。全局变量总是最慢的,因为它们总是位于作用域链的最后一环。

3. 避免使用 with 表达式,因为它改变了运行期上下文的作用域链。而且应当小心对待 try-catch 表达式的 catch 子句,因为它具有同样效果。

4. 嵌套对象成员会造成重大性能影响,尽量少用

5. 一个属性或方法在原形链中的位置越深,访问它的速度就越慢。

6. 提高 JavaScript 代码的性能:将经常使用的对象成员,数组项,和域外变量存入局部变量中。然后,访问局部变量的速度会快于那些原始变量。（比如document 是一个全局对象。搜索此变量,必须遍历整个作用域链, 直到最后在全局变量对象中找到它，我们就可以使用局部变量代替它）

### DOM 操作

文档对象模型(DOM)是一个独立于语言的，使用 XML 和 HTML 文档操作的应用程序接口(API)。

天生就慢：两个独立的部分以功能接口连接就会带来性能损耗1. 轻触DOM，最小化DOM操作

	- 不要使用循环访问和修改 DOM，可以使用局部变量存放需要反复使用的 DOM 引用
	
	- 使用innerHTML，而不是document.createElement ()［在老的浏览器效果明显，但新的差异不大］
	
	- 能clone节点就不要新建
	- 使用速度更快的api，例如querySelectorAll()和 firstElementChild

2. 重绘和重排

	- 批量修改 DOM 样式

		使用cssText集中修改样式
		
	- 离线操作 DOM 树

		需要对 DOM 元素进行多次修改时,通过以下步骤减少重绘和重排版的次数：
		- 从文档流中摘除该元素（隐藏，复制覆盖）
		- 对其应用多重改变
		- 将元素带回文档中
	- 通过缓存布局信息来减少对 DOM 的访问，例如进行动画时，缓存初始位置
	
3. 动画脱离文档流

	排版有时只影响渲染树的一小部分,但也可以影响很大的一部分,甚至整个渲染树。浏览器需要重排版的部分越小,应用程序的响应速度就越快。所以将动画提出文档流，减小渲染树重排的部分。
	
4. 使用事件托管
	
	事件句柄的负担：

	- 元素与每个句柄的链接增加了页面负担和运行时间（事件挂接过程都发生在onload(或 DOMContentReady)事件中）

	- 浏览器需要保存每个句柄的记录,占用更多内存

所以，使用事件托管（只需要在一个包装元素上挂接一个句柄,用于处理子元素发生的所有事件）来达到性能优化。
	
### 算法和流程控制

代码整体结构是执行速度的决定因素之一。代码量少不一定运行速度快,代码量多也不一定运行速度慢。 性能损失与代码组织方式和具体问题解决办法直接相关。

1. 循环

	JavaScript 提供了的四种循环类型:for、while、do-while、for-in，其中for-in 循环比其他循环明显要慢（由于每次迭代操作要搜索实例或原形的属性）。

	除 for-in 循环外,其他循环类型性能相当,难以确定哪种循环更快。所以选择循环类型应基于需求而不是性能。

	优化着力点：
	
	- 每次迭代的工作量
	- 迭代的次数

2. 条件表达式

	条件数量较大,使用 switch，条件数量小则使用if－else：
	- 易于阅读，如果条件较少时,if-else 容易阅读,而条件较多时 switch 更容易阅读。
	- 性能更佳，多数情况下 switch 表达式比 if-else 更快一点,但只有当条件体数量很大时这种性能差距才明显。
	
	优化点：
	
	- 最小化找到正确分支之前所判断条件体的数量

		- 将最常见的条件体放在首位
		- 使用嵌套表达式缩小查找范围
	- 查表法(测试的离散值数量非常大时）
	
		消除所有条件判断。操作转换成一个数组项查询或者一个对象成员查询。
		
3. 递归（再学习，表示不懂）
	- 调用栈限制
	
		JavaScript 引擎所支持的递归数量与 JavaScript 调用栈大小直接相关。当你使用了太多的递归,超过最大调用栈尺寸时,浏览器会出错
	- 递归模式
	- 迭代
	- 制表

### 字符串和正则表达式（再看）
1. 字符串链接
	- IE7 和它的早期版本上, jion性能更优
	- 现代浏览器，使用简单的+和+=性能更优，但是要避免使用临时字符串


### 响应接口
