{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/geek/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/geek/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/geek/source/js/js.js","path":"js/js.js","modified":0,"renderable":1},{"_id":"themes/geek/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/jquery.min.js","path":"libs/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/highlight.pack.js","path":"libs/highlight/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/HELP-US-OUT.txt","path":"libs/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/a11y-light.css","path":"libs/highlight/styles/a11y-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/a11y-dark.css","path":"libs/highlight/styles/a11y-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/an-old-hope.css","path":"libs/highlight/styles/an-old-hope.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/agate.css","path":"libs/highlight/styles/agate.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/androidstudio.css","path":"libs/highlight/styles/androidstudio.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/arduino-light.css","path":"libs/highlight/styles/arduino-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/ascetic.css","path":"libs/highlight/styles/ascetic.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/arta.css","path":"libs/highlight/styles/arta.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-cave-light.css","path":"libs/highlight/styles/atelier-cave-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-dune-dark.css","path":"libs/highlight/styles/atelier-dune-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-dune-light.css","path":"libs/highlight/styles/atelier-dune-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-cave-dark.css","path":"libs/highlight/styles/atelier-cave-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-forest-dark.css","path":"libs/highlight/styles/atelier-forest-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-estuary-light.css","path":"libs/highlight/styles/atelier-estuary-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-estuary-dark.css","path":"libs/highlight/styles/atelier-estuary-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-heath-dark.css","path":"libs/highlight/styles/atelier-heath-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-forest-light.css","path":"libs/highlight/styles/atelier-forest-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-heath-light.css","path":"libs/highlight/styles/atelier-heath-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-lakeside-light.css","path":"libs/highlight/styles/atelier-lakeside-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-lakeside-dark.css","path":"libs/highlight/styles/atelier-lakeside-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-plateau-dark.css","path":"libs/highlight/styles/atelier-plateau-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-plateau-light.css","path":"libs/highlight/styles/atelier-plateau-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-savanna-dark.css","path":"libs/highlight/styles/atelier-savanna-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-savanna-light.css","path":"libs/highlight/styles/atelier-savanna-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-seaside-dark.css","path":"libs/highlight/styles/atelier-seaside-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-seaside-light.css","path":"libs/highlight/styles/atelier-seaside-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-sulphurpool-dark.css","path":"libs/highlight/styles/atelier-sulphurpool-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-sulphurpool-light.css","path":"libs/highlight/styles/atelier-sulphurpool-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-dark-reasonable.css","path":"libs/highlight/styles/atom-one-dark-reasonable.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-dark.css","path":"libs/highlight/styles/atom-one-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-light.css","path":"libs/highlight/styles/atom-one-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/brown-paper.css","path":"libs/highlight/styles/brown-paper.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/brown-papersq.png","path":"libs/highlight/styles/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/codepen-embed.css","path":"libs/highlight/styles/codepen-embed.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/darcula.css","path":"libs/highlight/styles/darcula.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/color-brewer.css","path":"libs/highlight/styles/color-brewer.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/dark.css","path":"libs/highlight/styles/dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/darkula.css","path":"libs/highlight/styles/darkula.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/docco.css","path":"libs/highlight/styles/docco.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/default.css","path":"libs/highlight/styles/default.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/dracula.css","path":"libs/highlight/styles/dracula.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/far.css","path":"libs/highlight/styles/far.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/github-gist.css","path":"libs/highlight/styles/github-gist.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/foundation.css","path":"libs/highlight/styles/foundation.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/github.css","path":"libs/highlight/styles/github.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/gml.css","path":"libs/highlight/styles/gml.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/gradient-dark.css","path":"libs/highlight/styles/gradient-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/googlecode.css","path":"libs/highlight/styles/googlecode.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/grayscale.css","path":"libs/highlight/styles/grayscale.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/gruvbox-dark.css","path":"libs/highlight/styles/gruvbox-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/gruvbox-light.css","path":"libs/highlight/styles/gruvbox-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/hopscotch.css","path":"libs/highlight/styles/hopscotch.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/hybrid.css","path":"libs/highlight/styles/hybrid.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/idea.css","path":"libs/highlight/styles/idea.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/ir-black.css","path":"libs/highlight/styles/ir-black.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/isbl-editor-dark.css","path":"libs/highlight/styles/isbl-editor-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/isbl-editor-light.css","path":"libs/highlight/styles/isbl-editor-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/kimbie.dark.css","path":"libs/highlight/styles/kimbie.dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/kimbie.light.css","path":"libs/highlight/styles/kimbie.light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/lightfair.css","path":"libs/highlight/styles/lightfair.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/mono-blue.css","path":"libs/highlight/styles/mono-blue.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/magula.css","path":"libs/highlight/styles/magula.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/monokai-sublime.css","path":"libs/highlight/styles/monokai-sublime.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/monokai.css","path":"libs/highlight/styles/monokai.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/night-owl.css","path":"libs/highlight/styles/night-owl.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/nord.css","path":"libs/highlight/styles/nord.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/ocean.css","path":"libs/highlight/styles/ocean.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/obsidian.css","path":"libs/highlight/styles/obsidian.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/paraiso-dark.css","path":"libs/highlight/styles/paraiso-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/paraiso-light.css","path":"libs/highlight/styles/paraiso-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/pojoaque.css","path":"libs/highlight/styles/pojoaque.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/pojoaque.jpg","path":"libs/highlight/styles/pojoaque.jpg","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/purebasic.css","path":"libs/highlight/styles/purebasic.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/qtcreator_dark.css","path":"libs/highlight/styles/qtcreator_dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/qtcreator_light.css","path":"libs/highlight/styles/qtcreator_light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/railscasts.css","path":"libs/highlight/styles/railscasts.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/rainbow.css","path":"libs/highlight/styles/rainbow.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/routeros.css","path":"libs/highlight/styles/routeros.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/school-book.css","path":"libs/highlight/styles/school-book.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/school-book.png","path":"libs/highlight/styles/school-book.png","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/shades-of-purple.css","path":"libs/highlight/styles/shades-of-purple.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/solarized-dark.css","path":"libs/highlight/styles/solarized-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/solarized-light.css","path":"libs/highlight/styles/solarized-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/sunburst.css","path":"libs/highlight/styles/sunburst.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-blue.css","path":"libs/highlight/styles/tomorrow-night-blue.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-bright.css","path":"libs/highlight/styles/tomorrow-night-bright.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-eighties.css","path":"libs/highlight/styles/tomorrow-night-eighties.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night.css","path":"libs/highlight/styles/tomorrow-night.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow.css","path":"libs/highlight/styles/tomorrow.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/vs.css","path":"libs/highlight/styles/vs.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/vs2015.css","path":"libs/highlight/styles/vs2015.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/xcode.css","path":"libs/highlight/styles/xcode.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/zenburn.css","path":"libs/highlight/styles/zenburn.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/xt256.css","path":"libs/highlight/styles/xt256.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/css/font-awesome.css","path":"libs/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/css/font-awesome.min.css","path":"libs/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/FontAwesome.otf","path":"libs/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.svg","path":"libs/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.eot","path":"libs/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","path":"libs/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.woff","path":"libs/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","path":"libs/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/bordered-pulled.less","path":"libs/font-awesome/less/bordered-pulled.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/animated.less","path":"libs/font-awesome/less/animated.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/icons.less","path":"libs/font-awesome/less/icons.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/core.less","path":"libs/font-awesome/less/core.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/font-awesome.less","path":"libs/font-awesome/less/font-awesome.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/fixed-width.less","path":"libs/font-awesome/less/fixed-width.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/larger.less","path":"libs/font-awesome/less/larger.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/list.less","path":"libs/font-awesome/less/list.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/mixins.less","path":"libs/font-awesome/less/mixins.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/path.less","path":"libs/font-awesome/less/path.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/rotated-flipped.less","path":"libs/font-awesome/less/rotated-flipped.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/screen-reader.less","path":"libs/font-awesome/less/screen-reader.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/stacked.less","path":"libs/font-awesome/less/stacked.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/variables.less","path":"libs/font-awesome/less/variables.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/scss/font-awesome.scss","path":"libs/font-awesome/scss/font-awesome.scss","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1638760952290},{"_id":"source/_posts/test.md","hash":"c5db1f4d3d8d97ba681c45030f2d7ce00014ac4e","modified":1638772509630},{"_id":"themes/geek/.gitignore","hash":"824c6bad36ef799350c37bcd0fe5a1a88295d2f8","modified":1587438026000},{"_id":"themes/geek/LICENSE","hash":"e8b834a986c4367c3b8dbee511b93f94f3145947","modified":1587438026000},{"_id":"themes/geek/README.md","hash":"95aa0a37d3639f5e1eb6bedbbb2cb9dc3bde3444","modified":1587438026000},{"_id":"themes/geek/_config.yml","hash":"88578788d1f48e47ea2da5d1c36ac0e87717d1e6","modified":1638760164645},{"_id":"themes/geek/source/favicon.ico","hash":"8585da4c971c97523cc8c599110ed9a7e074241c","modified":1587438026000},{"_id":"themes/geek/layout/layout.ejs","hash":"710b13e895e7a9cc2341874fafbfeef1ae9b7279","modified":1587438026000},{"_id":"themes/geek/layout/index.ejs","hash":"1bf40e757764d950af89a0baaf793b27946bbc92","modified":1587438026000},{"_id":"themes/geek/layout/post.ejs","hash":"f5b31036768f4e7ae0577058f80e497562187a7c","modified":1587438026000},{"_id":"themes/geek/source/css/style.styl","hash":"7f2970c1b1f8ff89de90739725526ebe2686e49f","modified":1587438026000},{"_id":"themes/geek/source/js/js.js","hash":"0fb795dc0d1c2da9bee007a73fe246a03c88626b","modified":1587438026000},{"_id":"themes/geek/layout/_partial/head.ejs","hash":"caa33d4a948dd9c4e8ccb116c2f1e4471842aec5","modified":1587438026000},{"_id":"themes/geek/layout/_partial/nav.ejs","hash":"42e47f3014a43c8589adfa1f7f34355a586b1ec5","modified":1587438026000},{"_id":"themes/geek/layout/_partial/footer.ejs","hash":"24f991fd3e4310cdd0c0a3f1cd57620596d854bf","modified":1587438026000},{"_id":"themes/geek/source/css/_partial/index.styl","hash":"7750090da83d1a477d1735bed152434b2e9053ab","modified":1587438026000},{"_id":"themes/geek/source/css/_partial/markdown.styl","hash":"ec536affb40d91a181b6fa1df22672a07188671a","modified":1587438026000},{"_id":"themes/geek/source/css/_partial/post.styl","hash":"23aba61940dd2f9719c778318bbaa92e859f6b60","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/highlight.pack.js","hash":"e5a87508b4ce2f7e00c8f792251a0837879a6311","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/a11y-light.css","hash":"3f5cde8e2278a6d52e6e4f30509588c80a3ad5a6","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/a11y-dark.css","hash":"122f8c71ac1c35398e96bf209f20668195a9e144","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/an-old-hope.css","hash":"124d4856bbd6e2cfc164914080724f1a59b9899c","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/agate.css","hash":"8e122b0f00f5a7ec4e6dc492bf1560441eeef7f0","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/arduino-light.css","hash":"141b53b2e2de6a321a695d816a836666c5e2c5e6","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/androidstudio.css","hash":"958baa24814c06a625612a3b2b478d54bc1bf1b1","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/ascetic.css","hash":"6358377b5c25667886aca0d605cbc497cf02405f","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/arta.css","hash":"17b23b9fa57ef7a05a6aaeea9b5feb5442a8e584","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-cave-light.css","hash":"2933f0247ac6d84c2954dd4946e359853abbf70a","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-dune-dark.css","hash":"081d73e454db140cd41b2bb595be297cfcab25e0","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-dune-light.css","hash":"7ba074de897e6a5e27d8b97f7cd06c1746474e72","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-cave-dark.css","hash":"f397d4418ce88b998841fd9135242461ba1a79b5","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-forest-dark.css","hash":"d8a4dc060b3fc719aa2f7d7b3f1019a3964b8101","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-estuary-light.css","hash":"91ae4668c15a085ffce15ca21e93da445b5ecf3a","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-estuary-dark.css","hash":"a0c46a0f955e3864f5e967ea93f5e61519a17be8","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-forest-light.css","hash":"8a78a4eea0f32d094d1f9e316d59e990ba739d97","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-heath-dark.css","hash":"b93c2241ff123e62d4edb3dfc20410e4d1da3e78","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-heath-light.css","hash":"172b98f783d213a20211ec6aca9a3840ba524f55","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-lakeside-light.css","hash":"8ba595b9ba6e8be6dc029bf80caab38e85aed686","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-lakeside-dark.css","hash":"fa707b252d5d5caccc0589374522bed47b7ca100","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-plateau-dark.css","hash":"240f79f4e1fd63485c13900875b64c5a0d1bd06d","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-plateau-light.css","hash":"9731db1052f23351c983210701edd3f5ceed343f","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-savanna-dark.css","hash":"09d45a218f87b8cb55b5ca7f4e9d76ea89a9404a","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-savanna-light.css","hash":"6bd3a62c32558476d436bd389500e5fbeb693d67","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-seaside-dark.css","hash":"b2800804a21f729a3d0a16b3aadc17679fd0639c","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-seaside-light.css","hash":"3e6b9e2a3a5de455490b8224401f19702df4cde9","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-sulphurpool-dark.css","hash":"1f006f8bd28e2ffbb73f708769605ba766787fff","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atelier-sulphurpool-light.css","hash":"0319c3eea893601b79b6c57652ef49b9222cc9de","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-dark-reasonable.css","hash":"90e194ba1c1fe2ca1b5f40b5eb7c29f40ab66ff4","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-dark.css","hash":"a6d28e1c04cee20cd874fc7ac0903d8e2e4bd54e","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-light.css","hash":"eda63d8cce440dbf3bb823e10577a134e9941deb","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/brown-paper.css","hash":"a6817d890e58f80ce79d87620791dae821a70fff","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/codepen-embed.css","hash":"c4520e45d18259817b8942d17971f27c94f0fb09","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/darcula.css","hash":"617241bc95a5dbbd741820bf296155b90e22d61b","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/color-brewer.css","hash":"96332573db854e7b7411caa94ba29b238fede2d3","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/dark.css","hash":"fc77519d4f5d731054c5d4b7e7bbdbb510833271","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/darkula.css","hash":"0be948bb84acc05f93a1e5e9b48fe34cf61673a0","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/docco.css","hash":"1be7be09a1b927c22c7f11451becdb335145bdd2","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/default.css","hash":"fba68624d1b34a5543fe0bf4b2af2ac1ddf65e74","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/dracula.css","hash":"2633f2e84680e9f381e9ac1df344b542e28f9774","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/far.css","hash":"67e0658b2376e91e4894636a3522a30c2aec42de","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/github-gist.css","hash":"8cfbcbf4c0491e44e6b073c95a04cc401cb11ab2","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/foundation.css","hash":"29d960268ca944b5537ff2d2e70d620339dcd5d5","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/github.css","hash":"ee593952684a791317ee8b77ad096e729dec649e","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/gml.css","hash":"0f3f5502247b00ce37dc2b362a6984305001dd50","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/gradient-dark.css","hash":"e49b73bab4446ec2dbc0befb860a1fdc27bf1b42","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/googlecode.css","hash":"fed3d439d0c305b337dd9c0f68dcbfa51429f445","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/grayscale.css","hash":"5688658c28fc5799517e8f3c224ae3da3797ba44","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/gruvbox-dark.css","hash":"aaf90d076e34bc44016462d70f83985e0e55c8dc","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/gruvbox-light.css","hash":"084699ab0aa326fede86e38bf41ebe49edde3a90","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/hopscotch.css","hash":"3d258ff6f84900ad9abbe43f4ec8b8152c72e887","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/hybrid.css","hash":"1e2d54598b5f948b597059909d4bd158b7df021f","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/idea.css","hash":"164649ae1e7c891a0d88cca075521af28656e2a1","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/ir-black.css","hash":"95aad65ba77183500ce0f7ad62a7535b647ee20c","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/isbl-editor-dark.css","hash":"73d2282192e403868998cff2e77093ace8a6e5fb","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/isbl-editor-light.css","hash":"41baadd11cf10bab67128dd104f704fdd149318e","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/kimbie.dark.css","hash":"58ed061c204fbc09d221ee9135d66bad976e5fc3","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/kimbie.light.css","hash":"b7aa9b1b21a25dfefcac7649a328962f84c47913","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/lightfair.css","hash":"3bdc4517354b7acc495562d8b4937c7a40a89f06","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/mono-blue.css","hash":"3163f08756efa9e68e87addf20750e5650cdb8e4","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/magula.css","hash":"8f5cfb7c23c705de7c95577563eb79beb49b68f6","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/monokai-sublime.css","hash":"e4f3df87cbfa634c86b489e9cc43acf44d415986","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/monokai.css","hash":"99ab7678d541bc02a8d38de83a289c5e549a20ce","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/night-owl.css","hash":"d067142aeb74bfdcdec4acebb3241b3e79461bda","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/nord.css","hash":"98dfcd6eee4968fb4c634784cb048a98169b1bc8","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/ocean.css","hash":"fce6858e1c5eb9d2857cb5b5d24069c5994cfc91","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/obsidian.css","hash":"6ed475813fe4886a58b236297862ff2f181e66f7","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/paraiso-dark.css","hash":"8f5445327ce3c83b62f6bf4c1a0d87fa6f036341","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/paraiso-light.css","hash":"6eb3ab7a3337f9cad3a2e5fa6bf7dd83685228d8","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/pojoaque.css","hash":"4e1e6a431212f5043a550474a1acda63362cdd6f","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/purebasic.css","hash":"e6bb7a57221bed7a601dc9d8d41d9b1425e2dea6","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/qtcreator_dark.css","hash":"213a40d203c4986cdbcb1bdf7d0b9013b29041ba","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/qtcreator_light.css","hash":"9a2a19ac2f6e6a7d5edd7fae67b7de4a3957e878","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/railscasts.css","hash":"a6d2043478fae5915926914cbd96fe9b706d98a6","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/rainbow.css","hash":"1b2d98ccdda36aa926d0e6d069b673fdacd2d33e","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/routeros.css","hash":"fc5db7c8f18d6b31ad92df21a51e7867d459af19","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/school-book.css","hash":"6c4198b6ffde866f5e2fe9172aee094065f9774a","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/shades-of-purple.css","hash":"4d5b44a1615173d02b223ba2cce220ab70e09650","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/solarized-dark.css","hash":"d02fc2dcbeec4b7af2cadec4bbbfc5b016aed4c7","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/solarized-light.css","hash":"6b70caf1e84d096b1bc6318d5dae78d69e5dd1d3","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/sunburst.css","hash":"8309eab2e5b1765dbee81a626baacbdad869b76a","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-blue.css","hash":"cd257d7d6a37cd5a09419b5f5f9d34b6b282423f","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-bright.css","hash":"04f0af30fdda5e5d6ebdeef5a860b6b7e49cfe89","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-eighties.css","hash":"d82b84bcda0588105dbbc0e8e8ba5e62c208a061","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night.css","hash":"86264dd861d35a8b135f9fcb8ff2675e9fa69c16","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow.css","hash":"163593ad70770d0296c5e643fa62e58e63f1b340","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/vs2015.css","hash":"3c7fa677de2a785d90fc6c3f7520ac1b11bfd37a","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/vs.css","hash":"2ac5e89ceb3d5a0e0fdab1ed6d9a411ec7d221aa","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/xcode.css","hash":"d8a1f18e5344c2edf97921ec21a54b02745997e9","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/zenburn.css","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1587438026000},{"_id":"themes/geek/source/libs/highlight/styles/xt256.css","hash":"d9e0f7d8ab5cfd627ce085c16e7a90e1ad495516","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/bordered-pulled.less","hash":"a2c292137b17406183ad0fdbf4880fd648b9a5ca","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/animated.less","hash":"421f2c4e10191f148c13b8a34e5ff3f484d4c393","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/icons.less","hash":"0285a999eb1adad868366678c2d9365b77186a45","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/core.less","hash":"1a37352286619b789d151a06eb4b7551e4c1aaa2","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/font-awesome.less","hash":"9ffe7422dc235450a21f019f410ed359ed151f4b","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/fixed-width.less","hash":"ec0c24b97184dab86177660f486b8d08cd636c42","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/larger.less","hash":"e7119e82dc50540dbc3472bba7d74282815a7ecc","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/list.less","hash":"f53bc20884a1410d950b4a36a330c5181a8b55ab","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/mixins.less","hash":"3c5b36b0069372b525ed8bbbcf6b3d4d2bed4e78","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/path.less","hash":"1afb4a849059631f76ed2a519d7fb1bd0af14802","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/rotated-flipped.less","hash":"95de5de9009714692430b04f9cd4388be8fba8f3","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/screen-reader.less","hash":"71139132f170ebe7712836210f4d2c4905151899","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/stacked.less","hash":"f044077bc8be1a989c245254e81eb084d52d29a7","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/less/variables.less","hash":"8a5c800747705df16117cc598c1b9f512e873bfe","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_animated.scss","hash":"8daf189b2f8a404495b8424b6fd1ba630dd1c2dc","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_bordered-pulled.scss","hash":"164b6a0a2b307cd293f4a914ab0fcdf643950374","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_icons.scss","hash":"830e0183337d16c07b1c63838f7593a33ee87b15","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_larger.scss","hash":"940e1c5ebc690283bfaee92560cf15fabedbf6a9","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_fixed-width.scss","hash":"224417ca266c657849afb2bbcb6dc455894ff387","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_core.scss","hash":"55a14a34267edc401b82e5ee41d8bd84fbb5da3f","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_mixins.scss","hash":"4f3881034a4c11cae8cc915f288477b498a357a2","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_list.scss","hash":"4b53ee01513df8b9ce76442b2d8f1851613a435c","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_path.scss","hash":"080158aeb1bf6df59ec98b2bbed44da61d9c9ca3","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_rotated-flipped.scss","hash":"ca08a0af3da63c2f2a7d3c27a8747637744cc785","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_screen-reader.scss","hash":"2d8563c488f68e75a28d540dd89301ee4ee08c97","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_variables.scss","hash":"0d6d70535104b42e60d7f44ae6ccf9de023a7b8b","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/_stacked.scss","hash":"cf6752ee609af36eb293a7197c88d31ecacbbc74","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/scss/font-awesome.scss","hash":"dd83648ea5bc832f87c3c1bf956c54dec065a9bd","modified":1587438026000},{"_id":"themes/geek/source/libs/jquery.min.js","hash":"37b1db88b57438f1072a8ebc7559c909c9d3a682","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1587438026000},{"_id":"themes/geek/source/img/logo.png","hash":"f8e2caa981a79889fa58be8b8277ad6854caf447","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1587438026000},{"_id":"themes/geek/imgs/2.png","hash":"f63b6574c5f522b24e2cee18ba6b40b0676365e3","modified":1587438026000},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1587438026000},{"_id":"themes/geek/imgs/1.png","hash":"75038f82935c2ee04d753b76849c4ccbf3cdd222","modified":1587438026000},{"_id":"source/_posts/垃圾回收.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770825823},{"_id":"source/_posts/test2.md","hash":"74a1aaed9aeaef58c619b1fd8c2ceea47aa9af0a","modified":1638773363032},{"_id":"source/_posts/对象、原型与原型链.md","hash":"f1f9f4ae783461108aaafa7253c8b2a6c6297047","modified":1638770825833},{"_id":"source/_posts/编译器.md","hash":"65de75ba4291cd1fccd302409fa7487181e37b00","modified":1638770825839},{"_id":"source/_posts/运行机制-事件队列与调用栈.md","hash":"4c7ed29cc06ac2457e4cb0ccef6025d7f78b34e5","modified":1638770825844},{"_id":"source/_posts/面向对象编程.md","hash":"700028735b02e819312d864a038ce76e4f477e61","modified":1638770825844},{"_id":"public/2021/12/06/test2/index.html","hash":"7aff46a8e3d08aeeffd0947bd9e45cd425325a5e","modified":1638773439708},{"_id":"public/2021/12/06/面向对象编程/index.html","hash":"0201f4359d4ac0d5c69f9da0e0bd8188cbe34c48","modified":1638773439708},{"_id":"public/2021/12/06/运行机制-事件队列与调用栈/index.html","hash":"5c832848249eb76662743222b7cfcae373ff48c3","modified":1638773439708},{"_id":"public/2021/12/06/编译器/index.html","hash":"0a5f167efd7fc2050c100095953c8d35811c65c2","modified":1638773439708},{"_id":"public/2021/12/06/对象、原型与原型链/index.html","hash":"6fd1ec5eeba8a14d6b771ab11bbe0971c3919027","modified":1638773439708},{"_id":"public/2021/12/06/垃圾回收/index.html","hash":"b8b4ea6cdc53f4c235812e46237b4649e47604fa","modified":1638773439708},{"_id":"public/2021/12/06/test/index.html","hash":"b59e69e5ef2649d295454002671f32d92a49880e","modified":1638773439708},{"_id":"public/2021/12/06/hello-world/index.html","hash":"53d77f85b3395c697bb2a03ce99c5550cc504ace","modified":1638773439708},{"_id":"public/archives/index.html","hash":"3df643dc30860cc6dbfdb505f2261caaad9ea2c3","modified":1638774782496},{"_id":"public/archives/2021/index.html","hash":"3df643dc30860cc6dbfdb505f2261caaad9ea2c3","modified":1638774782496},{"_id":"public/archives/2021/12/index.html","hash":"3df643dc30860cc6dbfdb505f2261caaad9ea2c3","modified":1638774782496},{"_id":"public/index.html","hash":"3df643dc30860cc6dbfdb505f2261caaad9ea2c3","modified":1638774782496},{"_id":"public/categories/css/index.html","hash":"92696b26fd16e1b0b49b45ff0ace336e991a07ee","modified":1638773439708},{"_id":"public/favicon.ico","hash":"8585da4c971c97523cc8c599110ed9a7e074241c","modified":1638773439708},{"_id":"public/libs/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1638773439708},{"_id":"public/libs/highlight/styles/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1638773439708},{"_id":"public/libs/highlight/styles/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1638773439708},{"_id":"public/libs/highlight/styles/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1638773439708},{"_id":"public/libs/font-awesome/less/bordered-pulled.less","hash":"a2c292137b17406183ad0fdbf4880fd648b9a5ca","modified":1638773439708},{"_id":"public/libs/font-awesome/less/animated.less","hash":"421f2c4e10191f148c13b8a34e5ff3f484d4c393","modified":1638773439708},{"_id":"public/libs/font-awesome/less/icons.less","hash":"0285a999eb1adad868366678c2d9365b77186a45","modified":1638773439708},{"_id":"public/libs/font-awesome/less/larger.less","hash":"e7119e82dc50540dbc3472bba7d74282815a7ecc","modified":1638773439708},{"_id":"public/libs/font-awesome/less/core.less","hash":"1a37352286619b789d151a06eb4b7551e4c1aaa2","modified":1638773439708},{"_id":"public/libs/font-awesome/less/font-awesome.less","hash":"9ffe7422dc235450a21f019f410ed359ed151f4b","modified":1638773439708},{"_id":"public/libs/font-awesome/less/fixed-width.less","hash":"ec0c24b97184dab86177660f486b8d08cd636c42","modified":1638773439708},{"_id":"public/libs/font-awesome/less/list.less","hash":"f53bc20884a1410d950b4a36a330c5181a8b55ab","modified":1638773439708},{"_id":"public/libs/font-awesome/less/rotated-flipped.less","hash":"95de5de9009714692430b04f9cd4388be8fba8f3","modified":1638773439708},{"_id":"public/libs/font-awesome/less/path.less","hash":"1afb4a849059631f76ed2a519d7fb1bd0af14802","modified":1638773439708},{"_id":"public/libs/font-awesome/less/mixins.less","hash":"3c5b36b0069372b525ed8bbbcf6b3d4d2bed4e78","modified":1638773439708},{"_id":"public/libs/font-awesome/less/screen-reader.less","hash":"71139132f170ebe7712836210f4d2c4905151899","modified":1638773439708},{"_id":"public/libs/font-awesome/less/stacked.less","hash":"f044077bc8be1a989c245254e81eb084d52d29a7","modified":1638773439708},{"_id":"public/libs/font-awesome/scss/font-awesome.scss","hash":"dd83648ea5bc832f87c3c1bf956c54dec065a9bd","modified":1638773439708},{"_id":"public/libs/font-awesome/less/variables.less","hash":"8a5c800747705df16117cc598c1b9f512e873bfe","modified":1638773439708},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1638773439708},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1638773439708},{"_id":"public/js/js.js","hash":"0fb795dc0d1c2da9bee007a73fe246a03c88626b","modified":1638773439708},{"_id":"public/libs/highlight/styles/a11y-light.css","hash":"3f5cde8e2278a6d52e6e4f30509588c80a3ad5a6","modified":1638773439708},{"_id":"public/libs/highlight/styles/a11y-dark.css","hash":"122f8c71ac1c35398e96bf209f20668195a9e144","modified":1638773439708},{"_id":"public/libs/highlight/styles/an-old-hope.css","hash":"124d4856bbd6e2cfc164914080724f1a59b9899c","modified":1638773439708},{"_id":"public/libs/highlight/styles/agate.css","hash":"8e122b0f00f5a7ec4e6dc492bf1560441eeef7f0","modified":1638773439708},{"_id":"public/libs/highlight/styles/arduino-light.css","hash":"141b53b2e2de6a321a695d816a836666c5e2c5e6","modified":1638773439708},{"_id":"public/libs/highlight/styles/androidstudio.css","hash":"958baa24814c06a625612a3b2b478d54bc1bf1b1","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-cave-light.css","hash":"2933f0247ac6d84c2954dd4946e359853abbf70a","modified":1638773439708},{"_id":"public/libs/highlight/styles/arta.css","hash":"17b23b9fa57ef7a05a6aaeea9b5feb5442a8e584","modified":1638773439708},{"_id":"public/libs/highlight/styles/ascetic.css","hash":"6358377b5c25667886aca0d605cbc497cf02405f","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-dune-dark.css","hash":"081d73e454db140cd41b2bb595be297cfcab25e0","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-dune-light.css","hash":"7ba074de897e6a5e27d8b97f7cd06c1746474e72","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-cave-dark.css","hash":"f397d4418ce88b998841fd9135242461ba1a79b5","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-estuary-light.css","hash":"91ae4668c15a085ffce15ca21e93da445b5ecf3a","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-forest-dark.css","hash":"d8a4dc060b3fc719aa2f7d7b3f1019a3964b8101","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-heath-dark.css","hash":"b93c2241ff123e62d4edb3dfc20410e4d1da3e78","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-estuary-dark.css","hash":"a0c46a0f955e3864f5e967ea93f5e61519a17be8","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-heath-light.css","hash":"172b98f783d213a20211ec6aca9a3840ba524f55","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-forest-light.css","hash":"8a78a4eea0f32d094d1f9e316d59e990ba739d97","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-plateau-dark.css","hash":"240f79f4e1fd63485c13900875b64c5a0d1bd06d","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-lakeside-light.css","hash":"8ba595b9ba6e8be6dc029bf80caab38e85aed686","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-plateau-light.css","hash":"9731db1052f23351c983210701edd3f5ceed343f","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-lakeside-dark.css","hash":"fa707b252d5d5caccc0589374522bed47b7ca100","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-savanna-dark.css","hash":"09d45a218f87b8cb55b5ca7f4e9d76ea89a9404a","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-savanna-light.css","hash":"6bd3a62c32558476d436bd389500e5fbeb693d67","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-seaside-light.css","hash":"3e6b9e2a3a5de455490b8224401f19702df4cde9","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-seaside-dark.css","hash":"b2800804a21f729a3d0a16b3aadc17679fd0639c","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-sulphurpool-light.css","hash":"0319c3eea893601b79b6c57652ef49b9222cc9de","modified":1638773439708},{"_id":"public/libs/highlight/styles/atom-one-dark-reasonable.css","hash":"90e194ba1c1fe2ca1b5f40b5eb7c29f40ab66ff4","modified":1638773439708},{"_id":"public/libs/highlight/styles/atom-one-dark.css","hash":"a6d28e1c04cee20cd874fc7ac0903d8e2e4bd54e","modified":1638773439708},{"_id":"public/libs/highlight/styles/atom-one-light.css","hash":"eda63d8cce440dbf3bb823e10577a134e9941deb","modified":1638773439708},{"_id":"public/libs/highlight/styles/brown-paper.css","hash":"a6817d890e58f80ce79d87620791dae821a70fff","modified":1638773439708},{"_id":"public/libs/highlight/styles/codepen-embed.css","hash":"c4520e45d18259817b8942d17971f27c94f0fb09","modified":1638773439708},{"_id":"public/libs/highlight/styles/darcula.css","hash":"617241bc95a5dbbd741820bf296155b90e22d61b","modified":1638773439708},{"_id":"public/libs/highlight/styles/atelier-sulphurpool-dark.css","hash":"1f006f8bd28e2ffbb73f708769605ba766787fff","modified":1638773439708},{"_id":"public/libs/highlight/styles/color-brewer.css","hash":"96332573db854e7b7411caa94ba29b238fede2d3","modified":1638773439708},{"_id":"public/libs/highlight/styles/docco.css","hash":"1be7be09a1b927c22c7f11451becdb335145bdd2","modified":1638773439708},{"_id":"public/libs/highlight/styles/default.css","hash":"fba68624d1b34a5543fe0bf4b2af2ac1ddf65e74","modified":1638773439708},{"_id":"public/libs/highlight/styles/dracula.css","hash":"2633f2e84680e9f381e9ac1df344b542e28f9774","modified":1638773439708},{"_id":"public/libs/highlight/styles/dark.css","hash":"fc77519d4f5d731054c5d4b7e7bbdbb510833271","modified":1638773439708},{"_id":"public/libs/highlight/styles/github-gist.css","hash":"8cfbcbf4c0491e44e6b073c95a04cc401cb11ab2","modified":1638773439708},{"_id":"public/libs/highlight/styles/github.css","hash":"ee593952684a791317ee8b77ad096e729dec649e","modified":1638773439708},{"_id":"public/libs/highlight/styles/foundation.css","hash":"29d960268ca944b5537ff2d2e70d620339dcd5d5","modified":1638773439708},{"_id":"public/libs/highlight/styles/far.css","hash":"67e0658b2376e91e4894636a3522a30c2aec42de","modified":1638773439708},{"_id":"public/libs/highlight/styles/darkula.css","hash":"0be948bb84acc05f93a1e5e9b48fe34cf61673a0","modified":1638773439708},{"_id":"public/libs/highlight/styles/gml.css","hash":"0f3f5502247b00ce37dc2b362a6984305001dd50","modified":1638773439708},{"_id":"public/libs/highlight/styles/gruvbox-light.css","hash":"084699ab0aa326fede86e38bf41ebe49edde3a90","modified":1638773439708},{"_id":"public/libs/highlight/styles/grayscale.css","hash":"5688658c28fc5799517e8f3c224ae3da3797ba44","modified":1638773439708},{"_id":"public/libs/highlight/styles/hopscotch.css","hash":"3d258ff6f84900ad9abbe43f4ec8b8152c72e887","modified":1638773439708},{"_id":"public/libs/highlight/styles/gruvbox-dark.css","hash":"aaf90d076e34bc44016462d70f83985e0e55c8dc","modified":1638773439708},{"_id":"public/libs/highlight/styles/idea.css","hash":"164649ae1e7c891a0d88cca075521af28656e2a1","modified":1638773439708},{"_id":"public/libs/highlight/styles/hybrid.css","hash":"1e2d54598b5f948b597059909d4bd158b7df021f","modified":1638773439708},{"_id":"public/libs/highlight/styles/ir-black.css","hash":"95aad65ba77183500ce0f7ad62a7535b647ee20c","modified":1638773439708},{"_id":"public/libs/highlight/styles/isbl-editor-light.css","hash":"41baadd11cf10bab67128dd104f704fdd149318e","modified":1638773439708},{"_id":"public/libs/highlight/styles/isbl-editor-dark.css","hash":"73d2282192e403868998cff2e77093ace8a6e5fb","modified":1638773439708},{"_id":"public/libs/highlight/styles/gradient-dark.css","hash":"e49b73bab4446ec2dbc0befb860a1fdc27bf1b42","modified":1638773439708},{"_id":"public/libs/highlight/styles/googlecode.css","hash":"fed3d439d0c305b337dd9c0f68dcbfa51429f445","modified":1638773439708},{"_id":"public/libs/highlight/styles/kimbie.dark.css","hash":"58ed061c204fbc09d221ee9135d66bad976e5fc3","modified":1638773439708},{"_id":"public/libs/highlight/styles/kimbie.light.css","hash":"b7aa9b1b21a25dfefcac7649a328962f84c47913","modified":1638773439708},{"_id":"public/libs/highlight/styles/mono-blue.css","hash":"3163f08756efa9e68e87addf20750e5650cdb8e4","modified":1638773439708},{"_id":"public/libs/highlight/styles/lightfair.css","hash":"3bdc4517354b7acc495562d8b4937c7a40a89f06","modified":1638773439708},{"_id":"public/libs/highlight/styles/magula.css","hash":"8f5cfb7c23c705de7c95577563eb79beb49b68f6","modified":1638773439708},{"_id":"public/libs/highlight/styles/monokai-sublime.css","hash":"e4f3df87cbfa634c86b489e9cc43acf44d415986","modified":1638773439708},{"_id":"public/libs/highlight/styles/monokai.css","hash":"99ab7678d541bc02a8d38de83a289c5e549a20ce","modified":1638773439708},{"_id":"public/libs/highlight/styles/nord.css","hash":"98dfcd6eee4968fb4c634784cb048a98169b1bc8","modified":1638773439708},{"_id":"public/libs/highlight/styles/night-owl.css","hash":"d067142aeb74bfdcdec4acebb3241b3e79461bda","modified":1638773439708},{"_id":"public/libs/highlight/styles/ocean.css","hash":"fce6858e1c5eb9d2857cb5b5d24069c5994cfc91","modified":1638773439708},{"_id":"public/libs/highlight/styles/paraiso-dark.css","hash":"8f5445327ce3c83b62f6bf4c1a0d87fa6f036341","modified":1638773439708},{"_id":"public/libs/highlight/styles/pojoaque.css","hash":"4e1e6a431212f5043a550474a1acda63362cdd6f","modified":1638773439708},{"_id":"public/libs/highlight/styles/obsidian.css","hash":"6ed475813fe4886a58b236297862ff2f181e66f7","modified":1638773439708},{"_id":"public/libs/highlight/styles/paraiso-light.css","hash":"6eb3ab7a3337f9cad3a2e5fa6bf7dd83685228d8","modified":1638773439708},{"_id":"public/libs/highlight/styles/purebasic.css","hash":"e6bb7a57221bed7a601dc9d8d41d9b1425e2dea6","modified":1638773439708},{"_id":"public/libs/highlight/styles/qtcreator_light.css","hash":"9a2a19ac2f6e6a7d5edd7fae67b7de4a3957e878","modified":1638773439708},{"_id":"public/libs/highlight/styles/qtcreator_dark.css","hash":"213a40d203c4986cdbcb1bdf7d0b9013b29041ba","modified":1638773439708},{"_id":"public/libs/highlight/styles/routeros.css","hash":"fc5db7c8f18d6b31ad92df21a51e7867d459af19","modified":1638773439708},{"_id":"public/libs/highlight/styles/rainbow.css","hash":"1b2d98ccdda36aa926d0e6d069b673fdacd2d33e","modified":1638773439708},{"_id":"public/libs/highlight/styles/school-book.css","hash":"6c4198b6ffde866f5e2fe9172aee094065f9774a","modified":1638773439708},{"_id":"public/libs/highlight/styles/railscasts.css","hash":"a6d2043478fae5915926914cbd96fe9b706d98a6","modified":1638773439708},{"_id":"public/libs/highlight/styles/shades-of-purple.css","hash":"4d5b44a1615173d02b223ba2cce220ab70e09650","modified":1638773439708},{"_id":"public/libs/highlight/styles/solarized-dark.css","hash":"d02fc2dcbeec4b7af2cadec4bbbfc5b016aed4c7","modified":1638773439708},{"_id":"public/libs/highlight/styles/solarized-light.css","hash":"6b70caf1e84d096b1bc6318d5dae78d69e5dd1d3","modified":1638773439708},{"_id":"public/libs/highlight/styles/sunburst.css","hash":"8309eab2e5b1765dbee81a626baacbdad869b76a","modified":1638773439708},{"_id":"public/libs/highlight/styles/tomorrow-night-blue.css","hash":"cd257d7d6a37cd5a09419b5f5f9d34b6b282423f","modified":1638773439708},{"_id":"public/libs/highlight/styles/tomorrow-night.css","hash":"86264dd861d35a8b135f9fcb8ff2675e9fa69c16","modified":1638773439708},{"_id":"public/libs/highlight/styles/tomorrow-night-eighties.css","hash":"d82b84bcda0588105dbbc0e8e8ba5e62c208a061","modified":1638773439708},{"_id":"public/libs/highlight/styles/tomorrow-night-bright.css","hash":"04f0af30fdda5e5d6ebdeef5a860b6b7e49cfe89","modified":1638773439708},{"_id":"public/libs/highlight/styles/tomorrow.css","hash":"163593ad70770d0296c5e643fa62e58e63f1b340","modified":1638773439708},{"_id":"public/libs/highlight/styles/vs.css","hash":"2ac5e89ceb3d5a0e0fdab1ed6d9a411ec7d221aa","modified":1638773439708},{"_id":"public/libs/highlight/styles/xcode.css","hash":"d8a1f18e5344c2edf97921ec21a54b02745997e9","modified":1638773439708},{"_id":"public/libs/highlight/styles/vs2015.css","hash":"3c7fa677de2a785d90fc6c3f7520ac1b11bfd37a","modified":1638773439708},{"_id":"public/libs/highlight/styles/zenburn.css","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1638773439708},{"_id":"public/libs/highlight/styles/xt256.css","hash":"d9e0f7d8ab5cfd627ce085c16e7a90e1ad495516","modified":1638773439708},{"_id":"public/css/style.css","hash":"5aa83728a6eb1c08e990c43e99582a88d4ba3b17","modified":1638773439708},{"_id":"public/libs/jquery.min.js","hash":"37b1db88b57438f1072a8ebc7559c909c9d3a682","modified":1638773439708},{"_id":"public/libs/highlight/highlight.pack.js","hash":"e5a87508b4ce2f7e00c8f792251a0837879a6311","modified":1638773439708},{"_id":"public/libs/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1638773439708},{"_id":"public/libs/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1638773439708},{"_id":"public/img/logo.png","hash":"f8e2caa981a79889fa58be8b8277ad6854caf447","modified":1638773439708},{"_id":"public/libs/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1638773439708},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1638773439708},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1638773439708},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1638773439708},{"_id":"source/_posts/Object.creat.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521190265000},{"_id":"source/_posts/promise.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521190265000},{"_id":"source/_posts/箭头函数.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521190265000},{"_id":"source/_posts/2016年总结.md","hash":"08775565e0cd65a2ff18b6cd476cd78be250cf60","modified":1638770826089},{"_id":"source/_posts/BFC.md","hash":"7326245d0359f4937f63647a0ffb6b7b016b0c47","modified":1638774709508},{"_id":"source/_posts/CSS文本溢出显示省略号.md","hash":"aea2fe0b3091b2774243b376e8eb88250d3120c6","modified":1521190265000},{"_id":"source/_posts/ES6笔记（二）：ES6新增特性.md","hash":"3751d3ea28fbc952e01e810535652a95bd38c618","modified":1638770826103},{"_id":"source/_posts/ESLint--定制你的代码规则.md","hash":"8aae94fa994e9a0f1be6d68a95ed6aa3e6725989","modified":1638770826113},{"_id":"source/_posts/C语言入门.md","hash":"6942f55d24467def9e3bacb311457bf7f63083e8","modified":1638770826093},{"_id":"source/_posts/IO","hash":"d7584b5c05e30a9d901abf1c67405f1266f204fb","modified":1521190265000},{"_id":"source/_posts/Backbone学习笔记（一）.md","hash":"49e0bd7ed0fa54b9af53e3e0da7e564b74e455a2","modified":1638770826093},{"_id":"source/_posts/H5文件上传.md","hash":"8b72f9c32a3b22fffc9335c2ad5dd4bb9d93e8ce","modified":1638770826113},{"_id":"source/_posts/Java中的方法（函数）.md","hash":"24b36d3c6c9ba803b51aad6b2137218be004b7af","modified":1521190265000},{"_id":"source/_posts/Java多态.md","hash":"10d4b2dc44735a367a4a609e43d40ed9f59de55d","modified":1521190265000},{"_id":"source/_posts/Java基本语言.md","hash":"6ecafd8b25e89eae3f7cde6afeabb6f5b70bd2b6","modified":1521190265000},{"_id":"source/_posts/Java封装.md","hash":"021e38158f45041712a927cae2b2136b78f21478","modified":1521190265000},{"_id":"source/_posts/Java异常处理.md","hash":"6fb2df602cc1da2e4cd740047bd21e670dd57387","modified":1521190265000},{"_id":"source/_posts/Java抽象类.md","hash":"f1db85030c01c90da983b92a4197590a6e4fb937","modified":1521190265000},{"_id":"source/_posts/ES6笔记（一）：ES6所改良的javascript“缺陷”.md","hash":"7673952c802c362e3205cafe78b76330f9448155","modified":1638770826103},{"_id":"source/_posts/Java接口.md","hash":"259562d40af6047ba72fb18a2f31f3ebe99a86f1","modified":1521190265000},{"_id":"source/_posts/Java线程.md","hash":"139fdf22d74ac9334f54c1d68bd9af3f1f3a2c54","modified":1521190265000},{"_id":"source/_posts/Java数组.md","hash":"93020c8af5c0878aa89cc5d0e3cf5e996d2325f5","modified":1521190265000},{"_id":"source/_posts/IE hack.md","hash":"48dbfa02225b12add256855b556f582c1d6bea26","modified":1638770826123},{"_id":"source/_posts/JavaScript原型学习笔记.md","hash":"f4bbe806a0c75817aa1aa031421938d3b58d4d18","modified":1638770826123},{"_id":"source/_posts/Java的类和对象.md","hash":"39f4f147dee9e376be6e676e87a4f040a758e7c4","modified":1521190265000},{"_id":"source/_posts/Network","hash":"dfa5255023a9d4d8cfd5d0f44cfe59f49544bb70","modified":1521190265000},{"_id":"source/_posts/Node.js学习笔记（一）.md","hash":"ee8fcc9750dd397703eba515ec7263010f4b0bef","modified":1521190265000},{"_id":"source/_posts/Java继承.md","hash":"8c30a56009cf7f9a708a81415acd2cc077e6ae30","modified":1521190265000},{"_id":"source/_posts/Node.js学习笔记（三）- 事件机制.md","hash":"f81870da9a197094d2f477593911e674647b0177","modified":1521190265000},{"_id":"source/_posts/Node.js学习笔记（四）- 全局对象.md","hash":"0095e84b1f332d27b2f9794daf352ada10a87342","modified":1521190265000},{"_id":"source/_posts/Node.js学习笔记（五）- 文件系统.md","hash":"4ae975f8a473740fcf89561d0f8ddb849f0cc0f0","modified":1521190265000},{"_id":"source/_posts/Jquery属性获取——attr()与prop().md","hash":"19523e45cc7b7817cd6c9e2790c6a41fabb8ff52","modified":1638770826123},{"_id":"source/_posts/class&extends.md","hash":"1270a123c60feb146f01cd2b744099402ac32b2b","modified":1521190265000},{"_id":"source/_posts/Node.js学习笔记（二）：模块机制.md","hash":"af59d4d95816199e367492ff18e3859f8f981e6d","modified":1521190265000},{"_id":"source/_posts/css三角形的实现.md","hash":"785a49db8be4140995eb8ce0a632feb65a82bd23","modified":1521190265000},{"_id":"source/_posts/React-Redux.md","hash":"282985883225e22a476f692fa7cc6bf25cd0f648","modified":1638770826133},{"_id":"source/_posts/canvas初探.md","hash":"2f8e7ace54f9f623c74638a9da5a283eedc4d6c0","modified":1638770826143},{"_id":"source/_posts/React-Native性能优化点.md","hash":"159bbfa5aefa29b30731a7c69db4d604be61338a","modified":1638770826133},{"_id":"source/_posts/http","hash":"b1174ce5a128bf5d5427d09a99b4404d55883e35","modified":1521190265000},{"_id":"source/_posts/github-hexo构建静态博客（二）.md","hash":"deef7e5007e3704d6c90a82ba3166cf791263a64","modified":1638770826143},{"_id":"source/_posts/iScroll-js——smooth scrolling for the web.md","hash":"f9ccc541a0e754517c08d3ee7dfa855418218144","modified":1638770826153},{"_id":"source/_posts/github-hexo构建静态博客（一）.md","hash":"3e569c69b992f20762f35f8a31b759c0c875dbd7","modified":1638770826143},{"_id":"source/_posts/javascript中的prototype和constructor.md","hash":"1fef779ae3b77bb3b88a6a955421813c248476aa","modified":1638770826153},{"_id":"source/_posts/javascript中的继承.md","hash":"d591b61b02976a00c1dec9f2901196ebf49b67eb","modified":1638770826167},{"_id":"source/_posts/java控制流程语句.md","hash":"7c0d76b04e51193aed5f98da64db4d01d0c8522f","modified":1521190265000},{"_id":"source/_posts/javascript模块化.md","hash":"4e8831c7f4d189590d7afdb4b0530d4d557dd55f","modified":1638770826174},{"_id":"source/_posts/let&const.md","hash":"cf300a7b0f7f48822d93dc29fd5df04dcd507a51","modified":1521190265000},{"_id":"source/_posts/jquery和js获取及设置元素的尺寸和位置.md","hash":"5e7e6f99a65e79c0f2c208ec9c354e42ba551342","modified":1638770826174},{"_id":"source/_posts/javascript作用域链学习笔记.md","hash":"7c476f44852701a294a5421b579d974abc8a2885","modified":1638770826170},{"_id":"source/_posts/js基础.md","hash":"f1e55055483ef3e977361b2effc6a050ac9e3960","modified":1638770826184},{"_id":"source/_posts/jquery对javascript事件的封装一览.md","hash":"a675d96abf57bfc0ae5dde1e3e3349ff25857d9f","modified":1638770826174},{"_id":"source/_posts/lazyload-js详解.md","hash":"e9a0e446fe5f09c4f6c928a55f7ca90cc184d477","modified":1638770826184},{"_id":"source/_posts/mysql环境搭建.md","hash":"613032754e39aa51b65dcf0eb5e13a2d544d9d36","modified":1638770826193},{"_id":"source/_posts/redux中间价与副作用的理解.md","hash":"fb5c0675d5ab88c93c09cd98f629158fc9d33825","modified":1638770826206},{"_id":"source/_posts/nodejs 演示jsonp.md","hash":"7100f73a89fded453c927adbe0ad4f02780debe0","modified":1638770826196},{"_id":"source/_posts/return、break和continue.md","hash":"801a0ee14b7be54c07ec6c5f8c6f5ca446e79392","modified":1638770826221},{"_id":"source/_posts/rem在响应式布局中的应用.md","hash":"5c76694be82cee1b142aa02467173dbf258b4c7f","modified":1638770826217},{"_id":"source/_posts/npm package.json文件解读.md","hash":"4696d0ad6d630d7d217584f6d6cf85765c4c2833","modified":1638770826196},{"_id":"source/_posts/redux初识.md","hash":"7da987e99bb36c6b5990c8edc1911e06e82437ed","modified":1638770826206},{"_id":"source/_posts/seajs快速了解.md","hash":"ae45d592ce45287c2cc86df2a87bcd37eec70a4f","modified":1638770826226},{"_id":"source/_posts/sublimeText插件推荐.md","hash":"94e7da3465495501f5f5965f8fd8000331527fba","modified":1638770826226},{"_id":"source/_posts/sublimetext-Emmet插件的使用.md","hash":"63f728059bf82b756f037b8725260c1bc85356c1","modified":1638770826236},{"_id":"source/_posts/this与对象原型(一).md","hash":"ba35382639cbf98abfc286d6af677d8b724c9c1b","modified":1638770825854},{"_id":"source/_posts/this与对象原型(二).md","hash":"29174391e81616b590437b29bcdbe8681e1e00e3","modified":1638770825867},{"_id":"source/_posts/this与对象原型(三).md","hash":"6377efae667214f8d699c0a250490b4b3e978b57","modified":1638770825864},{"_id":"source/_posts/touch触摸事件.md","hash":"88032ce699318fabac71a7bf0b9492cc08fa8701","modified":1638770826246},{"_id":"source/_posts/this与对象原型(四).md","hash":"162a9237c215f73eb3f60e049c177e49ae71d8f6","modified":1638770825867},{"_id":"source/_posts/windows下React-native开发Android入门（ 一 ）环境搭建.md","hash":"c0f955dadeccf4915f8c140897356b1bb508c5e7","modified":1638770826246},{"_id":"source/_posts/windows下React-native开发Android入门（ 二 ）入口文件.md","hash":"6d6cf794e531b97f9c49cf6789c3f3b7cce88126","modified":1638770826256},{"_id":"source/_posts/url参数解析.md","hash":"2793f66cb934ac7a11eb82a1f334776078bdfe97","modified":1521190265000},{"_id":"source/_posts/this小记.md","hash":"752a079eaa30afe80030a5b2edc1e582a62f861e","modified":1638770826242},{"_id":"source/_posts/windows下React-native开发Android入门（ 三 ）布局及样式.md","hash":"452da47118de8d5c558e174997d060428cc69379","modified":1638770826246},{"_id":"source/_posts/事件循环机制.md","hash":"80eee886a562a846c18f0fab4293385383917504","modified":1638770826270},{"_id":"source/_posts/一个页面的孕育过程.md","hash":"6fcd98b1c92fa2943304384b6f173bbc20b8709c","modified":1638770826256},{"_id":"source/_posts/二分查找.md","hash":"e326f8d6000fa950ecbb47dd8b22cc6f611e472a","modified":1638770826067},{"_id":"source/_posts/使用gulp构建自动化工作流.md","hash":"520b3a1d6a6d38ef73845b6f121667e868ad8454","modified":1638770826270},{"_id":"source/_posts/了解闭包.md","hash":"dc70190660cede1dfa565f372b443f2cd59bd7db","modified":1638770826266},{"_id":"source/_posts/关于viewport.md","hash":"273c5e8f185477047f44bdd225792bbe08a756ea","modified":1638770826286},{"_id":"source/_posts/函数节流&函数防抖.md","hash":"22ba8bc2c0fde3b10ea57040071400ce2a97615c","modified":1521190265000},{"_id":"source/_posts/作用域与闭包.md","hash":"95f80e047f306038ba1b9badf78ef1b4a8350911","modified":1638770825874},{"_id":"source/_posts/使用ssh 连接gitHub.md","hash":"1ff50588c1b3b56702156dd927725c153a925737","modified":1638770826276},{"_id":"source/_posts/使用sublimeText至今我所遇到的问题及解决方法.md","hash":"b67dc8b662480742e82e0dcf9086cb774a2af6ab","modified":1638770826276},{"_id":"source/_posts/冒泡排序.md","hash":"9554ad6ac9bdced46c81e859de4727051654c4cc","modified":1638770826072},{"_id":"source/_posts/关于居中.md","hash":"3a1e4af36e3fd44fe5c4caee5a589fe55b9f358d","modified":1638770826286},{"_id":"source/_posts/前端工作随记.md","hash":"08775565e0cd65a2ff18b6cd476cd78be250cf60","modified":1638770826306},{"_id":"source/_posts/关于求职.md","hash":"2f55aeb3d8fe015787998b152faf2534fbeae922","modified":1638770826286},{"_id":"source/_posts/前端代码指南-一.md","hash":"e32896111e7dd739654199db6ec75c9c2ec2411c","modified":1638770826296},{"_id":"source/_posts/前端代码指南-三.md","hash":"d61388f9ce9ec2b0df9ad87f0c16de1bb8e4a51b","modified":1638770826302},{"_id":"source/_posts/原生js对IE78的兼容性写法.md","hash":"9ce149b1b8419c36d1a46f8439f5723d94c30088","modified":1638770826306},{"_id":"source/_posts/基础","hash":"25f322797bca53e6ad9902ac405a735e49dbc6c5","modified":1521190265000},{"_id":"source/_posts/前端代码指南-二.md","hash":"6f4993d483ef15574e32b2fc8553fc70cc804be8","modified":1638770826306},{"_id":"source/_posts/在github中创建演示demo.md","hash":"9316c6da0ed49e8c8875fd35b2e20302a255972d","modified":1638770826318},{"_id":"source/_posts/如何处理输入框的emoji表情.md","hash":"f1b2ccca7905f1d1492f18bf2e55e24e1b3d4eb8","modified":1638770826318},{"_id":"source/_posts/常用插件整理.md","hash":"2d5a66ff0c4f099f85bb43de4b210093322c301f","modified":1638770826337},{"_id":"source/_posts/实现弹出框的鼠标拖拽效果.md","hash":"cdb5189b7602c71231f725cfb2d06c20fd1f7f8f","modified":1638770826327},{"_id":"source/_posts/异步与阻塞","hash":"cc452a7f61b1dd90e555a7892f3d308913d58e81","modified":1521190265000},{"_id":"source/_posts/常用正则表达式函数.md","hash":"e2a7740ae4d60aecd66e9a9f1e0fcdc375424bf2","modified":1521190265000},{"_id":"source/_posts/对象的创建.md","hash":"c9ff5e0c7a2db58871be685cf9678078068226cf","modified":1638770826328},{"_id":"source/_posts/实现跨域.md","hash":"c7333f1e11a4b74706168caa8eefd60e29482a21","modified":1638770826328},{"_id":"source/_posts/弹性盒模型.md","hash":"f844188c12fed492ee00bfc4796c9a4ed16185d6","modified":1638773972661},{"_id":"source/_posts/快速排序.md","hash":"4f72fff9db62dfde97ad9be322bc89175d7936f3","modified":1638770826072},{"_id":"source/_posts/搜索算法.md","hash":"7866f836414b998594e3d4a96ea8192adb5c508e","modified":1638770826072},{"_id":"source/_posts/搭建Java开发环境.md","hash":"4e7c2c94686cd2e6f62f71f4c94c7a9961cd17f8","modified":1521190265000},{"_id":"source/_posts/数组去重.md","hash":"154a751b770a6a75c4dfaecd1baf52bd53d1342a","modified":1521190265000},{"_id":"source/_posts/校准定时器.md","hash":"02050450c753cfc7fd9c03f37c31115b7b5b2e82","modified":1521190265000},{"_id":"source/_posts/模块.md","hash":"7e8abe7b75d3f4873e5ec6e5971fbb6afe2bd728","modified":1521190265000},{"_id":"source/_posts/深拷贝.md","hash":"4ba982348a6ac0d70f5eeb9d1739dfbf89f4c1b0","modified":1521190265000},{"_id":"source/_posts/放大镜效果的基本实现.md","hash":"f77b2fdbe5947abeca1a3a3f571a2d90256e9659","modified":1638770826347},{"_id":"source/_posts/探究TCP.md","hash":"8bf94f99d8d87a85ecc906c5b9abcfd62ebed06e","modified":1638770826347},{"_id":"source/_posts/断点调试篇.md","hash":"c32445c261979b839dc1f6dcc5ccab6ae57291d2","modified":1638770826357},{"_id":"source/_posts/简易git操作命令.md","hash":"f997379b31538f70e4e25a7f385407a2ee42585d","modified":1638770826374},{"_id":"source/_posts/浏览器客户端的数据存储.md","hash":"bafa10bf32907ec14722981af9a68fdf65ee1bbc","modified":1638770826357},{"_id":"source/_posts/第一次react-native项目实践要点总结.md","hash":"388b4913d21c952d714d679bf6d199b3a45773f7","modified":1638770826370},{"_id":"source/_posts/算法复杂度.md","hash":"4491980a36d53c4814b6586cd98fc1ecc1efd849","modified":1638770826081},{"_id":"source/_posts/移动端调试工具-Debuggap.md","hash":"c8acbb96f288e5b780315b2ae21b0d0f50c4c478","modified":1638770826357},{"_id":"source/_posts/重绘和回流.md","hash":"e25c92bf3ea009b1b0d9578194d26b3e7b852c21","modified":1521190265000},{"_id":"source/_posts/计算机字符编码.md","hash":"d778afe0706cd1d7dfd335c661b75c73c723b242","modified":1638770826382},{"_id":"source/_posts/网页内嵌媒体的完美实现.md","hash":"056d6ad6c4dc267689107862ecf62ebf295af6b5","modified":1638770826379},{"_id":"source/_posts/面向对象.md","hash":"15f7e5052f3af555d60a8c75d4ac5be896a7d851","modified":1638770826390},{"_id":"source/_posts/语义化标签.md","hash":"6d78d76d92f309283e89d3c7e0cd7472a9d1b0b8","modified":1638770826386},{"_id":"source/_posts/高性能javascript.md","hash":"ba9d8de7e7219cea255e4376a727e01b907d56db","modified":1638770826394},{"_id":"source/_posts/IO.md","hash":"d7584b5c05e30a9d901abf1c67405f1266f204fb","modified":1638774361095},{"_id":"source/_posts/Network.md","hash":"dfa5255023a9d4d8cfd5d0f44cfe59f49544bb70","modified":1638774365799},{"_id":"source/_posts/http.md","hash":"b1174ce5a128bf5d5427d09a99b4404d55883e35","modified":1638774357325},{"_id":"source/_posts/基础.md","hash":"25f322797bca53e6ad9902ac405a735e49dbc6c5","modified":1638774350512},{"_id":"public/2021/12/06/高性能javascript/index.html","hash":"66d7e8bd21647b6a8f55edf51260b7601d81d36a","modified":1638774782496},{"_id":"public/2021/12/06/面向对象/index.html","hash":"784e646cc65ddb688f6a5b3ced514896f922e65f","modified":1638774782496},{"_id":"public/2021/12/06/计算机字符编码/index.html","hash":"58117d68a1e0e958592ccc338a3ab317cddc6576","modified":1638774782496},{"_id":"public/2021/12/06/简易git操作命令/index.html","hash":"4a9d37623244d011c4486601b6a4cac89412b82f","modified":1638774782496},{"_id":"public/2021/12/06/第一次react-native项目实践要点总结/index.html","hash":"133b61b3219b3c457367b17a542741bb872dc1a0","modified":1638774782496},{"_id":"public/2021/12/06/常用插件整理/index.html","hash":"3a1fa6b769ca978b7e3f8a861d80d972295bdfcd","modified":1638774782496},{"_id":"public/2021/12/06/如何处理输入框的emoji表情/index.html","hash":"6d180192eb249af730c1c63aa8a597266905c3f9","modified":1638774782496},{"_id":"public/2021/12/06/前端工作随记/index.html","hash":"0b43226e9de5ebdffcef687810e848d164d78ed1","modified":1638774782496},{"_id":"public/2021/12/06/原生js对IE78的兼容性写法/index.html","hash":"fb7eea2945532b8f3437a171884b7f4447ec6372","modified":1638774782496},{"_id":"public/2021/12/06/使用ssh 连接gitHub/index.html","hash":"8dd2efbbe1890672e7a1e055a54083581844277a","modified":1638774782496},{"_id":"public/2021/12/06/使用gulp构建自动化工作流/index.html","hash":"311cee3b0007e9e8128da6b75765531f55e754df","modified":1638774782496},{"_id":"public/2021/12/06/事件循环机制/index.html","hash":"1413497ae19cd848ef87a19628bf4a7e653f196f","modified":1638774782496},{"_id":"public/2021/12/06/windows下React-native开发Android入门（ 二 ）入口文件/index.html","hash":"e35038cf36a248d2b1d2848f5f2d8270ea392021","modified":1638774782496},{"_id":"public/2021/12/06/一个页面的孕育过程/index.html","hash":"ea5d1d2af859bbeabf035971460f290b88bf4abc","modified":1638774782496},{"_id":"public/2021/12/06/windows下React-native开发Android入门（ 一 ）环境搭建/index.html","hash":"8e2486a53fa95a9f0bf3fa113ee023b837179740","modified":1638774782496},{"_id":"public/2021/12/06/touch触摸事件/index.html","hash":"da40a7d53b85fd79adf72fa356fb0a53de0d7d80","modified":1638774782496},{"_id":"public/2021/12/06/windows下React-native开发Android入门（ 三 ）布局及样式/index.html","hash":"f96a838a03b2cd8d58f977080db5a71d6a25198d","modified":1638774782496},{"_id":"public/2021/12/06/this小记/index.html","hash":"4f84b31f863cc261904447da2fa65f7a3eb209f6","modified":1638774782496},{"_id":"public/2021/12/06/return、break和continue/index.html","hash":"fddb2616b9197161f079074efdf3edb5cf8571aa","modified":1638774782496},{"_id":"public/2021/12/06/redux中间价与副作用的理解/index.html","hash":"698212ee82bc7331c87ab2a851a14005608dfc82","modified":1638774782496},{"_id":"public/2021/12/06/redux初识/index.html","hash":"8425796830df4fe32b51777b061b104e77808e6d","modified":1638774782496},{"_id":"public/2021/12/06/nodejs 演示jsonp/index.html","hash":"d1d2310ab2b6f48e83a51586904012cf89d27281","modified":1638774782496},{"_id":"public/2021/12/06/npm package.json文件解读/index.html","hash":"5a719ff89af71ce824af54fadca94799af9b5d05","modified":1638774782496},{"_id":"public/2021/12/06/mysql环境搭建/index.html","hash":"8483efe3df02026b5986835089362ccfc6af279c","modified":1638774782496},{"_id":"public/2021/12/06/js基础/index.html","hash":"5d0106059bbf2f25e139e7a05106c31cad721929","modified":1638774782496},{"_id":"public/2021/12/06/javascript中的prototype和constructor/index.html","hash":"bdd77ab1701b7f27dd3b67ccfdb187f70c45d56f","modified":1638774782496},{"_id":"public/2021/12/06/React-Redux/index.html","hash":"387ff07279d8ae6437e9fab02ecb120a5ed40a3a","modified":1638774782496},{"_id":"public/2021/12/06/React-Native性能优化点/index.html","hash":"9b5e12dc4425deac637853c5da51502ca1e92f94","modified":1638774782496},{"_id":"public/2021/12/06/IE hack/index.html","hash":"8a25f756ecbec63f966afd15c3cfc63f10801c71","modified":1638774782496},{"_id":"public/2021/12/06/Jquery属性获取——attr()与prop()/index.html","hash":"73e6dc640e771c8e7042792c8908979eb4bcffdd","modified":1638774782496},{"_id":"public/2021/12/06/ESLint--定制你的代码规则/index.html","hash":"b5b48ff7bc3e709325241612f04563c04feb5599","modified":1638774782496},{"_id":"public/2021/12/06/H5文件上传/index.html","hash":"839548fe63b12eae0ebe40385a80118884f9b888","modified":1638774782496},{"_id":"public/2021/12/06/ES6笔记（二）：ES6新增特性/index.html","hash":"634f651154a53a91c1feafa9e78abd612e5684d0","modified":1638774782496},{"_id":"public/2021/12/06/2016年总结/index.html","hash":"0b43226e9de5ebdffcef687810e848d164d78ed1","modified":1638774782496},{"_id":"public/2021/12/06/算法复杂度/index.html","hash":"990693919aa289b997a2b8e0528fe11cf1fc2845","modified":1638774782496},{"_id":"public/2021/12/06/冒泡排序/index.html","hash":"f4cc61d77db68edc64e07fae069391fcfd971700","modified":1638774782496},{"_id":"public/2021/12/06/快速排序/index.html","hash":"619ce78727255500aabe95ad50dcf39290ff3b85","modified":1638774782496},{"_id":"public/2021/12/06/二分查找/index.html","hash":"0886e06e741e7f143f8f7ab490ef53fa88410f64","modified":1638774782496},{"_id":"public/2021/12/06/this与对象原型(四)/index.html","hash":"83ce3b2f65a83b5ccd70899f7081c507763d33f1","modified":1638774782496},{"_id":"public/2021/12/06/url参数解析/index.html","hash":"3a3786733fc24c7247820d6004333b880c198c90","modified":1638774782496},{"_id":"public/2021/12/06/函数节流&函数防抖/index.html","hash":"744a9302672f434a0753f111e667195a98c73afd","modified":1638774782496},{"_id":"public/2021/12/06/常用正则表达式函数/index.html","hash":"6a2302788e7f2f42f2eec1c25b297f1baaf8f17a","modified":1638774782496},{"_id":"public/2021/12/06/校准定时器/index.html","hash":"e275606db2d0f402942acdb6db6148b76f44e67c","modified":1638774782496},{"_id":"public/2021/12/06/数组去重/index.html","hash":"4210f673c63586dacce94b638fa9d430dd6fec48","modified":1638774782496},{"_id":"public/2021/12/06/深拷贝/index.html","hash":"e884a5ec70c9db4402e5b1cfa5439899d9f449f8","modified":1638774782496},{"_id":"public/2021/12/06/Node.js学习笔记（四）- 全局对象/index.html","hash":"f935f963015a8e6c060c6ccaa4797873c9d31536","modified":1638774782496},{"_id":"public/2021/12/06/Object.creat/index.html","hash":"b8b4ea6cdc53f4c235812e46237b4649e47604fa","modified":1638774782496},{"_id":"public/2021/12/06/class&extends/index.html","hash":"aacc7f2437fd4b5aeb6a7e402957efe5cc77e4e4","modified":1638774782496},{"_id":"public/2021/12/06/模块/index.html","hash":"8e0630d1e89a8f9adece647c25cfa02b1ed95687","modified":1638774782496},{"_id":"public/2021/12/06/基础/index.html","hash":"01512fe9f5fce09057a729c26d6dae849174783d","modified":1638774782496},{"_id":"public/2021/12/06/http/index.html","hash":"dc39e6c074ed4c25c5b14ae3029b70af864e4efa","modified":1638774782496},{"_id":"public/2021/12/06/Node.js学习笔记（一）/index.html","hash":"17428716b626857e03e0a3b3737e76110fb38c95","modified":1638774782496},{"_id":"public/2021/12/06/Node.js学习笔记（三）- 事件机制/index.html","hash":"db0f80460b8006e8df601ea881d0b2eb6abf3b38","modified":1638774782496},{"_id":"public/2021/12/06/Node.js学习笔记（二）：模块机制/index.html","hash":"371d0277e24580ed238a3d2e1366b0bc9dfda728","modified":1638774782496},{"_id":"public/2021/12/06/Node.js学习笔记（五）- 文件系统/index.html","hash":"1388c1b0bdf0722a2348f30eeddc10dbb53b63ae","modified":1638774782496},{"_id":"public/2021/12/06/IO/index.html","hash":"b1b95897b85bd5acf29254bfb0496d3b69cf5fc4","modified":1638774782496},{"_id":"public/2021/12/06/Network/index.html","hash":"63daab67e1088bb2ac67e487dd99898d257cb345","modified":1638774782496},{"_id":"public/2021/12/06/重绘和回流/index.html","hash":"790afb49ac20c25a8344a70448cccb2df5345c27","modified":1638774782496},{"_id":"public/2021/12/06/promise/index.html","hash":"b8b4ea6cdc53f4c235812e46237b4649e47604fa","modified":1638774782496},{"_id":"public/2016/06/12/断点调试篇/index.html","hash":"5251d11525ef8344aa584fdb1412bf2051ca8e32","modified":1638774782496},{"_id":"public/2021/12/06/箭头函数/index.html","hash":"b8b4ea6cdc53f4c235812e46237b4649e47604fa","modified":1638774782496},{"_id":"public/2016/04/12/Java线程/index.html","hash":"3510a69baeb7eeeb41f53f25f64480356158d837","modified":1638774782496},{"_id":"public/2016/04/05/Java封装/index.html","hash":"fbc10d2c36ab9ed476a94336e06bf42e1fe58eb0","modified":1638774782496},{"_id":"public/2021/12/06/let&const/index.html","hash":"eabbf4c9ed9f3c3d1e8d95caa6353ac7bb4b0b59","modified":1638774782496},{"_id":"public/2016/04/05/Java抽象类/index.html","hash":"bc4b2f975465914e7bd01fae0a6b547343504aec","modified":1638774782496},{"_id":"public/2016/04/01/Java多态/index.html","hash":"9f314b45885394fcc679f913ae8422f98c165392","modified":1638774782496},{"_id":"public/2016/04/06/Java接口/index.html","hash":"01a54379d6bd2e37152849dc8259dee334d9a5b5","modified":1638774782496},{"_id":"public/2016/03/31/Java继承/index.html","hash":"fc0b010ac1ef579a921617ccba15988f18cb526f","modified":1638774782496},{"_id":"public/2016/03/31/Java中的方法（函数）/index.html","hash":"6eb8e50c45a807a842e289c0e00df2b116e3d697","modified":1638774782496},{"_id":"public/2016/03/31/Java的类和对象/index.html","hash":"f59c868a9f6c2283e376b5e6813b93269fce3ea6","modified":1638774782496},{"_id":"public/2016/03/30/在github中创建演示demo/index.html","hash":"c3b2bafb84dcb064f69843fbe29e9c5064d81ac4","modified":1638774782496},{"_id":"public/2016/03/30/rem在响应式布局中的应用/index.html","hash":"ef619ed0c1817e66556efcc2ab43202680c2b2ea","modified":1638774782496},{"_id":"public/2016/03/29/Java数组/index.html","hash":"b0e96c9792c708dda08b546e6719934f9a863d28","modified":1638774782496},{"_id":"public/2016/03/29/java控制流程语句/index.html","hash":"08a9b67aaddf198cd2b0a07a33242f016fac7fdf","modified":1638774782496},{"_id":"public/2016/03/28/Java基本语言/index.html","hash":"094885b16fe02eebdf790ea68723791e586637ff","modified":1638774782496},{"_id":"public/2016/03/28/搭建Java开发环境/index.html","hash":"445c5822e37aed0c4ce57dd911e667282d6cf51f","modified":1638774782496},{"_id":"public/2016/03/16/网页内嵌媒体的完美实现/index.html","hash":"63b8db075ee72d4d1a26a717b975d541e905f57d","modified":1638774782496},{"_id":"public/2016/03/16/移动端调试工具-Debuggap/index.html","hash":"7c0c186beaca6f9bc042434c631c315fb11eef6d","modified":1638774782496},{"_id":"public/2016/03/16/探究TCP/index.html","hash":"30210443fbce93f6e4f9434896a6723e925ef155","modified":1638774782496},{"_id":"public/2016/01/12/弹性盒模型/index.html","hash":"ac4d60d705a5feece0a43eb5dbca5d4f67d8a6a6","modified":1638774782496},{"_id":"public/2016/01/11/sublimeText插件推荐/index.html","hash":"2b87ea2db2dceb2d8ca2ee19c9e1e86e815fca64","modified":1638774782496},{"_id":"public/2015/12/30/CSS文本溢出显示省略号/index.html","hash":"d9f6444373950420895e1bb3c78acb35eb85a1ef","modified":1638774782496},{"_id":"public/2015/12/29/语义化标签/index.html","hash":"19488130d29be7dcbc5f4f44763b57c2bac320f9","modified":1638774782496},{"_id":"public/2015/12/24/前端代码指南-一/index.html","hash":"8f04b243084d32ecb2bae0f3ed665608e270d9d1","modified":1638774782496},{"_id":"public/2015/12/22/了解闭包/index.html","hash":"1008328ce5965c05d3a9f64284d7a000e8ac4dfd","modified":1638774782496},{"_id":"public/2015/12/17/seajs快速了解/index.html","hash":"81bdfe1691f1cdf6ec9d0178f425263d35531039","modified":1638774782496},{"_id":"public/2015/12/16/lazyload-js详解/index.html","hash":"3bdce89efe647cd2b3824e364b0d41f49d24e405","modified":1638774782496},{"_id":"public/2015/12/15/iScroll-js——smooth scrolling for the web/index.html","hash":"4467e6d3c349a84b8b7c32d282083564b74c1734","modified":1638774782496},{"_id":"public/2015/12/03/关于viewport/index.html","hash":"47be5ffd14cbd63d4a3becaa25b1d29a1d2d64a6","modified":1638774782496},{"_id":"public/2021/12/06/关于求职/index.html","hash":"9c7d2e8865988788c2bf9dc2ed446f8b21ae0653","modified":1638774782496},{"_id":"public/2021/12/06/ES6笔记（一）：ES6所改良的javascript“缺陷”/index.html","hash":"1eb790a4f6f7e3b5f4e8c29342b2eb855ecfe9b6","modified":1638774782496},{"_id":"public/2021/12/06/搜索算法/index.html","hash":"0b47e197750dc770ea35c2607040345243ab0163","modified":1638774782496},{"_id":"public/2021/12/06/作用域与闭包/index.html","hash":"e9a14cc41ba184e3447915a1fecde9ed55f137f1","modified":1638774782496},{"_id":"public/2021/12/06/this与对象原型(二)/index.html","hash":"af65ee8ec0bc546c2ea47a9150da4cef382dd802","modified":1638774782496},{"_id":"public/2021/12/06/this与对象原型(一)/index.html","hash":"409198766df9aac983c8a7d19b9f2e995228ef64","modified":1638774782496},{"_id":"public/2021/12/06/this与对象原型(三)/index.html","hash":"f9c870b557bbd1198aa3fcb0eccbc071d479d896","modified":1638774782496},{"_id":"public/2021/12/06/BFC/index.html","hash":"13b11e533eba0cfa4da3394b494c4e1a78f48b71","modified":1638774782496},{"_id":"public/2016/04/07/Java异常处理/index.html","hash":"d625aefe9ab2e3a07b8c90ad922ef721ae91d531","modified":1638774782496},{"_id":"public/2016/03/25/javascript模块化/index.html","hash":"7dd03fcbae413d10360afe7e2628a15fbadc1087","modified":1638774782496},{"_id":"public/2016/03/23/浏览器客户端的数据存储/index.html","hash":"8ad9e92537493c2c475f60d82c74a2a476e83ed0","modified":1638774782496},{"_id":"public/2016/03/18/javascript中的继承/index.html","hash":"26a97904fc74a039a87fa3f0330e21eefcc7f6d8","modified":1638774782496},{"_id":"public/2016/03/15/JavaScript原型学习笔记/index.html","hash":"4d78057a91075a86f45ee59adb14e74b8c8a0d8b","modified":1638774782496},{"_id":"public/2016/03/14/javascript作用域链学习笔记/index.html","hash":"cce3535ba4a21abfcb2963faa25b7deece769339","modified":1638774782496},{"_id":"public/2015/12/25/前端代码指南-三/index.html","hash":"5498dd6800eff68cf8a3b861b6e04b9b7a8da0ae","modified":1638774782496},{"_id":"public/2015/12/25/前端代码指南-二/index.html","hash":"0e29a9e770afce6f997ae2b33ff82b3adf0c154e","modified":1638774782496},{"_id":"public/2015/12/23/实现跨域/index.html","hash":"71d59c984957a1b7481ee9af6a715221942c5004","modified":1638774782496},{"_id":"public/2015/12/21/C语言入门/index.html","hash":"36f813d8f44336ffe156b42c56cf6c51d69b274a","modified":1638774782496},{"_id":"public/2015/12/04/canvas初探/index.html","hash":"60882d0395e7d69c08f5eb4329c0395ec1c22411","modified":1638774782496},{"_id":"public/2015/12/01/Backbone学习笔记（一）/index.html","hash":"73f1e9bd37e5b8c28b903dc219cbce8b311d1d76","modified":1638774782496},{"_id":"public/2015/11/23/github-hexo构建静态博客（二）/index.html","hash":"8f95793772c67f237a517dd0ac283f875a849134","modified":1638774782496},{"_id":"public/2015/11/23/github-hexo构建静态博客（一）/index.html","hash":"b72c58b0baa4df258e3111f86361b28f36409955","modified":1638774782496},{"_id":"public/2015/10/16/jquery对javascript事件的封装一览/index.html","hash":"c1e85c0bdf8641e1c3096baf626f1786072a2e1a","modified":1638774782496},{"_id":"public/2015/09/23/对象的创建/index.html","hash":"0857f1166734b3d2588ffb174c4b36a55aa7ad5b","modified":1638774782496},{"_id":"public/2015/07/14/关于居中/index.html","hash":"70f85061b0fc4aaf6d0f8fa916bd74997ff8b24a","modified":1638774782496},{"_id":"public/2015/07/07/css三角形的实现/index.html","hash":"455c2b4a6f8753c59baedd274f45a7120f99ff73","modified":1638774782496},{"_id":"public/2015/05/06/sublimetext-Emmet插件的使用/index.html","hash":"2e335037c267905f8c2a0ff57463837303ea0a4a","modified":1638774782496},{"_id":"public/2015/05/04/使用sublimeText至今我所遇到的问题及解决方法/index.html","hash":"be14a0edcd185911d4065dbaa85c68a6df815158","modified":1638774782496},{"_id":"public/2015/04/28/jquery和js获取及设置元素的尺寸和位置/index.html","hash":"960758aab1be61cb4395b2b834de229e1443e20b","modified":1638774782496},{"_id":"public/2015/04/27/实现弹出框的鼠标拖拽效果/index.html","hash":"90efd6b811af6ab93953b2ccd4f9508174adb7f8","modified":1638774782496},{"_id":"public/2015/04/21/放大镜效果的基本实现/index.html","hash":"b6027010f554e705a941120e69367be9e31ad0cd","modified":1638774782496},{"_id":"public/page/2/index.html","hash":"4b3c9e20095add6f7324c2b9bcaccf6aa566f76e","modified":1638774782496},{"_id":"public/page/3/index.html","hash":"0e1a1f88b1d3de223a9c7fee730d22a11d3a6323","modified":1638774782496},{"_id":"public/page/4/index.html","hash":"c399f430295a11631561cccfed832b4cdb9c56ac","modified":1638774782496},{"_id":"public/page/5/index.html","hash":"a4af0e6d236b6e2a0bfdd8757c5554ce0cafb514","modified":1638774782496},{"_id":"public/page/6/index.html","hash":"be4c8afd847072d94695cd5dc5fed86a6804c9d3","modified":1638774782496},{"_id":"public/page/7/index.html","hash":"fc52e0a8125b1aeeca79fac94663075a08146dcb","modified":1638774782496},{"_id":"public/page/8/index.html","hash":"3f256bc6107e03cf2562b3afb238692e7894da24","modified":1638774782496},{"_id":"public/page/9/index.html","hash":"f3d502f4e4aa04deec839b552c0456bbfa514dbc","modified":1638774782496},{"_id":"public/page/10/index.html","hash":"ccbd61cbf8bcd1bfaa05ad862ac4d403b8297377","modified":1638774782496},{"_id":"public/page/11/index.html","hash":"a4354c14bcf12ff516f7304d46f8fe41b91a4d1b","modified":1638774782496},{"_id":"public/page/12/index.html","hash":"24942670a92bdc8f9ca5c28ae9580effacdc531a","modified":1638774782496},{"_id":"public/page/13/index.html","hash":"bcc84dd38efda67af83a9c066b3d15d8fb2bae78","modified":1638774782496},{"_id":"public/tags/css/index.html","hash":"30146e20b05451c594a898fd5fbb0639a5b14955","modified":1638774782496},{"_id":"public/tags/C语言/index.html","hash":"03a293e42f4e026eac9e199e1aaa32f962bb4f88","modified":1638774782496},{"_id":"public/tags/web/index.html","hash":"dec70c8499643cd1a1b42d1b514beaeba4339352","modified":1638774782496},{"_id":"public/tags/web/page/2/index.html","hash":"3ff1327ca54733359ae2893fb2ae49eb9379993b","modified":1638774782496},{"_id":"public/tags/Backbone/index.html","hash":"092c178b3c2f6a8334ee21f37e1ff69d1acf0087","modified":1638774782496},{"_id":"public/tags/java基础/index.html","hash":"aff56fb038fa63a1d874f55293edc85284ebe668","modified":1638774782496},{"_id":"public/tags/javascript/index.html","hash":"6bff4c42a53df60d0c9d104e10d8328f06a84444","modified":1638774782496},{"_id":"public/tags/javascript/page/2/index.html","hash":"b50ee3007aa2be90ae0f67ed8dafd0e8333e7d47","modified":1638774782496},{"_id":"public/tags/java面向对象/index.html","hash":"fbcadc4868a00ce5b218c782e1d2160b893d774e","modified":1638774782496},{"_id":"public/tags/Java基础/index.html","hash":"05a9899d75575c78487188d83183f03b66a64abf","modified":1638774782496},{"_id":"public/tags/H5/index.html","hash":"90ef1c53fc471af926df76fdd1ee4cdc6271cea4","modified":1638774782496},{"_id":"public/tags/其他/index.html","hash":"acd96bf37571857c08ec6d605e9ad04b9bbe22cf","modified":1638774782496},{"_id":"public/tags/插件/index.html","hash":"4cfc6e4faba7916a5fbc7ee657febc6c5fd73f50","modified":1638774782496},{"_id":"public/tags/移动端开发/index.html","hash":"7965def0cabd16bdb5218e35f122d0939ea70b9d","modified":1638774782496},{"_id":"public/tags/工具/index.html","hash":"3c9ea59e6c4d8a4b691fd18f96ba22190d01670c","modified":1638774782496},{"_id":"public/archives/page/4/index.html","hash":"c399f430295a11631561cccfed832b4cdb9c56ac","modified":1638774782496},{"_id":"public/tags/计算机网络/index.html","hash":"92b38af8da6f6763d81dbc63bfd087bdbd2b161c","modified":1638774782496},{"_id":"public/archives/page/3/index.html","hash":"0e1a1f88b1d3de223a9c7fee730d22a11d3a6323","modified":1638774782496},{"_id":"public/archives/page/2/index.html","hash":"4b3c9e20095add6f7324c2b9bcaccf6aa566f76e","modified":1638774782496},{"_id":"public/archives/page/7/index.html","hash":"fc52e0a8125b1aeeca79fac94663075a08146dcb","modified":1638774782496},{"_id":"public/archives/page/6/index.html","hash":"be4c8afd847072d94695cd5dc5fed86a6804c9d3","modified":1638774782496},{"_id":"public/archives/page/5/index.html","hash":"a4af0e6d236b6e2a0bfdd8757c5554ce0cafb514","modified":1638774782496},{"_id":"public/archives/page/8/index.html","hash":"3f256bc6107e03cf2562b3afb238692e7894da24","modified":1638774782496},{"_id":"public/archives/page/9/index.html","hash":"f3d502f4e4aa04deec839b552c0456bbfa514dbc","modified":1638774782496},{"_id":"public/archives/page/10/index.html","hash":"ccbd61cbf8bcd1bfaa05ad862ac4d403b8297377","modified":1638774782496},{"_id":"public/archives/page/11/index.html","hash":"a4354c14bcf12ff516f7304d46f8fe41b91a4d1b","modified":1638774782496},{"_id":"public/archives/page/12/index.html","hash":"24942670a92bdc8f9ca5c28ae9580effacdc531a","modified":1638774782496},{"_id":"public/archives/page/13/index.html","hash":"bcc84dd38efda67af83a9c066b3d15d8fb2bae78","modified":1638774782496},{"_id":"public/archives/2015/index.html","hash":"a9515f8a73a486d92b0657ed1304e61c55af5934","modified":1638774782496},{"_id":"public/archives/2015/page/2/index.html","hash":"c2f4c1cb9cec2701dad50a81beb90aaf73ceb063","modified":1638774782496},{"_id":"public/archives/2015/04/index.html","hash":"2ed90df4c9e05ef6a7e746199333d162a2d410e6","modified":1638774782496},{"_id":"public/archives/2015/page/3/index.html","hash":"eedddcbc7cd235fa03c5679077df4bb4edcefdbc","modified":1638774782496},{"_id":"public/archives/2015/05/index.html","hash":"38f6eb8f8af4338d55e05509ac72885c7a818b08","modified":1638774782496},{"_id":"public/archives/2015/09/index.html","hash":"95ec7afa25450a5728b62c62152a5688bd062cfc","modified":1638774782496},{"_id":"public/archives/2015/07/index.html","hash":"877152f6fb71291f988c3540eb704046d652c957","modified":1638774782496},{"_id":"public/archives/2015/10/index.html","hash":"7d470a9683eba943cd6944fcd41e3d4ca7af6fcb","modified":1638774782496},{"_id":"public/archives/2015/11/index.html","hash":"8db5016bbfcd9cced15e4c6e947b4daceee12ed9","modified":1638774782496},{"_id":"public/archives/2015/12/index.html","hash":"a9515f8a73a486d92b0657ed1304e61c55af5934","modified":1638774782496},{"_id":"public/archives/2015/12/page/2/index.html","hash":"cb986bab018695e758aef066009205fa753d552a","modified":1638774782496},{"_id":"public/archives/2016/index.html","hash":"ab1e3541e7977ab6bd07f55ca8d08ac7e0b38d5b","modified":1638774782496},{"_id":"public/archives/2016/page/2/index.html","hash":"ca3221eb71a596e1002269e161079fcaf3db0190","modified":1638774782496},{"_id":"public/archives/2016/page/3/index.html","hash":"707fd7f6973d2fa556c134bc31d5a68abc719ae3","modified":1638774782496},{"_id":"public/archives/2016/01/index.html","hash":"ef64176e89858b1c4a430a071bd505552e53f28e","modified":1638774782496},{"_id":"public/archives/2016/03/index.html","hash":"c36b14c992509865f5dc278a0865539955649e7f","modified":1638774782496},{"_id":"public/archives/2016/03/page/2/index.html","hash":"bb14d53d23de8b6f5c02ba61539cc0cd39caa1d5","modified":1638774782496},{"_id":"public/archives/2016/04/index.html","hash":"329b0312b15f6da7d0ad5d9dff47dcd61f9bd715","modified":1638774782496},{"_id":"public/archives/2021/page/2/index.html","hash":"4b3c9e20095add6f7324c2b9bcaccf6aa566f76e","modified":1638774782496},{"_id":"public/archives/2021/page/5/index.html","hash":"a4af0e6d236b6e2a0bfdd8757c5554ce0cafb514","modified":1638774782496},{"_id":"public/archives/2016/06/index.html","hash":"6ff46a417c47bccb7a42490e5657718f214405dc","modified":1638774782496},{"_id":"public/archives/2021/page/4/index.html","hash":"c399f430295a11631561cccfed832b4cdb9c56ac","modified":1638774782496},{"_id":"public/archives/2021/page/7/index.html","hash":"fc52e0a8125b1aeeca79fac94663075a08146dcb","modified":1638774782496},{"_id":"public/archives/2021/page/6/index.html","hash":"be4c8afd847072d94695cd5dc5fed86a6804c9d3","modified":1638774782496},{"_id":"public/archives/2021/page/3/index.html","hash":"0e1a1f88b1d3de223a9c7fee730d22a11d3a6323","modified":1638774782496},{"_id":"public/archives/2021/12/page/2/index.html","hash":"4b3c9e20095add6f7324c2b9bcaccf6aa566f76e","modified":1638774782496},{"_id":"public/archives/2021/page/8/index.html","hash":"d6db55fdbf26d43574ab40b662d6f6b4f7f9e9d1","modified":1638774782496},{"_id":"public/archives/2021/12/page/5/index.html","hash":"a4af0e6d236b6e2a0bfdd8757c5554ce0cafb514","modified":1638774782496},{"_id":"public/archives/2021/12/page/4/index.html","hash":"c399f430295a11631561cccfed832b4cdb9c56ac","modified":1638774782496},{"_id":"public/archives/2021/12/page/3/index.html","hash":"0e1a1f88b1d3de223a9c7fee730d22a11d3a6323","modified":1638774782496},{"_id":"public/archives/2021/12/page/8/index.html","hash":"d6db55fdbf26d43574ab40b662d6f6b4f7f9e9d1","modified":1638774782496},{"_id":"public/archives/2021/12/page/7/index.html","hash":"fc52e0a8125b1aeeca79fac94663075a08146dcb","modified":1638774782496},{"_id":"public/archives/2021/12/page/6/index.html","hash":"be4c8afd847072d94695cd5dc5fed86a6804c9d3","modified":1638774782496}],"Category":[{"name":"css","_id":"ckwuaudr80002wcv23zkl8o5j"}],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-12-06T02:07:54.078Z","updated":"2021-12-06T03:22:32.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwuaudqr0000wcv23yrk2e63","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"test","date":"2021-12-06T06:31:35.000Z","_content":"\nthis is a test page\n","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2021-12-06 14:31:35\ncategories: css\n---\n\nthis is a test page\n","slug":"test","published":1,"updated":"2021-12-06T06:35:09.630Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwuaudr60001wcv22yt06o0c","content":"<p>this is a test page</p>\n","site":{"data":{}},"excerpt":"","more":"<p>this is a test page</p>\n"},{"_content":"\n# 运行机制：事件队列与调用栈\n\n## JavaScript 是单线程单并发语言\n\n1. 什么是单线程\n\n    主程序只有一个线程，即同一时间片断内其只能执行单个任务。\n\n2. 为什么选择单线程？\n\n    JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。\n\n3. 单线程意味着什么？\n\n    单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就需要一直等着。这就会导致`IO操作（耗时但cpu闲置）`时造成性能浪费的问题。\n\n4. 如何解决单线程带来的性能问题？\n\n    答案是**异步**！主线程完全可以不管IO操作，暂时挂起处于等待中的任务，先运行排在后面的任务。等到IO操作返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。\n\n    **注：**  当主线程阻塞时，任务队列仍然是能够被推入任务的\n\n\n## 事件循环（Event Loop）\n\n1. JavaScript 内存模型\n\n    讲事件循环之前，先看一张下网上看到的 JavaScript 内存模型，相信看完这个会对事件循环机制有一种豁然开朗的感觉。\n\n    ![](https://raw.githubusercontent.com/bigdots/blog/master/images/201709/h-s-q.png)\n\n    + 调用栈（Call Stack）：用于主线程任务的执行\n    + 堆（Heap）： 用于存放非结构化数据，譬如程序分配的变量与对象\n    + 任务队列（Queue）： 用于存放异步任务与定时任务。\n\n2. JavaScript 代码执行机制：\n\n    + 所有同步任务都在主线程上的栈中执行。\n    + 主线程之外，还存在一个\"任务队列\"（task queue）。**只要异步任务有了运行结果**，就在\"任务队列\"之中放置一个事件。\n    + 一旦\"栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，选择出需要首先执行的任务（由浏览器决定，并不按序）。\n\n3. Event Loop\n\n    现在我们来聊事件循环。事件循环顾名思义它就是一个循环，主线程会不断循环执行上面的第三步,其基本的代码逻辑如下所示：\n\n    ```js\n    while (queue.waitForMessage()) {\n    queue.processNextMessage();\n    }\n    ```\n\n4. 常见异步任务进入任务队列时机\n\n    |  行为              |           时机              |\n    |:----              |:----                       |\n    | DOM操作           | 在用户点击等操作事件完成后      |\n    | 网络操作（Ajax等）  | 在网络操作响应后              |\n    | 定时器             | 在规定时间到达后              |\n\n\n    事件循环机制图解：\n\n    ![](https://raw.githubusercontent.com/bigdots/blog/master/images/201709/eventLoop.png)\n\n\n## 任务\n\n1. MacroTask（Task）\n    setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering\n\n2. MicroTask（在ES2015规范中称为Job）\n     process.nextTick, Promise, Object.observe, MutationObserver\n\n规范：\n\n+ 每个浏览器环境，至多有一个event loop。\n+ 一个event loop可以有1个或多个task queue，而仅有一个 MicroTask Queue。\n+ 一个task queue是一列有序的task, 每个task定义时都有一个task source，从同一个task source来的task必须放到同一个task queue，从不同源来的则被添加到不同队列。\n+ tasks are scheduled，所以浏览器可以从内部到JS/DOM，保证动作按序发生。\n+ Microtasks are scheduled，Microtask queue 在当前 task queue 的结尾执行。microtask中添加的microtask也被添加到Microtask queue的末尾并处理。\n\n **注：** event loop的每个turn，是由浏览器决定先执行哪个task queue。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。\n\n\n## 示例\n\n```js\n\nfunction ELoop() {\n    // 当前任务\n    let p = new Promise((resolve, reject)=>{\n        console.log(\"current Task\")\n        resolve();\n    });\n    let nextP; \n\n    setTimeout(()=>{\n        console.log(\"MacroTask_1\");\n        nextP.then(()=>{\n            // 第一次执行时，这段代码并没有执行到。\n            console.log(\"MicroTask_promise_1\"); //第一个MicroTask\n        })\n        console.log(\"MacroTask_1 end\")\n    }, 0) // 第一个 MacroTask\n\n    setTimeout(()=>{\n        console.log(\"MacroTask_2\");\n        console.log(\"MacroTask_2 end\")\n    }, 0)// 第二个MacroTask\n\n    nextP = p.then(()=>{\n        console.log(\"MicroTask_promise_2\"); //第一个MicroTask\n        console.log(1)\n    }).then(()=>{\n        console.log(\"MicroTask_promise_3\"); // 第二个MicroTask\n        console.log(1)\n    })\n\n    console.log(\"current Task end\")\n}\n\nELoop();\n\n/**输出结果：\ncurrent Task\nMicroTask_promise_2\nMicroTask_promise_3\nMacroTask_1\nMicroTask_promise_1\nMacroTask_2\n**/\n```\n\n参考文献:\n\n[从Promise来看JavaScript中的Event Loop、Tasks和Microtasks](https://github.com/creeperyang/blog/issues/21)\n\n[JavaScript Event Loop 机制详解与 Vue.js 中实践应用](http://mp.weixin.qq.com/s/qJSmotjzeu02EeK51NgFUQ)\n\n[JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)","source":"_posts/运行机制-事件队列与调用栈.md","raw":"\n# 运行机制：事件队列与调用栈\n\n## JavaScript 是单线程单并发语言\n\n1. 什么是单线程\n\n    主程序只有一个线程，即同一时间片断内其只能执行单个任务。\n\n2. 为什么选择单线程？\n\n    JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。\n\n3. 单线程意味着什么？\n\n    单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就需要一直等着。这就会导致`IO操作（耗时但cpu闲置）`时造成性能浪费的问题。\n\n4. 如何解决单线程带来的性能问题？\n\n    答案是**异步**！主线程完全可以不管IO操作，暂时挂起处于等待中的任务，先运行排在后面的任务。等到IO操作返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。\n\n    **注：**  当主线程阻塞时，任务队列仍然是能够被推入任务的\n\n\n## 事件循环（Event Loop）\n\n1. JavaScript 内存模型\n\n    讲事件循环之前，先看一张下网上看到的 JavaScript 内存模型，相信看完这个会对事件循环机制有一种豁然开朗的感觉。\n\n    ![](https://raw.githubusercontent.com/bigdots/blog/master/images/201709/h-s-q.png)\n\n    + 调用栈（Call Stack）：用于主线程任务的执行\n    + 堆（Heap）： 用于存放非结构化数据，譬如程序分配的变量与对象\n    + 任务队列（Queue）： 用于存放异步任务与定时任务。\n\n2. JavaScript 代码执行机制：\n\n    + 所有同步任务都在主线程上的栈中执行。\n    + 主线程之外，还存在一个\"任务队列\"（task queue）。**只要异步任务有了运行结果**，就在\"任务队列\"之中放置一个事件。\n    + 一旦\"栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，选择出需要首先执行的任务（由浏览器决定，并不按序）。\n\n3. Event Loop\n\n    现在我们来聊事件循环。事件循环顾名思义它就是一个循环，主线程会不断循环执行上面的第三步,其基本的代码逻辑如下所示：\n\n    ```js\n    while (queue.waitForMessage()) {\n    queue.processNextMessage();\n    }\n    ```\n\n4. 常见异步任务进入任务队列时机\n\n    |  行为              |           时机              |\n    |:----              |:----                       |\n    | DOM操作           | 在用户点击等操作事件完成后      |\n    | 网络操作（Ajax等）  | 在网络操作响应后              |\n    | 定时器             | 在规定时间到达后              |\n\n\n    事件循环机制图解：\n\n    ![](https://raw.githubusercontent.com/bigdots/blog/master/images/201709/eventLoop.png)\n\n\n## 任务\n\n1. MacroTask（Task）\n    setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering\n\n2. MicroTask（在ES2015规范中称为Job）\n     process.nextTick, Promise, Object.observe, MutationObserver\n\n规范：\n\n+ 每个浏览器环境，至多有一个event loop。\n+ 一个event loop可以有1个或多个task queue，而仅有一个 MicroTask Queue。\n+ 一个task queue是一列有序的task, 每个task定义时都有一个task source，从同一个task source来的task必须放到同一个task queue，从不同源来的则被添加到不同队列。\n+ tasks are scheduled，所以浏览器可以从内部到JS/DOM，保证动作按序发生。\n+ Microtasks are scheduled，Microtask queue 在当前 task queue 的结尾执行。microtask中添加的microtask也被添加到Microtask queue的末尾并处理。\n\n **注：** event loop的每个turn，是由浏览器决定先执行哪个task queue。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。\n\n\n## 示例\n\n```js\n\nfunction ELoop() {\n    // 当前任务\n    let p = new Promise((resolve, reject)=>{\n        console.log(\"current Task\")\n        resolve();\n    });\n    let nextP; \n\n    setTimeout(()=>{\n        console.log(\"MacroTask_1\");\n        nextP.then(()=>{\n            // 第一次执行时，这段代码并没有执行到。\n            console.log(\"MicroTask_promise_1\"); //第一个MicroTask\n        })\n        console.log(\"MacroTask_1 end\")\n    }, 0) // 第一个 MacroTask\n\n    setTimeout(()=>{\n        console.log(\"MacroTask_2\");\n        console.log(\"MacroTask_2 end\")\n    }, 0)// 第二个MacroTask\n\n    nextP = p.then(()=>{\n        console.log(\"MicroTask_promise_2\"); //第一个MicroTask\n        console.log(1)\n    }).then(()=>{\n        console.log(\"MicroTask_promise_3\"); // 第二个MicroTask\n        console.log(1)\n    })\n\n    console.log(\"current Task end\")\n}\n\nELoop();\n\n/**输出结果：\ncurrent Task\nMicroTask_promise_2\nMicroTask_promise_3\nMacroTask_1\nMicroTask_promise_1\nMacroTask_2\n**/\n```\n\n参考文献:\n\n[从Promise来看JavaScript中的Event Loop、Tasks和Microtasks](https://github.com/creeperyang/blog/issues/21)\n\n[JavaScript Event Loop 机制详解与 Vue.js 中实践应用](http://mp.weixin.qq.com/s/qJSmotjzeu02EeK51NgFUQ)\n\n[JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)","slug":"运行机制-事件队列与调用栈","published":1,"date":"2021-12-06T06:39:27.059Z","updated":"2021-12-06T06:07:05.844Z","_id":"ckwuazrxp0004wcv2ghf7bb9e","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"运行机制：事件队列与调用栈\"><a href=\"#运行机制：事件队列与调用栈\" class=\"headerlink\" title=\"运行机制：事件队列与调用栈\"></a>运行机制：事件队列与调用栈</h1><h2 id=\"JavaScript-是单线程单并发语言\"><a href=\"#JavaScript-是单线程单并发语言\" class=\"headerlink\" title=\"JavaScript 是单线程单并发语言\"></a>JavaScript 是单线程单并发语言</h2><ol>\n<li><p>什么是单线程</p>\n<p> 主程序只有一个线程，即同一时间片断内其只能执行单个任务。</p>\n</li>\n<li><p>为什么选择单线程？</p>\n<p> JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p>\n</li>\n<li><p>单线程意味着什么？</p>\n<p> 单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就需要一直等着。这就会导致<code>IO操作（耗时但cpu闲置）</code>时造成性能浪费的问题。</p>\n</li>\n<li><p>如何解决单线程带来的性能问题？</p>\n<p> 答案是<strong>异步</strong>！主线程完全可以不管IO操作，暂时挂起处于等待中的任务，先运行排在后面的任务。等到IO操作返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>\n<p> <strong>注：</strong>  当主线程阻塞时，任务队列仍然是能够被推入任务的</p>\n</li>\n</ol>\n<h2 id=\"事件循环（Event-Loop）\"><a href=\"#事件循环（Event-Loop）\" class=\"headerlink\" title=\"事件循环（Event Loop）\"></a>事件循环（Event Loop）</h2><ol>\n<li><p>JavaScript 内存模型</p>\n<p> 讲事件循环之前，先看一张下网上看到的 JavaScript 内存模型，相信看完这个会对事件循环机制有一种豁然开朗的感觉。</p>\n<p> <img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201709/h-s-q.png\"></p>\n<ul>\n<li>调用栈（Call Stack）：用于主线程任务的执行</li>\n<li>堆（Heap）： 用于存放非结构化数据，譬如程序分配的变量与对象</li>\n<li>任务队列（Queue）： 用于存放异步任务与定时任务。</li>\n</ul>\n</li>\n<li><p>JavaScript 代码执行机制：</p>\n<ul>\n<li>所有同步任务都在主线程上的栈中执行。</li>\n<li>主线程之外，还存在一个”任务队列”（task queue）。<strong>只要异步任务有了运行结果</strong>，就在”任务队列”之中放置一个事件。</li>\n<li>一旦”栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，选择出需要首先执行的任务（由浏览器决定，并不按序）。</li>\n</ul>\n</li>\n<li><p>Event Loop</p>\n<p> 现在我们来聊事件循环。事件循环顾名思义它就是一个循环，主线程会不断循环执行上面的第三步,其基本的代码逻辑如下所示：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (queue.waitForMessage()) &#123;</span><br><span class=\"line\">queue.processNextMessage();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>常见异步任务进入任务队列时机</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">行为</th>\n<th align=\"left\">时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">DOM操作</td>\n<td align=\"left\">在用户点击等操作事件完成后</td>\n</tr>\n<tr>\n<td align=\"left\">网络操作（Ajax等）</td>\n<td align=\"left\">在网络操作响应后</td>\n</tr>\n<tr>\n<td align=\"left\">定时器</td>\n<td align=\"left\">在规定时间到达后</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<pre><code>事件循环机制图解：\n\n![](https://raw.githubusercontent.com/bigdots/blog/master/images/201709/eventLoop.png)\n</code></pre>\n<h2 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h2><ol>\n<li><p>MacroTask（Task）<br> setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering</p>\n</li>\n<li><p>MicroTask（在ES2015规范中称为Job）<br>  process.nextTick, Promise, Object.observe, MutationObserver</p>\n</li>\n</ol>\n<p>规范：</p>\n<ul>\n<li>每个浏览器环境，至多有一个event loop。</li>\n<li>一个event loop可以有1个或多个task queue，而仅有一个 MicroTask Queue。</li>\n<li>一个task queue是一列有序的task, 每个task定义时都有一个task source，从同一个task source来的task必须放到同一个task queue，从不同源来的则被添加到不同队列。</li>\n<li>tasks are scheduled，所以浏览器可以从内部到JS/DOM，保证动作按序发生。</li>\n<li>Microtasks are scheduled，Microtask queue 在当前 task queue 的结尾执行。microtask中添加的microtask也被添加到Microtask queue的末尾并处理。</li>\n</ul>\n<p> <strong>注：</strong> event loop的每个turn，是由浏览器决定先执行哪个task queue。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ELoop</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前任务</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;current Task&quot;</span>)</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextP; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_1&quot;</span>);</span><br><span class=\"line\">        nextP.then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 第一次执行时，这段代码并没有执行到。</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_1&quot;</span>); <span class=\"comment\">//第一个MicroTask</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_1 end&quot;</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>) <span class=\"comment\">// 第一个 MacroTask</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_2&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_2 end&quot;</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)<span class=\"comment\">// 第二个MacroTask</span></span><br><span class=\"line\"></span><br><span class=\"line\">    nextP = p.then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_2&quot;</span>); <span class=\"comment\">//第一个MicroTask</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;).then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_3&quot;</span>); <span class=\"comment\">// 第二个MicroTask</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;current Task end&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ELoop();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">current Task</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_2</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_3</span></span><br><span class=\"line\"><span class=\"comment\">MacroTask_1</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_1</span></span><br><span class=\"line\"><span class=\"comment\">MacroTask_2</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n\n<p>参考文献:</p>\n<p><a href=\"https://github.com/creeperyang/blog/issues/21\">从Promise来看JavaScript中的Event Loop、Tasks和Microtasks</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s/qJSmotjzeu02EeK51NgFUQ\">JavaScript Event Loop 机制详解与 Vue.js 中实践应用</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"运行机制：事件队列与调用栈\"><a href=\"#运行机制：事件队列与调用栈\" class=\"headerlink\" title=\"运行机制：事件队列与调用栈\"></a>运行机制：事件队列与调用栈</h1><h2 id=\"JavaScript-是单线程单并发语言\"><a href=\"#JavaScript-是单线程单并发语言\" class=\"headerlink\" title=\"JavaScript 是单线程单并发语言\"></a>JavaScript 是单线程单并发语言</h2><ol>\n<li><p>什么是单线程</p>\n<p> 主程序只有一个线程，即同一时间片断内其只能执行单个任务。</p>\n</li>\n<li><p>为什么选择单线程？</p>\n<p> JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p>\n</li>\n<li><p>单线程意味着什么？</p>\n<p> 单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就需要一直等着。这就会导致<code>IO操作（耗时但cpu闲置）</code>时造成性能浪费的问题。</p>\n</li>\n<li><p>如何解决单线程带来的性能问题？</p>\n<p> 答案是<strong>异步</strong>！主线程完全可以不管IO操作，暂时挂起处于等待中的任务，先运行排在后面的任务。等到IO操作返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>\n<p> <strong>注：</strong>  当主线程阻塞时，任务队列仍然是能够被推入任务的</p>\n</li>\n</ol>\n<h2 id=\"事件循环（Event-Loop）\"><a href=\"#事件循环（Event-Loop）\" class=\"headerlink\" title=\"事件循环（Event Loop）\"></a>事件循环（Event Loop）</h2><ol>\n<li><p>JavaScript 内存模型</p>\n<p> 讲事件循环之前，先看一张下网上看到的 JavaScript 内存模型，相信看完这个会对事件循环机制有一种豁然开朗的感觉。</p>\n<p> <img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201709/h-s-q.png\"></p>\n<ul>\n<li>调用栈（Call Stack）：用于主线程任务的执行</li>\n<li>堆（Heap）： 用于存放非结构化数据，譬如程序分配的变量与对象</li>\n<li>任务队列（Queue）： 用于存放异步任务与定时任务。</li>\n</ul>\n</li>\n<li><p>JavaScript 代码执行机制：</p>\n<ul>\n<li>所有同步任务都在主线程上的栈中执行。</li>\n<li>主线程之外，还存在一个”任务队列”（task queue）。<strong>只要异步任务有了运行结果</strong>，就在”任务队列”之中放置一个事件。</li>\n<li>一旦”栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，选择出需要首先执行的任务（由浏览器决定，并不按序）。</li>\n</ul>\n</li>\n<li><p>Event Loop</p>\n<p> 现在我们来聊事件循环。事件循环顾名思义它就是一个循环，主线程会不断循环执行上面的第三步,其基本的代码逻辑如下所示：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (queue.waitForMessage()) &#123;</span><br><span class=\"line\">queue.processNextMessage();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>常见异步任务进入任务队列时机</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">行为</th>\n<th align=\"left\">时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">DOM操作</td>\n<td align=\"left\">在用户点击等操作事件完成后</td>\n</tr>\n<tr>\n<td align=\"left\">网络操作（Ajax等）</td>\n<td align=\"left\">在网络操作响应后</td>\n</tr>\n<tr>\n<td align=\"left\">定时器</td>\n<td align=\"left\">在规定时间到达后</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<pre><code>事件循环机制图解：\n\n![](https://raw.githubusercontent.com/bigdots/blog/master/images/201709/eventLoop.png)\n</code></pre>\n<h2 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h2><ol>\n<li><p>MacroTask（Task）<br> setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering</p>\n</li>\n<li><p>MicroTask（在ES2015规范中称为Job）<br>  process.nextTick, Promise, Object.observe, MutationObserver</p>\n</li>\n</ol>\n<p>规范：</p>\n<ul>\n<li>每个浏览器环境，至多有一个event loop。</li>\n<li>一个event loop可以有1个或多个task queue，而仅有一个 MicroTask Queue。</li>\n<li>一个task queue是一列有序的task, 每个task定义时都有一个task source，从同一个task source来的task必须放到同一个task queue，从不同源来的则被添加到不同队列。</li>\n<li>tasks are scheduled，所以浏览器可以从内部到JS/DOM，保证动作按序发生。</li>\n<li>Microtasks are scheduled，Microtask queue 在当前 task queue 的结尾执行。microtask中添加的microtask也被添加到Microtask queue的末尾并处理。</li>\n</ul>\n<p> <strong>注：</strong> event loop的每个turn，是由浏览器决定先执行哪个task queue。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ELoop</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前任务</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;current Task&quot;</span>)</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextP; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_1&quot;</span>);</span><br><span class=\"line\">        nextP.then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 第一次执行时，这段代码并没有执行到。</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_1&quot;</span>); <span class=\"comment\">//第一个MicroTask</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_1 end&quot;</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>) <span class=\"comment\">// 第一个 MacroTask</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_2&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_2 end&quot;</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)<span class=\"comment\">// 第二个MacroTask</span></span><br><span class=\"line\"></span><br><span class=\"line\">    nextP = p.then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_2&quot;</span>); <span class=\"comment\">//第一个MicroTask</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;).then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_3&quot;</span>); <span class=\"comment\">// 第二个MicroTask</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;current Task end&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ELoop();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">current Task</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_2</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_3</span></span><br><span class=\"line\"><span class=\"comment\">MacroTask_1</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_1</span></span><br><span class=\"line\"><span class=\"comment\">MacroTask_2</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n\n<p>参考文献:</p>\n<p><a href=\"https://github.com/creeperyang/blog/issues/21\">从Promise来看JavaScript中的Event Loop、Tasks和Microtasks</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s/qJSmotjzeu02EeK51NgFUQ\">JavaScript Event Loop 机制详解与 Vue.js 中实践应用</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop</a></p>\n"},{"_content":"\n\n* 分词／词法分析\n\n  将一连串字符串打断成有意义的片段，成为 token（记号）。\n\n* 解析\n\n  将一个 token 流（数组）转化为一个嵌套元素的树，即抽象语法树（AST）。\n\n* 代码生成\n\n  将抽象语法树转化为可执行的代码。其实是转化成机器指令。\n\n\n\n[the-super-tiny-compiler](https://github.com/jamiebuilds/the-super-tiny-compiler)\n[Babel是如何读懂JS代码的](https://zhuanlan.zhihu.com/p/27289600)","source":"_posts/编译器.md","raw":"\n\n* 分词／词法分析\n\n  将一连串字符串打断成有意义的片段，成为 token（记号）。\n\n* 解析\n\n  将一个 token 流（数组）转化为一个嵌套元素的树，即抽象语法树（AST）。\n\n* 代码生成\n\n  将抽象语法树转化为可执行的代码。其实是转化成机器指令。\n\n\n\n[the-super-tiny-compiler](https://github.com/jamiebuilds/the-super-tiny-compiler)\n[Babel是如何读懂JS代码的](https://zhuanlan.zhihu.com/p/27289600)","slug":"编译器","published":1,"date":"2021-12-06T06:39:27.059Z","updated":"2021-12-06T06:07:05.839Z","_id":"ckwuazrxr0005wcv2e0iwcpbp","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li><p>分词／词法分析</p>\n<p>将一连串字符串打断成有意义的片段，成为 token（记号）。</p>\n</li>\n<li><p>解析</p>\n<p>将一个 token 流（数组）转化为一个嵌套元素的树，即抽象语法树（AST）。</p>\n</li>\n<li><p>代码生成</p>\n<p>将抽象语法树转化为可执行的代码。其实是转化成机器指令。</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/jamiebuilds/the-super-tiny-compiler\">the-super-tiny-compiler</a><br><a href=\"https://zhuanlan.zhihu.com/p/27289600\">Babel是如何读懂JS代码的</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>分词／词法分析</p>\n<p>将一连串字符串打断成有意义的片段，成为 token（记号）。</p>\n</li>\n<li><p>解析</p>\n<p>将一个 token 流（数组）转化为一个嵌套元素的树，即抽象语法树（AST）。</p>\n</li>\n<li><p>代码生成</p>\n<p>将抽象语法树转化为可执行的代码。其实是转化成机器指令。</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/jamiebuilds/the-super-tiny-compiler\">the-super-tiny-compiler</a><br><a href=\"https://zhuanlan.zhihu.com/p/27289600\">Babel是如何读懂JS代码的</a></p>\n"},{"_content":"# 构造函数、原型与原型链\n\n<!-- TOC -->\n\n- [构造函数、原型与原型链](#构造函数原型与原型链)\n    - [构造函数](#构造函数)\n    - [prototype](#prototype)\n    - [constructor 属性](#constructor-属性)\n    - [\\_\\_proto\\_\\_](#\\_\\_proto\\_\\_)\n    - [原型链](#原型链)\n\n<!-- /TOC -->\n\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/构造函数、原型、实例.png)\n\n## 构造函数\n\nECMAScript 中提供了构造函数来创建新对象。但构造函数本身就是一个函数，与普通函数没有任何区别，只不过为了区分，一般将其首字母大写，但这并不是必须的。\n\n**函数被 new 关键字调用时就是构造函数。**\n\n```js\nfunction f(name) {\n    console.log(\"execute\");\n    this.name = name;\n}\n\nvar k = new f(\"k\"); // execute\nconsole.log(k); // {name: \"k\"}\nvar h = f(\"h\"); // execute\nconsole.log(h); // undefined\n```\n\n从上面代码可以看出：\n\n* 首字母是否大写并不影响函数 f 作为构造函数使用，\n* 不使用 new 调用函数就是普通函数，直接执行内部代码，使用 new，函数的角色就成为了构造函数，创建一个对象并返回。\n\n对象由构造函数通过 new 关键字创造，那么是如何创造的呢？\n\nnew 关键字的内部实现机制：\n\n* 创建一个新对象；\n* 将构造函数的作用域赋值给新对象；\n* 执行构造函数中的代码；\n* 返回新对象\n\n```js\nvar obj = {}; // 创建一个空对象\nobj.__proto__ = constructor.prototype; // 添加__proto__属性，并指向构造函数的 prototype 属性。\nconstructor.call(this); // 绑定this\nreturn obj;\n```\n\n\n## prototype\n\n> 每一个函数都有一个 `prototype` 属性。\n\n```js\nfunction Foo() {}\n\nFoo.prototype; // {constructor,__proto__}\n```\n\n**无论什么时候，只要创建了一个新函数，根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。**\n\n那么这个创建的原型对象是什么呢？\n\n```js\n{\n    constructor: ƒ Foo(),\n    __proto__: Object\n}\n```\n\n## constructor 属性\n\n> 每一个原型对象都有一个 `constructor` 属性\n\n创建了自定义的构造函数后，其原型对象只会默认取得 `constructor` 属性。这个属性解决了对象识别问题，即可以通过该属性判断出实例是由哪个构造函数创建的。\n\n<!-- 其中 constructor 指向当前构造函数；`__proto__` 指向 Object.prototype。 -->\n\n```js\nFoo.prototype.constructor === Foo; //  true\n```\n\n前面说了，原型对象只会默认取得 `constructor` 属性，那么原型对象的其他属性（比如：`__proto__` ）是这么来的呢，这就要说到 `__proto__` 指针了。\n\n<!-- **原来函数的原型的原型竟然是 Object 的原型！！！！** -->\n\n## \\_\\_proto\\_\\_\n\n> 每一个实例都有一个 `__proto__` 指针，指向构造函数的原型对象。\n\n```js\nvar foo = new Foo();\nfoo.__proto__ === Foo.prototype; //true\n```\n\n上面提到的构造函数的原型对象它本身也是一个实例，所以在它内部会有一个 `__proto__` 指针。\n\n想要知道构造函数的原型对象是由什么创建的吗？\n\n活学活用，这里我们可以使用刚刚学到对象指向问题判断的知识。我们想要知道 constructor，那么可以通过实例的原型对象（因为每一个原型对象都有一个 `constructor` 属性），所以我们可以这样操作：\n\n```js\nFoo.prototype.__proto__.constructor // ƒ Object() { [native code] }\n```\n\n这说明，构造函数的原型的原型是由 Object 生成的！！所以，构造函数原型对象的其他方法，则是从 Object 上继承来的。\n\n```js\nFoo.prototype.__proto__ === Object.prototype; // true\n```\n\n## 原型链\n\n原型链的理论主要基于上述提到的构造函数、实例和原型的关系：\n- 每一个构造函数都有一个原型对象\n- 原型对象都包含一个指向构造函数的 constructor 属性\n- 每一个实例都包含一个指向原型对象的 `__proto__` 指针\n\n其中最最重要的是第三条，依赖这条关系，层层递进，就形成了**实例与原型**的链条。\n\n我接着上面的探索，构造函数的原型的原型是由 Object 生成的，那么 Object 的原型是由什么生成？而原型链的终点又是在哪？\n\n```js\nObject.prototype.__proto__ // null\nnull.__proto__; // Uncaught TypeError: Cannot read property '__proto__' of null\n// game over\n```\n\n**原型的终点是 null**，因为 null 没有 **__proto__** 属性。\n\n哇，感觉这很符合创世纪的故事啊—— “初始，一切且不存在（null）”。\n\n_tips： 其实 null 是基本数据类型，typeof null 返回 object 是 ECMAScript 设计上的一个错误_\n\n\n最后，一图胜千言：\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/原型链.png)\n\n\n<!-- 关于 Function.**proto**===Function.prototype 的问题,\n是不是可以说 Function 也是 Function 本身的一个实例呢？这个具体该怎么理解 js 这种设计理念呢，Function 是不是既充当鸡又充当蛋呢。。。 -->\n","source":"_posts/对象、原型与原型链.md","raw":"# 构造函数、原型与原型链\n\n<!-- TOC -->\n\n- [构造函数、原型与原型链](#构造函数原型与原型链)\n    - [构造函数](#构造函数)\n    - [prototype](#prototype)\n    - [constructor 属性](#constructor-属性)\n    - [\\_\\_proto\\_\\_](#\\_\\_proto\\_\\_)\n    - [原型链](#原型链)\n\n<!-- /TOC -->\n\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/构造函数、原型、实例.png)\n\n## 构造函数\n\nECMAScript 中提供了构造函数来创建新对象。但构造函数本身就是一个函数，与普通函数没有任何区别，只不过为了区分，一般将其首字母大写，但这并不是必须的。\n\n**函数被 new 关键字调用时就是构造函数。**\n\n```js\nfunction f(name) {\n    console.log(\"execute\");\n    this.name = name;\n}\n\nvar k = new f(\"k\"); // execute\nconsole.log(k); // {name: \"k\"}\nvar h = f(\"h\"); // execute\nconsole.log(h); // undefined\n```\n\n从上面代码可以看出：\n\n* 首字母是否大写并不影响函数 f 作为构造函数使用，\n* 不使用 new 调用函数就是普通函数，直接执行内部代码，使用 new，函数的角色就成为了构造函数，创建一个对象并返回。\n\n对象由构造函数通过 new 关键字创造，那么是如何创造的呢？\n\nnew 关键字的内部实现机制：\n\n* 创建一个新对象；\n* 将构造函数的作用域赋值给新对象；\n* 执行构造函数中的代码；\n* 返回新对象\n\n```js\nvar obj = {}; // 创建一个空对象\nobj.__proto__ = constructor.prototype; // 添加__proto__属性，并指向构造函数的 prototype 属性。\nconstructor.call(this); // 绑定this\nreturn obj;\n```\n\n\n## prototype\n\n> 每一个函数都有一个 `prototype` 属性。\n\n```js\nfunction Foo() {}\n\nFoo.prototype; // {constructor,__proto__}\n```\n\n**无论什么时候，只要创建了一个新函数，根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。**\n\n那么这个创建的原型对象是什么呢？\n\n```js\n{\n    constructor: ƒ Foo(),\n    __proto__: Object\n}\n```\n\n## constructor 属性\n\n> 每一个原型对象都有一个 `constructor` 属性\n\n创建了自定义的构造函数后，其原型对象只会默认取得 `constructor` 属性。这个属性解决了对象识别问题，即可以通过该属性判断出实例是由哪个构造函数创建的。\n\n<!-- 其中 constructor 指向当前构造函数；`__proto__` 指向 Object.prototype。 -->\n\n```js\nFoo.prototype.constructor === Foo; //  true\n```\n\n前面说了，原型对象只会默认取得 `constructor` 属性，那么原型对象的其他属性（比如：`__proto__` ）是这么来的呢，这就要说到 `__proto__` 指针了。\n\n<!-- **原来函数的原型的原型竟然是 Object 的原型！！！！** -->\n\n## \\_\\_proto\\_\\_\n\n> 每一个实例都有一个 `__proto__` 指针，指向构造函数的原型对象。\n\n```js\nvar foo = new Foo();\nfoo.__proto__ === Foo.prototype; //true\n```\n\n上面提到的构造函数的原型对象它本身也是一个实例，所以在它内部会有一个 `__proto__` 指针。\n\n想要知道构造函数的原型对象是由什么创建的吗？\n\n活学活用，这里我们可以使用刚刚学到对象指向问题判断的知识。我们想要知道 constructor，那么可以通过实例的原型对象（因为每一个原型对象都有一个 `constructor` 属性），所以我们可以这样操作：\n\n```js\nFoo.prototype.__proto__.constructor // ƒ Object() { [native code] }\n```\n\n这说明，构造函数的原型的原型是由 Object 生成的！！所以，构造函数原型对象的其他方法，则是从 Object 上继承来的。\n\n```js\nFoo.prototype.__proto__ === Object.prototype; // true\n```\n\n## 原型链\n\n原型链的理论主要基于上述提到的构造函数、实例和原型的关系：\n- 每一个构造函数都有一个原型对象\n- 原型对象都包含一个指向构造函数的 constructor 属性\n- 每一个实例都包含一个指向原型对象的 `__proto__` 指针\n\n其中最最重要的是第三条，依赖这条关系，层层递进，就形成了**实例与原型**的链条。\n\n我接着上面的探索，构造函数的原型的原型是由 Object 生成的，那么 Object 的原型是由什么生成？而原型链的终点又是在哪？\n\n```js\nObject.prototype.__proto__ // null\nnull.__proto__; // Uncaught TypeError: Cannot read property '__proto__' of null\n// game over\n```\n\n**原型的终点是 null**，因为 null 没有 **__proto__** 属性。\n\n哇，感觉这很符合创世纪的故事啊—— “初始，一切且不存在（null）”。\n\n_tips： 其实 null 是基本数据类型，typeof null 返回 object 是 ECMAScript 设计上的一个错误_\n\n\n最后，一图胜千言：\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/原型链.png)\n\n\n<!-- 关于 Function.**proto**===Function.prototype 的问题,\n是不是可以说 Function 也是 Function 本身的一个实例呢？这个具体该怎么理解 js 这种设计理念呢，Function 是不是既充当鸡又充当蛋呢。。。 -->\n","slug":"对象、原型与原型链","published":1,"date":"2021-12-06T06:39:27.059Z","updated":"2021-12-06T06:07:05.833Z","_id":"ckwuazrxs0006wcv2bp7r290z","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"构造函数、原型与原型链\"><a href=\"#构造函数、原型与原型链\" class=\"headerlink\" title=\"构造函数、原型与原型链\"></a>构造函数、原型与原型链</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE\">构造函数、原型与原型链</a><ul>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">构造函数</a></li>\n<li><a href=\"#prototype\">prototype</a></li>\n<li><a href=\"#constructor-%E5%B1%9E%E6%80%A7\">constructor 属性</a></li>\n<li><a href=\"#__proto__\">__proto__</a></li>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE\">原型链</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E5%AE%9E%E4%BE%8B.png\" alt=\"image\"></p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>ECMAScript 中提供了构造函数来创建新对象。但构造函数本身就是一个函数，与普通函数没有任何区别，只不过为了区分，一般将其首字母大写，但这并不是必须的。</p>\n<p><strong>函数被 new 关键字调用时就是构造函数。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;execute&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> k = <span class=\"keyword\">new</span> f(<span class=\"string\">&quot;k&quot;</span>); <span class=\"comment\">// execute</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(k); <span class=\"comment\">// &#123;name: &quot;k&quot;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> h = f(<span class=\"string\">&quot;h&quot;</span>); <span class=\"comment\">// execute</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(h); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>从上面代码可以看出：</p>\n<ul>\n<li>首字母是否大写并不影响函数 f 作为构造函数使用，</li>\n<li>不使用 new 调用函数就是普通函数，直接执行内部代码，使用 new，函数的角色就成为了构造函数，创建一个对象并返回。</li>\n</ul>\n<p>对象由构造函数通过 new 关键字创造，那么是如何创造的呢？</p>\n<p>new 关键字的内部实现机制：</p>\n<ul>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋值给新对象；</li>\n<li>执行构造函数中的代码；</li>\n<li>返回新对象</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;; <span class=\"comment\">// 创建一个空对象</span></span><br><span class=\"line\">obj.__proto__ = <span class=\"title\">constructor</span>.<span class=\"title\">prototype</span>; <span class=\"comment\">// 添加__proto__属性，并指向构造函数的 prototype 属性。</span></span><br><span class=\"line\"><span class=\"title\">constructor</span>.<span class=\"title\">call</span>(<span class=\"params\"><span class=\"built_in\">this</span></span>); <span class=\"comment\">// 绑定this</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> obj;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h2><blockquote>\n<p>每一个函数都有一个 <code>prototype</code> 属性。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype; <span class=\"comment\">// &#123;constructor,__proto__&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>无论什么时候，只要创建了一个新函数，根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。</strong></p>\n<p>那么这个创建的原型对象是什么呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: ƒ Foo(),</span><br><span class=\"line\">    <span class=\"attr\">__proto__</span>: <span class=\"built_in\">Object</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"constructor-属性\"><a href=\"#constructor-属性\" class=\"headerlink\" title=\"constructor 属性\"></a>constructor 属性</h2><blockquote>\n<p>每一个原型对象都有一个 <code>constructor</code> 属性</p>\n</blockquote>\n<p>创建了自定义的构造函数后，其原型对象只会默认取得 <code>constructor</code> 属性。这个属性解决了对象识别问题，即可以通过该属性判断出实例是由哪个构造函数创建的。</p>\n<!-- 其中 constructor 指向当前构造函数；`__proto__` 指向 Object.prototype。 -->\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.constructor === Foo; <span class=\"comment\">//  true</span></span><br></pre></td></tr></table></figure>\n\n<p>前面说了，原型对象只会默认取得 <code>constructor</code> 属性，那么原型对象的其他属性（比如：<code>__proto__</code> ）是这么来的呢，这就要说到 <code>__proto__</code> 指针了。</p>\n<!-- **原来函数的原型的原型竟然是 Object 的原型！！！！** -->\n\n<h2 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"__proto__\"></a>__proto__</h2><blockquote>\n<p>每一个实例都有一个 <code>__proto__</code> 指针，指向构造函数的原型对象。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">foo.__proto__ === Foo.prototype; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面提到的构造函数的原型对象它本身也是一个实例，所以在它内部会有一个 <code>__proto__</code> 指针。</p>\n<p>想要知道构造函数的原型对象是由什么创建的吗？</p>\n<p>活学活用，这里我们可以使用刚刚学到对象指向问题判断的知识。我们想要知道 constructor，那么可以通过实例的原型对象（因为每一个原型对象都有一个 <code>constructor</code> 属性），所以我们可以这样操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.__proto__.constructor <span class=\"comment\">// ƒ Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这说明，构造函数的原型的原型是由 Object 生成的！！所以，构造函数原型对象的其他方法，则是从 Object 上继承来的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>原型链的理论主要基于上述提到的构造函数、实例和原型的关系：</p>\n<ul>\n<li>每一个构造函数都有一个原型对象</li>\n<li>原型对象都包含一个指向构造函数的 constructor 属性</li>\n<li>每一个实例都包含一个指向原型对象的 <code>__proto__</code> 指针</li>\n</ul>\n<p>其中最最重要的是第三条，依赖这条关系，层层递进，就形成了<strong>实例与原型</strong>的链条。</p>\n<p>我接着上面的探索，构造函数的原型的原型是由 Object 生成的，那么 Object 的原型是由什么生成？而原型链的终点又是在哪？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__ <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"literal\">null</span>.__proto__; <span class=\"comment\">// Uncaught TypeError: Cannot read property &#x27;__proto__&#x27; of null</span></span><br><span class=\"line\"><span class=\"comment\">// game over</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>原型的终点是 null</strong>，因为 null 没有 <strong><strong>proto</strong></strong> 属性。</p>\n<p>哇，感觉这很符合创世纪的故事啊—— “初始，一切且不存在（null）”。</p>\n<p><em>tips： 其实 null 是基本数据类型，typeof null 返回 object 是 ECMAScript 设计上的一个错误</em></p>\n<p>最后，一图胜千言：<br><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/%E5%8E%9F%E5%9E%8B%E9%93%BE.png\" alt=\"image\"></p>\n<!-- 关于 Function.**proto**===Function.prototype 的问题,\n是不是可以说 Function 也是 Function 本身的一个实例呢？这个具体该怎么理解 js 这种设计理念呢，Function 是不是既充当鸡又充当蛋呢。。。 -->\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"构造函数、原型与原型链\"><a href=\"#构造函数、原型与原型链\" class=\"headerlink\" title=\"构造函数、原型与原型链\"></a>构造函数、原型与原型链</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE\">构造函数、原型与原型链</a><ul>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">构造函数</a></li>\n<li><a href=\"#prototype\">prototype</a></li>\n<li><a href=\"#constructor-%E5%B1%9E%E6%80%A7\">constructor 属性</a></li>\n<li><a href=\"#__proto__\">__proto__</a></li>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE\">原型链</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E5%AE%9E%E4%BE%8B.png\" alt=\"image\"></p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>ECMAScript 中提供了构造函数来创建新对象。但构造函数本身就是一个函数，与普通函数没有任何区别，只不过为了区分，一般将其首字母大写，但这并不是必须的。</p>\n<p><strong>函数被 new 关键字调用时就是构造函数。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;execute&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> k = <span class=\"keyword\">new</span> f(<span class=\"string\">&quot;k&quot;</span>); <span class=\"comment\">// execute</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(k); <span class=\"comment\">// &#123;name: &quot;k&quot;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> h = f(<span class=\"string\">&quot;h&quot;</span>); <span class=\"comment\">// execute</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(h); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>从上面代码可以看出：</p>\n<ul>\n<li>首字母是否大写并不影响函数 f 作为构造函数使用，</li>\n<li>不使用 new 调用函数就是普通函数，直接执行内部代码，使用 new，函数的角色就成为了构造函数，创建一个对象并返回。</li>\n</ul>\n<p>对象由构造函数通过 new 关键字创造，那么是如何创造的呢？</p>\n<p>new 关键字的内部实现机制：</p>\n<ul>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋值给新对象；</li>\n<li>执行构造函数中的代码；</li>\n<li>返回新对象</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;; <span class=\"comment\">// 创建一个空对象</span></span><br><span class=\"line\">obj.__proto__ = <span class=\"title\">constructor</span>.<span class=\"title\">prototype</span>; <span class=\"comment\">// 添加__proto__属性，并指向构造函数的 prototype 属性。</span></span><br><span class=\"line\"><span class=\"title\">constructor</span>.<span class=\"title\">call</span>(<span class=\"params\"><span class=\"built_in\">this</span></span>); <span class=\"comment\">// 绑定this</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> obj;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h2><blockquote>\n<p>每一个函数都有一个 <code>prototype</code> 属性。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype; <span class=\"comment\">// &#123;constructor,__proto__&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>无论什么时候，只要创建了一个新函数，根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。</strong></p>\n<p>那么这个创建的原型对象是什么呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: ƒ Foo(),</span><br><span class=\"line\">    <span class=\"attr\">__proto__</span>: <span class=\"built_in\">Object</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"constructor-属性\"><a href=\"#constructor-属性\" class=\"headerlink\" title=\"constructor 属性\"></a>constructor 属性</h2><blockquote>\n<p>每一个原型对象都有一个 <code>constructor</code> 属性</p>\n</blockquote>\n<p>创建了自定义的构造函数后，其原型对象只会默认取得 <code>constructor</code> 属性。这个属性解决了对象识别问题，即可以通过该属性判断出实例是由哪个构造函数创建的。</p>\n<!-- 其中 constructor 指向当前构造函数；`__proto__` 指向 Object.prototype。 -->\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.constructor === Foo; <span class=\"comment\">//  true</span></span><br></pre></td></tr></table></figure>\n\n<p>前面说了，原型对象只会默认取得 <code>constructor</code> 属性，那么原型对象的其他属性（比如：<code>__proto__</code> ）是这么来的呢，这就要说到 <code>__proto__</code> 指针了。</p>\n<!-- **原来函数的原型的原型竟然是 Object 的原型！！！！** -->\n\n<h2 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"__proto__\"></a>__proto__</h2><blockquote>\n<p>每一个实例都有一个 <code>__proto__</code> 指针，指向构造函数的原型对象。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">foo.__proto__ === Foo.prototype; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面提到的构造函数的原型对象它本身也是一个实例，所以在它内部会有一个 <code>__proto__</code> 指针。</p>\n<p>想要知道构造函数的原型对象是由什么创建的吗？</p>\n<p>活学活用，这里我们可以使用刚刚学到对象指向问题判断的知识。我们想要知道 constructor，那么可以通过实例的原型对象（因为每一个原型对象都有一个 <code>constructor</code> 属性），所以我们可以这样操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.__proto__.constructor <span class=\"comment\">// ƒ Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这说明，构造函数的原型的原型是由 Object 生成的！！所以，构造函数原型对象的其他方法，则是从 Object 上继承来的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>原型链的理论主要基于上述提到的构造函数、实例和原型的关系：</p>\n<ul>\n<li>每一个构造函数都有一个原型对象</li>\n<li>原型对象都包含一个指向构造函数的 constructor 属性</li>\n<li>每一个实例都包含一个指向原型对象的 <code>__proto__</code> 指针</li>\n</ul>\n<p>其中最最重要的是第三条，依赖这条关系，层层递进，就形成了<strong>实例与原型</strong>的链条。</p>\n<p>我接着上面的探索，构造函数的原型的原型是由 Object 生成的，那么 Object 的原型是由什么生成？而原型链的终点又是在哪？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__ <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"literal\">null</span>.__proto__; <span class=\"comment\">// Uncaught TypeError: Cannot read property &#x27;__proto__&#x27; of null</span></span><br><span class=\"line\"><span class=\"comment\">// game over</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>原型的终点是 null</strong>，因为 null 没有 <strong><strong>proto</strong></strong> 属性。</p>\n<p>哇，感觉这很符合创世纪的故事啊—— “初始，一切且不存在（null）”。</p>\n<p><em>tips： 其实 null 是基本数据类型，typeof null 返回 object 是 ECMAScript 设计上的一个错误</em></p>\n<p>最后，一图胜千言：<br><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/%E5%8E%9F%E5%9E%8B%E9%93%BE.png\" alt=\"image\"></p>\n<!-- 关于 Function.**proto**===Function.prototype 的问题,\n是不是可以说 Function 也是 Function 本身的一个实例呢？这个具体该怎么理解 js 这种设计理念呢，Function 是不是既充当鸡又充当蛋呢。。。 -->\n"},{"_content":"","source":"_posts/垃圾回收.md","raw":"","slug":"垃圾回收","published":1,"date":"2021-12-06T06:39:27.059Z","updated":"2021-12-06T06:07:05.823Z","_id":"ckwuazrxy0007wcv2d0ljdad7","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"# 面向对象编程\n\n<!-- TOC -->\n\n- [面向对象编程](#面向对象编程)\n    - [类理论](#类理论)\n    - [模拟创建类](#模拟创建类)\n        - [工厂模式](#工厂模式)\n        - [构造函数模式](#构造函数模式)\n        - [原型模式](#原型模式)\n        - [构造函数+原型的组合模式](#构造函数原型的组合模式)\n        - [动态原型模式](#动态原型模式)\n        - [寄生构造函数模式](#寄生构造函数模式)\n        - [稳妥构造函数模式](#稳妥构造函数模式)\n    - [实现继承](#实现继承)\n        - [原型链](#原型链)\n        - [借用构造函数](#借用构造函数)\n        - [组合继承](#组合继承)\n        - [原型式继承](#原型式继承)\n        - [寄生式继承](#寄生式继承)\n        - [寄生组合式继承](#寄生组合式继承)\n\n<!-- /TOC -->\n\n> 面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为打包(或者说封装)起来。\n\n我门来理解下上面这句话：\n\n```js\nvar str = \"hello\";\n```\n\n这里，hello 是一个字符串，它就是数据，但我们往往会有操作它的行为，比如截断、分割等。面向对象得设计思想呢，就是将它的数据和行为封装起来，这就产生了 js 中得 `String` 类。\n\n## 类理论\n\n大多数语言在面向对象的设计上都采用了类理论。\n\n> 类是一种设计模式，它是一种代码的组织结构形式。\n\n类理论的核心概念包括：\n\n1. 继承\n\n    子类可以继承父类的属性和方法，从而达到复用。\n\n2. 实例化\n\n    类可以被实例化，生成具体对象。\n\n3. 多态。\n\n    父类的行为可以被子类用更特殊的行为重写。\n\n关于类的理论，这里不多展开，大家可以自行学习。\n\n那么，JavaScript 有没有实现上述的类的功能呢？答案是没有。但由于类是一种设计模式，所以我们以用一些方法近似实现类的功能。\n\n下面的内容，有高程的，可以直接读高程了。\n\n## 模拟创建类\n\n### 工厂模式\n\n```js\nfunction createPerson(name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function() {\n        alert(this.name);\n    };\n    return o;\n}\nvar person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = createPerson(\"Greg\", 27, \"Doctor\");\n```\n\n优：解决了属性复用的问题；\n\n劣：对象识别问题\n\n### 构造函数模式\n\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function() {\n        alert(this.name);\n    };\n}\nvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\n```\n\n优：不存在对象识别问题；\n\n劣：公共方法无法共享，每个实例里都会创建一个名为 sayName 的函数对象。\n\n### 原型模式\n\n```js\nfunction Person() {}\nPerson.prototype.name = \"Nicholas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function() {\n    alert(this.name);\n};\nvar person1 = new Person();\nperson1.sayName(); //\"Nicholas\"\nvar person2 = new Person();\nperson2.sayName(); //\"Nicholas\"\nalert(person1.sayName == person2.sayName); //true\n```\n\n优：实现劣属性的共享，\n劣：原型上的所有属性都会共享，各个实例间会互有影响\n\n### 构造函数+原型的组合模式\n\n### 动态原型模式\n\n### 寄生构造函数模式\n\n### 稳妥构造函数模式\n\n## 实现继承\n\n### 原型链\n\n### 借用构造函数\n\n### 组合继承\n\n### 原型式继承\n\n### 寄生式继承\n\n### 寄生组合式继承\n","source":"_posts/面向对象编程.md","raw":"# 面向对象编程\n\n<!-- TOC -->\n\n- [面向对象编程](#面向对象编程)\n    - [类理论](#类理论)\n    - [模拟创建类](#模拟创建类)\n        - [工厂模式](#工厂模式)\n        - [构造函数模式](#构造函数模式)\n        - [原型模式](#原型模式)\n        - [构造函数+原型的组合模式](#构造函数原型的组合模式)\n        - [动态原型模式](#动态原型模式)\n        - [寄生构造函数模式](#寄生构造函数模式)\n        - [稳妥构造函数模式](#稳妥构造函数模式)\n    - [实现继承](#实现继承)\n        - [原型链](#原型链)\n        - [借用构造函数](#借用构造函数)\n        - [组合继承](#组合继承)\n        - [原型式继承](#原型式继承)\n        - [寄生式继承](#寄生式继承)\n        - [寄生组合式继承](#寄生组合式继承)\n\n<!-- /TOC -->\n\n> 面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为打包(或者说封装)起来。\n\n我门来理解下上面这句话：\n\n```js\nvar str = \"hello\";\n```\n\n这里，hello 是一个字符串，它就是数据，但我们往往会有操作它的行为，比如截断、分割等。面向对象得设计思想呢，就是将它的数据和行为封装起来，这就产生了 js 中得 `String` 类。\n\n## 类理论\n\n大多数语言在面向对象的设计上都采用了类理论。\n\n> 类是一种设计模式，它是一种代码的组织结构形式。\n\n类理论的核心概念包括：\n\n1. 继承\n\n    子类可以继承父类的属性和方法，从而达到复用。\n\n2. 实例化\n\n    类可以被实例化，生成具体对象。\n\n3. 多态。\n\n    父类的行为可以被子类用更特殊的行为重写。\n\n关于类的理论，这里不多展开，大家可以自行学习。\n\n那么，JavaScript 有没有实现上述的类的功能呢？答案是没有。但由于类是一种设计模式，所以我们以用一些方法近似实现类的功能。\n\n下面的内容，有高程的，可以直接读高程了。\n\n## 模拟创建类\n\n### 工厂模式\n\n```js\nfunction createPerson(name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function() {\n        alert(this.name);\n    };\n    return o;\n}\nvar person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = createPerson(\"Greg\", 27, \"Doctor\");\n```\n\n优：解决了属性复用的问题；\n\n劣：对象识别问题\n\n### 构造函数模式\n\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function() {\n        alert(this.name);\n    };\n}\nvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\n```\n\n优：不存在对象识别问题；\n\n劣：公共方法无法共享，每个实例里都会创建一个名为 sayName 的函数对象。\n\n### 原型模式\n\n```js\nfunction Person() {}\nPerson.prototype.name = \"Nicholas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function() {\n    alert(this.name);\n};\nvar person1 = new Person();\nperson1.sayName(); //\"Nicholas\"\nvar person2 = new Person();\nperson2.sayName(); //\"Nicholas\"\nalert(person1.sayName == person2.sayName); //true\n```\n\n优：实现劣属性的共享，\n劣：原型上的所有属性都会共享，各个实例间会互有影响\n\n### 构造函数+原型的组合模式\n\n### 动态原型模式\n\n### 寄生构造函数模式\n\n### 稳妥构造函数模式\n\n## 实现继承\n\n### 原型链\n\n### 借用构造函数\n\n### 组合继承\n\n### 原型式继承\n\n### 寄生式继承\n\n### 寄生组合式继承\n","slug":"面向对象编程","published":1,"date":"2021-12-06T06:39:27.069Z","updated":"2021-12-06T06:07:05.844Z","_id":"ckwuazrxz0008wcv201vu50la","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\">面向对象编程</a><ul>\n<li><a href=\"#%E7%B1%BB%E7%90%86%E8%AE%BA\">类理论</a></li>\n<li><a href=\"#%E6%A8%A1%E6%8B%9F%E5%88%9B%E5%BB%BA%E7%B1%BB\">模拟创建类</a><ul>\n<li><a href=\"#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\">工厂模式</a></li>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F\">构造函数模式</a></li>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\">原型模式</a></li>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F\">构造函数+原型的组合模式</a></li>\n<li><a href=\"#%E5%8A%A8%E6%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\">动态原型模式</a></li>\n<li><a href=\"#%E5%AF%84%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F\">寄生构造函数模式</a></li>\n<li><a href=\"#%E7%A8%B3%E5%A6%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F\">稳妥构造函数模式</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF\">实现继承</a><ul>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE\">原型链</a></li>\n<li><a href=\"#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">借用构造函数</a></li>\n<li><a href=\"#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF\">组合继承</a></li>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF\">原型式继承</a></li>\n<li><a href=\"#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF\">寄生式继承</a></li>\n<li><a href=\"#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF\">寄生组合式继承</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<blockquote>\n<p>面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为打包(或者说封装)起来。</p>\n</blockquote>\n<p>我门来理解下上面这句话：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这里，hello 是一个字符串，它就是数据，但我们往往会有操作它的行为，比如截断、分割等。面向对象得设计思想呢，就是将它的数据和行为封装起来，这就产生了 js 中得 <code>String</code> 类。</p>\n<h2 id=\"类理论\"><a href=\"#类理论\" class=\"headerlink\" title=\"类理论\"></a>类理论</h2><p>大多数语言在面向对象的设计上都采用了类理论。</p>\n<blockquote>\n<p>类是一种设计模式，它是一种代码的组织结构形式。</p>\n</blockquote>\n<p>类理论的核心概念包括：</p>\n<ol>\n<li><p>继承</p>\n<p> 子类可以继承父类的属性和方法，从而达到复用。</p>\n</li>\n<li><p>实例化</p>\n<p> 类可以被实例化，生成具体对象。</p>\n</li>\n<li><p>多态。</p>\n<p> 父类的行为可以被子类用更特殊的行为重写。</p>\n</li>\n</ol>\n<p>关于类的理论，这里不多展开，大家可以自行学习。</p>\n<p>那么，JavaScript 有没有实现上述的类的功能呢？答案是没有。但由于类是一种设计模式，所以我们以用一些方法近似实现类的功能。</p>\n<p>下面的内容，有高程的，可以直接读高程了。</p>\n<h2 id=\"模拟创建类\"><a href=\"#模拟创建类\" class=\"headerlink\" title=\"模拟创建类\"></a>模拟创建类</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    o.name = name;</span><br><span class=\"line\">    o.age = age;</span><br><span class=\"line\">    o.job = job;</span><br><span class=\"line\">    o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">29</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">&quot;Greg&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>优：解决了属性复用的问题；</p>\n<p>劣：对象识别问题</p>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.job = job;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">29</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Greg&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>优：不存在对象识别问题；</p>\n<p>劣：公共方法无法共享，每个实例里都会创建一个名为 sayName 的函数对象。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">&quot;Nicholas&quot;</span>;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">Person.prototype.job = <span class=\"string\">&quot;Software Engineer&quot;</span>;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person1.sayName(); <span class=\"comment\">//&quot;Nicholas&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person2.sayName(); <span class=\"comment\">//&quot;Nicholas&quot;</span></span><br><span class=\"line\">alert(person1.sayName == person2.sayName); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>优：实现劣属性的共享，<br>劣：原型上的所有属性都会共享，各个实例间会互有影响</p>\n<h3 id=\"构造函数-原型的组合模式\"><a href=\"#构造函数-原型的组合模式\" class=\"headerlink\" title=\"构造函数+原型的组合模式\"></a>构造函数+原型的组合模式</h3><h3 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a>动态原型模式</h3><h3 id=\"寄生构造函数模式\"><a href=\"#寄生构造函数模式\" class=\"headerlink\" title=\"寄生构造函数模式\"></a>寄生构造函数模式</h3><h3 id=\"稳妥构造函数模式\"><a href=\"#稳妥构造函数模式\" class=\"headerlink\" title=\"稳妥构造函数模式\"></a>稳妥构造函数模式</h3><h2 id=\"实现继承\"><a href=\"#实现继承\" class=\"headerlink\" title=\"实现继承\"></a>实现继承</h2><h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><h3 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h3><h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><h3 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h3><h3 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h3><h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\">面向对象编程</a><ul>\n<li><a href=\"#%E7%B1%BB%E7%90%86%E8%AE%BA\">类理论</a></li>\n<li><a href=\"#%E6%A8%A1%E6%8B%9F%E5%88%9B%E5%BB%BA%E7%B1%BB\">模拟创建类</a><ul>\n<li><a href=\"#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\">工厂模式</a></li>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F\">构造函数模式</a></li>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\">原型模式</a></li>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F\">构造函数+原型的组合模式</a></li>\n<li><a href=\"#%E5%8A%A8%E6%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\">动态原型模式</a></li>\n<li><a href=\"#%E5%AF%84%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F\">寄生构造函数模式</a></li>\n<li><a href=\"#%E7%A8%B3%E5%A6%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F\">稳妥构造函数模式</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF\">实现继承</a><ul>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE\">原型链</a></li>\n<li><a href=\"#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">借用构造函数</a></li>\n<li><a href=\"#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF\">组合继承</a></li>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF\">原型式继承</a></li>\n<li><a href=\"#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF\">寄生式继承</a></li>\n<li><a href=\"#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF\">寄生组合式继承</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<blockquote>\n<p>面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为打包(或者说封装)起来。</p>\n</blockquote>\n<p>我门来理解下上面这句话：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这里，hello 是一个字符串，它就是数据，但我们往往会有操作它的行为，比如截断、分割等。面向对象得设计思想呢，就是将它的数据和行为封装起来，这就产生了 js 中得 <code>String</code> 类。</p>\n<h2 id=\"类理论\"><a href=\"#类理论\" class=\"headerlink\" title=\"类理论\"></a>类理论</h2><p>大多数语言在面向对象的设计上都采用了类理论。</p>\n<blockquote>\n<p>类是一种设计模式，它是一种代码的组织结构形式。</p>\n</blockquote>\n<p>类理论的核心概念包括：</p>\n<ol>\n<li><p>继承</p>\n<p> 子类可以继承父类的属性和方法，从而达到复用。</p>\n</li>\n<li><p>实例化</p>\n<p> 类可以被实例化，生成具体对象。</p>\n</li>\n<li><p>多态。</p>\n<p> 父类的行为可以被子类用更特殊的行为重写。</p>\n</li>\n</ol>\n<p>关于类的理论，这里不多展开，大家可以自行学习。</p>\n<p>那么，JavaScript 有没有实现上述的类的功能呢？答案是没有。但由于类是一种设计模式，所以我们以用一些方法近似实现类的功能。</p>\n<p>下面的内容，有高程的，可以直接读高程了。</p>\n<h2 id=\"模拟创建类\"><a href=\"#模拟创建类\" class=\"headerlink\" title=\"模拟创建类\"></a>模拟创建类</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    o.name = name;</span><br><span class=\"line\">    o.age = age;</span><br><span class=\"line\">    o.job = job;</span><br><span class=\"line\">    o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">29</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">&quot;Greg&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>优：解决了属性复用的问题；</p>\n<p>劣：对象识别问题</p>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.job = job;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">29</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Greg&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>优：不存在对象识别问题；</p>\n<p>劣：公共方法无法共享，每个实例里都会创建一个名为 sayName 的函数对象。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">&quot;Nicholas&quot;</span>;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">Person.prototype.job = <span class=\"string\">&quot;Software Engineer&quot;</span>;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person1.sayName(); <span class=\"comment\">//&quot;Nicholas&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person2.sayName(); <span class=\"comment\">//&quot;Nicholas&quot;</span></span><br><span class=\"line\">alert(person1.sayName == person2.sayName); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>优：实现劣属性的共享，<br>劣：原型上的所有属性都会共享，各个实例间会互有影响</p>\n<h3 id=\"构造函数-原型的组合模式\"><a href=\"#构造函数-原型的组合模式\" class=\"headerlink\" title=\"构造函数+原型的组合模式\"></a>构造函数+原型的组合模式</h3><h3 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a>动态原型模式</h3><h3 id=\"寄生构造函数模式\"><a href=\"#寄生构造函数模式\" class=\"headerlink\" title=\"寄生构造函数模式\"></a>寄生构造函数模式</h3><h3 id=\"稳妥构造函数模式\"><a href=\"#稳妥构造函数模式\" class=\"headerlink\" title=\"稳妥构造函数模式\"></a>稳妥构造函数模式</h3><h2 id=\"实现继承\"><a href=\"#实现继承\" class=\"headerlink\" title=\"实现继承\"></a>实现继承</h2><h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><h3 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h3><h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><h3 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h3><h3 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h3><h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3>"},{"title":"test2","archives":2021,"date":"2021-12-06T06:48:46.000Z","_content":"\nthis a 2 yes","source":"_posts/test2.md","raw":"---\ntitle: test2\narchives: 2021\ndate: 2021-12-06 14:48:46\ncategories: css\n---\n\nthis a 2 yes","slug":"test2","published":1,"updated":"2021-12-06T06:49:23.032Z","_id":"ckwubce7g0000igv2ghs79vns","comments":1,"layout":"post","photos":[],"link":"","content":"<p>this a 2 yes</p>\n","site":{"data":{}},"excerpt":"","more":"<p>this a 2 yes</p>\n"},{"_content":"# this\n\n## 绑定时机\n\n1. 非箭头函数函数\n    声明时\n2. 箭头函数\n    调用时\n\n## 绑定机制\n1. 默认绑定\n    `this`指向全局对象\n2. 隐含绑定：拥有调用者\n    `this`指向调用者\n3. 明确绑定\n    call\n    apply\n4. new 绑定\n\nnew 绑定 > 明确绑定 > 隐含绑定 > 默认绑定","source":"_posts/2016年总结.md","raw":"# this\n\n## 绑定时机\n\n1. 非箭头函数函数\n    声明时\n2. 箭头函数\n    调用时\n\n## 绑定机制\n1. 默认绑定\n    `this`指向全局对象\n2. 隐含绑定：拥有调用者\n    `this`指向调用者\n3. 明确绑定\n    call\n    apply\n4. new 绑定\n\nnew 绑定 > 明确绑定 > 隐含绑定 > 默认绑定","slug":"2016年总结","published":1,"date":"2021-12-06T06:07:06.089Z","updated":"2021-12-06T06:07:06.089Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwojo0000y4v23fvj7t9e","content":"<h1 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h1><h2 id=\"绑定时机\"><a href=\"#绑定时机\" class=\"headerlink\" title=\"绑定时机\"></a>绑定时机</h2><ol>\n<li>非箭头函数函数<br> 声明时</li>\n<li>箭头函数<br> 调用时</li>\n</ol>\n<h2 id=\"绑定机制\"><a href=\"#绑定机制\" class=\"headerlink\" title=\"绑定机制\"></a>绑定机制</h2><ol>\n<li>默认绑定<br> <code>this</code>指向全局对象</li>\n<li>隐含绑定：拥有调用者<br> <code>this</code>指向调用者</li>\n<li>明确绑定<br> call<br> apply</li>\n<li>new 绑定</li>\n</ol>\n<p>new 绑定 &gt; 明确绑定 &gt; 隐含绑定 &gt; 默认绑定</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h1><h2 id=\"绑定时机\"><a href=\"#绑定时机\" class=\"headerlink\" title=\"绑定时机\"></a>绑定时机</h2><ol>\n<li>非箭头函数函数<br> 声明时</li>\n<li>箭头函数<br> 调用时</li>\n</ol>\n<h2 id=\"绑定机制\"><a href=\"#绑定机制\" class=\"headerlink\" title=\"绑定机制\"></a>绑定机制</h2><ol>\n<li>默认绑定<br> <code>this</code>指向全局对象</li>\n<li>隐含绑定：拥有调用者<br> <code>this</code>指向调用者</li>\n<li>明确绑定<br> call<br> apply</li>\n<li>new 绑定</li>\n</ol>\n<p>new 绑定 &gt; 明确绑定 &gt; 隐含绑定 &gt; 默认绑定</p>\n"},{"title":"CSS文本溢出显示省略号","date":"2015-12-30T07:30:50.000Z","description":"CSS文本溢出显示省略号","_content":"\n项目中常常有这种需要我们对溢出文本进行\"...\"显示的操作，单行多行的情况都有（具体几行得看设计师心情了），这篇随笔是我个人对这种情况解决办法的归纳，欢迎各路英雄指教。\n<!-- more -->\n\n## 单行\n\n<span style=\"color:#C0F\">语法</span>\n\n```CSS\n\toverflow:hidden;\n\ttext-overflow:ellipsis;\n\twhite-space:nowrap\n```\n\n<span style=\"color:#0A8\">示例</span>\n\n<p style=\"width:250px;\n  overflow:hidden;\n  text-overflow:ellipsis;\n  white-space:nowrap;background-color: #f0ad4e;\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号\n</p>\n\n## 多行\n\n**1.直接用css属性设置(只有-webkit内核才有作用)**\n\n<span style=\"color:#C0F\">语法</span>\n\n```CSS\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n```\n\n<span style=\"color:#d44950\">移动端浏览器绝大部分是WebKit内核的，所以该方法适用于移动端；</span>\n\n+ -webkit-line-clamp  用来限制在一个块元素显示的文本的行数,这是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。\n\n+ display: -webkit-box 将对象作为弹性伸缩盒子模型显示 。\n\n+ -webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式 。\n\n+ text-overflow: ellipsis  以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。\n\n<span style=\"color:#0A8\">示例</span>\n<p style=\"\n  width:250px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n\tbackground-color: #f0ad4e;\n  \">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</p>\n\n**2.利用伪类**\n\n<span style=\"color:#C0F\">语法</span>\n```HTML\n<div id=\"con\">\n  <span id=\"txt\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</span>\n  <span class=\"t\"></span>\n</div>\n<style>\n#txt{\n  display: inline-block;\n  height: 40px;\n  width: 250px;\n  line-height: 20px;\n  overflow: hidden;\n  font-size: 16px;\n}\n.t:after{\n  display: inline;\n  content: \"...\";\n  font-size: 16px;\n\t\n}\n</style>\n```\n\n<span style=\"color:#0A8\">示例</span>\n\n<style>\n\t#con{\n\tbackground-color: #f0ad4e;\n    }\n\t#txt{\n\t\tdisplay: inline-block;\n\t\theight: 40px;\n\t\twidth: 250px;\n\t\tline-height: 20px;\n\t\toverflow: hidden;\n\t}\n\t.t:after{\n\t\tdisplay: inline;\n\t\tcontent: \"...\";\n\t}\n</style>\n<p id=\"con\"><span id=\"txt\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</span><span class=\"t\"></span>\n</p>\n\n\n\n**3.利用绝对定位和padding;(跨浏览器解决方案)**\n看到上例是不是觉得“哇，终于可以跨浏览器使用了”，但你这样想的时候有没有考虑过IE的感受？IE6/7是没有伪类的，还不赶快跪下对IE叫声“大哥”，虽然IE6已经退出市场，但是IE7还是需要兼容的，所以呢，我自己又想到了以下的办法，我这边测试了下感觉还行。\n\n<span style=\"color:#C0F\">上代码</span>\n\n```\n<p id=\"con2\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略<span class=\"t2\">...</span>\n</p>\n<style>\n#con2{\n  position: relative;\n  height: 40px;\n  width: 250px;\n  line-height: 20px;\n  overflow: hidden;\n  padding-right: 12px;\n}  \n.t2{\n  position: absolute;\n  right: 0;\n  bottom: 0;\n}\n</style>\n```\n这个方法的原理是：首先在包含文字的元素里，嵌入一个`<span>...</span>`，然后包含文字的元素右侧留出`...`的位置(`padding-right`),最后利用绝对定位将`...`定位至右侧的`padding-right`区域\n<span style=\"color:#0A8\">示例</span>\n\n\n<p id=\"con2\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略<span class=\"t2\">...</span>\n</p>\n<style>\n  #con2{\n  \tposition: relative;\n  \theight: 40px;\n  \twidth: 250px;\n  \tline-height: 20px;\n  \toverflow: hidden;\n  \tpadding-right: 12px;\n  \tbackground-color: #f0ad4e;\n  }  \n  .t2{\n  \tposition: absolute;\n  \tright: 0;\n  \tbottom: 0;\n  }\n</style>\n\n\n**4.其他**\n利用js插件来实现该功能，这里有俩款插件推荐，这篇主要介绍的是css方法，所以它们使用方法就不废话了。\n\n+ [Clamp.js](https://github.com/bigdots/Clamp.js)\n+ [jQuery.dotdotdot](https://github.com/bigdots/jQuery.dotdotdot)","source":"_posts/CSS文本溢出显示省略号.md","raw":"title: CSS文本溢出显示省略号\ndate: 2015-12-30 15:30:50\ntags: [css]\ndescription: CSS文本溢出显示省略号\n\n---\n\n项目中常常有这种需要我们对溢出文本进行\"...\"显示的操作，单行多行的情况都有（具体几行得看设计师心情了），这篇随笔是我个人对这种情况解决办法的归纳，欢迎各路英雄指教。\n<!-- more -->\n\n## 单行\n\n<span style=\"color:#C0F\">语法</span>\n\n```CSS\n\toverflow:hidden;\n\ttext-overflow:ellipsis;\n\twhite-space:nowrap\n```\n\n<span style=\"color:#0A8\">示例</span>\n\n<p style=\"width:250px;\n  overflow:hidden;\n  text-overflow:ellipsis;\n  white-space:nowrap;background-color: #f0ad4e;\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号\n</p>\n\n## 多行\n\n**1.直接用css属性设置(只有-webkit内核才有作用)**\n\n<span style=\"color:#C0F\">语法</span>\n\n```CSS\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n```\n\n<span style=\"color:#d44950\">移动端浏览器绝大部分是WebKit内核的，所以该方法适用于移动端；</span>\n\n+ -webkit-line-clamp  用来限制在一个块元素显示的文本的行数,这是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。\n\n+ display: -webkit-box 将对象作为弹性伸缩盒子模型显示 。\n\n+ -webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式 。\n\n+ text-overflow: ellipsis  以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。\n\n<span style=\"color:#0A8\">示例</span>\n<p style=\"\n  width:250px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n\tbackground-color: #f0ad4e;\n  \">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</p>\n\n**2.利用伪类**\n\n<span style=\"color:#C0F\">语法</span>\n```HTML\n<div id=\"con\">\n  <span id=\"txt\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</span>\n  <span class=\"t\"></span>\n</div>\n<style>\n#txt{\n  display: inline-block;\n  height: 40px;\n  width: 250px;\n  line-height: 20px;\n  overflow: hidden;\n  font-size: 16px;\n}\n.t:after{\n  display: inline;\n  content: \"...\";\n  font-size: 16px;\n\t\n}\n</style>\n```\n\n<span style=\"color:#0A8\">示例</span>\n\n<style>\n\t#con{\n\tbackground-color: #f0ad4e;\n    }\n\t#txt{\n\t\tdisplay: inline-block;\n\t\theight: 40px;\n\t\twidth: 250px;\n\t\tline-height: 20px;\n\t\toverflow: hidden;\n\t}\n\t.t:after{\n\t\tdisplay: inline;\n\t\tcontent: \"...\";\n\t}\n</style>\n<p id=\"con\"><span id=\"txt\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</span><span class=\"t\"></span>\n</p>\n\n\n\n**3.利用绝对定位和padding;(跨浏览器解决方案)**\n看到上例是不是觉得“哇，终于可以跨浏览器使用了”，但你这样想的时候有没有考虑过IE的感受？IE6/7是没有伪类的，还不赶快跪下对IE叫声“大哥”，虽然IE6已经退出市场，但是IE7还是需要兼容的，所以呢，我自己又想到了以下的办法，我这边测试了下感觉还行。\n\n<span style=\"color:#C0F\">上代码</span>\n\n```\n<p id=\"con2\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略<span class=\"t2\">...</span>\n</p>\n<style>\n#con2{\n  position: relative;\n  height: 40px;\n  width: 250px;\n  line-height: 20px;\n  overflow: hidden;\n  padding-right: 12px;\n}  \n.t2{\n  position: absolute;\n  right: 0;\n  bottom: 0;\n}\n</style>\n```\n这个方法的原理是：首先在包含文字的元素里，嵌入一个`<span>...</span>`，然后包含文字的元素右侧留出`...`的位置(`padding-right`),最后利用绝对定位将`...`定位至右侧的`padding-right`区域\n<span style=\"color:#0A8\">示例</span>\n\n\n<p id=\"con2\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略<span class=\"t2\">...</span>\n</p>\n<style>\n  #con2{\n  \tposition: relative;\n  \theight: 40px;\n  \twidth: 250px;\n  \tline-height: 20px;\n  \toverflow: hidden;\n  \tpadding-right: 12px;\n  \tbackground-color: #f0ad4e;\n  }  \n  .t2{\n  \tposition: absolute;\n  \tright: 0;\n  \tbottom: 0;\n  }\n</style>\n\n\n**4.其他**\n利用js插件来实现该功能，这里有俩款插件推荐，这篇主要介绍的是css方法，所以它们使用方法就不废话了。\n\n+ [Clamp.js](https://github.com/bigdots/Clamp.js)\n+ [jQuery.dotdotdot](https://github.com/bigdots/jQuery.dotdotdot)","slug":"CSS文本溢出显示省略号","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwok20001y4v2fg7u7gnx","content":"<p>项目中常常有这种需要我们对溢出文本进行”…”显示的操作，单行多行的情况都有（具体几行得看设计师心情了），这篇随笔是我个人对这种情况解决办法的归纳，欢迎各路英雄指教。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"单行\"><a href=\"#单行\" class=\"headerlink\" title=\"单行\"></a>单行</h2><p><span style=\"color:#C0F\">语法</span></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">overflow</span>:hidden;</span><br><span class=\"line\"><span class=\"attribute\">text-overflow</span>:ellipsis;</span><br><span class=\"line\"><span class=\"attribute\">white-space</span>:nowrap</span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color:#0A8\">示例</span></p>\n<p style=\"width:250px;\n  overflow:hidden;\n  text-overflow:ellipsis;\n  white-space:nowrap;background-color: #f0ad4e;\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号\n</p>\n\n<h2 id=\"多行\"><a href=\"#多行\" class=\"headerlink\" title=\"多行\"></a>多行</h2><p><strong>1.直接用css属性设置(只有-webkit内核才有作用)</strong></p>\n<p><span style=\"color:#C0F\">语法</span></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\"><span class=\"attribute\">text-overflow</span>: ellipsis;</span><br><span class=\"line\"><span class=\"attribute\">display</span>: -webkit-box;</span><br><span class=\"line\">-webkit-line-clamp: <span class=\"number\">2</span>;</span><br><span class=\"line\">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color:#d44950\">移动端浏览器绝大部分是WebKit内核的，所以该方法适用于移动端；</span></p>\n<ul>\n<li><p>-webkit-line-clamp  用来限制在一个块元素显示的文本的行数,这是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。</p>\n</li>\n<li><p>display: -webkit-box 将对象作为弹性伸缩盒子模型显示 。</p>\n</li>\n<li><p>-webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式 。</p>\n</li>\n<li><p>text-overflow: ellipsis  以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。</p>\n</li>\n</ul>\n<p><span style=\"color:#0A8\">示例</span></p>\n<p style=\"\n  width:250px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n    background-color: #f0ad4e;\n  \">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</p>\n\n<p><strong>2.利用伪类</strong></p>\n<p><span style=\"color:#C0F\">语法</span></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;con&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;txt&quot;</span>&gt;</span>文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;t&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-id\">#txt</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">display</span>: inline-block;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">height</span>: <span class=\"number\">40px</span>;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">width</span>: <span class=\"number\">250px</span>;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">20px</span>;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">overflow</span>: hidden;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">16px</span>;</span></span><br><span class=\"line\"><span class=\"css\">&#125;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.t</span>:after&#123;</span></span><br><span class=\"line\"><span class=\"css\">  display: inline;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;...&quot;</span>;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">16px</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t</span></span><br><span class=\"line\"><span class=\"css\">&#125;</span></span><br><span class=\"line\"><span class=\"css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color:#0A8\">示例</span></p>\n<style>\n    #con{\n    background-color: #f0ad4e;\n    }\n    #txt{\n        display: inline-block;\n        height: 40px;\n        width: 250px;\n        line-height: 20px;\n        overflow: hidden;\n    }\n    .t:after{\n        display: inline;\n        content: \"...\";\n    }\n</style>\n<p id=\"con\"><span id=\"txt\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</span><span class=\"t\"></span>\n</p>\n\n\n\n<p><strong>3.利用绝对定位和padding;(跨浏览器解决方案)</strong><br>看到上例是不是觉得“哇，终于可以跨浏览器使用了”，但你这样想的时候有没有考虑过IE的感受？IE6/7是没有伪类的，还不赶快跪下对IE叫声“大哥”，虽然IE6已经退出市场，但是IE7还是需要兼容的，所以呢，我自己又想到了以下的办法，我这边测试了下感觉还行。</p>\n<p><span style=\"color:#C0F\">上代码</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p id=&quot;con2&quot;&gt;文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略&lt;span class=&quot;t2&quot;&gt;...&lt;/span&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">#con2&#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  height: 40px;</span><br><span class=\"line\">  width: 250px;</span><br><span class=\"line\">  line-height: 20px;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  padding-right: 12px;</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">.t2&#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>这个方法的原理是：首先在包含文字的元素里，嵌入一个<code>&lt;span&gt;...&lt;/span&gt;</code>，然后包含文字的元素右侧留出<code>...</code>的位置(<code>padding-right</code>),最后利用绝对定位将<code>...</code>定位至右侧的<code>padding-right</code>区域<br><span style=\"color:#0A8\">示例</span></p>\n<p id=\"con2\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略<span class=\"t2\">...</span>\n</p>\n<style>\n  #con2{\n      position: relative;\n      height: 40px;\n      width: 250px;\n      line-height: 20px;\n      overflow: hidden;\n      padding-right: 12px;\n      background-color: #f0ad4e;\n  }  \n  .t2{\n      position: absolute;\n      right: 0;\n      bottom: 0;\n  }\n</style>\n\n\n<p><strong>4.其他</strong><br>利用js插件来实现该功能，这里有俩款插件推荐，这篇主要介绍的是css方法，所以它们使用方法就不废话了。</p>\n<ul>\n<li><a href=\"https://github.com/bigdots/Clamp.js\">Clamp.js</a></li>\n<li><a href=\"https://github.com/bigdots/jQuery.dotdotdot\">jQuery.dotdotdot</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>项目中常常有这种需要我们对溢出文本进行”…”显示的操作，单行多行的情况都有（具体几行得看设计师心情了），这篇随笔是我个人对这种情况解决办法的归纳，欢迎各路英雄指教。</p>","more":"<h2 id=\"单行\"><a href=\"#单行\" class=\"headerlink\" title=\"单行\"></a>单行</h2><p><span style=\"color:#C0F\">语法</span></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">overflow</span>:hidden;</span><br><span class=\"line\"><span class=\"attribute\">text-overflow</span>:ellipsis;</span><br><span class=\"line\"><span class=\"attribute\">white-space</span>:nowrap</span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color:#0A8\">示例</span></p>\n<p style=\"width:250px;\n  overflow:hidden;\n  text-overflow:ellipsis;\n  white-space:nowrap;background-color: #f0ad4e;\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号\n</p>\n\n<h2 id=\"多行\"><a href=\"#多行\" class=\"headerlink\" title=\"多行\"></a>多行</h2><p><strong>1.直接用css属性设置(只有-webkit内核才有作用)</strong></p>\n<p><span style=\"color:#C0F\">语法</span></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\"><span class=\"attribute\">text-overflow</span>: ellipsis;</span><br><span class=\"line\"><span class=\"attribute\">display</span>: -webkit-box;</span><br><span class=\"line\">-webkit-line-clamp: <span class=\"number\">2</span>;</span><br><span class=\"line\">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color:#d44950\">移动端浏览器绝大部分是WebKit内核的，所以该方法适用于移动端；</span></p>\n<ul>\n<li><p>-webkit-line-clamp  用来限制在一个块元素显示的文本的行数,这是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。</p>\n</li>\n<li><p>display: -webkit-box 将对象作为弹性伸缩盒子模型显示 。</p>\n</li>\n<li><p>-webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式 。</p>\n</li>\n<li><p>text-overflow: ellipsis  以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。</p>\n</li>\n</ul>\n<p><span style=\"color:#0A8\">示例</span></p>\n<p style=\"\n  width:250px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n    background-color: #f0ad4e;\n  \">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</p>\n\n<p><strong>2.利用伪类</strong></p>\n<p><span style=\"color:#C0F\">语法</span></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;con&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;txt&quot;</span>&gt;</span>文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;t&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-id\">#txt</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">display</span>: inline-block;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">height</span>: <span class=\"number\">40px</span>;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">width</span>: <span class=\"number\">250px</span>;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">20px</span>;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">overflow</span>: hidden;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">16px</span>;</span></span><br><span class=\"line\"><span class=\"css\">&#125;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.t</span>:after&#123;</span></span><br><span class=\"line\"><span class=\"css\">  display: inline;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;...&quot;</span>;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">16px</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t</span></span><br><span class=\"line\"><span class=\"css\">&#125;</span></span><br><span class=\"line\"><span class=\"css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color:#0A8\">示例</span></p>\n<style>\n    #con{\n    background-color: #f0ad4e;\n    }\n    #txt{\n        display: inline-block;\n        height: 40px;\n        width: 250px;\n        line-height: 20px;\n        overflow: hidden;\n    }\n    .t:after{\n        display: inline;\n        content: \"...\";\n    }\n</style>\n<p id=\"con\"><span id=\"txt\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</span><span class=\"t\"></span>\n</p>\n\n\n\n<p><strong>3.利用绝对定位和padding;(跨浏览器解决方案)</strong><br>看到上例是不是觉得“哇，终于可以跨浏览器使用了”，但你这样想的时候有没有考虑过IE的感受？IE6/7是没有伪类的，还不赶快跪下对IE叫声“大哥”，虽然IE6已经退出市场，但是IE7还是需要兼容的，所以呢，我自己又想到了以下的办法，我这边测试了下感觉还行。</p>\n<p><span style=\"color:#C0F\">上代码</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p id=&quot;con2&quot;&gt;文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略&lt;span class=&quot;t2&quot;&gt;...&lt;/span&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">#con2&#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  height: 40px;</span><br><span class=\"line\">  width: 250px;</span><br><span class=\"line\">  line-height: 20px;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  padding-right: 12px;</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">.t2&#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>这个方法的原理是：首先在包含文字的元素里，嵌入一个<code>&lt;span&gt;...&lt;/span&gt;</code>，然后包含文字的元素右侧留出<code>...</code>的位置(<code>padding-right</code>),最后利用绝对定位将<code>...</code>定位至右侧的<code>padding-right</code>区域<br><span style=\"color:#0A8\">示例</span></p>\n<p id=\"con2\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略<span class=\"t2\">...</span>\n</p>\n<style>\n  #con2{\n      position: relative;\n      height: 40px;\n      width: 250px;\n      line-height: 20px;\n      overflow: hidden;\n      padding-right: 12px;\n      background-color: #f0ad4e;\n  }  \n  .t2{\n      position: absolute;\n      right: 0;\n      bottom: 0;\n  }\n</style>\n\n\n<p><strong>4.其他</strong><br>利用js插件来实现该功能，这里有俩款插件推荐，这篇主要介绍的是css方法，所以它们使用方法就不废话了。</p>\n<ul>\n<li><a href=\"https://github.com/bigdots/Clamp.js\">Clamp.js</a></li>\n<li><a href=\"https://github.com/bigdots/jQuery.dotdotdot\">jQuery.dotdotdot</a></li>\n</ul>"},{"title":"C语言入门","date":"2015-12-21T03:43:33.000Z","description":"C语言学习，C语言入门","_content":"C语言一经出现就以其功能丰富、表达能力强、灵活方便、应用面广等特点迅速在全世界普及和推广。C语言不但执行效率高而且可移植性好，可以用来开发应用软件、驱动、操作系统等。C语言也是其它众多高级语言的鼻祖语言，所以说学习C语言是进入编程世界的必修课。\n\n## hello world不解释\n\n\t#include <stdio.h>\n    int main()            \n\t{\n\t    printf(\"hello world\");\n\t\treturn 0;\n\t}\n\n<!-- more -->\n\n+ `#include <stdio.h>`就是一条预处理命令，它的作用是通知C语言编译系统在对C程序进行正式编译之前需做一些预处理工作。\n+ 一个C程序有且只有一个主函数，即main函数，主函数就是C语言中的唯一入口。\n\n+ C语言注释方法有两种：\n```\n\t多行注释：  /* 注释内容 */ \n\t单行注释：  //注释一行\n```\n\n## 基本数据类型\n\nC语言中，数据类型可分为：基本数据类型，构造数据类型，指针类型，空类型。\n![](/images/201511/5.jpg)\n\n## 格式化输出语句\n\n格式化输出语句，也可以说是占位输出，是将各种类型的数据按照格式化后的类型及指定的位置从计算机上显示。\n\n\t#include <stdio.h>\n\tint main(){\n\t    int age = 18;\n\t\tfloat height = 1.85;\n\t\tchar unit = 'm';\n\t\tprintf(\"小明今年%d岁\\n\", age);\n\t\tprintf(\"小明身高%f%c\\n\", height, unit);\n\t\tprintf(\"小明现在在慕课网上学习IT技术\"); \n\t\treturn 0;\n\t}\n\n![](/images/201511/7.jpg)\n\n## 定义常量\n\n` #define  标识符 常量值 `\n\n## 类型转换\n\n\n1. 自动类型转换\n\n![](/images/201511/6.jpg)\n\n<p style=\"color:red\">注：字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换</p>\n\n2. 强制类型转换\n\n在使用强制转换时应注意以下问题：\n\n+ 数据类型和表达式都必须加括号，如把(int)(x/2+y)写成(int)x/2+y则成了把x转换成int型之后再除2再与y相加了。\n\n+ 转换后不会改变原数据的类型及变量值，只在本次运算中临时性转换。\n\n+ 强制转换后的运算结果不遵循四舍五入原则。\n\n\n## 函数\n\n**声明：**\n![](/images/201511/8.jpg)\n\n\tint sayLove()\n\t{\n\t    //在这里输入输出语句printf，输出内容为I Love imooc \n\t   printf(\"I LOVE imooc\");\n\t    return 0;\n\t}\n\n\tint main()\n\t{\n\t    /* 调用所写函数 */\n\t    sayLove();\n\t    return 0;\n\t}\n\n<p style=\"color:red\">注：自定义函数尽量放在main函数之前，如果要放在main函数后面的话，需要在main函数之前先声明自定义函数，声明格式为：[数据类型说明] 函数名称（[参数]）;</p>\n\n### 内部函数与外部函数\n1. 在C语言中不能被其他源文件调用的函数称谓内部函数 ，内部函数由static关键字来定义，因此又被称谓静态函数，形式为：\n\n `static [数据类型] 函数名（[参数]） `\n\n这里的static是对函数的作用范围的一个限定，限定该函数只能在其所处的源文件中使用，因此在不同文件中出现相同的函数名称的内部函数是没有问题的。\n\n2. 在C语言中能被其他源文件调用的函数称谓外部函数 ，外部函数由extern关键字来定义，形式为：\n\n `extern [数据类型] 函数名([参数]) `\n\nC语言规定，在没有指定函数的作用范围时，系统会默认认为是外部函数，因此当需要定义外部函数时extern也可以省略。\n\n\n### 参数\n\n参数分为形参和实参两种,形参是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数；实参是在调用时传递该函数的参数。\n\n+ 形参只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。\n+ 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值等办法使实参获得确定值。\n+ 在参数传递时，实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹配”的错误。\n\n### 返回值\n\n函数的返回值是指函数被调用之后，执行函数体中的程序段所取得的并返回给主调函数的值。\n\n1. 函数的值只能通过return语句返回主调函数。return语句的一般形式为：\n   `return 表达式`   或者为：  `return (表达式)`;\n\n2. 函数值的类型和函数定义中函数的类型应保持一致。如果两者不一致，则以函数返回类型为准，自动进行类型转换。\n\n3. 没有返回值的函数，返回类型为void。\n\n<p style=\"color:red\">注意：void函数中可以有执行代码块，但是不能有返回值，另void函数中如果有return语句，该语句只能起到结束函数运行的功能。其格式为：return;</p>\n\n### 变量\n\n#### 局部和全局\n1. 局部变量也称为内部变量。局部变量是在函数内作定义说明的。其作用域仅限于函数内， 离开该函数后再使用这种变量是非法的。在复合语句中也可定义变量，其作用域只在复合语句范围内。\n\n2. 全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序。\n\n#### 存储类别\n\nC语言根据变量的生存周期来划分，可以分为静态存储方式和动态存储方式。\n\n1. 静态存储方式\n\n静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。\n\n2. 动态存储方式\n\n动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。\n\n3. 存储类别\nC语言中存储类别又分为四类：自动（auto）、静态（static）、寄存器的（register）和外部的（extern）。\n+ 用关键字auto定义的变量为自动变量，auto可以省略，auto不写则隐含定为“自动存储类别”，属于动态存储方式\n+ 用static修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。\n\n<p style=\"color:red\">注意：静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放；静态局部变量在编译时赋初值，即只赋初值一次；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。</p>\n\n+ 为了提高效率，C语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫“寄存器变量”，用关键字register作声明\n\n<p style=\"color:red\">注意：只有局部自动变量和形式参数可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；局部静态变量不能定义为寄存器变量。</p>\n+ 用extern声明的的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。\n\n\n\n## 数组\n\n**声明及初始化**\n\n1. 声明\n数据类型 数组名称[长度]; \n\n2. 初始化\n\n\n第一种形式\n`int arrFirst[3] = {1,2,3};`\n第二种形式\n`int arrSecond[] = {1,2,3};`\n第三种形式\n`int arrThird[3];`\n\n<b style=\"color:red\">注意：</b>\n1、数组的下标均以0开始；\n2、数组在初始化的时候，数组内元素的个数不能大于声明的数组长度；\n3、如果采用第一种初始化方式，元素个数小于数组的长度时，多余的数组元素初始化为0；\n4、在声明数组后没有进行初始化的时候，静态（static）和外部（extern）类型的数组元素初始化元素为0，自动（auto）类型的数组的元素初始化值不确定。\n\n\n多维数组\n\n定义：\n\n```\n\t数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; \n```\n\n初始化\n```\n\t数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n] = {{值1,..,值n},{值1,..,值n},...,{值1,..,值n}}; \n```\n```\n\t数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; 数组名称[下标1][下标2]...[下标n] = 值; \n```\n\n<b style=\"color:red\">注意：</b>\n\n1. 采用第一种始化时数组声明必须指定列的维数。因为系统会根据数组中元素的总个数来分配空间，当知道元素总个数以及列的维数后，会直接计算出行的维数；\n\n2. 采用第二种初始化时数组声明必须同时指定行和列的维数。\n\n\n### 利用数组定义字符串\n\n在C语言中，是没有办法直接定义字符串数据类型的，但是我们可以使用数组来定义我们所要的字符串。\n\n\n方法：\n\n1. `char 字符串名称[长度] = \"字符串值\"`\n\n2. `char 字符串名称[长度] = {'字符1','字符2',...,'字符n','\\0'}`\n\n<b style=\"color:red\">注意：</b>\n\n1. []中的长度是可以省略不写的；\n\n2. 采用第2种方式的时候最后一个元素必须是'\\0'，'\\0'表示字符串的结束标志；\n\n3. 采用第2种方式的时候在数组中不能写中文。\n\n4. 在输出字符串的时候要使用：printf(“%s”,字符数组名字);或者puts(字符数组名字);\n\n``` C\nvoid say(char string[])       \n{\n        printf(\"%s\\n\",string);     \n        puts(string);\n}\n```\n\n---\n\n**字符串函数**\n\n![](/images/201511/9.jpg)\n\n使用字符串函数注意以下事项：\n\n1. strlen()获取字符串的长度，在字符串长度中是不包括‘\\0’而且汉字和字母的长度是不一样的。\n2. strcmp()在比较的时候会把字符串先转换成ASCII码再进行比较,返回的结果为0表示s1和s2的ASCII码相等,返回结果为1表示s1比s2的ASCII码大,返回结果为-1表示s1比s2的ASCII码小\n3. strcpy()拷贝之后会覆盖原来字符串且不能对字符串常量进行拷贝\n4. strcat在使用时s1与s2指的内存空间不能重叠，且s1要有足够的空间来容纳要复制的字符串\n\n学习自[慕课网](http://www.imooc.com/learn/249)","source":"_posts/C语言入门.md","raw":"title: C语言入门\ndate: 2015-12-21 11:43:33\ntags: [C语言]\ndescription: C语言学习，C语言入门\n\n---\nC语言一经出现就以其功能丰富、表达能力强、灵活方便、应用面广等特点迅速在全世界普及和推广。C语言不但执行效率高而且可移植性好，可以用来开发应用软件、驱动、操作系统等。C语言也是其它众多高级语言的鼻祖语言，所以说学习C语言是进入编程世界的必修课。\n\n## hello world不解释\n\n\t#include <stdio.h>\n    int main()            \n\t{\n\t    printf(\"hello world\");\n\t\treturn 0;\n\t}\n\n<!-- more -->\n\n+ `#include <stdio.h>`就是一条预处理命令，它的作用是通知C语言编译系统在对C程序进行正式编译之前需做一些预处理工作。\n+ 一个C程序有且只有一个主函数，即main函数，主函数就是C语言中的唯一入口。\n\n+ C语言注释方法有两种：\n```\n\t多行注释：  /* 注释内容 */ \n\t单行注释：  //注释一行\n```\n\n## 基本数据类型\n\nC语言中，数据类型可分为：基本数据类型，构造数据类型，指针类型，空类型。\n![](/images/201511/5.jpg)\n\n## 格式化输出语句\n\n格式化输出语句，也可以说是占位输出，是将各种类型的数据按照格式化后的类型及指定的位置从计算机上显示。\n\n\t#include <stdio.h>\n\tint main(){\n\t    int age = 18;\n\t\tfloat height = 1.85;\n\t\tchar unit = 'm';\n\t\tprintf(\"小明今年%d岁\\n\", age);\n\t\tprintf(\"小明身高%f%c\\n\", height, unit);\n\t\tprintf(\"小明现在在慕课网上学习IT技术\"); \n\t\treturn 0;\n\t}\n\n![](/images/201511/7.jpg)\n\n## 定义常量\n\n` #define  标识符 常量值 `\n\n## 类型转换\n\n\n1. 自动类型转换\n\n![](/images/201511/6.jpg)\n\n<p style=\"color:red\">注：字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换</p>\n\n2. 强制类型转换\n\n在使用强制转换时应注意以下问题：\n\n+ 数据类型和表达式都必须加括号，如把(int)(x/2+y)写成(int)x/2+y则成了把x转换成int型之后再除2再与y相加了。\n\n+ 转换后不会改变原数据的类型及变量值，只在本次运算中临时性转换。\n\n+ 强制转换后的运算结果不遵循四舍五入原则。\n\n\n## 函数\n\n**声明：**\n![](/images/201511/8.jpg)\n\n\tint sayLove()\n\t{\n\t    //在这里输入输出语句printf，输出内容为I Love imooc \n\t   printf(\"I LOVE imooc\");\n\t    return 0;\n\t}\n\n\tint main()\n\t{\n\t    /* 调用所写函数 */\n\t    sayLove();\n\t    return 0;\n\t}\n\n<p style=\"color:red\">注：自定义函数尽量放在main函数之前，如果要放在main函数后面的话，需要在main函数之前先声明自定义函数，声明格式为：[数据类型说明] 函数名称（[参数]）;</p>\n\n### 内部函数与外部函数\n1. 在C语言中不能被其他源文件调用的函数称谓内部函数 ，内部函数由static关键字来定义，因此又被称谓静态函数，形式为：\n\n `static [数据类型] 函数名（[参数]） `\n\n这里的static是对函数的作用范围的一个限定，限定该函数只能在其所处的源文件中使用，因此在不同文件中出现相同的函数名称的内部函数是没有问题的。\n\n2. 在C语言中能被其他源文件调用的函数称谓外部函数 ，外部函数由extern关键字来定义，形式为：\n\n `extern [数据类型] 函数名([参数]) `\n\nC语言规定，在没有指定函数的作用范围时，系统会默认认为是外部函数，因此当需要定义外部函数时extern也可以省略。\n\n\n### 参数\n\n参数分为形参和实参两种,形参是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数；实参是在调用时传递该函数的参数。\n\n+ 形参只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。\n+ 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值等办法使实参获得确定值。\n+ 在参数传递时，实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹配”的错误。\n\n### 返回值\n\n函数的返回值是指函数被调用之后，执行函数体中的程序段所取得的并返回给主调函数的值。\n\n1. 函数的值只能通过return语句返回主调函数。return语句的一般形式为：\n   `return 表达式`   或者为：  `return (表达式)`;\n\n2. 函数值的类型和函数定义中函数的类型应保持一致。如果两者不一致，则以函数返回类型为准，自动进行类型转换。\n\n3. 没有返回值的函数，返回类型为void。\n\n<p style=\"color:red\">注意：void函数中可以有执行代码块，但是不能有返回值，另void函数中如果有return语句，该语句只能起到结束函数运行的功能。其格式为：return;</p>\n\n### 变量\n\n#### 局部和全局\n1. 局部变量也称为内部变量。局部变量是在函数内作定义说明的。其作用域仅限于函数内， 离开该函数后再使用这种变量是非法的。在复合语句中也可定义变量，其作用域只在复合语句范围内。\n\n2. 全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序。\n\n#### 存储类别\n\nC语言根据变量的生存周期来划分，可以分为静态存储方式和动态存储方式。\n\n1. 静态存储方式\n\n静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。\n\n2. 动态存储方式\n\n动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。\n\n3. 存储类别\nC语言中存储类别又分为四类：自动（auto）、静态（static）、寄存器的（register）和外部的（extern）。\n+ 用关键字auto定义的变量为自动变量，auto可以省略，auto不写则隐含定为“自动存储类别”，属于动态存储方式\n+ 用static修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。\n\n<p style=\"color:red\">注意：静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放；静态局部变量在编译时赋初值，即只赋初值一次；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。</p>\n\n+ 为了提高效率，C语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫“寄存器变量”，用关键字register作声明\n\n<p style=\"color:red\">注意：只有局部自动变量和形式参数可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；局部静态变量不能定义为寄存器变量。</p>\n+ 用extern声明的的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。\n\n\n\n## 数组\n\n**声明及初始化**\n\n1. 声明\n数据类型 数组名称[长度]; \n\n2. 初始化\n\n\n第一种形式\n`int arrFirst[3] = {1,2,3};`\n第二种形式\n`int arrSecond[] = {1,2,3};`\n第三种形式\n`int arrThird[3];`\n\n<b style=\"color:red\">注意：</b>\n1、数组的下标均以0开始；\n2、数组在初始化的时候，数组内元素的个数不能大于声明的数组长度；\n3、如果采用第一种初始化方式，元素个数小于数组的长度时，多余的数组元素初始化为0；\n4、在声明数组后没有进行初始化的时候，静态（static）和外部（extern）类型的数组元素初始化元素为0，自动（auto）类型的数组的元素初始化值不确定。\n\n\n多维数组\n\n定义：\n\n```\n\t数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; \n```\n\n初始化\n```\n\t数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n] = {{值1,..,值n},{值1,..,值n},...,{值1,..,值n}}; \n```\n```\n\t数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; 数组名称[下标1][下标2]...[下标n] = 值; \n```\n\n<b style=\"color:red\">注意：</b>\n\n1. 采用第一种始化时数组声明必须指定列的维数。因为系统会根据数组中元素的总个数来分配空间，当知道元素总个数以及列的维数后，会直接计算出行的维数；\n\n2. 采用第二种初始化时数组声明必须同时指定行和列的维数。\n\n\n### 利用数组定义字符串\n\n在C语言中，是没有办法直接定义字符串数据类型的，但是我们可以使用数组来定义我们所要的字符串。\n\n\n方法：\n\n1. `char 字符串名称[长度] = \"字符串值\"`\n\n2. `char 字符串名称[长度] = {'字符1','字符2',...,'字符n','\\0'}`\n\n<b style=\"color:red\">注意：</b>\n\n1. []中的长度是可以省略不写的；\n\n2. 采用第2种方式的时候最后一个元素必须是'\\0'，'\\0'表示字符串的结束标志；\n\n3. 采用第2种方式的时候在数组中不能写中文。\n\n4. 在输出字符串的时候要使用：printf(“%s”,字符数组名字);或者puts(字符数组名字);\n\n``` C\nvoid say(char string[])       \n{\n        printf(\"%s\\n\",string);     \n        puts(string);\n}\n```\n\n---\n\n**字符串函数**\n\n![](/images/201511/9.jpg)\n\n使用字符串函数注意以下事项：\n\n1. strlen()获取字符串的长度，在字符串长度中是不包括‘\\0’而且汉字和字母的长度是不一样的。\n2. strcmp()在比较的时候会把字符串先转换成ASCII码再进行比较,返回的结果为0表示s1和s2的ASCII码相等,返回结果为1表示s1比s2的ASCII码大,返回结果为-1表示s1比s2的ASCII码小\n3. strcpy()拷贝之后会覆盖原来字符串且不能对字符串常量进行拷贝\n4. strcat在使用时s1与s2指的内存空间不能重叠，且s1要有足够的空间来容纳要复制的字符串\n\n学习自[慕课网](http://www.imooc.com/learn/249)","slug":"C语言入门","published":1,"updated":"2021-12-06T06:07:06.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwok40002y4v28bue8zfs","content":"<p>C语言一经出现就以其功能丰富、表达能力强、灵活方便、应用面广等特点迅速在全世界普及和推广。C语言不但执行效率高而且可移植性好，可以用来开发应用软件、驱动、操作系统等。C语言也是其它众多高级语言的鼻祖语言，所以说学习C语言是进入编程世界的必修课。</p>\n<h2 id=\"hello-world不解释\"><a href=\"#hello-world不解释\" class=\"headerlink\" title=\"hello world不解释\"></a>hello world不解释</h2><pre><code>#include &lt;stdio.h&gt;\nint main()            \n&#123;\n    printf(&quot;hello world&quot;);\n    return 0;\n&#125;\n</code></pre>\n<span id=\"more\"></span>\n\n<ul>\n<li><p><code>#include &lt;stdio.h&gt;</code>就是一条预处理命令，它的作用是通知C语言编译系统在对C程序进行正式编译之前需做一些预处理工作。</p>\n</li>\n<li><p>一个C程序有且只有一个主函数，即main函数，主函数就是C语言中的唯一入口。</p>\n</li>\n<li><p>C语言注释方法有两种：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多行注释：  /* 注释内容 */ </span><br><span class=\"line\">单行注释：  //注释一行</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><p>C语言中，数据类型可分为：基本数据类型，构造数据类型，指针类型，空类型。<br><img src=\"/images/201511/5.jpg\"></p>\n<h2 id=\"格式化输出语句\"><a href=\"#格式化输出语句\" class=\"headerlink\" title=\"格式化输出语句\"></a>格式化输出语句</h2><p>格式化输出语句，也可以说是占位输出，是将各种类型的数据按照格式化后的类型及指定的位置从计算机上显示。</p>\n<pre><code>#include &lt;stdio.h&gt;\nint main()&#123;\n    int age = 18;\n    float height = 1.85;\n    char unit = &#39;m&#39;;\n    printf(&quot;小明今年%d岁\\n&quot;, age);\n    printf(&quot;小明身高%f%c\\n&quot;, height, unit);\n    printf(&quot;小明现在在慕课网上学习IT技术&quot;); \n    return 0;\n&#125;\n</code></pre>\n<p><img src=\"/images/201511/7.jpg\"></p>\n<h2 id=\"定义常量\"><a href=\"#定义常量\" class=\"headerlink\" title=\"定义常量\"></a>定义常量</h2><p><code>#define  标识符 常量值</code></p>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ol>\n<li>自动类型转换</li>\n</ol>\n<p><img src=\"/images/201511/6.jpg\"></p>\n<p style=\"color:red\">注：字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换</p>\n\n<ol start=\"2\">\n<li>强制类型转换</li>\n</ol>\n<p>在使用强制转换时应注意以下问题：</p>\n<ul>\n<li><p>数据类型和表达式都必须加括号，如把(int)(x/2+y)写成(int)x/2+y则成了把x转换成int型之后再除2再与y相加了。</p>\n</li>\n<li><p>转换后不会改变原数据的类型及变量值，只在本次运算中临时性转换。</p>\n</li>\n<li><p>强制转换后的运算结果不遵循四舍五入原则。</p>\n</li>\n</ul>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p><strong>声明：</strong><br><img src=\"/images/201511/8.jpg\"></p>\n<pre><code>int sayLove()\n&#123;\n    //在这里输入输出语句printf，输出内容为I Love imooc \n   printf(&quot;I LOVE imooc&quot;);\n    return 0;\n&#125;\n\nint main()\n&#123;\n    /* 调用所写函数 */\n    sayLove();\n    return 0;\n&#125;\n</code></pre>\n<p style=\"color:red\">注：自定义函数尽量放在main函数之前，如果要放在main函数后面的话，需要在main函数之前先声明自定义函数，声明格式为：[数据类型说明] 函数名称（[参数]）;</p>\n\n<h3 id=\"内部函数与外部函数\"><a href=\"#内部函数与外部函数\" class=\"headerlink\" title=\"内部函数与外部函数\"></a>内部函数与外部函数</h3><ol>\n<li>在C语言中不能被其他源文件调用的函数称谓内部函数 ，内部函数由static关键字来定义，因此又被称谓静态函数，形式为：</li>\n</ol>\n<p> <code>static [数据类型] 函数名（[参数]） </code></p>\n<p>这里的static是对函数的作用范围的一个限定，限定该函数只能在其所处的源文件中使用，因此在不同文件中出现相同的函数名称的内部函数是没有问题的。</p>\n<ol start=\"2\">\n<li>在C语言中能被其他源文件调用的函数称谓外部函数 ，外部函数由extern关键字来定义，形式为：</li>\n</ol>\n<p> <code>extern [数据类型] 函数名([参数]) </code></p>\n<p>C语言规定，在没有指定函数的作用范围时，系统会默认认为是外部函数，因此当需要定义外部函数时extern也可以省略。</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>参数分为形参和实参两种,形参是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数；实参是在调用时传递该函数的参数。</p>\n<ul>\n<li>形参只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。</li>\n<li>实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值等办法使实参获得确定值。</li>\n<li>在参数传递时，实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹配”的错误。</li>\n</ul>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>函数的返回值是指函数被调用之后，执行函数体中的程序段所取得的并返回给主调函数的值。</p>\n<ol>\n<li><p>函数的值只能通过return语句返回主调函数。return语句的一般形式为：<br><code>return 表达式</code>   或者为：  <code>return (表达式)</code>;</p>\n</li>\n<li><p>函数值的类型和函数定义中函数的类型应保持一致。如果两者不一致，则以函数返回类型为准，自动进行类型转换。</p>\n</li>\n<li><p>没有返回值的函数，返回类型为void。</p>\n</li>\n</ol>\n<p style=\"color:red\">注意：void函数中可以有执行代码块，但是不能有返回值，另void函数中如果有return语句，该语句只能起到结束函数运行的功能。其格式为：return;</p>\n\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><h4 id=\"局部和全局\"><a href=\"#局部和全局\" class=\"headerlink\" title=\"局部和全局\"></a>局部和全局</h4><ol>\n<li><p>局部变量也称为内部变量。局部变量是在函数内作定义说明的。其作用域仅限于函数内， 离开该函数后再使用这种变量是非法的。在复合语句中也可定义变量，其作用域只在复合语句范围内。</p>\n</li>\n<li><p>全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序。</p>\n</li>\n</ol>\n<h4 id=\"存储类别\"><a href=\"#存储类别\" class=\"headerlink\" title=\"存储类别\"></a>存储类别</h4><p>C语言根据变量的生存周期来划分，可以分为静态存储方式和动态存储方式。</p>\n<ol>\n<li>静态存储方式</li>\n</ol>\n<p>静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。</p>\n<ol start=\"2\">\n<li>动态存储方式</li>\n</ol>\n<p>动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。</p>\n<ol start=\"3\">\n<li>存储类别<br>C语言中存储类别又分为四类：自动（auto）、静态（static）、寄存器的（register）和外部的（extern）。</li>\n</ol>\n<ul>\n<li>用关键字auto定义的变量为自动变量，auto可以省略，auto不写则隐含定为“自动存储类别”，属于动态存储方式</li>\n<li>用static修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。</li>\n</ul>\n<p style=\"color:red\">注意：静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放；静态局部变量在编译时赋初值，即只赋初值一次；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。</p>\n\n<ul>\n<li>为了提高效率，C语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫“寄存器变量”，用关键字register作声明</li>\n</ul>\n<p style=\"color:red\">注意：只有局部自动变量和形式参数可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；局部静态变量不能定义为寄存器变量。</p>\n+ 用extern声明的的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。\n\n\n\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p><strong>声明及初始化</strong></p>\n<ol>\n<li><p>声明<br>数据类型 数组名称[长度]; </p>\n</li>\n<li><p>初始化</p>\n</li>\n</ol>\n<p>第一种形式<br><code>int arrFirst[3] = &#123;1,2,3&#125;;</code><br>第二种形式<br><code>int arrSecond[] = &#123;1,2,3&#125;;</code><br>第三种形式<br><code>int arrThird[3];</code></p>\n<p><b style=\"color:red\">注意：</b><br>1、数组的下标均以0开始；<br>2、数组在初始化的时候，数组内元素的个数不能大于声明的数组长度；<br>3、如果采用第一种初始化方式，元素个数小于数组的长度时，多余的数组元素初始化为0；<br>4、在声明数组后没有进行初始化的时候，静态（static）和外部（extern）类型的数组元素初始化元素为0，自动（auto）类型的数组的元素初始化值不确定。</p>\n<p>多维数组</p>\n<p>定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; </span><br></pre></td></tr></table></figure>\n\n<p>初始化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n] = &#123;&#123;值1,..,值n&#125;,&#123;值1,..,值n&#125;,...,&#123;值1,..,值n&#125;&#125;; </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; 数组名称[下标1][下标2]...[下标n] = 值; </span><br></pre></td></tr></table></figure>\n\n<p><b style=\"color:red\">注意：</b></p>\n<ol>\n<li><p>采用第一种始化时数组声明必须指定列的维数。因为系统会根据数组中元素的总个数来分配空间，当知道元素总个数以及列的维数后，会直接计算出行的维数；</p>\n</li>\n<li><p>采用第二种初始化时数组声明必须同时指定行和列的维数。</p>\n</li>\n</ol>\n<h3 id=\"利用数组定义字符串\"><a href=\"#利用数组定义字符串\" class=\"headerlink\" title=\"利用数组定义字符串\"></a>利用数组定义字符串</h3><p>在C语言中，是没有办法直接定义字符串数据类型的，但是我们可以使用数组来定义我们所要的字符串。</p>\n<p>方法：</p>\n<ol>\n<li><p><code>char 字符串名称[长度] = &quot;字符串值&quot;</code></p>\n</li>\n<li><p><code>char 字符串名称[长度] = &#123;&#39;字符1&#39;,&#39;字符2&#39;,...,&#39;字符n&#39;,&#39;\\0&#39;&#125;</code></p>\n</li>\n</ol>\n<p><b style=\"color:red\">注意：</b></p>\n<ol>\n<li><p>[]中的长度是可以省略不写的；</p>\n</li>\n<li><p>采用第2种方式的时候最后一个元素必须是’\\0’，’\\0’表示字符串的结束标志；</p>\n</li>\n<li><p>采用第2种方式的时候在数组中不能写中文。</p>\n</li>\n<li><p>在输出字符串的时候要使用：printf(“%s”,字符数组名字);或者puts(字符数组名字);</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"built_in\">string</span>[])</span>       </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,<span class=\"built_in\">string</span>);     </span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"built_in\">string</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>字符串函数</strong></p>\n<p><img src=\"/images/201511/9.jpg\"></p>\n<p>使用字符串函数注意以下事项：</p>\n<ol>\n<li>strlen()获取字符串的长度，在字符串长度中是不包括‘\\0’而且汉字和字母的长度是不一样的。</li>\n<li>strcmp()在比较的时候会把字符串先转换成ASCII码再进行比较,返回的结果为0表示s1和s2的ASCII码相等,返回结果为1表示s1比s2的ASCII码大,返回结果为-1表示s1比s2的ASCII码小</li>\n<li>strcpy()拷贝之后会覆盖原来字符串且不能对字符串常量进行拷贝</li>\n<li>strcat在使用时s1与s2指的内存空间不能重叠，且s1要有足够的空间来容纳要复制的字符串</li>\n</ol>\n<p>学习自<a href=\"http://www.imooc.com/learn/249\">慕课网</a></p>\n","site":{"data":{}},"excerpt":"<p>C语言一经出现就以其功能丰富、表达能力强、灵活方便、应用面广等特点迅速在全世界普及和推广。C语言不但执行效率高而且可移植性好，可以用来开发应用软件、驱动、操作系统等。C语言也是其它众多高级语言的鼻祖语言，所以说学习C语言是进入编程世界的必修课。</p>\n<h2 id=\"hello-world不解释\"><a href=\"#hello-world不解释\" class=\"headerlink\" title=\"hello world不解释\"></a>hello world不解释</h2><pre><code>#include &lt;stdio.h&gt;\nint main()            \n&#123;\n    printf(&quot;hello world&quot;);\n    return 0;\n&#125;\n</code></pre>","more":"<ul>\n<li><p><code>#include &lt;stdio.h&gt;</code>就是一条预处理命令，它的作用是通知C语言编译系统在对C程序进行正式编译之前需做一些预处理工作。</p>\n</li>\n<li><p>一个C程序有且只有一个主函数，即main函数，主函数就是C语言中的唯一入口。</p>\n</li>\n<li><p>C语言注释方法有两种：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多行注释：  /* 注释内容 */ </span><br><span class=\"line\">单行注释：  //注释一行</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><p>C语言中，数据类型可分为：基本数据类型，构造数据类型，指针类型，空类型。<br><img src=\"/images/201511/5.jpg\"></p>\n<h2 id=\"格式化输出语句\"><a href=\"#格式化输出语句\" class=\"headerlink\" title=\"格式化输出语句\"></a>格式化输出语句</h2><p>格式化输出语句，也可以说是占位输出，是将各种类型的数据按照格式化后的类型及指定的位置从计算机上显示。</p>\n<pre><code>#include &lt;stdio.h&gt;\nint main()&#123;\n    int age = 18;\n    float height = 1.85;\n    char unit = &#39;m&#39;;\n    printf(&quot;小明今年%d岁\\n&quot;, age);\n    printf(&quot;小明身高%f%c\\n&quot;, height, unit);\n    printf(&quot;小明现在在慕课网上学习IT技术&quot;); \n    return 0;\n&#125;\n</code></pre>\n<p><img src=\"/images/201511/7.jpg\"></p>\n<h2 id=\"定义常量\"><a href=\"#定义常量\" class=\"headerlink\" title=\"定义常量\"></a>定义常量</h2><p><code>#define  标识符 常量值</code></p>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ol>\n<li>自动类型转换</li>\n</ol>\n<p><img src=\"/images/201511/6.jpg\"></p>\n<p style=\"color:red\">注：字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换</p>\n\n<ol start=\"2\">\n<li>强制类型转换</li>\n</ol>\n<p>在使用强制转换时应注意以下问题：</p>\n<ul>\n<li><p>数据类型和表达式都必须加括号，如把(int)(x/2+y)写成(int)x/2+y则成了把x转换成int型之后再除2再与y相加了。</p>\n</li>\n<li><p>转换后不会改变原数据的类型及变量值，只在本次运算中临时性转换。</p>\n</li>\n<li><p>强制转换后的运算结果不遵循四舍五入原则。</p>\n</li>\n</ul>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p><strong>声明：</strong><br><img src=\"/images/201511/8.jpg\"></p>\n<pre><code>int sayLove()\n&#123;\n    //在这里输入输出语句printf，输出内容为I Love imooc \n   printf(&quot;I LOVE imooc&quot;);\n    return 0;\n&#125;\n\nint main()\n&#123;\n    /* 调用所写函数 */\n    sayLove();\n    return 0;\n&#125;\n</code></pre>\n<p style=\"color:red\">注：自定义函数尽量放在main函数之前，如果要放在main函数后面的话，需要在main函数之前先声明自定义函数，声明格式为：[数据类型说明] 函数名称（[参数]）;</p>\n\n<h3 id=\"内部函数与外部函数\"><a href=\"#内部函数与外部函数\" class=\"headerlink\" title=\"内部函数与外部函数\"></a>内部函数与外部函数</h3><ol>\n<li>在C语言中不能被其他源文件调用的函数称谓内部函数 ，内部函数由static关键字来定义，因此又被称谓静态函数，形式为：</li>\n</ol>\n<p> <code>static [数据类型] 函数名（[参数]） </code></p>\n<p>这里的static是对函数的作用范围的一个限定，限定该函数只能在其所处的源文件中使用，因此在不同文件中出现相同的函数名称的内部函数是没有问题的。</p>\n<ol start=\"2\">\n<li>在C语言中能被其他源文件调用的函数称谓外部函数 ，外部函数由extern关键字来定义，形式为：</li>\n</ol>\n<p> <code>extern [数据类型] 函数名([参数]) </code></p>\n<p>C语言规定，在没有指定函数的作用范围时，系统会默认认为是外部函数，因此当需要定义外部函数时extern也可以省略。</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>参数分为形参和实参两种,形参是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数；实参是在调用时传递该函数的参数。</p>\n<ul>\n<li>形参只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。</li>\n<li>实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值等办法使实参获得确定值。</li>\n<li>在参数传递时，实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹配”的错误。</li>\n</ul>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>函数的返回值是指函数被调用之后，执行函数体中的程序段所取得的并返回给主调函数的值。</p>\n<ol>\n<li><p>函数的值只能通过return语句返回主调函数。return语句的一般形式为：<br><code>return 表达式</code>   或者为：  <code>return (表达式)</code>;</p>\n</li>\n<li><p>函数值的类型和函数定义中函数的类型应保持一致。如果两者不一致，则以函数返回类型为准，自动进行类型转换。</p>\n</li>\n<li><p>没有返回值的函数，返回类型为void。</p>\n</li>\n</ol>\n<p style=\"color:red\">注意：void函数中可以有执行代码块，但是不能有返回值，另void函数中如果有return语句，该语句只能起到结束函数运行的功能。其格式为：return;</p>\n\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><h4 id=\"局部和全局\"><a href=\"#局部和全局\" class=\"headerlink\" title=\"局部和全局\"></a>局部和全局</h4><ol>\n<li><p>局部变量也称为内部变量。局部变量是在函数内作定义说明的。其作用域仅限于函数内， 离开该函数后再使用这种变量是非法的。在复合语句中也可定义变量，其作用域只在复合语句范围内。</p>\n</li>\n<li><p>全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序。</p>\n</li>\n</ol>\n<h4 id=\"存储类别\"><a href=\"#存储类别\" class=\"headerlink\" title=\"存储类别\"></a>存储类别</h4><p>C语言根据变量的生存周期来划分，可以分为静态存储方式和动态存储方式。</p>\n<ol>\n<li>静态存储方式</li>\n</ol>\n<p>静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。</p>\n<ol start=\"2\">\n<li>动态存储方式</li>\n</ol>\n<p>动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。</p>\n<ol start=\"3\">\n<li>存储类别<br>C语言中存储类别又分为四类：自动（auto）、静态（static）、寄存器的（register）和外部的（extern）。</li>\n</ol>\n<ul>\n<li>用关键字auto定义的变量为自动变量，auto可以省略，auto不写则隐含定为“自动存储类别”，属于动态存储方式</li>\n<li>用static修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。</li>\n</ul>\n<p style=\"color:red\">注意：静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放；静态局部变量在编译时赋初值，即只赋初值一次；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。</p>\n\n<ul>\n<li>为了提高效率，C语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫“寄存器变量”，用关键字register作声明</li>\n</ul>\n<p style=\"color:red\">注意：只有局部自动变量和形式参数可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；局部静态变量不能定义为寄存器变量。</p>\n+ 用extern声明的的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。\n\n\n\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p><strong>声明及初始化</strong></p>\n<ol>\n<li><p>声明<br>数据类型 数组名称[长度]; </p>\n</li>\n<li><p>初始化</p>\n</li>\n</ol>\n<p>第一种形式<br><code>int arrFirst[3] = &#123;1,2,3&#125;;</code><br>第二种形式<br><code>int arrSecond[] = &#123;1,2,3&#125;;</code><br>第三种形式<br><code>int arrThird[3];</code></p>\n<p><b style=\"color:red\">注意：</b><br>1、数组的下标均以0开始；<br>2、数组在初始化的时候，数组内元素的个数不能大于声明的数组长度；<br>3、如果采用第一种初始化方式，元素个数小于数组的长度时，多余的数组元素初始化为0；<br>4、在声明数组后没有进行初始化的时候，静态（static）和外部（extern）类型的数组元素初始化元素为0，自动（auto）类型的数组的元素初始化值不确定。</p>\n<p>多维数组</p>\n<p>定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; </span><br></pre></td></tr></table></figure>\n\n<p>初始化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n] = &#123;&#123;值1,..,值n&#125;,&#123;值1,..,值n&#125;,...,&#123;值1,..,值n&#125;&#125;; </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; 数组名称[下标1][下标2]...[下标n] = 值; </span><br></pre></td></tr></table></figure>\n\n<p><b style=\"color:red\">注意：</b></p>\n<ol>\n<li><p>采用第一种始化时数组声明必须指定列的维数。因为系统会根据数组中元素的总个数来分配空间，当知道元素总个数以及列的维数后，会直接计算出行的维数；</p>\n</li>\n<li><p>采用第二种初始化时数组声明必须同时指定行和列的维数。</p>\n</li>\n</ol>\n<h3 id=\"利用数组定义字符串\"><a href=\"#利用数组定义字符串\" class=\"headerlink\" title=\"利用数组定义字符串\"></a>利用数组定义字符串</h3><p>在C语言中，是没有办法直接定义字符串数据类型的，但是我们可以使用数组来定义我们所要的字符串。</p>\n<p>方法：</p>\n<ol>\n<li><p><code>char 字符串名称[长度] = &quot;字符串值&quot;</code></p>\n</li>\n<li><p><code>char 字符串名称[长度] = &#123;&#39;字符1&#39;,&#39;字符2&#39;,...,&#39;字符n&#39;,&#39;\\0&#39;&#125;</code></p>\n</li>\n</ol>\n<p><b style=\"color:red\">注意：</b></p>\n<ol>\n<li><p>[]中的长度是可以省略不写的；</p>\n</li>\n<li><p>采用第2种方式的时候最后一个元素必须是’\\0’，’\\0’表示字符串的结束标志；</p>\n</li>\n<li><p>采用第2种方式的时候在数组中不能写中文。</p>\n</li>\n<li><p>在输出字符串的时候要使用：printf(“%s”,字符数组名字);或者puts(字符数组名字);</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"built_in\">string</span>[])</span>       </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,<span class=\"built_in\">string</span>);     </span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"built_in\">string</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>字符串函数</strong></p>\n<p><img src=\"/images/201511/9.jpg\"></p>\n<p>使用字符串函数注意以下事项：</p>\n<ol>\n<li>strlen()获取字符串的长度，在字符串长度中是不包括‘\\0’而且汉字和字母的长度是不一样的。</li>\n<li>strcmp()在比较的时候会把字符串先转换成ASCII码再进行比较,返回的结果为0表示s1和s2的ASCII码相等,返回结果为1表示s1比s2的ASCII码大,返回结果为-1表示s1比s2的ASCII码小</li>\n<li>strcpy()拷贝之后会覆盖原来字符串且不能对字符串常量进行拷贝</li>\n<li>strcat在使用时s1与s2指的内存空间不能重叠，且s1要有足够的空间来容纳要复制的字符串</li>\n</ol>\n<p>学习自<a href=\"http://www.imooc.com/learn/249\">慕课网</a></p>"},{"title":"Backbone学习笔记（一）","date":"2015-12-01T08:02:22.000Z","description":"Backbone Backbone.js MVC","_content":"\n# ——Backbone中的MVC\n[Backbone.js](http://backbonejs.org/)为复杂WEB应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中models用于绑定键值数据和自定义事件；collections附有可枚举函数的丰富API； views可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。\n\n下面通过实例来学习backbone的MVC。实例来自[http://dmyz.org/archives/598](http://dmyz.org/archives/598)。原文章虽然是入门范例，但大牛的入门对我这种菜逼来说还是看不懂，所以我在其原来的例子上进行了一些取舍并对一些代码进行了注释。\n\n[Backbone.js中文文档:http://www.css88.com/doc/backbone/](http://www.css88.com/doc/backbone/)\n\n![](/images/201511/1.svg)\n<!-- more -->\n\n---\n\nHTML代码，只要把backbone的代码放入其<script></script>内运行即可：\n\n\t<!DOCTYPE html>\n\t<html>\n\t<head>\n\t<script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.11.1.js\"></script>\n\t<script type=\"text/javascript\" src=\"http://underscorejs.org/underscore-min.js\"></script>\n\t<script type=\"text/javascript\" src=\"http://backbonejs.org/backbone-min.js\"></script>\n\n\t<link href=\"http://cdn.bootcss.com/bootstrap/3.1.1/css/bootstrap.min.css\" rel=\"stylesheet\">\n\t</head>\n\t<body>\n\t  <table id=\"js-id-gists\" class=\"table\">\n\t    <thead><th>description</th><th>URL</th><th>created_at</th></thead>\n\t    <tbody></tbody>\n\t  </table>\n\n\t  <script>\n\t\t//backbone....\n\t  </script>\n\t</body>\n\t</html>\n\n\n## 首先是M:\n\n\t//创建一个自定义模型类\n\tvar Gist = Backbone.Model.extend({\n      url: 'https://api.github.com/gists/public',\n\n      //backbone提供了一个parse方法,它会在 fetch及 save 时执行。 \n      //传入本函数的为原始 response 对象,这个方法提供传入两个参数，并返回第一个参数。\n      parse:function(response){\n          return (response[0])\n      },\n\n      //默认属性值设置，如果属性中没有website（注意不是website值为空），会设置website值为dmyz。\n      defaults:{\n        website:'dmyz'\n      },\n\n      //验证事件，当website值为dmyz时触发\n      validate:function(attrs){\n        if(attrs.website == 'dmyz'){\n          return 'website error'\n        }\n      }\n    })\n\n    gist = new Gist(); //实例化模块\n\n    gist.on(\"validate\",function(model,error){\n      alert(error)\n    })\n\n    //get    collection.get(id) 通过一个id，一个cid，或者传递一个model来获得集合中的模型。\n\n    gist.on('change',function(model){   //绑定一个change事件\n      var tbody = document.getElementById('js-id-gists').children[1],\n          tr = document.getElementById(model.get('id'));  \n\n      if(!tr){\n        tr = document.createElement('tr');  \n        tr.setAttribute('id',model.get('id')); \n      }\n\n      tr.innerHTML=\"<td>\"+model.get('description')+\"</td><td>\"+model.get('url')+\"</td><td>\"+model.get('created_at') + '</td>';\n      tbody.appendChild(tr);\n    })\n\n    //从远程获取数据，获到数据后会触发change事件\n    // gist.fetch();\n    \n    // 将数据存储到数据库\n    gist.save()\n\n整个过程:\n1. 创建自定义模型类，并实例化\n2. gist.fetch()从远程拉取数据，触发了change事件\n3. 绑定在gist上的change事件执行（model是其数据模型），通过model.get()来获取数据，渲染到页面\n4. 在本例中，可以看出model是数据模型，起到操作数据的作用，\n---\n\n## M+V:\n\n    var Gist = Backbone.Model.extend({\n      url: 'https://api.github.com/gists/public',\n      parse:function(response){\n          return (response[0])\n      }\n    })\n\n    //实例化模块\n    gist = new Gist();\n     \n    //创建一个自定义视图类\n    var GistRow = Backbone.View.extend({\n      //所有的视图都拥有一个 DOM 元素（el 属性），即使该元素仍未插入页面中去。 视图可以在任何时候渲染，然后一次性插入 DOM 中去，这样能尽量减少 reflows 和 repaints 从而获得高性能的 UI 渲染。\n\n      el:'tbody',\n      \n      //指定视图的数据模型\n      Model:gist,\n\n\t  //initialize为初始化函数，创建视图时，它会立刻被调用。\n      //initialize函数在this上监听Model的change事件，发生改变时时触发render事件\n      initialize:function(){\n        this.listenTo(this.Model,'change',this.render);\n      },\n\n      //渲染视图\n      render:function(){\n        var model =this.Model,\n            tr = document.createElement('tr');\n        tr.innerHTML='<td>' + model.get('description') + '</td><td>' + model.get('url') + '</td><td>' + model.get('created_at') + \"</td>\";\n        this.el.innerHTML = tr.outerHTML;\n        // console.log(this.el)\n        return this;\n      }\n    });\n    \n    //实例化GistRow,立即执行initialize函数\n    var tr = new GistRow();\n    gist.fetch();\n    \n整个过程：\n1. 创建自定义模型类，并实例化\n2. 创建自定义视图类，并实例化，指定模型\n3. 立即执行initialize函数，监听model的change事件，\n4. fetch()事件获取远程数据，触发change事件，执行render事件\n\n---\n\n## M+V+C:\n\tvar Gist = Backbone.Model.extend();\n\n\t//创建一个自定义集合类（collection）\n    var Gists = Backbone.Collection.extend({\n      //指定集合（collection）中包含的模型类\n      model:Gist,\n      url:'https://api.github.com/gists/public',\n      parse:function(response){\n          return response;\n      }\n    })\n\n    gists = new Gists(); \n\n    //创建一个视图类，其作用是渲染每一行的视图\n    var GistRow = Backbone.View.extend({\n      //tagName, className, 或 id 为视图指定根元素\n      tagName:'tr',\n      render:function(model){\n        this.el.id = model.cid;\n        this.el.innerHTML =  '<td>' + model.get('description') + '</td><td>'+ model.get('url') + '</td><td>' + model.get('created_at')+\"</td>\"\n        return this;\n      }\n    })\n\n    var GistView = Backbone.View.extend({\n      el:'tbody',\n\t  // 指定集合类\n      collection:gists,\n\n      //初始化函数，实例化时立即执行\n      initialize:function(){\n        this.listenTo(this.collection,'reset',this.render);\n      },\n\n      //渲染视图\n      render:function(){\n        var html = '';\n        //collection.models 访问集合中模型的内置的JavaScript 数组\n        //遍历所有models，设置他们的html\n        //下划线 _ 是underscore.js的一个全局对象\n        _.forEach(this.collection.models,function(model){\n          var tr = new GistRow();\n          html += tr.render(model).el.outerHTML;\n        })\n        this.el.innerHTML = html;\n        return this;\n      }\n    });\n    \n    //实例化GistRow,调用initialize函数\n    var gistsView = new GistView();\n    gists.fetch({reset:true});\n\n整个过程：\n1. 创建一个自定义模型类和集合类，实例化集合类\n2. 创建俩个自定义视图类，一个渲染每行的数据，一个渲染整个页面\n3. 实例化视图类GistView，在集合类上绑定监听事件\n4. fetch()触发监听事件，执行render函数，遍历所有models\n5. 在render函数中实例化视图类GistRow,，渲染每行\n\n","source":"_posts/Backbone学习笔记（一）.md","raw":"title: Backbone学习笔记（一）\ndate: 2015-12-01 16:02:22\ntags: [web,Backbone]\ndescription: Backbone Backbone.js MVC\n\n---\n\n# ——Backbone中的MVC\n[Backbone.js](http://backbonejs.org/)为复杂WEB应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中models用于绑定键值数据和自定义事件；collections附有可枚举函数的丰富API； views可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。\n\n下面通过实例来学习backbone的MVC。实例来自[http://dmyz.org/archives/598](http://dmyz.org/archives/598)。原文章虽然是入门范例，但大牛的入门对我这种菜逼来说还是看不懂，所以我在其原来的例子上进行了一些取舍并对一些代码进行了注释。\n\n[Backbone.js中文文档:http://www.css88.com/doc/backbone/](http://www.css88.com/doc/backbone/)\n\n![](/images/201511/1.svg)\n<!-- more -->\n\n---\n\nHTML代码，只要把backbone的代码放入其<script></script>内运行即可：\n\n\t<!DOCTYPE html>\n\t<html>\n\t<head>\n\t<script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.11.1.js\"></script>\n\t<script type=\"text/javascript\" src=\"http://underscorejs.org/underscore-min.js\"></script>\n\t<script type=\"text/javascript\" src=\"http://backbonejs.org/backbone-min.js\"></script>\n\n\t<link href=\"http://cdn.bootcss.com/bootstrap/3.1.1/css/bootstrap.min.css\" rel=\"stylesheet\">\n\t</head>\n\t<body>\n\t  <table id=\"js-id-gists\" class=\"table\">\n\t    <thead><th>description</th><th>URL</th><th>created_at</th></thead>\n\t    <tbody></tbody>\n\t  </table>\n\n\t  <script>\n\t\t//backbone....\n\t  </script>\n\t</body>\n\t</html>\n\n\n## 首先是M:\n\n\t//创建一个自定义模型类\n\tvar Gist = Backbone.Model.extend({\n      url: 'https://api.github.com/gists/public',\n\n      //backbone提供了一个parse方法,它会在 fetch及 save 时执行。 \n      //传入本函数的为原始 response 对象,这个方法提供传入两个参数，并返回第一个参数。\n      parse:function(response){\n          return (response[0])\n      },\n\n      //默认属性值设置，如果属性中没有website（注意不是website值为空），会设置website值为dmyz。\n      defaults:{\n        website:'dmyz'\n      },\n\n      //验证事件，当website值为dmyz时触发\n      validate:function(attrs){\n        if(attrs.website == 'dmyz'){\n          return 'website error'\n        }\n      }\n    })\n\n    gist = new Gist(); //实例化模块\n\n    gist.on(\"validate\",function(model,error){\n      alert(error)\n    })\n\n    //get    collection.get(id) 通过一个id，一个cid，或者传递一个model来获得集合中的模型。\n\n    gist.on('change',function(model){   //绑定一个change事件\n      var tbody = document.getElementById('js-id-gists').children[1],\n          tr = document.getElementById(model.get('id'));  \n\n      if(!tr){\n        tr = document.createElement('tr');  \n        tr.setAttribute('id',model.get('id')); \n      }\n\n      tr.innerHTML=\"<td>\"+model.get('description')+\"</td><td>\"+model.get('url')+\"</td><td>\"+model.get('created_at') + '</td>';\n      tbody.appendChild(tr);\n    })\n\n    //从远程获取数据，获到数据后会触发change事件\n    // gist.fetch();\n    \n    // 将数据存储到数据库\n    gist.save()\n\n整个过程:\n1. 创建自定义模型类，并实例化\n2. gist.fetch()从远程拉取数据，触发了change事件\n3. 绑定在gist上的change事件执行（model是其数据模型），通过model.get()来获取数据，渲染到页面\n4. 在本例中，可以看出model是数据模型，起到操作数据的作用，\n---\n\n## M+V:\n\n    var Gist = Backbone.Model.extend({\n      url: 'https://api.github.com/gists/public',\n      parse:function(response){\n          return (response[0])\n      }\n    })\n\n    //实例化模块\n    gist = new Gist();\n     \n    //创建一个自定义视图类\n    var GistRow = Backbone.View.extend({\n      //所有的视图都拥有一个 DOM 元素（el 属性），即使该元素仍未插入页面中去。 视图可以在任何时候渲染，然后一次性插入 DOM 中去，这样能尽量减少 reflows 和 repaints 从而获得高性能的 UI 渲染。\n\n      el:'tbody',\n      \n      //指定视图的数据模型\n      Model:gist,\n\n\t  //initialize为初始化函数，创建视图时，它会立刻被调用。\n      //initialize函数在this上监听Model的change事件，发生改变时时触发render事件\n      initialize:function(){\n        this.listenTo(this.Model,'change',this.render);\n      },\n\n      //渲染视图\n      render:function(){\n        var model =this.Model,\n            tr = document.createElement('tr');\n        tr.innerHTML='<td>' + model.get('description') + '</td><td>' + model.get('url') + '</td><td>' + model.get('created_at') + \"</td>\";\n        this.el.innerHTML = tr.outerHTML;\n        // console.log(this.el)\n        return this;\n      }\n    });\n    \n    //实例化GistRow,立即执行initialize函数\n    var tr = new GistRow();\n    gist.fetch();\n    \n整个过程：\n1. 创建自定义模型类，并实例化\n2. 创建自定义视图类，并实例化，指定模型\n3. 立即执行initialize函数，监听model的change事件，\n4. fetch()事件获取远程数据，触发change事件，执行render事件\n\n---\n\n## M+V+C:\n\tvar Gist = Backbone.Model.extend();\n\n\t//创建一个自定义集合类（collection）\n    var Gists = Backbone.Collection.extend({\n      //指定集合（collection）中包含的模型类\n      model:Gist,\n      url:'https://api.github.com/gists/public',\n      parse:function(response){\n          return response;\n      }\n    })\n\n    gists = new Gists(); \n\n    //创建一个视图类，其作用是渲染每一行的视图\n    var GistRow = Backbone.View.extend({\n      //tagName, className, 或 id 为视图指定根元素\n      tagName:'tr',\n      render:function(model){\n        this.el.id = model.cid;\n        this.el.innerHTML =  '<td>' + model.get('description') + '</td><td>'+ model.get('url') + '</td><td>' + model.get('created_at')+\"</td>\"\n        return this;\n      }\n    })\n\n    var GistView = Backbone.View.extend({\n      el:'tbody',\n\t  // 指定集合类\n      collection:gists,\n\n      //初始化函数，实例化时立即执行\n      initialize:function(){\n        this.listenTo(this.collection,'reset',this.render);\n      },\n\n      //渲染视图\n      render:function(){\n        var html = '';\n        //collection.models 访问集合中模型的内置的JavaScript 数组\n        //遍历所有models，设置他们的html\n        //下划线 _ 是underscore.js的一个全局对象\n        _.forEach(this.collection.models,function(model){\n          var tr = new GistRow();\n          html += tr.render(model).el.outerHTML;\n        })\n        this.el.innerHTML = html;\n        return this;\n      }\n    });\n    \n    //实例化GistRow,调用initialize函数\n    var gistsView = new GistView();\n    gists.fetch({reset:true});\n\n整个过程：\n1. 创建一个自定义模型类和集合类，实例化集合类\n2. 创建俩个自定义视图类，一个渲染每行的数据，一个渲染整个页面\n3. 实例化视图类GistView，在集合类上绑定监听事件\n4. fetch()触发监听事件，执行render函数，遍历所有models\n5. 在render函数中实例化视图类GistRow,，渲染每行\n\n","slug":"Backbone学习笔记（一）","published":1,"updated":"2021-12-06T06:07:06.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoka0004y4v27ea5h26r","content":"<h1 id=\"——Backbone中的MVC\"><a href=\"#——Backbone中的MVC\" class=\"headerlink\" title=\"——Backbone中的MVC\"></a>——Backbone中的MVC</h1><p><a href=\"http://backbonejs.org/\">Backbone.js</a>为复杂WEB应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中models用于绑定键值数据和自定义事件；collections附有可枚举函数的丰富API； views可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。</p>\n<p>下面通过实例来学习backbone的MVC。实例来自<a href=\"http://dmyz.org/archives/598\">http://dmyz.org/archives/598</a>。原文章虽然是入门范例，但大牛的入门对我这种菜逼来说还是看不懂，所以我在其原来的例子上进行了一些取舍并对一些代码进行了注释。</p>\n<p><a href=\"http://www.css88.com/doc/backbone/\">Backbone.js中文文档:http://www.css88.com/doc/backbone/</a></p>\n<p><img src=\"/images/201511/1.svg\"></p>\n<span id=\"more\"></span>\n\n<hr>\n<p>HTML代码，只要把backbone的代码放入其<script></script>内运行即可：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-1.11.1.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;http://underscorejs.org/underscore-min.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;http://backbonejs.org/backbone-min.js&quot;&gt;&lt;/script&gt;\n\n&lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.1.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;table id=&quot;js-id-gists&quot; class=&quot;table&quot;&gt;\n    &lt;thead&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;URL&lt;/th&gt;&lt;th&gt;created_at&lt;/th&gt;&lt;/thead&gt;\n    &lt;tbody&gt;&lt;/tbody&gt;\n  &lt;/table&gt;\n\n  &lt;script&gt;\n    //backbone....\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"首先是M\"><a href=\"#首先是M\" class=\"headerlink\" title=\"首先是M:\"></a>首先是M:</h2><pre><code>//创建一个自定义模型类\nvar Gist = Backbone.Model.extend(&#123;\n  url: &#39;https://api.github.com/gists/public&#39;,\n\n  //backbone提供了一个parse方法,它会在 fetch及 save 时执行。 \n  //传入本函数的为原始 response 对象,这个方法提供传入两个参数，并返回第一个参数。\n  parse:function(response)&#123;\n      return (response[0])\n  &#125;,\n\n  //默认属性值设置，如果属性中没有website（注意不是website值为空），会设置website值为dmyz。\n  defaults:&#123;\n    website:&#39;dmyz&#39;\n  &#125;,\n\n  //验证事件，当website值为dmyz时触发\n  validate:function(attrs)&#123;\n    if(attrs.website == &#39;dmyz&#39;)&#123;\n      return &#39;website error&#39;\n    &#125;\n  &#125;\n&#125;)\n\ngist = new Gist(); //实例化模块\n\ngist.on(&quot;validate&quot;,function(model,error)&#123;\n  alert(error)\n&#125;)\n\n//get    collection.get(id) 通过一个id，一个cid，或者传递一个model来获得集合中的模型。\n\ngist.on(&#39;change&#39;,function(model)&#123;   //绑定一个change事件\n  var tbody = document.getElementById(&#39;js-id-gists&#39;).children[1],\n      tr = document.getElementById(model.get(&#39;id&#39;));  \n\n  if(!tr)&#123;\n    tr = document.createElement(&#39;tr&#39;);  \n    tr.setAttribute(&#39;id&#39;,model.get(&#39;id&#39;)); \n  &#125;\n\n  tr.innerHTML=&quot;&lt;td&gt;&quot;+model.get(&#39;description&#39;)+&quot;&lt;/td&gt;&lt;td&gt;&quot;+model.get(&#39;url&#39;)+&quot;&lt;/td&gt;&lt;td&gt;&quot;+model.get(&#39;created_at&#39;) + &#39;&lt;/td&gt;&#39;;\n  tbody.appendChild(tr);\n&#125;)\n\n//从远程获取数据，获到数据后会触发change事件\n// gist.fetch();\n\n// 将数据存储到数据库\ngist.save()\n</code></pre>\n<p>整个过程:</p>\n<ol>\n<li>创建自定义模型类，并实例化</li>\n<li>gist.fetch()从远程拉取数据，触发了change事件</li>\n<li>绑定在gist上的change事件执行（model是其数据模型），通过model.get()来获取数据，渲染到页面</li>\n<li>在本例中，可以看出model是数据模型，起到操作数据的作用，</li>\n</ol>\n<hr>\n<h2 id=\"M-V\"><a href=\"#M-V\" class=\"headerlink\" title=\"M+V:\"></a>M+V:</h2><pre><code>var Gist = Backbone.Model.extend(&#123;\n  url: &#39;https://api.github.com/gists/public&#39;,\n  parse:function(response)&#123;\n      return (response[0])\n  &#125;\n&#125;)\n\n//实例化模块\ngist = new Gist();\n \n//创建一个自定义视图类\nvar GistRow = Backbone.View.extend(&#123;\n  //所有的视图都拥有一个 DOM 元素（el 属性），即使该元素仍未插入页面中去。 视图可以在任何时候渲染，然后一次性插入 DOM 中去，这样能尽量减少 reflows 和 repaints 从而获得高性能的 UI 渲染。\n\n  el:&#39;tbody&#39;,\n  \n  //指定视图的数据模型\n  Model:gist,\n\n  //initialize为初始化函数，创建视图时，它会立刻被调用。\n  //initialize函数在this上监听Model的change事件，发生改变时时触发render事件\n  initialize:function()&#123;\n    this.listenTo(this.Model,&#39;change&#39;,this.render);\n  &#125;,\n\n  //渲染视图\n  render:function()&#123;\n    var model =this.Model,\n        tr = document.createElement(&#39;tr&#39;);\n    tr.innerHTML=&#39;&lt;td&gt;&#39; + model.get(&#39;description&#39;) + &#39;&lt;/td&gt;&lt;td&gt;&#39; + model.get(&#39;url&#39;) + &#39;&lt;/td&gt;&lt;td&gt;&#39; + model.get(&#39;created_at&#39;) + &quot;&lt;/td&gt;&quot;;\n    this.el.innerHTML = tr.outerHTML;\n    // console.log(this.el)\n    return this;\n  &#125;\n&#125;);\n\n//实例化GistRow,立即执行initialize函数\nvar tr = new GistRow();\ngist.fetch();\n</code></pre>\n<p>整个过程：</p>\n<ol>\n<li>创建自定义模型类，并实例化</li>\n<li>创建自定义视图类，并实例化，指定模型</li>\n<li>立即执行initialize函数，监听model的change事件，</li>\n<li>fetch()事件获取远程数据，触发change事件，执行render事件</li>\n</ol>\n<hr>\n<h2 id=\"M-V-C\"><a href=\"#M-V-C\" class=\"headerlink\" title=\"M+V+C:\"></a>M+V+C:</h2><pre><code>var Gist = Backbone.Model.extend();\n\n//创建一个自定义集合类（collection）\nvar Gists = Backbone.Collection.extend(&#123;\n  //指定集合（collection）中包含的模型类\n  model:Gist,\n  url:&#39;https://api.github.com/gists/public&#39;,\n  parse:function(response)&#123;\n      return response;\n  &#125;\n&#125;)\n\ngists = new Gists(); \n\n//创建一个视图类，其作用是渲染每一行的视图\nvar GistRow = Backbone.View.extend(&#123;\n  //tagName, className, 或 id 为视图指定根元素\n  tagName:&#39;tr&#39;,\n  render:function(model)&#123;\n    this.el.id = model.cid;\n    this.el.innerHTML =  &#39;&lt;td&gt;&#39; + model.get(&#39;description&#39;) + &#39;&lt;/td&gt;&lt;td&gt;&#39;+ model.get(&#39;url&#39;) + &#39;&lt;/td&gt;&lt;td&gt;&#39; + model.get(&#39;created_at&#39;)+&quot;&lt;/td&gt;&quot;\n    return this;\n  &#125;\n&#125;)\n\nvar GistView = Backbone.View.extend(&#123;\n  el:&#39;tbody&#39;,\n  // 指定集合类\n  collection:gists,\n\n  //初始化函数，实例化时立即执行\n  initialize:function()&#123;\n    this.listenTo(this.collection,&#39;reset&#39;,this.render);\n  &#125;,\n\n  //渲染视图\n  render:function()&#123;\n    var html = &#39;&#39;;\n    //collection.models 访问集合中模型的内置的JavaScript 数组\n    //遍历所有models，设置他们的html\n    //下划线 _ 是underscore.js的一个全局对象\n    _.forEach(this.collection.models,function(model)&#123;\n      var tr = new GistRow();\n      html += tr.render(model).el.outerHTML;\n    &#125;)\n    this.el.innerHTML = html;\n    return this;\n  &#125;\n&#125;);\n\n//实例化GistRow,调用initialize函数\nvar gistsView = new GistView();\ngists.fetch(&#123;reset:true&#125;);\n</code></pre>\n<p>整个过程：</p>\n<ol>\n<li>创建一个自定义模型类和集合类，实例化集合类</li>\n<li>创建俩个自定义视图类，一个渲染每行的数据，一个渲染整个页面</li>\n<li>实例化视图类GistView，在集合类上绑定监听事件</li>\n<li>fetch()触发监听事件，执行render函数，遍历所有models</li>\n<li>在render函数中实例化视图类GistRow,，渲染每行</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"——Backbone中的MVC\"><a href=\"#——Backbone中的MVC\" class=\"headerlink\" title=\"——Backbone中的MVC\"></a>——Backbone中的MVC</h1><p><a href=\"http://backbonejs.org/\">Backbone.js</a>为复杂WEB应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中models用于绑定键值数据和自定义事件；collections附有可枚举函数的丰富API； views可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。</p>\n<p>下面通过实例来学习backbone的MVC。实例来自<a href=\"http://dmyz.org/archives/598\">http://dmyz.org/archives/598</a>。原文章虽然是入门范例，但大牛的入门对我这种菜逼来说还是看不懂，所以我在其原来的例子上进行了一些取舍并对一些代码进行了注释。</p>\n<p><a href=\"http://www.css88.com/doc/backbone/\">Backbone.js中文文档:http://www.css88.com/doc/backbone/</a></p>\n<p><img src=\"/images/201511/1.svg\"></p>","more":"<hr>\n<p>HTML代码，只要把backbone的代码放入其<script></script>内运行即可：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-1.11.1.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;http://underscorejs.org/underscore-min.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;http://backbonejs.org/backbone-min.js&quot;&gt;&lt;/script&gt;\n\n&lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.1.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;table id=&quot;js-id-gists&quot; class=&quot;table&quot;&gt;\n    &lt;thead&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;URL&lt;/th&gt;&lt;th&gt;created_at&lt;/th&gt;&lt;/thead&gt;\n    &lt;tbody&gt;&lt;/tbody&gt;\n  &lt;/table&gt;\n\n  &lt;script&gt;\n    //backbone....\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"首先是M\"><a href=\"#首先是M\" class=\"headerlink\" title=\"首先是M:\"></a>首先是M:</h2><pre><code>//创建一个自定义模型类\nvar Gist = Backbone.Model.extend(&#123;\n  url: &#39;https://api.github.com/gists/public&#39;,\n\n  //backbone提供了一个parse方法,它会在 fetch及 save 时执行。 \n  //传入本函数的为原始 response 对象,这个方法提供传入两个参数，并返回第一个参数。\n  parse:function(response)&#123;\n      return (response[0])\n  &#125;,\n\n  //默认属性值设置，如果属性中没有website（注意不是website值为空），会设置website值为dmyz。\n  defaults:&#123;\n    website:&#39;dmyz&#39;\n  &#125;,\n\n  //验证事件，当website值为dmyz时触发\n  validate:function(attrs)&#123;\n    if(attrs.website == &#39;dmyz&#39;)&#123;\n      return &#39;website error&#39;\n    &#125;\n  &#125;\n&#125;)\n\ngist = new Gist(); //实例化模块\n\ngist.on(&quot;validate&quot;,function(model,error)&#123;\n  alert(error)\n&#125;)\n\n//get    collection.get(id) 通过一个id，一个cid，或者传递一个model来获得集合中的模型。\n\ngist.on(&#39;change&#39;,function(model)&#123;   //绑定一个change事件\n  var tbody = document.getElementById(&#39;js-id-gists&#39;).children[1],\n      tr = document.getElementById(model.get(&#39;id&#39;));  \n\n  if(!tr)&#123;\n    tr = document.createElement(&#39;tr&#39;);  \n    tr.setAttribute(&#39;id&#39;,model.get(&#39;id&#39;)); \n  &#125;\n\n  tr.innerHTML=&quot;&lt;td&gt;&quot;+model.get(&#39;description&#39;)+&quot;&lt;/td&gt;&lt;td&gt;&quot;+model.get(&#39;url&#39;)+&quot;&lt;/td&gt;&lt;td&gt;&quot;+model.get(&#39;created_at&#39;) + &#39;&lt;/td&gt;&#39;;\n  tbody.appendChild(tr);\n&#125;)\n\n//从远程获取数据，获到数据后会触发change事件\n// gist.fetch();\n\n// 将数据存储到数据库\ngist.save()\n</code></pre>\n<p>整个过程:</p>\n<ol>\n<li>创建自定义模型类，并实例化</li>\n<li>gist.fetch()从远程拉取数据，触发了change事件</li>\n<li>绑定在gist上的change事件执行（model是其数据模型），通过model.get()来获取数据，渲染到页面</li>\n<li>在本例中，可以看出model是数据模型，起到操作数据的作用，</li>\n</ol>\n<hr>\n<h2 id=\"M-V\"><a href=\"#M-V\" class=\"headerlink\" title=\"M+V:\"></a>M+V:</h2><pre><code>var Gist = Backbone.Model.extend(&#123;\n  url: &#39;https://api.github.com/gists/public&#39;,\n  parse:function(response)&#123;\n      return (response[0])\n  &#125;\n&#125;)\n\n//实例化模块\ngist = new Gist();\n \n//创建一个自定义视图类\nvar GistRow = Backbone.View.extend(&#123;\n  //所有的视图都拥有一个 DOM 元素（el 属性），即使该元素仍未插入页面中去。 视图可以在任何时候渲染，然后一次性插入 DOM 中去，这样能尽量减少 reflows 和 repaints 从而获得高性能的 UI 渲染。\n\n  el:&#39;tbody&#39;,\n  \n  //指定视图的数据模型\n  Model:gist,\n\n  //initialize为初始化函数，创建视图时，它会立刻被调用。\n  //initialize函数在this上监听Model的change事件，发生改变时时触发render事件\n  initialize:function()&#123;\n    this.listenTo(this.Model,&#39;change&#39;,this.render);\n  &#125;,\n\n  //渲染视图\n  render:function()&#123;\n    var model =this.Model,\n        tr = document.createElement(&#39;tr&#39;);\n    tr.innerHTML=&#39;&lt;td&gt;&#39; + model.get(&#39;description&#39;) + &#39;&lt;/td&gt;&lt;td&gt;&#39; + model.get(&#39;url&#39;) + &#39;&lt;/td&gt;&lt;td&gt;&#39; + model.get(&#39;created_at&#39;) + &quot;&lt;/td&gt;&quot;;\n    this.el.innerHTML = tr.outerHTML;\n    // console.log(this.el)\n    return this;\n  &#125;\n&#125;);\n\n//实例化GistRow,立即执行initialize函数\nvar tr = new GistRow();\ngist.fetch();\n</code></pre>\n<p>整个过程：</p>\n<ol>\n<li>创建自定义模型类，并实例化</li>\n<li>创建自定义视图类，并实例化，指定模型</li>\n<li>立即执行initialize函数，监听model的change事件，</li>\n<li>fetch()事件获取远程数据，触发change事件，执行render事件</li>\n</ol>\n<hr>\n<h2 id=\"M-V-C\"><a href=\"#M-V-C\" class=\"headerlink\" title=\"M+V+C:\"></a>M+V+C:</h2><pre><code>var Gist = Backbone.Model.extend();\n\n//创建一个自定义集合类（collection）\nvar Gists = Backbone.Collection.extend(&#123;\n  //指定集合（collection）中包含的模型类\n  model:Gist,\n  url:&#39;https://api.github.com/gists/public&#39;,\n  parse:function(response)&#123;\n      return response;\n  &#125;\n&#125;)\n\ngists = new Gists(); \n\n//创建一个视图类，其作用是渲染每一行的视图\nvar GistRow = Backbone.View.extend(&#123;\n  //tagName, className, 或 id 为视图指定根元素\n  tagName:&#39;tr&#39;,\n  render:function(model)&#123;\n    this.el.id = model.cid;\n    this.el.innerHTML =  &#39;&lt;td&gt;&#39; + model.get(&#39;description&#39;) + &#39;&lt;/td&gt;&lt;td&gt;&#39;+ model.get(&#39;url&#39;) + &#39;&lt;/td&gt;&lt;td&gt;&#39; + model.get(&#39;created_at&#39;)+&quot;&lt;/td&gt;&quot;\n    return this;\n  &#125;\n&#125;)\n\nvar GistView = Backbone.View.extend(&#123;\n  el:&#39;tbody&#39;,\n  // 指定集合类\n  collection:gists,\n\n  //初始化函数，实例化时立即执行\n  initialize:function()&#123;\n    this.listenTo(this.collection,&#39;reset&#39;,this.render);\n  &#125;,\n\n  //渲染视图\n  render:function()&#123;\n    var html = &#39;&#39;;\n    //collection.models 访问集合中模型的内置的JavaScript 数组\n    //遍历所有models，设置他们的html\n    //下划线 _ 是underscore.js的一个全局对象\n    _.forEach(this.collection.models,function(model)&#123;\n      var tr = new GistRow();\n      html += tr.render(model).el.outerHTML;\n    &#125;)\n    this.el.innerHTML = html;\n    return this;\n  &#125;\n&#125;);\n\n//实例化GistRow,调用initialize函数\nvar gistsView = new GistView();\ngists.fetch(&#123;reset:true&#125;);\n</code></pre>\n<p>整个过程：</p>\n<ol>\n<li>创建一个自定义模型类和集合类，实例化集合类</li>\n<li>创建俩个自定义视图类，一个渲染每行的数据，一个渲染整个页面</li>\n<li>实例化视图类GistView，在集合类上绑定监听事件</li>\n<li>fetch()触发监听事件，执行render函数，遍历所有models</li>\n<li>在render函数中实例化视图类GistRow,，渲染每行</li>\n</ol>"},{"_content":"# ES6笔记（一）：ES6所改良的javascript“缺陷” #\n\n## 块级作用域 ##\n\nES5没有块级作用域，只有全局作用域和函数作用域，由于这一点，变量的作用域甚广，所以一进入函数就要马上将它创建出来。这就造成了所谓的变量提升。\n\nES5的“变量提升”这一特性往往一不小心就会造成一下错误：\n\n1. 内层变量覆盖外层变量\n\n\t\tvar tmp = new Date();\n\t\tfunction f() {\n\t\t  console.log(tmp);\n\t\t  if (false) {    //执行则undefined\n\t\t    var tmp = \"hello world\";\n\t\t  }\n\t\t}\n\n2. 变量泄露，成为全局变量\n\n\t\tvar s = 'hello';\n\t\tfor (var i = 0; i < s.length; i++) {\n\t\t  console.log(s[i]);\n\t\t}\n\t\tconsole.log(i); // 5\n\n往常我们往往是使用`闭包`来解决这一问题的（比如自执行函数）。现在，基于这一问题，ES6增加了`块级作用域`,所以不再需要自执行函数了。\n\n### let 和 const ###\n\nES6是是向后兼容的，而保持向后兼容性意味着永不改变JS代码在Web平台上的行为，所以`var`创建的变量其作用域依旧将会是全局作用域和函数作用域。这样以来，即使拥有了块级作用域，也无法解决ES5的“变量提升”问题。所以，这里ES6新增了俩个新关键词：`let`和`const`。\n\n1. let\n  \n\t“let是更完美的var”，它有着更好的作用域规则。\n\n2. const\n\tconst声明一个只读的常量。一旦声明，常量的值就不能改变，但const声明的对象可以有属性变化（对象冻结Object.freeze）\n\n\t\tconst a = [];\n\t\ta.push('Hello'); // 可执行\n\t\ta = ['Dave'];    // 报错\n\n\t也可以使用Object.freeze将对象冻结\n\n\t\tconst foo = Object.freeze({});\n\t\t// 常规模式时，下面一行不起作用；\n\t\t// 严格模式时，该行会报错\n\t\tfoo.prop = 123;//\n\n使用let和const：\n\n- 变量只在声明所在的块级作用域内有效\n\n- 变量声明后方可使用（暂时性死区）\n\n- 不能重复定义变量\n\n- 声明的全局变量，不属于全局对象的属性\n\n\t\tvar a = 1;\n\t\twindow.a // 1\n\t\tlet b = 1;\n\t\twindow.b // undefined\n\n##  this关键字 ##\n\n我们知道，ES5函数中的this指向的是运行时所在的作用域。比如\n\n\tfunction foo() {\n\t  setTimeout(function(){\n\t    console.log('id:', this.id);\n\t  }, 100);\n\t}\n\t\n\tvar id = 21;\n\t\n\tfoo.call({id:42});//id: 21\n\n在这里，我声明了一个函数foo,其内部为一个延迟函数setTimeout，每隔100ms打印一个this.id。我们通过`foo.call({id:42})`来调用它，并且为这个函数设定作用域。它真正执行要等到100毫秒后，由于this指向的是运行时所在的作用域，所以这里的this就指向了全局对象window，而不是函数foo。这里：\n\n- 使用call来改变foo的执行上下文，使函数的执行上下文不再是window，从而来辨别setTimeout中的this指向\n\n- setTimeout方法挂在window对象下，所以其this指向执行时所在的作用域——window对象。\n\t> 超时调用的代码都是在全局作用域中执行的，因此函数中this 的值在非严格模式下指向window 对象，在严格模式下是undefined   --《javascript高级程序设计》\n\n\n为了解决这一问题，我们往常的做法往往是将this赋值给其他变量：\n\n\tfunction foo() {var that = this;\n\t  setTimeout(function(){\n\t    console.log('id:', that.id);\n\t  }, 100);\n\t}\n\t\t\n\tvar id = 21;\n\tfoo.call({id:42});//id: 42\n\n而现在ES6推出了箭头函数解决了这一问题。\n\n### 箭头函数 ###\n\n标识符=> 表达式\n\n\tvar sum = (num1, num2) => { return num1 + num2; }\n\t// 等同于\n\tvar sum = function(num1, num2) {\n\t  return num1 + num2;\n\t};\n- 如果函数只有一个参数，则可以省略`圆括号`\n\n- 如果函数只有一条返回语句，则可以省略`大括号`和`return`\n\n- 如果函数直接返回一个对象，必须在对象外面加上括号。(因为一个空对象{}和一个空的块 {} 看起来完全一样。所以需要用小括号包裹对象字面量。)\n\n\n针对this关键字的问题，ES6规定箭头函数中的this绑定定义时所在的作用域，而不是指向运行时所在的作用域。这一以来，this指向固定化了，从而有利于封装回调函数。\n\n\tfunction foo() {var that = this;\n\t  setTimeout(()=>{\n\t    console.log('id:', that.id);\n\t  }, 100);\n\t}\n\t\t\n\tvar id = 21;\n\tfoo.call({id:42});//id: 42\n\n**注意：**箭头函数this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this。而箭头函数根本没有自己的this，其内部的this也就是外层代码块的this。这就导致了其：\n\n- 不能用作构造函数\n\n- 不能用call()、apply()、bind()这些方法去改变this的指向\n\n\n## 类与继承 ##\n\n传统ECMAScript没类的概念，它描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。而实现这一行为的传统方法便是通过构造函数：\n\tfunction Point(x, y) {\n\t  this.x = x;\n\t  this.y = y;\n\t}\n\t\n\tPoint.prototype.toString = function () {\n\t  return '(' + this.x + ', ' + this.y + ')';\n\t};\n\t\n\tvar p = new Point(1, 2);\n\n在这里，构造函数Point会有一个原型对象（prototype），这个原型对象包含一个指向Point的指针(constructor)，而实例p包含一个指向原型对象的内部指针(_prop_)。所以整个的继承是通过原型链来实现的。详情可见我的这篇文章：[javascript中的prototype和constructor](http://www.cnblogs.com/yzg1/p/5688722.html)\n\n### class ###\n\nES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。但是类只是基于原型的面向对象模式的语法糖。对于`class`的引入，褒贬不一，很多人认为它反而是一大缺陷，但对我来说，这是一个好的语法糖，因为往常的原型链继承的方式往往能把我绕那么一会儿。\n\n\t//定义类\n\tclass Point {\n\t  constructor(x, y) {\n\t    this.x = x;\n\t    this.y = y;\n\t  }\n\t\n\t  toString() {\n\t    return '(' + this.x + ', ' + this.y + ')';\n\t  }\n\t}\n\tvar p = new Point(1, 2);\n\n- 类里面有一个constructor方法，它是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\n\n- constructor方法中的this关键字代表实例对象，\n\n- 定义“类”的方法(如上例的toString)的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。\n\n- 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致\n\n- 类的所有方法都定义在类的prototype属性上面\n\n### class的继承——extend ###\nClass之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。\n\n\tclass ColorPoint extends Point {\n\t  constructor(x, y, color) {\n\t    super(x, y); // 调用父类的constructor(x, y)\n\t    this.color = color;\n\t  }\n\t\n\t  toString() {\n\t    return this.color + ' ' + super.toString(); // 调用父类的toString()\n\t  }\n\t}\n\n- super关键字，作为函数调用时（即super(...args)），它代表父类的构造函数；作为对象调用时（即super.prop或super.method()），它代表父类。在这里，它表示父类的构造函数，用来新建父类的this对象。\n- 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。\n\n\n## 模块化 ##\n历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来，这对开发大型的、复杂的项目形成了巨大障碍。为了适应大型模块的开发，社区制定了一些模块加载方案，比如CMD和AMD。\n\nES6的模块化写法：\n\n\timport { stat, exists, readFile } from 'fs';\n\n上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。\n\n模块功能主要由两个命令构成：\n\n- export\n\n\t用于规定模块的对外接口，对外的接口，必须与模块内部的变量建立一一对应关系。\n\n\t\t// 写法一\n\t\texport var m = 1;\n\t\t//错误\n\t\texport 1;\n\t\t\n\t\t// 写法二\n\t\tvar m = 1;\n\t\texport {m};\n\t\t//错误\n\t\texport m;\n\t\t\n\t\t// 写法三  重命名\n\t\tvar n = 1;\n\t\texport {n as m}; \n\n- import\n\t\n\t用于输入其他模块提供的功能，它接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名（也可以使用*号整体加载）\n\n\t\n\n## 字符串插值 ##\n\n在javascript的开发中，我们常常需要这样来输出模板：\n\n\tfunction sayHello(name){\n\t\treturn \"hello,my name is \"+name+\" I am \"+getAge(18);\n\t}\n\tfunction getAge(age){\n\t\treturn age;\n\t}\n\tsayHello(\"brand\") //\"hello,my name is brand I am 18\"\n\n我们需要使用+来连接字符串和变量（或者表达式）。例子比较简单，所以看上去无伤大雅，但是一旦在比较复杂的情况下，就会显得相当繁琐不方便，这一用法也让我们不厌其烦。对此，ES6引入了`模板字符串`,可以方便优雅地将 JS 的值插入到字符串中。\n\n### 模板字符串 ###\n\n对于模板字符串，它：\n\n- 使用反引号``包裹；\n- 使用${}来输出值；\n- ${}里的内容可以是任何 JavaScript 表达式，所以函数调用和算数运算等都是合法的；\n- 如果一个值不是字符串，它将被转换为字符串；\n- 保留所有的空格、换行和缩进，并输出到结果字符串中（可以书写多行字符串）\n- 内部使用反引号和大括号需要转义，转义使用反斜杠`\\`\n\n对于上面的例子，模板字符串的写法是：\n\n\tfunction sayHello(name){\n\t\treturn `hello,my name is ${name} I am ${getAge(18)}`;\n\t}\n\tfunction getAge(age){\n\t\treturn age;\n\t}\n\tsayHello(\"brand\") //\"hello,my name is brandI am 18\"\n\n## 严格模式 ##\n严格模式的目标之一是允许更快地调试错误。帮助开发者调试的最佳途径是当确定的问题发生时抛出相应的错误(throw errors when certain patterns occur)，而不是悄无声息地失败或者表现出奇怪的行为(非严格模式下经常发生)。严格模式下的代码会抛出更多的错误信息，能帮助开发者很快注意到一些必须立即解决的问题。在 ES5 中, 严格模式是可选项，但是在 ES6 中，许多特性要求必须使用严格模式，这个习惯有助于我们书写更好的 JavaScript。","source":"_posts/ES6笔记（一）：ES6所改良的javascript“缺陷”.md","raw":"# ES6笔记（一）：ES6所改良的javascript“缺陷” #\n\n## 块级作用域 ##\n\nES5没有块级作用域，只有全局作用域和函数作用域，由于这一点，变量的作用域甚广，所以一进入函数就要马上将它创建出来。这就造成了所谓的变量提升。\n\nES5的“变量提升”这一特性往往一不小心就会造成一下错误：\n\n1. 内层变量覆盖外层变量\n\n\t\tvar tmp = new Date();\n\t\tfunction f() {\n\t\t  console.log(tmp);\n\t\t  if (false) {    //执行则undefined\n\t\t    var tmp = \"hello world\";\n\t\t  }\n\t\t}\n\n2. 变量泄露，成为全局变量\n\n\t\tvar s = 'hello';\n\t\tfor (var i = 0; i < s.length; i++) {\n\t\t  console.log(s[i]);\n\t\t}\n\t\tconsole.log(i); // 5\n\n往常我们往往是使用`闭包`来解决这一问题的（比如自执行函数）。现在，基于这一问题，ES6增加了`块级作用域`,所以不再需要自执行函数了。\n\n### let 和 const ###\n\nES6是是向后兼容的，而保持向后兼容性意味着永不改变JS代码在Web平台上的行为，所以`var`创建的变量其作用域依旧将会是全局作用域和函数作用域。这样以来，即使拥有了块级作用域，也无法解决ES5的“变量提升”问题。所以，这里ES6新增了俩个新关键词：`let`和`const`。\n\n1. let\n  \n\t“let是更完美的var”，它有着更好的作用域规则。\n\n2. const\n\tconst声明一个只读的常量。一旦声明，常量的值就不能改变，但const声明的对象可以有属性变化（对象冻结Object.freeze）\n\n\t\tconst a = [];\n\t\ta.push('Hello'); // 可执行\n\t\ta = ['Dave'];    // 报错\n\n\t也可以使用Object.freeze将对象冻结\n\n\t\tconst foo = Object.freeze({});\n\t\t// 常规模式时，下面一行不起作用；\n\t\t// 严格模式时，该行会报错\n\t\tfoo.prop = 123;//\n\n使用let和const：\n\n- 变量只在声明所在的块级作用域内有效\n\n- 变量声明后方可使用（暂时性死区）\n\n- 不能重复定义变量\n\n- 声明的全局变量，不属于全局对象的属性\n\n\t\tvar a = 1;\n\t\twindow.a // 1\n\t\tlet b = 1;\n\t\twindow.b // undefined\n\n##  this关键字 ##\n\n我们知道，ES5函数中的this指向的是运行时所在的作用域。比如\n\n\tfunction foo() {\n\t  setTimeout(function(){\n\t    console.log('id:', this.id);\n\t  }, 100);\n\t}\n\t\n\tvar id = 21;\n\t\n\tfoo.call({id:42});//id: 21\n\n在这里，我声明了一个函数foo,其内部为一个延迟函数setTimeout，每隔100ms打印一个this.id。我们通过`foo.call({id:42})`来调用它，并且为这个函数设定作用域。它真正执行要等到100毫秒后，由于this指向的是运行时所在的作用域，所以这里的this就指向了全局对象window，而不是函数foo。这里：\n\n- 使用call来改变foo的执行上下文，使函数的执行上下文不再是window，从而来辨别setTimeout中的this指向\n\n- setTimeout方法挂在window对象下，所以其this指向执行时所在的作用域——window对象。\n\t> 超时调用的代码都是在全局作用域中执行的，因此函数中this 的值在非严格模式下指向window 对象，在严格模式下是undefined   --《javascript高级程序设计》\n\n\n为了解决这一问题，我们往常的做法往往是将this赋值给其他变量：\n\n\tfunction foo() {var that = this;\n\t  setTimeout(function(){\n\t    console.log('id:', that.id);\n\t  }, 100);\n\t}\n\t\t\n\tvar id = 21;\n\tfoo.call({id:42});//id: 42\n\n而现在ES6推出了箭头函数解决了这一问题。\n\n### 箭头函数 ###\n\n标识符=> 表达式\n\n\tvar sum = (num1, num2) => { return num1 + num2; }\n\t// 等同于\n\tvar sum = function(num1, num2) {\n\t  return num1 + num2;\n\t};\n- 如果函数只有一个参数，则可以省略`圆括号`\n\n- 如果函数只有一条返回语句，则可以省略`大括号`和`return`\n\n- 如果函数直接返回一个对象，必须在对象外面加上括号。(因为一个空对象{}和一个空的块 {} 看起来完全一样。所以需要用小括号包裹对象字面量。)\n\n\n针对this关键字的问题，ES6规定箭头函数中的this绑定定义时所在的作用域，而不是指向运行时所在的作用域。这一以来，this指向固定化了，从而有利于封装回调函数。\n\n\tfunction foo() {var that = this;\n\t  setTimeout(()=>{\n\t    console.log('id:', that.id);\n\t  }, 100);\n\t}\n\t\t\n\tvar id = 21;\n\tfoo.call({id:42});//id: 42\n\n**注意：**箭头函数this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this。而箭头函数根本没有自己的this，其内部的this也就是外层代码块的this。这就导致了其：\n\n- 不能用作构造函数\n\n- 不能用call()、apply()、bind()这些方法去改变this的指向\n\n\n## 类与继承 ##\n\n传统ECMAScript没类的概念，它描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。而实现这一行为的传统方法便是通过构造函数：\n\tfunction Point(x, y) {\n\t  this.x = x;\n\t  this.y = y;\n\t}\n\t\n\tPoint.prototype.toString = function () {\n\t  return '(' + this.x + ', ' + this.y + ')';\n\t};\n\t\n\tvar p = new Point(1, 2);\n\n在这里，构造函数Point会有一个原型对象（prototype），这个原型对象包含一个指向Point的指针(constructor)，而实例p包含一个指向原型对象的内部指针(_prop_)。所以整个的继承是通过原型链来实现的。详情可见我的这篇文章：[javascript中的prototype和constructor](http://www.cnblogs.com/yzg1/p/5688722.html)\n\n### class ###\n\nES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。但是类只是基于原型的面向对象模式的语法糖。对于`class`的引入，褒贬不一，很多人认为它反而是一大缺陷，但对我来说，这是一个好的语法糖，因为往常的原型链继承的方式往往能把我绕那么一会儿。\n\n\t//定义类\n\tclass Point {\n\t  constructor(x, y) {\n\t    this.x = x;\n\t    this.y = y;\n\t  }\n\t\n\t  toString() {\n\t    return '(' + this.x + ', ' + this.y + ')';\n\t  }\n\t}\n\tvar p = new Point(1, 2);\n\n- 类里面有一个constructor方法，它是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\n\n- constructor方法中的this关键字代表实例对象，\n\n- 定义“类”的方法(如上例的toString)的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。\n\n- 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致\n\n- 类的所有方法都定义在类的prototype属性上面\n\n### class的继承——extend ###\nClass之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。\n\n\tclass ColorPoint extends Point {\n\t  constructor(x, y, color) {\n\t    super(x, y); // 调用父类的constructor(x, y)\n\t    this.color = color;\n\t  }\n\t\n\t  toString() {\n\t    return this.color + ' ' + super.toString(); // 调用父类的toString()\n\t  }\n\t}\n\n- super关键字，作为函数调用时（即super(...args)），它代表父类的构造函数；作为对象调用时（即super.prop或super.method()），它代表父类。在这里，它表示父类的构造函数，用来新建父类的this对象。\n- 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。\n\n\n## 模块化 ##\n历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来，这对开发大型的、复杂的项目形成了巨大障碍。为了适应大型模块的开发，社区制定了一些模块加载方案，比如CMD和AMD。\n\nES6的模块化写法：\n\n\timport { stat, exists, readFile } from 'fs';\n\n上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。\n\n模块功能主要由两个命令构成：\n\n- export\n\n\t用于规定模块的对外接口，对外的接口，必须与模块内部的变量建立一一对应关系。\n\n\t\t// 写法一\n\t\texport var m = 1;\n\t\t//错误\n\t\texport 1;\n\t\t\n\t\t// 写法二\n\t\tvar m = 1;\n\t\texport {m};\n\t\t//错误\n\t\texport m;\n\t\t\n\t\t// 写法三  重命名\n\t\tvar n = 1;\n\t\texport {n as m}; \n\n- import\n\t\n\t用于输入其他模块提供的功能，它接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名（也可以使用*号整体加载）\n\n\t\n\n## 字符串插值 ##\n\n在javascript的开发中，我们常常需要这样来输出模板：\n\n\tfunction sayHello(name){\n\t\treturn \"hello,my name is \"+name+\" I am \"+getAge(18);\n\t}\n\tfunction getAge(age){\n\t\treturn age;\n\t}\n\tsayHello(\"brand\") //\"hello,my name is brand I am 18\"\n\n我们需要使用+来连接字符串和变量（或者表达式）。例子比较简单，所以看上去无伤大雅，但是一旦在比较复杂的情况下，就会显得相当繁琐不方便，这一用法也让我们不厌其烦。对此，ES6引入了`模板字符串`,可以方便优雅地将 JS 的值插入到字符串中。\n\n### 模板字符串 ###\n\n对于模板字符串，它：\n\n- 使用反引号``包裹；\n- 使用${}来输出值；\n- ${}里的内容可以是任何 JavaScript 表达式，所以函数调用和算数运算等都是合法的；\n- 如果一个值不是字符串，它将被转换为字符串；\n- 保留所有的空格、换行和缩进，并输出到结果字符串中（可以书写多行字符串）\n- 内部使用反引号和大括号需要转义，转义使用反斜杠`\\`\n\n对于上面的例子，模板字符串的写法是：\n\n\tfunction sayHello(name){\n\t\treturn `hello,my name is ${name} I am ${getAge(18)}`;\n\t}\n\tfunction getAge(age){\n\t\treturn age;\n\t}\n\tsayHello(\"brand\") //\"hello,my name is brandI am 18\"\n\n## 严格模式 ##\n严格模式的目标之一是允许更快地调试错误。帮助开发者调试的最佳途径是当确定的问题发生时抛出相应的错误(throw errors when certain patterns occur)，而不是悄无声息地失败或者表现出奇怪的行为(非严格模式下经常发生)。严格模式下的代码会抛出更多的错误信息，能帮助开发者很快注意到一些必须立即解决的问题。在 ES5 中, 严格模式是可选项，但是在 ES6 中，许多特性要求必须使用严格模式，这个习惯有助于我们书写更好的 JavaScript。","slug":"ES6笔记（一）：ES6所改良的javascript“缺陷”","published":1,"date":"2021-12-06T06:07:06.103Z","updated":"2021-12-06T06:07:06.103Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokb0005y4v2akswhj98","content":"<h1 id=\"ES6笔记（一）：ES6所改良的javascript“缺陷”\"><a href=\"#ES6笔记（一）：ES6所改良的javascript“缺陷”\" class=\"headerlink\" title=\"ES6笔记（一）：ES6所改良的javascript“缺陷”\"></a>ES6笔记（一）：ES6所改良的javascript“缺陷”</h1><h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>ES5没有块级作用域，只有全局作用域和函数作用域，由于这一点，变量的作用域甚广，所以一进入函数就要马上将它创建出来。这就造成了所谓的变量提升。</p>\n<p>ES5的“变量提升”这一特性往往一不小心就会造成一下错误：</p>\n<ol>\n<li><p>内层变量覆盖外层变量</p>\n<pre><code> var tmp = new Date();\n function f() &#123;\n   console.log(tmp);\n   if (false) &#123;    //执行则undefined\n     var tmp = &quot;hello world&quot;;\n   &#125;\n &#125;\n</code></pre>\n</li>\n<li><p>变量泄露，成为全局变量</p>\n<pre><code> var s = &#39;hello&#39;;\n for (var i = 0; i &lt; s.length; i++) &#123;\n   console.log(s[i]);\n &#125;\n console.log(i); // 5\n</code></pre>\n</li>\n</ol>\n<p>往常我们往往是使用<code>闭包</code>来解决这一问题的（比如自执行函数）。现在，基于这一问题，ES6增加了<code>块级作用域</code>,所以不再需要自执行函数了。</p>\n<h3 id=\"let-和-const\"><a href=\"#let-和-const\" class=\"headerlink\" title=\"let 和 const\"></a>let 和 const</h3><p>ES6是是向后兼容的，而保持向后兼容性意味着永不改变JS代码在Web平台上的行为，所以<code>var</code>创建的变量其作用域依旧将会是全局作用域和函数作用域。这样以来，即使拥有了块级作用域，也无法解决ES5的“变量提升”问题。所以，这里ES6新增了俩个新关键词：<code>let</code>和<code>const</code>。</p>\n<ol>\n<li><p>let</p>\n<p> “let是更完美的var”，它有着更好的作用域规则。</p>\n</li>\n<li><p>const<br> const声明一个只读的常量。一旦声明，常量的值就不能改变，但const声明的对象可以有属性变化（对象冻结Object.freeze）</p>\n<pre><code> const a = [];\n a.push(&#39;Hello&#39;); // 可执行\n a = [&#39;Dave&#39;];    // 报错\n</code></pre>\n<p> 也可以使用Object.freeze将对象冻结</p>\n<pre><code> const foo = Object.freeze(&#123;&#125;);\n // 常规模式时，下面一行不起作用；\n // 严格模式时，该行会报错\n foo.prop = 123;//\n</code></pre>\n</li>\n</ol>\n<p>使用let和const：</p>\n<ul>\n<li><p>变量只在声明所在的块级作用域内有效</p>\n</li>\n<li><p>变量声明后方可使用（暂时性死区）</p>\n</li>\n<li><p>不能重复定义变量</p>\n</li>\n<li><p>声明的全局变量，不属于全局对象的属性</p>\n<pre><code>  var a = 1;\n  window.a // 1\n  let b = 1;\n  window.b // undefined\n</code></pre>\n</li>\n</ul>\n<h2 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a>this关键字</h2><p>我们知道，ES5函数中的this指向的是运行时所在的作用域。比如</p>\n<pre><code>function foo() &#123;\n  setTimeout(function()&#123;\n    console.log(&#39;id:&#39;, this.id);\n  &#125;, 100);\n&#125;\n\nvar id = 21;\n\nfoo.call(&#123;id:42&#125;);//id: 21\n</code></pre>\n<p>在这里，我声明了一个函数foo,其内部为一个延迟函数setTimeout，每隔100ms打印一个this.id。我们通过<code>foo.call(&#123;id:42&#125;)</code>来调用它，并且为这个函数设定作用域。它真正执行要等到100毫秒后，由于this指向的是运行时所在的作用域，所以这里的this就指向了全局对象window，而不是函数foo。这里：</p>\n<ul>\n<li><p>使用call来改变foo的执行上下文，使函数的执行上下文不再是window，从而来辨别setTimeout中的this指向</p>\n</li>\n<li><p>setTimeout方法挂在window对象下，所以其this指向执行时所在的作用域——window对象。</p>\n<blockquote>\n<p>超时调用的代码都是在全局作用域中执行的，因此函数中this 的值在非严格模式下指向window 对象，在严格模式下是undefined   –《javascript高级程序设计》</p>\n</blockquote>\n</li>\n</ul>\n<p>为了解决这一问题，我们往常的做法往往是将this赋值给其他变量：</p>\n<pre><code>function foo() &#123;var that = this;\n  setTimeout(function()&#123;\n    console.log(&#39;id:&#39;, that.id);\n  &#125;, 100);\n&#125;\n    \nvar id = 21;\nfoo.call(&#123;id:42&#125;);//id: 42\n</code></pre>\n<p>而现在ES6推出了箭头函数解决了这一问题。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>标识符=&gt; 表达式</p>\n<pre><code>var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;\n// 等同于\nvar sum = function(num1, num2) &#123;\n  return num1 + num2;\n&#125;;\n</code></pre>\n<ul>\n<li><p>如果函数只有一个参数，则可以省略<code>圆括号</code></p>\n</li>\n<li><p>如果函数只有一条返回语句，则可以省略<code>大括号</code>和<code>return</code></p>\n</li>\n<li><p>如果函数直接返回一个对象，必须在对象外面加上括号。(因为一个空对象{}和一个空的块 {} 看起来完全一样。所以需要用小括号包裹对象字面量。)</p>\n</li>\n</ul>\n<p>针对this关键字的问题，ES6规定箭头函数中的this绑定定义时所在的作用域，而不是指向运行时所在的作用域。这一以来，this指向固定化了，从而有利于封装回调函数。</p>\n<pre><code>function foo() &#123;var that = this;\n  setTimeout(()=&gt;&#123;\n    console.log(&#39;id:&#39;, that.id);\n  &#125;, 100);\n&#125;\n    \nvar id = 21;\nfoo.call(&#123;id:42&#125;);//id: 42\n</code></pre>\n<p><strong>注意：</strong>箭头函数this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this。而箭头函数根本没有自己的this，其内部的this也就是外层代码块的this。这就导致了其：</p>\n<ul>\n<li><p>不能用作构造函数</p>\n</li>\n<li><p>不能用call()、apply()、bind()这些方法去改变this的指向</p>\n</li>\n</ul>\n<h2 id=\"类与继承\"><a href=\"#类与继承\" class=\"headerlink\" title=\"类与继承\"></a>类与继承</h2><p>传统ECMAScript没类的概念，它描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。而实现这一行为的传统方法便是通过构造函数：<br>    function Point(x, y) {<br>      this.x = x;<br>      this.y = y;<br>    }</p>\n<pre><code>Point.prototype.toString = function () &#123;\n  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n&#125;;\n\nvar p = new Point(1, 2);\n</code></pre>\n<p>在这里，构造函数Point会有一个原型对象（prototype），这个原型对象包含一个指向Point的指针(constructor)，而实例p包含一个指向原型对象的内部指针(<em>prop</em>)。所以整个的继承是通过原型链来实现的。详情可见我的这篇文章：<a href=\"http://www.cnblogs.com/yzg1/p/5688722.html\">javascript中的prototype和constructor</a></p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。但是类只是基于原型的面向对象模式的语法糖。对于<code>class</code>的引入，褒贬不一，很多人认为它反而是一大缺陷，但对我来说，这是一个好的语法糖，因为往常的原型链继承的方式往往能把我绕那么一会儿。</p>\n<pre><code>//定义类\nclass Point &#123;\n  constructor(x, y) &#123;\n    this.x = x;\n    this.y = y;\n  &#125;\n\n  toString() &#123;\n    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n  &#125;\n&#125;\nvar p = new Point(1, 2);\n</code></pre>\n<ul>\n<li><p>类里面有一个constructor方法，它是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>\n</li>\n<li><p>constructor方法中的this关键字代表实例对象，</p>\n</li>\n<li><p>定义“类”的方法(如上例的toString)的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>\n</li>\n<li><p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致</p>\n</li>\n<li><p>类的所有方法都定义在类的prototype属性上面</p>\n</li>\n</ul>\n<h3 id=\"class的继承——extend\"><a href=\"#class的继承——extend\" class=\"headerlink\" title=\"class的继承——extend\"></a>class的继承——extend</h3><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>\n<pre><code>class ColorPoint extends Point &#123;\n  constructor(x, y, color) &#123;\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  &#125;\n\n  toString() &#123;\n    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()\n  &#125;\n&#125;\n</code></pre>\n<ul>\n<li>super关键字，作为函数调用时（即super(…args)），它代表父类的构造函数；作为对象调用时（即super.prop或super.method()），它代表父类。在这里，它表示父类的构造函数，用来新建父类的this对象。</li>\n<li>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</li>\n</ul>\n<h2 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h2><p>历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来，这对开发大型的、复杂的项目形成了巨大障碍。为了适应大型模块的开发，社区制定了一些模块加载方案，比如CMD和AMD。</p>\n<p>ES6的模块化写法：</p>\n<pre><code>import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;\n</code></pre>\n<p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p>\n<p>模块功能主要由两个命令构成：</p>\n<ul>\n<li><p>export</p>\n<p>  用于规定模块的对外接口，对外的接口，必须与模块内部的变量建立一一对应关系。</p>\n<pre><code>  // 写法一\n  export var m = 1;\n  //错误\n  export 1;\n  \n  // 写法二\n  var m = 1;\n  export &#123;m&#125;;\n  //错误\n  export m;\n  \n  // 写法三  重命名\n  var n = 1;\n  export &#123;n as m&#125;; \n</code></pre>\n</li>\n<li><p>import</p>\n<p>  用于输入其他模块提供的功能，它接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名（也可以使用*号整体加载）</p>\n</li>\n</ul>\n<h2 id=\"字符串插值\"><a href=\"#字符串插值\" class=\"headerlink\" title=\"字符串插值\"></a>字符串插值</h2><p>在javascript的开发中，我们常常需要这样来输出模板：</p>\n<pre><code>function sayHello(name)&#123;\n    return &quot;hello,my name is &quot;+name+&quot; I am &quot;+getAge(18);\n&#125;\nfunction getAge(age)&#123;\n    return age;\n&#125;\nsayHello(&quot;brand&quot;) //&quot;hello,my name is brand I am 18&quot;\n</code></pre>\n<p>我们需要使用+来连接字符串和变量（或者表达式）。例子比较简单，所以看上去无伤大雅，但是一旦在比较复杂的情况下，就会显得相当繁琐不方便，这一用法也让我们不厌其烦。对此，ES6引入了<code>模板字符串</code>,可以方便优雅地将 JS 的值插入到字符串中。</p>\n<h3 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h3><p>对于模板字符串，它：</p>\n<ul>\n<li>使用反引号``包裹；</li>\n<li>使用${}来输出值；</li>\n<li>${}里的内容可以是任何 JavaScript 表达式，所以函数调用和算数运算等都是合法的；</li>\n<li>如果一个值不是字符串，它将被转换为字符串；</li>\n<li>保留所有的空格、换行和缩进，并输出到结果字符串中（可以书写多行字符串）</li>\n<li>内部使用反引号和大括号需要转义，转义使用反斜杠<code>\\</code></li>\n</ul>\n<p>对于上面的例子，模板字符串的写法是：</p>\n<pre><code>function sayHello(name)&#123;\n    return `hello,my name is $&#123;name&#125; I am $&#123;getAge(18)&#125;`;\n&#125;\nfunction getAge(age)&#123;\n    return age;\n&#125;\nsayHello(&quot;brand&quot;) //&quot;hello,my name is brandI am 18&quot;\n</code></pre>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>严格模式的目标之一是允许更快地调试错误。帮助开发者调试的最佳途径是当确定的问题发生时抛出相应的错误(throw errors when certain patterns occur)，而不是悄无声息地失败或者表现出奇怪的行为(非严格模式下经常发生)。严格模式下的代码会抛出更多的错误信息，能帮助开发者很快注意到一些必须立即解决的问题。在 ES5 中, 严格模式是可选项，但是在 ES6 中，许多特性要求必须使用严格模式，这个习惯有助于我们书写更好的 JavaScript。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ES6笔记（一）：ES6所改良的javascript“缺陷”\"><a href=\"#ES6笔记（一）：ES6所改良的javascript“缺陷”\" class=\"headerlink\" title=\"ES6笔记（一）：ES6所改良的javascript“缺陷”\"></a>ES6笔记（一）：ES6所改良的javascript“缺陷”</h1><h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>ES5没有块级作用域，只有全局作用域和函数作用域，由于这一点，变量的作用域甚广，所以一进入函数就要马上将它创建出来。这就造成了所谓的变量提升。</p>\n<p>ES5的“变量提升”这一特性往往一不小心就会造成一下错误：</p>\n<ol>\n<li><p>内层变量覆盖外层变量</p>\n<pre><code> var tmp = new Date();\n function f() &#123;\n   console.log(tmp);\n   if (false) &#123;    //执行则undefined\n     var tmp = &quot;hello world&quot;;\n   &#125;\n &#125;\n</code></pre>\n</li>\n<li><p>变量泄露，成为全局变量</p>\n<pre><code> var s = &#39;hello&#39;;\n for (var i = 0; i &lt; s.length; i++) &#123;\n   console.log(s[i]);\n &#125;\n console.log(i); // 5\n</code></pre>\n</li>\n</ol>\n<p>往常我们往往是使用<code>闭包</code>来解决这一问题的（比如自执行函数）。现在，基于这一问题，ES6增加了<code>块级作用域</code>,所以不再需要自执行函数了。</p>\n<h3 id=\"let-和-const\"><a href=\"#let-和-const\" class=\"headerlink\" title=\"let 和 const\"></a>let 和 const</h3><p>ES6是是向后兼容的，而保持向后兼容性意味着永不改变JS代码在Web平台上的行为，所以<code>var</code>创建的变量其作用域依旧将会是全局作用域和函数作用域。这样以来，即使拥有了块级作用域，也无法解决ES5的“变量提升”问题。所以，这里ES6新增了俩个新关键词：<code>let</code>和<code>const</code>。</p>\n<ol>\n<li><p>let</p>\n<p> “let是更完美的var”，它有着更好的作用域规则。</p>\n</li>\n<li><p>const<br> const声明一个只读的常量。一旦声明，常量的值就不能改变，但const声明的对象可以有属性变化（对象冻结Object.freeze）</p>\n<pre><code> const a = [];\n a.push(&#39;Hello&#39;); // 可执行\n a = [&#39;Dave&#39;];    // 报错\n</code></pre>\n<p> 也可以使用Object.freeze将对象冻结</p>\n<pre><code> const foo = Object.freeze(&#123;&#125;);\n // 常规模式时，下面一行不起作用；\n // 严格模式时，该行会报错\n foo.prop = 123;//\n</code></pre>\n</li>\n</ol>\n<p>使用let和const：</p>\n<ul>\n<li><p>变量只在声明所在的块级作用域内有效</p>\n</li>\n<li><p>变量声明后方可使用（暂时性死区）</p>\n</li>\n<li><p>不能重复定义变量</p>\n</li>\n<li><p>声明的全局变量，不属于全局对象的属性</p>\n<pre><code>  var a = 1;\n  window.a // 1\n  let b = 1;\n  window.b // undefined\n</code></pre>\n</li>\n</ul>\n<h2 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a>this关键字</h2><p>我们知道，ES5函数中的this指向的是运行时所在的作用域。比如</p>\n<pre><code>function foo() &#123;\n  setTimeout(function()&#123;\n    console.log(&#39;id:&#39;, this.id);\n  &#125;, 100);\n&#125;\n\nvar id = 21;\n\nfoo.call(&#123;id:42&#125;);//id: 21\n</code></pre>\n<p>在这里，我声明了一个函数foo,其内部为一个延迟函数setTimeout，每隔100ms打印一个this.id。我们通过<code>foo.call(&#123;id:42&#125;)</code>来调用它，并且为这个函数设定作用域。它真正执行要等到100毫秒后，由于this指向的是运行时所在的作用域，所以这里的this就指向了全局对象window，而不是函数foo。这里：</p>\n<ul>\n<li><p>使用call来改变foo的执行上下文，使函数的执行上下文不再是window，从而来辨别setTimeout中的this指向</p>\n</li>\n<li><p>setTimeout方法挂在window对象下，所以其this指向执行时所在的作用域——window对象。</p>\n<blockquote>\n<p>超时调用的代码都是在全局作用域中执行的，因此函数中this 的值在非严格模式下指向window 对象，在严格模式下是undefined   –《javascript高级程序设计》</p>\n</blockquote>\n</li>\n</ul>\n<p>为了解决这一问题，我们往常的做法往往是将this赋值给其他变量：</p>\n<pre><code>function foo() &#123;var that = this;\n  setTimeout(function()&#123;\n    console.log(&#39;id:&#39;, that.id);\n  &#125;, 100);\n&#125;\n    \nvar id = 21;\nfoo.call(&#123;id:42&#125;);//id: 42\n</code></pre>\n<p>而现在ES6推出了箭头函数解决了这一问题。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>标识符=&gt; 表达式</p>\n<pre><code>var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;\n// 等同于\nvar sum = function(num1, num2) &#123;\n  return num1 + num2;\n&#125;;\n</code></pre>\n<ul>\n<li><p>如果函数只有一个参数，则可以省略<code>圆括号</code></p>\n</li>\n<li><p>如果函数只有一条返回语句，则可以省略<code>大括号</code>和<code>return</code></p>\n</li>\n<li><p>如果函数直接返回一个对象，必须在对象外面加上括号。(因为一个空对象{}和一个空的块 {} 看起来完全一样。所以需要用小括号包裹对象字面量。)</p>\n</li>\n</ul>\n<p>针对this关键字的问题，ES6规定箭头函数中的this绑定定义时所在的作用域，而不是指向运行时所在的作用域。这一以来，this指向固定化了，从而有利于封装回调函数。</p>\n<pre><code>function foo() &#123;var that = this;\n  setTimeout(()=&gt;&#123;\n    console.log(&#39;id:&#39;, that.id);\n  &#125;, 100);\n&#125;\n    \nvar id = 21;\nfoo.call(&#123;id:42&#125;);//id: 42\n</code></pre>\n<p><strong>注意：</strong>箭头函数this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this。而箭头函数根本没有自己的this，其内部的this也就是外层代码块的this。这就导致了其：</p>\n<ul>\n<li><p>不能用作构造函数</p>\n</li>\n<li><p>不能用call()、apply()、bind()这些方法去改变this的指向</p>\n</li>\n</ul>\n<h2 id=\"类与继承\"><a href=\"#类与继承\" class=\"headerlink\" title=\"类与继承\"></a>类与继承</h2><p>传统ECMAScript没类的概念，它描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。而实现这一行为的传统方法便是通过构造函数：<br>    function Point(x, y) {<br>      this.x = x;<br>      this.y = y;<br>    }</p>\n<pre><code>Point.prototype.toString = function () &#123;\n  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n&#125;;\n\nvar p = new Point(1, 2);\n</code></pre>\n<p>在这里，构造函数Point会有一个原型对象（prototype），这个原型对象包含一个指向Point的指针(constructor)，而实例p包含一个指向原型对象的内部指针(<em>prop</em>)。所以整个的继承是通过原型链来实现的。详情可见我的这篇文章：<a href=\"http://www.cnblogs.com/yzg1/p/5688722.html\">javascript中的prototype和constructor</a></p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。但是类只是基于原型的面向对象模式的语法糖。对于<code>class</code>的引入，褒贬不一，很多人认为它反而是一大缺陷，但对我来说，这是一个好的语法糖，因为往常的原型链继承的方式往往能把我绕那么一会儿。</p>\n<pre><code>//定义类\nclass Point &#123;\n  constructor(x, y) &#123;\n    this.x = x;\n    this.y = y;\n  &#125;\n\n  toString() &#123;\n    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n  &#125;\n&#125;\nvar p = new Point(1, 2);\n</code></pre>\n<ul>\n<li><p>类里面有一个constructor方法，它是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>\n</li>\n<li><p>constructor方法中的this关键字代表实例对象，</p>\n</li>\n<li><p>定义“类”的方法(如上例的toString)的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>\n</li>\n<li><p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致</p>\n</li>\n<li><p>类的所有方法都定义在类的prototype属性上面</p>\n</li>\n</ul>\n<h3 id=\"class的继承——extend\"><a href=\"#class的继承——extend\" class=\"headerlink\" title=\"class的继承——extend\"></a>class的继承——extend</h3><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>\n<pre><code>class ColorPoint extends Point &#123;\n  constructor(x, y, color) &#123;\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  &#125;\n\n  toString() &#123;\n    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()\n  &#125;\n&#125;\n</code></pre>\n<ul>\n<li>super关键字，作为函数调用时（即super(…args)），它代表父类的构造函数；作为对象调用时（即super.prop或super.method()），它代表父类。在这里，它表示父类的构造函数，用来新建父类的this对象。</li>\n<li>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</li>\n</ul>\n<h2 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h2><p>历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来，这对开发大型的、复杂的项目形成了巨大障碍。为了适应大型模块的开发，社区制定了一些模块加载方案，比如CMD和AMD。</p>\n<p>ES6的模块化写法：</p>\n<pre><code>import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;\n</code></pre>\n<p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p>\n<p>模块功能主要由两个命令构成：</p>\n<ul>\n<li><p>export</p>\n<p>  用于规定模块的对外接口，对外的接口，必须与模块内部的变量建立一一对应关系。</p>\n<pre><code>  // 写法一\n  export var m = 1;\n  //错误\n  export 1;\n  \n  // 写法二\n  var m = 1;\n  export &#123;m&#125;;\n  //错误\n  export m;\n  \n  // 写法三  重命名\n  var n = 1;\n  export &#123;n as m&#125;; \n</code></pre>\n</li>\n<li><p>import</p>\n<p>  用于输入其他模块提供的功能，它接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名（也可以使用*号整体加载）</p>\n</li>\n</ul>\n<h2 id=\"字符串插值\"><a href=\"#字符串插值\" class=\"headerlink\" title=\"字符串插值\"></a>字符串插值</h2><p>在javascript的开发中，我们常常需要这样来输出模板：</p>\n<pre><code>function sayHello(name)&#123;\n    return &quot;hello,my name is &quot;+name+&quot; I am &quot;+getAge(18);\n&#125;\nfunction getAge(age)&#123;\n    return age;\n&#125;\nsayHello(&quot;brand&quot;) //&quot;hello,my name is brand I am 18&quot;\n</code></pre>\n<p>我们需要使用+来连接字符串和变量（或者表达式）。例子比较简单，所以看上去无伤大雅，但是一旦在比较复杂的情况下，就会显得相当繁琐不方便，这一用法也让我们不厌其烦。对此，ES6引入了<code>模板字符串</code>,可以方便优雅地将 JS 的值插入到字符串中。</p>\n<h3 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h3><p>对于模板字符串，它：</p>\n<ul>\n<li>使用反引号``包裹；</li>\n<li>使用${}来输出值；</li>\n<li>${}里的内容可以是任何 JavaScript 表达式，所以函数调用和算数运算等都是合法的；</li>\n<li>如果一个值不是字符串，它将被转换为字符串；</li>\n<li>保留所有的空格、换行和缩进，并输出到结果字符串中（可以书写多行字符串）</li>\n<li>内部使用反引号和大括号需要转义，转义使用反斜杠<code>\\</code></li>\n</ul>\n<p>对于上面的例子，模板字符串的写法是：</p>\n<pre><code>function sayHello(name)&#123;\n    return `hello,my name is $&#123;name&#125; I am $&#123;getAge(18)&#125;`;\n&#125;\nfunction getAge(age)&#123;\n    return age;\n&#125;\nsayHello(&quot;brand&quot;) //&quot;hello,my name is brandI am 18&quot;\n</code></pre>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>严格模式的目标之一是允许更快地调试错误。帮助开发者调试的最佳途径是当确定的问题发生时抛出相应的错误(throw errors when certain patterns occur)，而不是悄无声息地失败或者表现出奇怪的行为(非严格模式下经常发生)。严格模式下的代码会抛出更多的错误信息，能帮助开发者很快注意到一些必须立即解决的问题。在 ES5 中, 严格模式是可选项，但是在 ES6 中，许多特性要求必须使用严格模式，这个习惯有助于我们书写更好的 JavaScript。</p>\n"},{"_content":"# ES6笔记（三）：ES6新增特性 #","source":"_posts/ES6笔记（二）：ES6新增特性.md","raw":"# ES6笔记（三）：ES6新增特性 #","slug":"ES6笔记（二）：ES6新增特性","published":1,"date":"2021-12-06T06:07:06.103Z","updated":"2021-12-06T06:07:06.103Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokc0006y4v216ar29yk","content":"<h1 id=\"ES6笔记（三）：ES6新增特性\"><a href=\"#ES6笔记（三）：ES6新增特性\" class=\"headerlink\" title=\"ES6笔记（三）：ES6新增特性\"></a>ES6笔记（三）：ES6新增特性</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ES6笔记（三）：ES6新增特性\"><a href=\"#ES6笔记（三）：ES6新增特性\" class=\"headerlink\" title=\"ES6笔记（三）：ES6新增特性\"></a>ES6笔记（三）：ES6新增特性</h1>"},{"_content":"# ESLint--定制你的代码规则\n\n## 简介\nESLint是一个开源的项目，由Nicholas C. Zakas（《JavaScript高级程序设计》作者）于2013年六月创建。它的目标是为JavaScript提供一个完全可配置的实用lint工具。\n\nJavaScript是一种动态的、松散型的语言，是特别容易受到开发人员的错误使用。而ESLint可以在不执行JavaScript代码的情况下发现代码的问题。\n\nESLint由Node.js编写，通过NPM提供快速的运行环境，并且安装方便。\n\n## 安装\n1. 全局安装\n\n\t```\n\t$ npm install -g eslint\n\t```\n2. 本地安装\n\n\t```\n\t$ npm install eslint --save-dev\n\t```\n\n## 使用\n\n### 生成配置文件\n在你想要使用ESLint的工程根目录下执行：\n\n```\neslint --init\n```\n这个命令的目的是创建一个eslint配置文件。如果你是全局安装的eslint，那么可以在任意文件中使用该命令，否则，你必须在使用该命令之前在该项目中安装eslint。\n\n执行该命令后，一般会出现三个选项可供选择，他们分别是：\n\n```\n❯ Answer questions about your style\n  Use a popular style guide\n  Inspect your JavaScript file(s)\n```\n+ 通过询问你来定制你的配置文件；\n+ 使用通用的配置文件；\n+ 通过审查你写的JavaScript文件来生成一个配置文件；\n\n在这之后， 在你的目录中会有一个.eslintrc文件，这个.eslintrc的存在形式也是可选择的，它可以是JavaScript、YAML、JSON、package.json等等。\n\n### 配置文件\n生成配置文件之后，打开.eslintrc文件（一般是隐藏的），可以看到以下格式的内容：\n\n```\n{\n    \"env\": {\n        \"browser\": true\n    },\n    \"extends\": \"eslint:recommended\",\n    \"rules\": {\n        \"indent\": [\n            \"error\",\n            \"tab\"\n        ],\n        \"linebreak-style\": [\n            \"error\",\n            \"unix\"\n        ],\n        \"quotes\": [\n            \"error\",\n            \"double\"\n        ],\n        \"semi\": [\n            \"error\",\n            \"always\"\n        ]\n    },\n    Globals: {\n    }\n}\n```\n\n我这个是json格式的，这里解释一下这个文件里各个参数的意思：\n\n1. env ：指定你的js代码在哪个运行环境中检测（每个运行环境都有一组预定义的全局变量）；\n\n2. extends ：扩展配置规则（），我这里扩展的是eslint的推荐规则；\n\n3. rules ：指定检测规则；\n\n\t这是最重要的部分，也是你的自定义js代码监测规则的地方，他的格式是：规则名: 规则。比如：\n\t```\n\t\"indent\": [\"error\",\"tab\"]\n\t```\n\t这里`indent`就是规则名，它定义了缩进应该使用tab，规则内的第一个值`error`指的是错误等级，它有三个等级，分别是：\n\n\t| error level | 数值表示   | 涵义       |\n\t| ----------- |:---------:| ---------:|\n\t| error       | 2         | 作为错误    |\n\t| warn        | 1         | 作为提醒    |\n\t| off         | 0         | 关闭该规则  |\n更多的规则可以参考[官网](http://eslint.org/docs/rules/)的rules。\n\n4. Globals ：指定脚本执行过程中访问的附加全局变量（比如jquery）\n\n**PS:**\n\n您可以配置全局的.eslint文件，而不至于要每个工程中都创建一个独有的.eslint文件，烹制方法是将您的.eslintr文件放在当前用户的根目录下，类Unix系统的当前用户目录是`~`，而Windows系统的话则是类似于`C:\\Windows\\Users\\Username`这样的地方\n\n### 检测文件\n在你的工程目录下执行：\n\n```\neslint yourfile.js\n```\n\n它会在命令后输出你的所有报错信息。这样就ok了。个人感觉它的最大优势就是完全可配置，而且配置文件一次构建，可以通过粘贴复制的方式无数次使用。甚至整个团队可以通过使用一份配置文件来达到规范代码的作用，还是很强大的。\n\n## 使用现有的通用规则\neslint官方提供了3种预安装包：\n\n1. [eslint-config-google](https://www.npmjs.com/package/eslint-config-google)\n\n\tGoogle标准\n\t\n\t执行安装：\n\t\n\t```\n\tnpm install eslint eslint-config-google -g\n\t```\n\t\n2. [eslint-config-airbnb](https://www.npmjs.com/package/eslint-config-airbnb)\n\n\tAirbnb标准,它依赖eslint, eslint-plugin-import, eslint-plugin-react, and eslint-plugin-jsx-a11y等插件，并且对各个插件的版本有所要求。\n\t\n\t你可以执行以下命令查看所依赖的各个版本：\n\n\t```\n\tnpm info \"eslint-config-airbnb@latest\" peerDependencies\n\t```\n\t你会看到以下输出信息，包含每个了每个plugins的版本要求\n\t\n\t```\n\t{ eslint: '^3.15.0',\n\t  'eslint-plugin-jsx-a11y': '^3.0.2 || ^4.0.0',\n\t  'eslint-plugin-import': '^2.2.0',\n\t  'eslint-plugin-react': '^6.9.0' }\n\t```\n\t知道了每个plugins的版本要求后，代入以下命令执行安装即可使用：\n\t\n\t```\n\tnpm install eslint-config-airbnb eslint@^#.#.# eslint-plugin-jsx-a11y@^#.#.# eslint-plugin-import@^#.#.# eslint-plugin-react@^#.#.# -g\n\t```\n\t\n3. [eslint-config-standard](https://www.npmjs.com/package/eslint-config-standard)\n\n\tStandard标准，它是一些前端工程师自定的标准。\n\t\n\t执行安装：\n\t\n\t```\n\tnpm install eslint-config-standard eslint-plugin-standard eslint-plugin-promise -g\n\t```\n\n目前来看，公认的最好的标准是Airbnb标准。建议全局安装这些标准，然后在你的.eslint配置文件中直接使用：\n\n```\n{\n  \"extends\": \"Airbnb/standard/Google/\"\n}\n\n```\n\n","source":"_posts/ESLint--定制你的代码规则.md","raw":"# ESLint--定制你的代码规则\n\n## 简介\nESLint是一个开源的项目，由Nicholas C. Zakas（《JavaScript高级程序设计》作者）于2013年六月创建。它的目标是为JavaScript提供一个完全可配置的实用lint工具。\n\nJavaScript是一种动态的、松散型的语言，是特别容易受到开发人员的错误使用。而ESLint可以在不执行JavaScript代码的情况下发现代码的问题。\n\nESLint由Node.js编写，通过NPM提供快速的运行环境，并且安装方便。\n\n## 安装\n1. 全局安装\n\n\t```\n\t$ npm install -g eslint\n\t```\n2. 本地安装\n\n\t```\n\t$ npm install eslint --save-dev\n\t```\n\n## 使用\n\n### 生成配置文件\n在你想要使用ESLint的工程根目录下执行：\n\n```\neslint --init\n```\n这个命令的目的是创建一个eslint配置文件。如果你是全局安装的eslint，那么可以在任意文件中使用该命令，否则，你必须在使用该命令之前在该项目中安装eslint。\n\n执行该命令后，一般会出现三个选项可供选择，他们分别是：\n\n```\n❯ Answer questions about your style\n  Use a popular style guide\n  Inspect your JavaScript file(s)\n```\n+ 通过询问你来定制你的配置文件；\n+ 使用通用的配置文件；\n+ 通过审查你写的JavaScript文件来生成一个配置文件；\n\n在这之后， 在你的目录中会有一个.eslintrc文件，这个.eslintrc的存在形式也是可选择的，它可以是JavaScript、YAML、JSON、package.json等等。\n\n### 配置文件\n生成配置文件之后，打开.eslintrc文件（一般是隐藏的），可以看到以下格式的内容：\n\n```\n{\n    \"env\": {\n        \"browser\": true\n    },\n    \"extends\": \"eslint:recommended\",\n    \"rules\": {\n        \"indent\": [\n            \"error\",\n            \"tab\"\n        ],\n        \"linebreak-style\": [\n            \"error\",\n            \"unix\"\n        ],\n        \"quotes\": [\n            \"error\",\n            \"double\"\n        ],\n        \"semi\": [\n            \"error\",\n            \"always\"\n        ]\n    },\n    Globals: {\n    }\n}\n```\n\n我这个是json格式的，这里解释一下这个文件里各个参数的意思：\n\n1. env ：指定你的js代码在哪个运行环境中检测（每个运行环境都有一组预定义的全局变量）；\n\n2. extends ：扩展配置规则（），我这里扩展的是eslint的推荐规则；\n\n3. rules ：指定检测规则；\n\n\t这是最重要的部分，也是你的自定义js代码监测规则的地方，他的格式是：规则名: 规则。比如：\n\t```\n\t\"indent\": [\"error\",\"tab\"]\n\t```\n\t这里`indent`就是规则名，它定义了缩进应该使用tab，规则内的第一个值`error`指的是错误等级，它有三个等级，分别是：\n\n\t| error level | 数值表示   | 涵义       |\n\t| ----------- |:---------:| ---------:|\n\t| error       | 2         | 作为错误    |\n\t| warn        | 1         | 作为提醒    |\n\t| off         | 0         | 关闭该规则  |\n更多的规则可以参考[官网](http://eslint.org/docs/rules/)的rules。\n\n4. Globals ：指定脚本执行过程中访问的附加全局变量（比如jquery）\n\n**PS:**\n\n您可以配置全局的.eslint文件，而不至于要每个工程中都创建一个独有的.eslint文件，烹制方法是将您的.eslintr文件放在当前用户的根目录下，类Unix系统的当前用户目录是`~`，而Windows系统的话则是类似于`C:\\Windows\\Users\\Username`这样的地方\n\n### 检测文件\n在你的工程目录下执行：\n\n```\neslint yourfile.js\n```\n\n它会在命令后输出你的所有报错信息。这样就ok了。个人感觉它的最大优势就是完全可配置，而且配置文件一次构建，可以通过粘贴复制的方式无数次使用。甚至整个团队可以通过使用一份配置文件来达到规范代码的作用，还是很强大的。\n\n## 使用现有的通用规则\neslint官方提供了3种预安装包：\n\n1. [eslint-config-google](https://www.npmjs.com/package/eslint-config-google)\n\n\tGoogle标准\n\t\n\t执行安装：\n\t\n\t```\n\tnpm install eslint eslint-config-google -g\n\t```\n\t\n2. [eslint-config-airbnb](https://www.npmjs.com/package/eslint-config-airbnb)\n\n\tAirbnb标准,它依赖eslint, eslint-plugin-import, eslint-plugin-react, and eslint-plugin-jsx-a11y等插件，并且对各个插件的版本有所要求。\n\t\n\t你可以执行以下命令查看所依赖的各个版本：\n\n\t```\n\tnpm info \"eslint-config-airbnb@latest\" peerDependencies\n\t```\n\t你会看到以下输出信息，包含每个了每个plugins的版本要求\n\t\n\t```\n\t{ eslint: '^3.15.0',\n\t  'eslint-plugin-jsx-a11y': '^3.0.2 || ^4.0.0',\n\t  'eslint-plugin-import': '^2.2.0',\n\t  'eslint-plugin-react': '^6.9.0' }\n\t```\n\t知道了每个plugins的版本要求后，代入以下命令执行安装即可使用：\n\t\n\t```\n\tnpm install eslint-config-airbnb eslint@^#.#.# eslint-plugin-jsx-a11y@^#.#.# eslint-plugin-import@^#.#.# eslint-plugin-react@^#.#.# -g\n\t```\n\t\n3. [eslint-config-standard](https://www.npmjs.com/package/eslint-config-standard)\n\n\tStandard标准，它是一些前端工程师自定的标准。\n\t\n\t执行安装：\n\t\n\t```\n\tnpm install eslint-config-standard eslint-plugin-standard eslint-plugin-promise -g\n\t```\n\n目前来看，公认的最好的标准是Airbnb标准。建议全局安装这些标准，然后在你的.eslint配置文件中直接使用：\n\n```\n{\n  \"extends\": \"Airbnb/standard/Google/\"\n}\n\n```\n\n","slug":"ESLint--定制你的代码规则","published":1,"date":"2021-12-06T06:07:06.113Z","updated":"2021-12-06T06:07:06.113Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokd0009y4v2a4aperfr","content":"<h1 id=\"ESLint–定制你的代码规则\"><a href=\"#ESLint–定制你的代码规则\" class=\"headerlink\" title=\"ESLint–定制你的代码规则\"></a>ESLint–定制你的代码规则</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ESLint是一个开源的项目，由Nicholas C. Zakas（《JavaScript高级程序设计》作者）于2013年六月创建。它的目标是为JavaScript提供一个完全可配置的实用lint工具。</p>\n<p>JavaScript是一种动态的、松散型的语言，是特别容易受到开发人员的错误使用。而ESLint可以在不执行JavaScript代码的情况下发现代码的问题。</p>\n<p>ESLint由Node.js编写，通过NPM提供快速的运行环境，并且安装方便。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ol>\n<li><p>全局安装</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g eslint</span><br></pre></td></tr></table></figure></li>\n<li><p>本地安装</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install eslint --save-dev</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"生成配置文件\"><a href=\"#生成配置文件\" class=\"headerlink\" title=\"生成配置文件\"></a>生成配置文件</h3><p>在你想要使用ESLint的工程根目录下执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eslint --init</span><br></pre></td></tr></table></figure>\n<p>这个命令的目的是创建一个eslint配置文件。如果你是全局安装的eslint，那么可以在任意文件中使用该命令，否则，你必须在使用该命令之前在该项目中安装eslint。</p>\n<p>执行该命令后，一般会出现三个选项可供选择，他们分别是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">❯ Answer questions about your style</span><br><span class=\"line\">  Use a popular style guide</span><br><span class=\"line\">  Inspect your JavaScript file(s)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过询问你来定制你的配置文件；</li>\n<li>使用通用的配置文件；</li>\n<li>通过审查你写的JavaScript文件来生成一个配置文件；</li>\n</ul>\n<p>在这之后， 在你的目录中会有一个.eslintrc文件，这个.eslintrc的存在形式也是可选择的，它可以是JavaScript、YAML、JSON、package.json等等。</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>生成配置文件之后，打开.eslintrc文件（一般是隐藏的），可以看到以下格式的内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;env&quot;: &#123;</span><br><span class=\"line\">        &quot;browser&quot;: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;extends&quot;: &quot;eslint:recommended&quot;,</span><br><span class=\"line\">    &quot;rules&quot;: &#123;</span><br><span class=\"line\">        &quot;indent&quot;: [</span><br><span class=\"line\">            &quot;error&quot;,</span><br><span class=\"line\">            &quot;tab&quot;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        &quot;linebreak-style&quot;: [</span><br><span class=\"line\">            &quot;error&quot;,</span><br><span class=\"line\">            &quot;unix&quot;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        &quot;quotes&quot;: [</span><br><span class=\"line\">            &quot;error&quot;,</span><br><span class=\"line\">            &quot;double&quot;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        &quot;semi&quot;: [</span><br><span class=\"line\">            &quot;error&quot;,</span><br><span class=\"line\">            &quot;always&quot;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Globals: &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我这个是json格式的，这里解释一下这个文件里各个参数的意思：</p>\n<ol>\n<li><p>env ：指定你的js代码在哪个运行环境中检测（每个运行环境都有一组预定义的全局变量）；</p>\n</li>\n<li><p>extends ：扩展配置规则（），我这里扩展的是eslint的推荐规则；</p>\n</li>\n<li><p>rules ：指定检测规则；</p>\n<p> 这是最重要的部分，也是你的自定义js代码监测规则的地方，他的格式是：规则名: 规则。比如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;indent&quot;: [&quot;error&quot;,&quot;tab&quot;]</span><br></pre></td></tr></table></figure>\n<p> 这里<code>indent</code>就是规则名，它定义了缩进应该使用tab，规则内的第一个值<code>error</code>指的是错误等级，它有三个等级，分别是：</p>\n<table>\n<thead>\n<tr>\n<th>error level</th>\n<th align=\"center\">数值表示</th>\n<th align=\"right\">涵义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>error</td>\n<td align=\"center\">2</td>\n<td align=\"right\">作为错误</td>\n</tr>\n<tr>\n<td>warn</td>\n<td align=\"center\">1</td>\n<td align=\"right\">作为提醒</td>\n</tr>\n<tr>\n<td>off</td>\n<td align=\"center\">0</td>\n<td align=\"right\">关闭该规则</td>\n</tr>\n<tr>\n<td>更多的规则可以参考<a href=\"http://eslint.org/docs/rules/\">官网</a>的rules。</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>Globals ：指定脚本执行过程中访问的附加全局变量（比如jquery）</p>\n</li>\n</ol>\n<p><strong>PS:</strong></p>\n<p>您可以配置全局的.eslint文件，而不至于要每个工程中都创建一个独有的.eslint文件，烹制方法是将您的.eslintr文件放在当前用户的根目录下，类Unix系统的当前用户目录是<code>~</code>，而Windows系统的话则是类似于<code>C:\\Windows\\Users\\Username</code>这样的地方</p>\n<h3 id=\"检测文件\"><a href=\"#检测文件\" class=\"headerlink\" title=\"检测文件\"></a>检测文件</h3><p>在你的工程目录下执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eslint yourfile.js</span><br></pre></td></tr></table></figure>\n\n<p>它会在命令后输出你的所有报错信息。这样就ok了。个人感觉它的最大优势就是完全可配置，而且配置文件一次构建，可以通过粘贴复制的方式无数次使用。甚至整个团队可以通过使用一份配置文件来达到规范代码的作用，还是很强大的。</p>\n<h2 id=\"使用现有的通用规则\"><a href=\"#使用现有的通用规则\" class=\"headerlink\" title=\"使用现有的通用规则\"></a>使用现有的通用规则</h2><p>eslint官方提供了3种预安装包：</p>\n<ol>\n<li><p><a href=\"https://www.npmjs.com/package/eslint-config-google\">eslint-config-google</a></p>\n<p> Google标准</p>\n<p> 执行安装：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint eslint-config-google -g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://www.npmjs.com/package/eslint-config-airbnb\">eslint-config-airbnb</a></p>\n<p> Airbnb标准,它依赖eslint, eslint-plugin-import, eslint-plugin-react, and eslint-plugin-jsx-a11y等插件，并且对各个插件的版本有所要求。</p>\n<p> 你可以执行以下命令查看所依赖的各个版本：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm info &quot;eslint-config-airbnb@latest&quot; peerDependencies</span><br></pre></td></tr></table></figure>\n<p> 你会看到以下输出信息，包含每个了每个plugins的版本要求</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; eslint: &#x27;^3.15.0&#x27;,</span><br><span class=\"line\">  &#x27;eslint-plugin-jsx-a11y&#x27;: &#x27;^3.0.2 || ^4.0.0&#x27;,</span><br><span class=\"line\">  &#x27;eslint-plugin-import&#x27;: &#x27;^2.2.0&#x27;,</span><br><span class=\"line\">  &#x27;eslint-plugin-react&#x27;: &#x27;^6.9.0&#x27; &#125;</span><br></pre></td></tr></table></figure>\n<p> 知道了每个plugins的版本要求后，代入以下命令执行安装即可使用：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint-config-airbnb eslint@^#.#.# eslint-plugin-jsx-a11y@^#.#.# eslint-plugin-import@^#.#.# eslint-plugin-react@^#.#.# -g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://www.npmjs.com/package/eslint-config-standard\">eslint-config-standard</a></p>\n<p> Standard标准，它是一些前端工程师自定的标准。</p>\n<p> 执行安装：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint-config-standard eslint-plugin-standard eslint-plugin-promise -g</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>目前来看，公认的最好的标准是Airbnb标准。建议全局安装这些标准，然后在你的.eslint配置文件中直接使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;extends&quot;: &quot;Airbnb/standard/Google/&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ESLint–定制你的代码规则\"><a href=\"#ESLint–定制你的代码规则\" class=\"headerlink\" title=\"ESLint–定制你的代码规则\"></a>ESLint–定制你的代码规则</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ESLint是一个开源的项目，由Nicholas C. Zakas（《JavaScript高级程序设计》作者）于2013年六月创建。它的目标是为JavaScript提供一个完全可配置的实用lint工具。</p>\n<p>JavaScript是一种动态的、松散型的语言，是特别容易受到开发人员的错误使用。而ESLint可以在不执行JavaScript代码的情况下发现代码的问题。</p>\n<p>ESLint由Node.js编写，通过NPM提供快速的运行环境，并且安装方便。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ol>\n<li><p>全局安装</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g eslint</span><br></pre></td></tr></table></figure></li>\n<li><p>本地安装</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install eslint --save-dev</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"生成配置文件\"><a href=\"#生成配置文件\" class=\"headerlink\" title=\"生成配置文件\"></a>生成配置文件</h3><p>在你想要使用ESLint的工程根目录下执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eslint --init</span><br></pre></td></tr></table></figure>\n<p>这个命令的目的是创建一个eslint配置文件。如果你是全局安装的eslint，那么可以在任意文件中使用该命令，否则，你必须在使用该命令之前在该项目中安装eslint。</p>\n<p>执行该命令后，一般会出现三个选项可供选择，他们分别是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">❯ Answer questions about your style</span><br><span class=\"line\">  Use a popular style guide</span><br><span class=\"line\">  Inspect your JavaScript file(s)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过询问你来定制你的配置文件；</li>\n<li>使用通用的配置文件；</li>\n<li>通过审查你写的JavaScript文件来生成一个配置文件；</li>\n</ul>\n<p>在这之后， 在你的目录中会有一个.eslintrc文件，这个.eslintrc的存在形式也是可选择的，它可以是JavaScript、YAML、JSON、package.json等等。</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>生成配置文件之后，打开.eslintrc文件（一般是隐藏的），可以看到以下格式的内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;env&quot;: &#123;</span><br><span class=\"line\">        &quot;browser&quot;: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;extends&quot;: &quot;eslint:recommended&quot;,</span><br><span class=\"line\">    &quot;rules&quot;: &#123;</span><br><span class=\"line\">        &quot;indent&quot;: [</span><br><span class=\"line\">            &quot;error&quot;,</span><br><span class=\"line\">            &quot;tab&quot;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        &quot;linebreak-style&quot;: [</span><br><span class=\"line\">            &quot;error&quot;,</span><br><span class=\"line\">            &quot;unix&quot;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        &quot;quotes&quot;: [</span><br><span class=\"line\">            &quot;error&quot;,</span><br><span class=\"line\">            &quot;double&quot;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        &quot;semi&quot;: [</span><br><span class=\"line\">            &quot;error&quot;,</span><br><span class=\"line\">            &quot;always&quot;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Globals: &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我这个是json格式的，这里解释一下这个文件里各个参数的意思：</p>\n<ol>\n<li><p>env ：指定你的js代码在哪个运行环境中检测（每个运行环境都有一组预定义的全局变量）；</p>\n</li>\n<li><p>extends ：扩展配置规则（），我这里扩展的是eslint的推荐规则；</p>\n</li>\n<li><p>rules ：指定检测规则；</p>\n<p> 这是最重要的部分，也是你的自定义js代码监测规则的地方，他的格式是：规则名: 规则。比如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;indent&quot;: [&quot;error&quot;,&quot;tab&quot;]</span><br></pre></td></tr></table></figure>\n<p> 这里<code>indent</code>就是规则名，它定义了缩进应该使用tab，规则内的第一个值<code>error</code>指的是错误等级，它有三个等级，分别是：</p>\n<table>\n<thead>\n<tr>\n<th>error level</th>\n<th align=\"center\">数值表示</th>\n<th align=\"right\">涵义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>error</td>\n<td align=\"center\">2</td>\n<td align=\"right\">作为错误</td>\n</tr>\n<tr>\n<td>warn</td>\n<td align=\"center\">1</td>\n<td align=\"right\">作为提醒</td>\n</tr>\n<tr>\n<td>off</td>\n<td align=\"center\">0</td>\n<td align=\"right\">关闭该规则</td>\n</tr>\n<tr>\n<td>更多的规则可以参考<a href=\"http://eslint.org/docs/rules/\">官网</a>的rules。</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>Globals ：指定脚本执行过程中访问的附加全局变量（比如jquery）</p>\n</li>\n</ol>\n<p><strong>PS:</strong></p>\n<p>您可以配置全局的.eslint文件，而不至于要每个工程中都创建一个独有的.eslint文件，烹制方法是将您的.eslintr文件放在当前用户的根目录下，类Unix系统的当前用户目录是<code>~</code>，而Windows系统的话则是类似于<code>C:\\Windows\\Users\\Username</code>这样的地方</p>\n<h3 id=\"检测文件\"><a href=\"#检测文件\" class=\"headerlink\" title=\"检测文件\"></a>检测文件</h3><p>在你的工程目录下执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eslint yourfile.js</span><br></pre></td></tr></table></figure>\n\n<p>它会在命令后输出你的所有报错信息。这样就ok了。个人感觉它的最大优势就是完全可配置，而且配置文件一次构建，可以通过粘贴复制的方式无数次使用。甚至整个团队可以通过使用一份配置文件来达到规范代码的作用，还是很强大的。</p>\n<h2 id=\"使用现有的通用规则\"><a href=\"#使用现有的通用规则\" class=\"headerlink\" title=\"使用现有的通用规则\"></a>使用现有的通用规则</h2><p>eslint官方提供了3种预安装包：</p>\n<ol>\n<li><p><a href=\"https://www.npmjs.com/package/eslint-config-google\">eslint-config-google</a></p>\n<p> Google标准</p>\n<p> 执行安装：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint eslint-config-google -g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://www.npmjs.com/package/eslint-config-airbnb\">eslint-config-airbnb</a></p>\n<p> Airbnb标准,它依赖eslint, eslint-plugin-import, eslint-plugin-react, and eslint-plugin-jsx-a11y等插件，并且对各个插件的版本有所要求。</p>\n<p> 你可以执行以下命令查看所依赖的各个版本：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm info &quot;eslint-config-airbnb@latest&quot; peerDependencies</span><br></pre></td></tr></table></figure>\n<p> 你会看到以下输出信息，包含每个了每个plugins的版本要求</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; eslint: &#x27;^3.15.0&#x27;,</span><br><span class=\"line\">  &#x27;eslint-plugin-jsx-a11y&#x27;: &#x27;^3.0.2 || ^4.0.0&#x27;,</span><br><span class=\"line\">  &#x27;eslint-plugin-import&#x27;: &#x27;^2.2.0&#x27;,</span><br><span class=\"line\">  &#x27;eslint-plugin-react&#x27;: &#x27;^6.9.0&#x27; &#125;</span><br></pre></td></tr></table></figure>\n<p> 知道了每个plugins的版本要求后，代入以下命令执行安装即可使用：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint-config-airbnb eslint@^#.#.# eslint-plugin-jsx-a11y@^#.#.# eslint-plugin-import@^#.#.# eslint-plugin-react@^#.#.# -g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://www.npmjs.com/package/eslint-config-standard\">eslint-config-standard</a></p>\n<p> Standard标准，它是一些前端工程师自定的标准。</p>\n<p> 执行安装：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint-config-standard eslint-plugin-standard eslint-plugin-promise -g</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>目前来看，公认的最好的标准是Airbnb标准。建议全局安装这些标准，然后在你的.eslint配置文件中直接使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;extends&quot;: &quot;Airbnb/standard/Google/&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"_content":"# H5文件上传\n\n## 序\n以前做网站图片上传功能基本用的是百度的webupload插件，该插件功能十分强大，兼容性也很好。但是最近开始接触移动端的前端开发，就不想再使用这个插件了。原因有三：\n\n第一，插件的体积过大，消耗流量，影响页面打开速度；\n\n第二，移动端的兼容性问题已经几乎不需要考虑了；\n\n第三，h5的发展，足够强大，提供了FormData，可以帮助我们拼凑参数，乃至文件资源。\n\n于是开始研究h5来实现文件上传。\n\n##HTML\n\nhtml部分不用多说，肯定是一个file类型的input按钮。\n```\n<input type=\"file\">\n```\n这个按钮点击以后会弹出一个文件选择框，选择相应文件后会将文件暂存到原始数据缓冲区。接下来的活就交给FileReader了。\n\n## FileReader\n文档请戳这里[FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader)\n\nFileReader用来把文件读入内存，并且读取文件中的数据。FileReader接口提供了一个异步API，使用该API可以在浏览器主线程中异步访问文件系统，并通过file或者blog对象读取文件中的数据。\n\n\n\n### 方法\n\nFileReader接口有4个方法，其中3个用来读取文件，另一个用来中断读取。无论读取成功或失败，方法并不会返回读取结果，这一结果存储在result属性中。\n\n\n| 方法名        | 参数           | 描述  |\n| ------------- |:-------------:| -----:|\n|readAsBinaryString | file |  将文件读取为二进制编码 |\n|readAsText |file,[encoding] |  将文件读取为文本 |\n|readAsDataURL | file | 将文件读取为DataURL |\n|abort |(none) | 终端读取操作 |\n\n### 事件\nFileReader接口包含了一套完整的事件模型，用于捕获读取文件时的状态。\n\n| 事件名  | 描述  |\n| ------------- | -----:|\n|onabort | 中断 |\n|onerror | 出错 |\n|onloadstart | 开始 |\n| onprogress | 正在读取 |\n| onload | 成功读取 |\n| onloadend | 读取完成，无论成功失败 |\n\n\n\n## FormData\n\n文档请戳这里[FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n\n平常我们提交form表单后，form会把form中的所有表格元素的name与value组成一个queryStrin提交到后台，这就是formdata。\n\nFormData接口提供了一种便捷构建一套键/值形式数据的方式，它可以被xhrhttprequest发送，使用formdata最大的优点就是可以上传二进制文件（将字符编码设置为“multipart/form-data“）。\n\n声明：\n\n```\nvar f = new FormData()\n```\n\n添加数据：\n\n```\nf.append(key,value)\n\n```\n\n删除数据：\n\n```\nf.delete(key,value)\n\n```\n\n","source":"_posts/H5文件上传.md","raw":"# H5文件上传\n\n## 序\n以前做网站图片上传功能基本用的是百度的webupload插件，该插件功能十分强大，兼容性也很好。但是最近开始接触移动端的前端开发，就不想再使用这个插件了。原因有三：\n\n第一，插件的体积过大，消耗流量，影响页面打开速度；\n\n第二，移动端的兼容性问题已经几乎不需要考虑了；\n\n第三，h5的发展，足够强大，提供了FormData，可以帮助我们拼凑参数，乃至文件资源。\n\n于是开始研究h5来实现文件上传。\n\n##HTML\n\nhtml部分不用多说，肯定是一个file类型的input按钮。\n```\n<input type=\"file\">\n```\n这个按钮点击以后会弹出一个文件选择框，选择相应文件后会将文件暂存到原始数据缓冲区。接下来的活就交给FileReader了。\n\n## FileReader\n文档请戳这里[FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader)\n\nFileReader用来把文件读入内存，并且读取文件中的数据。FileReader接口提供了一个异步API，使用该API可以在浏览器主线程中异步访问文件系统，并通过file或者blog对象读取文件中的数据。\n\n\n\n### 方法\n\nFileReader接口有4个方法，其中3个用来读取文件，另一个用来中断读取。无论读取成功或失败，方法并不会返回读取结果，这一结果存储在result属性中。\n\n\n| 方法名        | 参数           | 描述  |\n| ------------- |:-------------:| -----:|\n|readAsBinaryString | file |  将文件读取为二进制编码 |\n|readAsText |file,[encoding] |  将文件读取为文本 |\n|readAsDataURL | file | 将文件读取为DataURL |\n|abort |(none) | 终端读取操作 |\n\n### 事件\nFileReader接口包含了一套完整的事件模型，用于捕获读取文件时的状态。\n\n| 事件名  | 描述  |\n| ------------- | -----:|\n|onabort | 中断 |\n|onerror | 出错 |\n|onloadstart | 开始 |\n| onprogress | 正在读取 |\n| onload | 成功读取 |\n| onloadend | 读取完成，无论成功失败 |\n\n\n\n## FormData\n\n文档请戳这里[FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n\n平常我们提交form表单后，form会把form中的所有表格元素的name与value组成一个queryStrin提交到后台，这就是formdata。\n\nFormData接口提供了一种便捷构建一套键/值形式数据的方式，它可以被xhrhttprequest发送，使用formdata最大的优点就是可以上传二进制文件（将字符编码设置为“multipart/form-data“）。\n\n声明：\n\n```\nvar f = new FormData()\n```\n\n添加数据：\n\n```\nf.append(key,value)\n\n```\n\n删除数据：\n\n```\nf.delete(key,value)\n\n```\n\n","slug":"H5文件上传","published":1,"date":"2021-12-06T06:07:06.113Z","updated":"2021-12-06T06:07:06.113Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoke000ay4v2c0p58www","content":"<h1 id=\"H5文件上传\"><a href=\"#H5文件上传\" class=\"headerlink\" title=\"H5文件上传\"></a>H5文件上传</h1><h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>以前做网站图片上传功能基本用的是百度的webupload插件，该插件功能十分强大，兼容性也很好。但是最近开始接触移动端的前端开发，就不想再使用这个插件了。原因有三：</p>\n<p>第一，插件的体积过大，消耗流量，影响页面打开速度；</p>\n<p>第二，移动端的兼容性问题已经几乎不需要考虑了；</p>\n<p>第三，h5的发展，足够强大，提供了FormData，可以帮助我们拼凑参数，乃至文件资源。</p>\n<p>于是开始研究h5来实现文件上传。</p>\n<p>##HTML</p>\n<p>html部分不用多说，肯定是一个file类型的input按钮。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;file&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>这个按钮点击以后会弹出一个文件选择框，选择相应文件后会将文件暂存到原始数据缓冲区。接下来的活就交给FileReader了。</p>\n<h2 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a>FileReader</h2><p>文档请戳这里<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader\">FileReader</a></p>\n<p>FileReader用来把文件读入内存，并且读取文件中的数据。FileReader接口提供了一个异步API，使用该API可以在浏览器主线程中异步访问文件系统，并通过file或者blog对象读取文件中的数据。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>FileReader接口有4个方法，其中3个用来读取文件，另一个用来中断读取。无论读取成功或失败，方法并不会返回读取结果，这一结果存储在result属性中。</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th align=\"center\">参数</th>\n<th align=\"right\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>readAsBinaryString</td>\n<td align=\"center\">file</td>\n<td align=\"right\">将文件读取为二进制编码</td>\n</tr>\n<tr>\n<td>readAsText</td>\n<td align=\"center\">file,[encoding]</td>\n<td align=\"right\">将文件读取为文本</td>\n</tr>\n<tr>\n<td>readAsDataURL</td>\n<td align=\"center\">file</td>\n<td align=\"right\">将文件读取为DataURL</td>\n</tr>\n<tr>\n<td>abort</td>\n<td align=\"center\">(none)</td>\n<td align=\"right\">终端读取操作</td>\n</tr>\n</tbody></table>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p>FileReader接口包含了一套完整的事件模型，用于捕获读取文件时的状态。</p>\n<table>\n<thead>\n<tr>\n<th>事件名</th>\n<th align=\"right\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onabort</td>\n<td align=\"right\">中断</td>\n</tr>\n<tr>\n<td>onerror</td>\n<td align=\"right\">出错</td>\n</tr>\n<tr>\n<td>onloadstart</td>\n<td align=\"right\">开始</td>\n</tr>\n<tr>\n<td>onprogress</td>\n<td align=\"right\">正在读取</td>\n</tr>\n<tr>\n<td>onload</td>\n<td align=\"right\">成功读取</td>\n</tr>\n<tr>\n<td>onloadend</td>\n<td align=\"right\">读取完成，无论成功失败</td>\n</tr>\n</tbody></table>\n<h2 id=\"FormData\"><a href=\"#FormData\" class=\"headerlink\" title=\"FormData\"></a>FormData</h2><p>文档请戳这里<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FormData\">FormData</a></p>\n<p>平常我们提交form表单后，form会把form中的所有表格元素的name与value组成一个queryStrin提交到后台，这就是formdata。</p>\n<p>FormData接口提供了一种便捷构建一套键/值形式数据的方式，它可以被xhrhttprequest发送，使用formdata最大的优点就是可以上传二进制文件（将字符编码设置为“multipart/form-data“）。</p>\n<p>声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f = new FormData()</span><br></pre></td></tr></table></figure>\n\n<p>添加数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.append(key,value)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>删除数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.delete(key,value)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"H5文件上传\"><a href=\"#H5文件上传\" class=\"headerlink\" title=\"H5文件上传\"></a>H5文件上传</h1><h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>以前做网站图片上传功能基本用的是百度的webupload插件，该插件功能十分强大，兼容性也很好。但是最近开始接触移动端的前端开发，就不想再使用这个插件了。原因有三：</p>\n<p>第一，插件的体积过大，消耗流量，影响页面打开速度；</p>\n<p>第二，移动端的兼容性问题已经几乎不需要考虑了；</p>\n<p>第三，h5的发展，足够强大，提供了FormData，可以帮助我们拼凑参数，乃至文件资源。</p>\n<p>于是开始研究h5来实现文件上传。</p>\n<p>##HTML</p>\n<p>html部分不用多说，肯定是一个file类型的input按钮。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;file&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>这个按钮点击以后会弹出一个文件选择框，选择相应文件后会将文件暂存到原始数据缓冲区。接下来的活就交给FileReader了。</p>\n<h2 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a>FileReader</h2><p>文档请戳这里<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader\">FileReader</a></p>\n<p>FileReader用来把文件读入内存，并且读取文件中的数据。FileReader接口提供了一个异步API，使用该API可以在浏览器主线程中异步访问文件系统，并通过file或者blog对象读取文件中的数据。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>FileReader接口有4个方法，其中3个用来读取文件，另一个用来中断读取。无论读取成功或失败，方法并不会返回读取结果，这一结果存储在result属性中。</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th align=\"center\">参数</th>\n<th align=\"right\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>readAsBinaryString</td>\n<td align=\"center\">file</td>\n<td align=\"right\">将文件读取为二进制编码</td>\n</tr>\n<tr>\n<td>readAsText</td>\n<td align=\"center\">file,[encoding]</td>\n<td align=\"right\">将文件读取为文本</td>\n</tr>\n<tr>\n<td>readAsDataURL</td>\n<td align=\"center\">file</td>\n<td align=\"right\">将文件读取为DataURL</td>\n</tr>\n<tr>\n<td>abort</td>\n<td align=\"center\">(none)</td>\n<td align=\"right\">终端读取操作</td>\n</tr>\n</tbody></table>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p>FileReader接口包含了一套完整的事件模型，用于捕获读取文件时的状态。</p>\n<table>\n<thead>\n<tr>\n<th>事件名</th>\n<th align=\"right\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onabort</td>\n<td align=\"right\">中断</td>\n</tr>\n<tr>\n<td>onerror</td>\n<td align=\"right\">出错</td>\n</tr>\n<tr>\n<td>onloadstart</td>\n<td align=\"right\">开始</td>\n</tr>\n<tr>\n<td>onprogress</td>\n<td align=\"right\">正在读取</td>\n</tr>\n<tr>\n<td>onload</td>\n<td align=\"right\">成功读取</td>\n</tr>\n<tr>\n<td>onloadend</td>\n<td align=\"right\">读取完成，无论成功失败</td>\n</tr>\n</tbody></table>\n<h2 id=\"FormData\"><a href=\"#FormData\" class=\"headerlink\" title=\"FormData\"></a>FormData</h2><p>文档请戳这里<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FormData\">FormData</a></p>\n<p>平常我们提交form表单后，form会把form中的所有表格元素的name与value组成一个queryStrin提交到后台，这就是formdata。</p>\n<p>FormData接口提供了一种便捷构建一套键/值形式数据的方式，它可以被xhrhttprequest发送，使用formdata最大的优点就是可以上传二进制文件（将字符编码设置为“multipart/form-data“）。</p>\n<p>声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f = new FormData()</span><br></pre></td></tr></table></figure>\n\n<p>添加数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.append(key,value)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>删除数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.delete(key,value)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Java中的方法（函数）","date":"2016-03-31T05:48:25.000Z","description":"Java中的方法（函数）","_content":"## 定义\n> 访问修饰符 返回值类型 方法名(参数列表){\n    //code...\n}\n\n<!-- more -->\n\n+ 修饰符：方法允许被访问的权限范围，可以是 public、protected、private 甚至可以省略 ，其中 public 表示该方法可以被其他任何代码调用\n+ 返回值类型 ：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字`void`。\n+ 方法名：定义的方法的名字\n+ 参数列表：传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开\n\n## 调用\n+ 方法有返回值，方法调用通常被当做一个值；\n+ 方法返回void，方法调用通常直接执行；\n\n## 方法重载\n在 Java 中支持有两个或多个同名的方法，但是它们的参数个数和类型必须有差别。这种情况就是方法重载（overloading）。重载是Java 实现多态的方式之一。当调用这些同名的方法时，Java 根据参数类型和参数的数目来确定到底调用哪一个方法，注意返回值类型并不起到区别方法的作用。\n```java\npublic class OverLoadDemo {\n        //定义一系列的方法，这些方法的参数是不同的，通过参数来区别调用的方法\n        void method(){\n            System.out.println(\"无参数方法被调用\");\n        }\n        void method(int a){\n            System.out.println(\"参数为int 类型被调用\");\n        }\n        void method(double d){\n            System.out.println(\"参数为double 方法被调用\");\n        }\n        void method(String s){\n            System.out.println(\"参数为String 方法被调用\");\n        }\n        public static void main(String args[ ]){\n            OverLoadDemo ov=new OverLoadDemo();\n            //使用不同的参数调用方法\n            ov.method();\n            ov.method(4);\n            ov.method(4.5D);\n            ov.method(\"a String\");\n        }\n}\n```\n\n## 变量作用域\n+ 变量的范围是程序中该变量可以被引用的部分。\n+ 方法内定义的变量被称为局部变量。\n+ 局部变量的作用范围从声明开始，直到包含它的块结束。\n+ 局部变量必须声明才可以使用。\n+ 方法的参数范围涵盖整个方法。参数实际上是一个局部变量。\n+ for循环的初始化部分声明的变量，其作用范围在整个循环。但循环体内声明的变量其适用范围是从它声明到循环体结束。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/Java中的方法（函数）.md","raw":"title: Java中的方法（函数）\ntags: [java基础]\ndate: 2016-03-31 13:48:25\ndescription: Java中的方法（函数）\n---\n## 定义\n> 访问修饰符 返回值类型 方法名(参数列表){\n    //code...\n}\n\n<!-- more -->\n\n+ 修饰符：方法允许被访问的权限范围，可以是 public、protected、private 甚至可以省略 ，其中 public 表示该方法可以被其他任何代码调用\n+ 返回值类型 ：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字`void`。\n+ 方法名：定义的方法的名字\n+ 参数列表：传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开\n\n## 调用\n+ 方法有返回值，方法调用通常被当做一个值；\n+ 方法返回void，方法调用通常直接执行；\n\n## 方法重载\n在 Java 中支持有两个或多个同名的方法，但是它们的参数个数和类型必须有差别。这种情况就是方法重载（overloading）。重载是Java 实现多态的方式之一。当调用这些同名的方法时，Java 根据参数类型和参数的数目来确定到底调用哪一个方法，注意返回值类型并不起到区别方法的作用。\n```java\npublic class OverLoadDemo {\n        //定义一系列的方法，这些方法的参数是不同的，通过参数来区别调用的方法\n        void method(){\n            System.out.println(\"无参数方法被调用\");\n        }\n        void method(int a){\n            System.out.println(\"参数为int 类型被调用\");\n        }\n        void method(double d){\n            System.out.println(\"参数为double 方法被调用\");\n        }\n        void method(String s){\n            System.out.println(\"参数为String 方法被调用\");\n        }\n        public static void main(String args[ ]){\n            OverLoadDemo ov=new OverLoadDemo();\n            //使用不同的参数调用方法\n            ov.method();\n            ov.method(4);\n            ov.method(4.5D);\n            ov.method(\"a String\");\n        }\n}\n```\n\n## 变量作用域\n+ 变量的范围是程序中该变量可以被引用的部分。\n+ 方法内定义的变量被称为局部变量。\n+ 局部变量的作用范围从声明开始，直到包含它的块结束。\n+ 局部变量必须声明才可以使用。\n+ 方法的参数范围涵盖整个方法。参数实际上是一个局部变量。\n+ for循环的初始化部分声明的变量，其作用范围在整个循环。但循环体内声明的变量其适用范围是从它声明到循环体结束。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"Java中的方法（函数）","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokg000cy4v2c9m2g21p","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>访问修饰符 返回值类型 方法名(参数列表){<br>    //code…<br>}</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<ul>\n<li>修饰符：方法允许被访问的权限范围，可以是 public、protected、private 甚至可以省略 ，其中 public 表示该方法可以被其他任何代码调用</li>\n<li>返回值类型 ：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字<code>void</code>。</li>\n<li>方法名：定义的方法的名字</li>\n<li>参数列表：传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开</li>\n</ul>\n<h2 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h2><ul>\n<li>方法有返回值，方法调用通常被当做一个值；</li>\n<li>方法返回void，方法调用通常直接执行；</li>\n</ul>\n<h2 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h2><p>在 Java 中支持有两个或多个同名的方法，但是它们的参数个数和类型必须有差别。这种情况就是方法重载（overloading）。重载是Java 实现多态的方式之一。当调用这些同名的方法时，Java 根据参数类型和参数的数目来确定到底调用哪一个方法，注意返回值类型并不起到区别方法的作用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OverLoadDemo</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//定义一系列的方法，这些方法的参数是不同的，通过参数来区别调用的方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;无参数方法被调用&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;参数为int 类型被调用&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">double</span> d)</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;参数为double 方法被调用&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(String s)</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;参数为String 方法被调用&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[ ])</span></span>&#123;</span><br><span class=\"line\">            OverLoadDemo ov=<span class=\"keyword\">new</span> OverLoadDemo();</span><br><span class=\"line\">            <span class=\"comment\">//使用不同的参数调用方法</span></span><br><span class=\"line\">            ov.method();</span><br><span class=\"line\">            ov.method(<span class=\"number\">4</span>);</span><br><span class=\"line\">            ov.method(<span class=\"number\">4.5D</span>);</span><br><span class=\"line\">            ov.method(<span class=\"string\">&quot;a String&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><ul>\n<li>变量的范围是程序中该变量可以被引用的部分。</li>\n<li>方法内定义的变量被称为局部变量。</li>\n<li>局部变量的作用范围从声明开始，直到包含它的块结束。</li>\n<li>局部变量必须声明才可以使用。</li>\n<li>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。</li>\n<li>for循环的初始化部分声明的变量，其作用范围在整个循环。但循环体内声明的变量其适用范围是从它声明到循环体结束。</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>访问修饰符 返回值类型 方法名(参数列表){<br>    //code…<br>}</p>\n</blockquote>","more":"<ul>\n<li>修饰符：方法允许被访问的权限范围，可以是 public、protected、private 甚至可以省略 ，其中 public 表示该方法可以被其他任何代码调用</li>\n<li>返回值类型 ：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字<code>void</code>。</li>\n<li>方法名：定义的方法的名字</li>\n<li>参数列表：传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开</li>\n</ul>\n<h2 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h2><ul>\n<li>方法有返回值，方法调用通常被当做一个值；</li>\n<li>方法返回void，方法调用通常直接执行；</li>\n</ul>\n<h2 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h2><p>在 Java 中支持有两个或多个同名的方法，但是它们的参数个数和类型必须有差别。这种情况就是方法重载（overloading）。重载是Java 实现多态的方式之一。当调用这些同名的方法时，Java 根据参数类型和参数的数目来确定到底调用哪一个方法，注意返回值类型并不起到区别方法的作用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OverLoadDemo</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//定义一系列的方法，这些方法的参数是不同的，通过参数来区别调用的方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;无参数方法被调用&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;参数为int 类型被调用&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">double</span> d)</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;参数为double 方法被调用&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(String s)</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;参数为String 方法被调用&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[ ])</span></span>&#123;</span><br><span class=\"line\">            OverLoadDemo ov=<span class=\"keyword\">new</span> OverLoadDemo();</span><br><span class=\"line\">            <span class=\"comment\">//使用不同的参数调用方法</span></span><br><span class=\"line\">            ov.method();</span><br><span class=\"line\">            ov.method(<span class=\"number\">4</span>);</span><br><span class=\"line\">            ov.method(<span class=\"number\">4.5D</span>);</span><br><span class=\"line\">            ov.method(<span class=\"string\">&quot;a String&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><ul>\n<li>变量的范围是程序中该变量可以被引用的部分。</li>\n<li>方法内定义的变量被称为局部变量。</li>\n<li>局部变量的作用范围从声明开始，直到包含它的块结束。</li>\n<li>局部变量必须声明才可以使用。</li>\n<li>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。</li>\n<li>for循环的初始化部分声明的变量，其作用范围在整个循环。但循环体内声明的变量其适用范围是从它声明到循环体结束。</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"JavaScript原型学习笔记","date":"2016-03-15T02:49:29.000Z","description":null,"_content":"\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n## 原型对象\n\n任何一个对象都有一个prototype的属性，在js中可以把它记为：`__proto__`。 `__proto__`相当于指针,每当你去定义一个prototype的时候，相当于把该实例的`__proto__`指向一个结构体，那么这个被指向结构体就称为该实例的原型。\n\n\n> 对象是属性的集合，并带有一个单一的原型对象。原型可以是一个对象或空值。\n\n<!-- more -->\n如图：下面的例子foo对象有俩个显性的x、y属性并且有一个隐形的prototype属性。\n```javascript\nvar foo = {\n    x:10,\n    y:20\n}\n```\n![](/images/201601/basic-object.png)\n\n\n## 原型链\n\n原型对象也是一个简单的对象，也拥有自己的原型。如果有一个非空引用原型的原型对象，这是所谓的原型链。\n\n> 原型链是一个对象的有限链，它用来实现继承和共享。ECMAScript 实现继承的方式主要是依靠原型链。\n\n显然，对于一个好的设计模式，我们可以重用类似的功能/代码，而不需要在每一个对象中重复。因此，下面的代码中，a对象存储b、c这两个对象的共同部分。而b、c只储存他们自己的附加属性或方法。\n\n\n```javascript\nvar a = {\n  x: 10,\n  calculate: function (z) {\n    return this.x + this.y + z;\n  }\n};\n\nvar b = {\n  y: 20,\n  __proto__: a\n};\n\nvar c = {\n  y: 30,\n  __proto__: a\n};\n\n// call the inherited method\nb.calculate(30); // 60\nc.calculate(40); // 80\n```\n\n我们可以看到，b和c有访问定义在a对象的`calculate`方法的入口，这是通过原型链实现的。\n\n\n+ 属性查找规则：当查找一个对象的属性时，如果一个属性或一个方法在对象本身内没有找到（即对象没有这样一个自己的属性），JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 `undefined`，\n\n+ hasOwnProperty是Object.prototype的一个方法，他能判断一个对象是否包含自定义属性而不是原型链上的属性，因为hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。\n\n+ 注意:在使用继承方法时，`this`的值被设置为原始对象，而不是在该方法被发现的（原型）对象中。例如，在上面的例子中，`this.y`是取自于b和c，而不是从a，但是，`this.x`是取自于a，这是通过原型链机制获取的。\n\n+ 事实上，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object 的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。object.prototype本身也有`__proto__`，这是一个链的最后一环，被设置为null。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层\n次。\n![](/images/201601/prototype-chain.png)\n\n\n## 构造函数和原型\n\n> 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。\n\n\n构造函数能做另一个有用的事情-它会自动设置一个新创建的对象的原型对象。这个原型对象存储在`constructorfunction.prototype`属性中。\n\n```javascript\n// a constructor function\nfunction Foo(y) {\n  // which may create objects\n  // by specified pattern: they have after\n  // creation own \"y\" property\n  this.y = y;\n}\n\n// also \"Foo.prototype\" stores reference\n// to the prototype of newly created objects,\n// so we may use it to define shared/inherited\n// properties or methods, so the same as in\n// previous example we have:\n\n// inherited property \"x\"\nFoo.prototype.x = 10;\n\n// and inherited method \"calculate\"\nFoo.prototype.calculate = function (z) {\n  return this.x + this.y + z;\n};\n\n// now create our \"b\" and \"c\"\n// objects using \"pattern\" Foo\nvar b = new Foo(20);\nvar c = new Foo(30);\n\n// call the inherited method\nb.calculate(30); // 60\nc.calculate(40); // 80\n\n// let's show that we reference\n// properties we expect\n\nconsole.log(\n\n  b.__proto__ === Foo.prototype, // true\n  c.__proto__ === Foo.prototype, // true\n\n  // also \"Foo.prototype\" automatically creates\n  // a special property \"constructor\", which is a\n  // reference to the constructor function itself;\n  // instances \"b\" and \"c\" may found it via\n  // delegation and use to check their constructor\n\n  b.constructor === Foo, // true\n  c.constructor === Foo, // true\n  Foo.prototype.constructor === Foo, // true\n\n  b.calculate === b.__proto__.calculate, // true\n  b.__proto__.calculate === Foo.prototype.calculate // true\n\n);\n```\n\n![](/images/201601/constructor-proto-chain.png)\n\n构造函数Foo也有自己的`__proto__`，它指向function.prototype。foo.prototype是Foo指向B和C原型的显式属性。\n\n## 原型使用方式\n\n1. 对象字面量\n```javascript\nvar Calculator = function (decimalDigits, tax) {\n    this.decimalDigits = decimalDigits;\n    this.tax = tax;\n};\nCalculator.prototype = {\n    add: function (x, y) {\n        return x + y;\n    },\n    subtract: function (x, y) {\n        return x - y;\n    }\n};\n//alert((new Calculator()).add(1, 3));\n```\n\n2. 自执行函数\n```javascript\nvar Calculator = function (decimalDigits, tax) {\n    this.decimalDigits = decimalDigits;\n    this.tax = tax;\n};\nCalculator.prototype = function () {\n    add = function (x, y) {\n        return x + y;\n    },\n    subtract = function (x, y) {\n        return x - y;\n    }\n    return {\n        add: add,\n        //subtract: subtract\n    }\n} ();\nalert((new Calculator()).add(11, 3)); //14\n//alert((new Calculator()).subtract(11, 3)); //not a function\n```\n\n这种方法的好处就是可以封装私有的function，通过return的形式暴露出简单的使用名称，以达到public/private的效果。\n\n\n参考文章:[《ECMA-262》](http://dmitrysoshnikov.com/ecmascript/javascript-the-core/)、[《JavaScript探秘：强大的原型和原型链》](http://www.nowamagic.net/librarys/veda/detail/1648)","source":"_posts/JavaScript原型学习笔记.md","raw":"title: JavaScript原型学习笔记\ndate: 2016-03-15 10:49:29\ntags: [javascript]\ndescription:\n\n---\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n## 原型对象\n\n任何一个对象都有一个prototype的属性，在js中可以把它记为：`__proto__`。 `__proto__`相当于指针,每当你去定义一个prototype的时候，相当于把该实例的`__proto__`指向一个结构体，那么这个被指向结构体就称为该实例的原型。\n\n\n> 对象是属性的集合，并带有一个单一的原型对象。原型可以是一个对象或空值。\n\n<!-- more -->\n如图：下面的例子foo对象有俩个显性的x、y属性并且有一个隐形的prototype属性。\n```javascript\nvar foo = {\n    x:10,\n    y:20\n}\n```\n![](/images/201601/basic-object.png)\n\n\n## 原型链\n\n原型对象也是一个简单的对象，也拥有自己的原型。如果有一个非空引用原型的原型对象，这是所谓的原型链。\n\n> 原型链是一个对象的有限链，它用来实现继承和共享。ECMAScript 实现继承的方式主要是依靠原型链。\n\n显然，对于一个好的设计模式，我们可以重用类似的功能/代码，而不需要在每一个对象中重复。因此，下面的代码中，a对象存储b、c这两个对象的共同部分。而b、c只储存他们自己的附加属性或方法。\n\n\n```javascript\nvar a = {\n  x: 10,\n  calculate: function (z) {\n    return this.x + this.y + z;\n  }\n};\n\nvar b = {\n  y: 20,\n  __proto__: a\n};\n\nvar c = {\n  y: 30,\n  __proto__: a\n};\n\n// call the inherited method\nb.calculate(30); // 60\nc.calculate(40); // 80\n```\n\n我们可以看到，b和c有访问定义在a对象的`calculate`方法的入口，这是通过原型链实现的。\n\n\n+ 属性查找规则：当查找一个对象的属性时，如果一个属性或一个方法在对象本身内没有找到（即对象没有这样一个自己的属性），JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 `undefined`，\n\n+ hasOwnProperty是Object.prototype的一个方法，他能判断一个对象是否包含自定义属性而不是原型链上的属性，因为hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。\n\n+ 注意:在使用继承方法时，`this`的值被设置为原始对象，而不是在该方法被发现的（原型）对象中。例如，在上面的例子中，`this.y`是取自于b和c，而不是从a，但是，`this.x`是取自于a，这是通过原型链机制获取的。\n\n+ 事实上，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object 的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。object.prototype本身也有`__proto__`，这是一个链的最后一环，被设置为null。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层\n次。\n![](/images/201601/prototype-chain.png)\n\n\n## 构造函数和原型\n\n> 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。\n\n\n构造函数能做另一个有用的事情-它会自动设置一个新创建的对象的原型对象。这个原型对象存储在`constructorfunction.prototype`属性中。\n\n```javascript\n// a constructor function\nfunction Foo(y) {\n  // which may create objects\n  // by specified pattern: they have after\n  // creation own \"y\" property\n  this.y = y;\n}\n\n// also \"Foo.prototype\" stores reference\n// to the prototype of newly created objects,\n// so we may use it to define shared/inherited\n// properties or methods, so the same as in\n// previous example we have:\n\n// inherited property \"x\"\nFoo.prototype.x = 10;\n\n// and inherited method \"calculate\"\nFoo.prototype.calculate = function (z) {\n  return this.x + this.y + z;\n};\n\n// now create our \"b\" and \"c\"\n// objects using \"pattern\" Foo\nvar b = new Foo(20);\nvar c = new Foo(30);\n\n// call the inherited method\nb.calculate(30); // 60\nc.calculate(40); // 80\n\n// let's show that we reference\n// properties we expect\n\nconsole.log(\n\n  b.__proto__ === Foo.prototype, // true\n  c.__proto__ === Foo.prototype, // true\n\n  // also \"Foo.prototype\" automatically creates\n  // a special property \"constructor\", which is a\n  // reference to the constructor function itself;\n  // instances \"b\" and \"c\" may found it via\n  // delegation and use to check their constructor\n\n  b.constructor === Foo, // true\n  c.constructor === Foo, // true\n  Foo.prototype.constructor === Foo, // true\n\n  b.calculate === b.__proto__.calculate, // true\n  b.__proto__.calculate === Foo.prototype.calculate // true\n\n);\n```\n\n![](/images/201601/constructor-proto-chain.png)\n\n构造函数Foo也有自己的`__proto__`，它指向function.prototype。foo.prototype是Foo指向B和C原型的显式属性。\n\n## 原型使用方式\n\n1. 对象字面量\n```javascript\nvar Calculator = function (decimalDigits, tax) {\n    this.decimalDigits = decimalDigits;\n    this.tax = tax;\n};\nCalculator.prototype = {\n    add: function (x, y) {\n        return x + y;\n    },\n    subtract: function (x, y) {\n        return x - y;\n    }\n};\n//alert((new Calculator()).add(1, 3));\n```\n\n2. 自执行函数\n```javascript\nvar Calculator = function (decimalDigits, tax) {\n    this.decimalDigits = decimalDigits;\n    this.tax = tax;\n};\nCalculator.prototype = function () {\n    add = function (x, y) {\n        return x + y;\n    },\n    subtract = function (x, y) {\n        return x - y;\n    }\n    return {\n        add: add,\n        //subtract: subtract\n    }\n} ();\nalert((new Calculator()).add(11, 3)); //14\n//alert((new Calculator()).subtract(11, 3)); //not a function\n```\n\n这种方法的好处就是可以封装私有的function，通过return的形式暴露出简单的使用名称，以达到public/private的效果。\n\n\n参考文章:[《ECMA-262》](http://dmitrysoshnikov.com/ecmascript/javascript-the-core/)、[《JavaScript探秘：强大的原型和原型链》](http://www.nowamagic.net/librarys/veda/detail/1648)","slug":"JavaScript原型学习笔记","published":1,"updated":"2021-12-06T06:07:06.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokg000ey4v26zzw479g","content":"<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<h2 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h2><p>任何一个对象都有一个prototype的属性，在js中可以把它记为：<code>__proto__</code>。 <code>__proto__</code>相当于指针,每当你去定义一个prototype的时候，相当于把该实例的<code>__proto__</code>指向一个结构体，那么这个被指向结构体就称为该实例的原型。</p>\n<blockquote>\n<p>对象是属性的集合，并带有一个单一的原型对象。原型可以是一个对象或空值。</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>如图：下面的例子foo对象有俩个显性的x、y属性并且有一个隐形的prototype属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">x</span>:<span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"attr\">y</span>:<span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/201601/basic-object.png\"></p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>原型对象也是一个简单的对象，也拥有自己的原型。如果有一个非空引用原型的原型对象，这是所谓的原型链。</p>\n<blockquote>\n<p>原型链是一个对象的有限链，它用来实现继承和共享。ECMAScript 实现继承的方式主要是依靠原型链。</p>\n</blockquote>\n<p>显然，对于一个好的设计模式，我们可以重用类似的功能/代码，而不需要在每一个对象中重复。因此，下面的代码中，a对象存储b、c这两个对象的共同部分。而b、c只储存他们自己的附加属性或方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">  <span class=\"attr\">calculate</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">z</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.x + <span class=\"built_in\">this</span>.y + z;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\">  <span class=\"attr\">__proto__</span>: a</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"number\">30</span>,</span><br><span class=\"line\">  <span class=\"attr\">__proto__</span>: a</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call the inherited method</span></span><br><span class=\"line\">b.calculate(<span class=\"number\">30</span>); <span class=\"comment\">// 60</span></span><br><span class=\"line\">c.calculate(<span class=\"number\">40</span>); <span class=\"comment\">// 80</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，b和c有访问定义在a对象的<code>calculate</code>方法的入口，这是通过原型链实现的。</p>\n<ul>\n<li><p>属性查找规则：当查找一个对象的属性时，如果一个属性或一个方法在对象本身内没有找到（即对象没有这样一个自己的属性），JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 <code>undefined</code>，</p>\n</li>\n<li><p>hasOwnProperty是Object.prototype的一个方法，他能判断一个对象是否包含自定义属性而不是原型链上的属性，因为hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。</p>\n</li>\n<li><p>注意:在使用继承方法时，<code>this</code>的值被设置为原始对象，而不是在该方法被发现的（原型）对象中。例如，在上面的例子中，<code>this.y</code>是取自于b和c，而不是从a，但是，<code>this.x</code>是取自于a，这是通过原型链机制获取的。</p>\n</li>\n<li><p>事实上，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object 的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。object.prototype本身也有<code>__proto__</code>，这是一个链的最后一环，被设置为null。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层<br>次。<br><img src=\"/images/201601/prototype-chain.png\"></p>\n</li>\n</ul>\n<h2 id=\"构造函数和原型\"><a href=\"#构造函数和原型\" class=\"headerlink\" title=\"构造函数和原型\"></a>构造函数和原型</h2><blockquote>\n<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>\n</blockquote>\n<p>构造函数能做另一个有用的事情-它会自动设置一个新创建的对象的原型对象。这个原型对象存储在<code>constructorfunction.prototype</code>属性中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a constructor function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// which may create objects</span></span><br><span class=\"line\">  <span class=\"comment\">// by specified pattern: they have after</span></span><br><span class=\"line\">  <span class=\"comment\">// creation own &quot;y&quot; property</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// also &quot;Foo.prototype&quot; stores reference</span></span><br><span class=\"line\"><span class=\"comment\">// to the prototype of newly created objects,</span></span><br><span class=\"line\"><span class=\"comment\">// so we may use it to define shared/inherited</span></span><br><span class=\"line\"><span class=\"comment\">// properties or methods, so the same as in</span></span><br><span class=\"line\"><span class=\"comment\">// previous example we have:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// inherited property &quot;x&quot;</span></span><br><span class=\"line\">Foo.prototype.x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// and inherited method &quot;calculate&quot;</span></span><br><span class=\"line\">Foo.prototype.calculate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">z</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.x + <span class=\"built_in\">this</span>.y + z;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// now create our &quot;b&quot; and &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// objects using &quot;pattern&quot; Foo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Foo(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Foo(<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call the inherited method</span></span><br><span class=\"line\">b.calculate(<span class=\"number\">30</span>); <span class=\"comment\">// 60</span></span><br><span class=\"line\">c.calculate(<span class=\"number\">40</span>); <span class=\"comment\">// 80</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let&#x27;s show that we reference</span></span><br><span class=\"line\"><span class=\"comment\">// properties we expect</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\"></span><br><span class=\"line\">  b.__proto__ === Foo.prototype, <span class=\"comment\">// true</span></span><br><span class=\"line\">  c.__proto__ === Foo.prototype, <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// also &quot;Foo.prototype&quot; automatically creates</span></span><br><span class=\"line\">  <span class=\"comment\">// a special property &quot;constructor&quot;, which is a</span></span><br><span class=\"line\">  <span class=\"comment\">// reference to the constructor function itself;</span></span><br><span class=\"line\">  <span class=\"comment\">// instances &quot;b&quot; and &quot;c&quot; may found it via</span></span><br><span class=\"line\">  <span class=\"comment\">// delegation and use to check their constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">  b.constructor === Foo, <span class=\"comment\">// true</span></span><br><span class=\"line\">  c.constructor === Foo, <span class=\"comment\">// true</span></span><br><span class=\"line\">  Foo.prototype.constructor === Foo, <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  b.calculate === b.__proto__.calculate, <span class=\"comment\">// true</span></span><br><span class=\"line\">  b.__proto__.calculate === Foo.prototype.calculate <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/201601/constructor-proto-chain.png\"></p>\n<p>构造函数Foo也有自己的<code>__proto__</code>，它指向function.prototype。foo.prototype是Foo指向B和C原型的显式属性。</p>\n<h2 id=\"原型使用方式\"><a href=\"#原型使用方式\" class=\"headerlink\" title=\"原型使用方式\"></a>原型使用方式</h2><ol>\n<li><p>对象字面量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Calculator = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">decimalDigits, tax</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.decimalDigits = decimalDigits;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.tax = tax;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Calculator.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">add</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">subtract</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x - y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//alert((new Calculator()).add(1, 3));</span></span><br></pre></td></tr></table></figure></li>\n<li><p>自执行函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Calculator = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">decimalDigits, tax</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.decimalDigits = decimalDigits;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.tax = tax;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Calculator.prototype = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    subtract = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x - y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">add</span>: add,</span><br><span class=\"line\">        <span class=\"comment\">//subtract: subtract</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; ();</span><br><span class=\"line\">alert((<span class=\"keyword\">new</span> Calculator()).add(<span class=\"number\">11</span>, <span class=\"number\">3</span>)); <span class=\"comment\">//14</span></span><br><span class=\"line\"><span class=\"comment\">//alert((new Calculator()).subtract(11, 3)); //not a function</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>这种方法的好处就是可以封装私有的function，通过return的形式暴露出简单的使用名称，以达到public/private的效果。</p>\n<p>参考文章:<a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core/\">《ECMA-262》</a>、<a href=\"http://www.nowamagic.net/librarys/veda/detail/1648\">《JavaScript探秘：强大的原型和原型链》</a></p>\n","site":{"data":{}},"excerpt":"<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<h2 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h2><p>任何一个对象都有一个prototype的属性，在js中可以把它记为：<code>__proto__</code>。 <code>__proto__</code>相当于指针,每当你去定义一个prototype的时候，相当于把该实例的<code>__proto__</code>指向一个结构体，那么这个被指向结构体就称为该实例的原型。</p>\n<blockquote>\n<p>对象是属性的集合，并带有一个单一的原型对象。原型可以是一个对象或空值。</p>\n</blockquote>","more":"<p>如图：下面的例子foo对象有俩个显性的x、y属性并且有一个隐形的prototype属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">x</span>:<span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"attr\">y</span>:<span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/201601/basic-object.png\"></p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>原型对象也是一个简单的对象，也拥有自己的原型。如果有一个非空引用原型的原型对象，这是所谓的原型链。</p>\n<blockquote>\n<p>原型链是一个对象的有限链，它用来实现继承和共享。ECMAScript 实现继承的方式主要是依靠原型链。</p>\n</blockquote>\n<p>显然，对于一个好的设计模式，我们可以重用类似的功能/代码，而不需要在每一个对象中重复。因此，下面的代码中，a对象存储b、c这两个对象的共同部分。而b、c只储存他们自己的附加属性或方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">  <span class=\"attr\">calculate</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">z</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.x + <span class=\"built_in\">this</span>.y + z;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\">  <span class=\"attr\">__proto__</span>: a</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"number\">30</span>,</span><br><span class=\"line\">  <span class=\"attr\">__proto__</span>: a</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call the inherited method</span></span><br><span class=\"line\">b.calculate(<span class=\"number\">30</span>); <span class=\"comment\">// 60</span></span><br><span class=\"line\">c.calculate(<span class=\"number\">40</span>); <span class=\"comment\">// 80</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，b和c有访问定义在a对象的<code>calculate</code>方法的入口，这是通过原型链实现的。</p>\n<ul>\n<li><p>属性查找规则：当查找一个对象的属性时，如果一个属性或一个方法在对象本身内没有找到（即对象没有这样一个自己的属性），JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 <code>undefined</code>，</p>\n</li>\n<li><p>hasOwnProperty是Object.prototype的一个方法，他能判断一个对象是否包含自定义属性而不是原型链上的属性，因为hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。</p>\n</li>\n<li><p>注意:在使用继承方法时，<code>this</code>的值被设置为原始对象，而不是在该方法被发现的（原型）对象中。例如，在上面的例子中，<code>this.y</code>是取自于b和c，而不是从a，但是，<code>this.x</code>是取自于a，这是通过原型链机制获取的。</p>\n</li>\n<li><p>事实上，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object 的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。object.prototype本身也有<code>__proto__</code>，这是一个链的最后一环，被设置为null。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层<br>次。<br><img src=\"/images/201601/prototype-chain.png\"></p>\n</li>\n</ul>\n<h2 id=\"构造函数和原型\"><a href=\"#构造函数和原型\" class=\"headerlink\" title=\"构造函数和原型\"></a>构造函数和原型</h2><blockquote>\n<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>\n</blockquote>\n<p>构造函数能做另一个有用的事情-它会自动设置一个新创建的对象的原型对象。这个原型对象存储在<code>constructorfunction.prototype</code>属性中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a constructor function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// which may create objects</span></span><br><span class=\"line\">  <span class=\"comment\">// by specified pattern: they have after</span></span><br><span class=\"line\">  <span class=\"comment\">// creation own &quot;y&quot; property</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// also &quot;Foo.prototype&quot; stores reference</span></span><br><span class=\"line\"><span class=\"comment\">// to the prototype of newly created objects,</span></span><br><span class=\"line\"><span class=\"comment\">// so we may use it to define shared/inherited</span></span><br><span class=\"line\"><span class=\"comment\">// properties or methods, so the same as in</span></span><br><span class=\"line\"><span class=\"comment\">// previous example we have:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// inherited property &quot;x&quot;</span></span><br><span class=\"line\">Foo.prototype.x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// and inherited method &quot;calculate&quot;</span></span><br><span class=\"line\">Foo.prototype.calculate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">z</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.x + <span class=\"built_in\">this</span>.y + z;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// now create our &quot;b&quot; and &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// objects using &quot;pattern&quot; Foo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Foo(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Foo(<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call the inherited method</span></span><br><span class=\"line\">b.calculate(<span class=\"number\">30</span>); <span class=\"comment\">// 60</span></span><br><span class=\"line\">c.calculate(<span class=\"number\">40</span>); <span class=\"comment\">// 80</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let&#x27;s show that we reference</span></span><br><span class=\"line\"><span class=\"comment\">// properties we expect</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\"></span><br><span class=\"line\">  b.__proto__ === Foo.prototype, <span class=\"comment\">// true</span></span><br><span class=\"line\">  c.__proto__ === Foo.prototype, <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// also &quot;Foo.prototype&quot; automatically creates</span></span><br><span class=\"line\">  <span class=\"comment\">// a special property &quot;constructor&quot;, which is a</span></span><br><span class=\"line\">  <span class=\"comment\">// reference to the constructor function itself;</span></span><br><span class=\"line\">  <span class=\"comment\">// instances &quot;b&quot; and &quot;c&quot; may found it via</span></span><br><span class=\"line\">  <span class=\"comment\">// delegation and use to check their constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">  b.constructor === Foo, <span class=\"comment\">// true</span></span><br><span class=\"line\">  c.constructor === Foo, <span class=\"comment\">// true</span></span><br><span class=\"line\">  Foo.prototype.constructor === Foo, <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  b.calculate === b.__proto__.calculate, <span class=\"comment\">// true</span></span><br><span class=\"line\">  b.__proto__.calculate === Foo.prototype.calculate <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/201601/constructor-proto-chain.png\"></p>\n<p>构造函数Foo也有自己的<code>__proto__</code>，它指向function.prototype。foo.prototype是Foo指向B和C原型的显式属性。</p>\n<h2 id=\"原型使用方式\"><a href=\"#原型使用方式\" class=\"headerlink\" title=\"原型使用方式\"></a>原型使用方式</h2><ol>\n<li><p>对象字面量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Calculator = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">decimalDigits, tax</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.decimalDigits = decimalDigits;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.tax = tax;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Calculator.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">add</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">subtract</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x - y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//alert((new Calculator()).add(1, 3));</span></span><br></pre></td></tr></table></figure></li>\n<li><p>自执行函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Calculator = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">decimalDigits, tax</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.decimalDigits = decimalDigits;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.tax = tax;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Calculator.prototype = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    subtract = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x - y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">add</span>: add,</span><br><span class=\"line\">        <span class=\"comment\">//subtract: subtract</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; ();</span><br><span class=\"line\">alert((<span class=\"keyword\">new</span> Calculator()).add(<span class=\"number\">11</span>, <span class=\"number\">3</span>)); <span class=\"comment\">//14</span></span><br><span class=\"line\"><span class=\"comment\">//alert((new Calculator()).subtract(11, 3)); //not a function</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>这种方法的好处就是可以封装私有的function，通过return的形式暴露出简单的使用名称，以达到public/private的效果。</p>\n<p>参考文章:<a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core/\">《ECMA-262》</a>、<a href=\"http://www.nowamagic.net/librarys/veda/detail/1648\">《JavaScript探秘：强大的原型和原型链》</a></p>"},{"_content":"# IE hack整理 #\n\n\n\n\n### CSS属性前缀法 ###\n\n\nhack       | browser               |使用\n-----      | ---                   |---\n[*+><]     | IE7                   |用于属性值前\n\\9         | IE6/IE7/IE8/IE9/IE10  |用于属性值前\n\\0         | IE8/IE9/IE10          |用于属性值前\n\\9\\0       | IE9/IE10              |用于属性值前\n\n测试用例：\n\n```css\n＃color{\n\tcolor:#000; /* 所有识别 */\n\tcolor:#000\\9; /* IE识别 */\n\t*color:#000; /* IE7识别 */\n}\n```\n\n### 条件注释法 ###\n\n1. 只在IE下生效\n\n\t```html\n\t<!--[if IE]>\n\t这段文字只在IE浏览器显示\n\t<![endif]-->\n\t```\n\n2. 只在IE6下生效\n\n\t```html\n\t<!--[if IE 6]>\n\t这段文字只在IE6浏览器显示\n\t<![endif]-->\n\t```\n\n3. 只在IE6以上版本生效\n\n\t```html\n\t<!--[if gte IE 6]>\n\t这段文字只在IE6以上(包括)版本IE浏览器显示\n\t<![endif]-->\n\t```\n\n4. 非IE浏览器生效\n\n\t```html\n\t<!--[if !IE]>\n\t这段文字只在非IE浏览器显示\n\t<![endif]-->\n\t```\n\n### 选择器前缀法 ###\n\n阅读了相关文章，觉得基本用不上，不做记录。","source":"_posts/IE hack.md","raw":"# IE hack整理 #\n\n\n\n\n### CSS属性前缀法 ###\n\n\nhack       | browser               |使用\n-----      | ---                   |---\n[*+><]     | IE7                   |用于属性值前\n\\9         | IE6/IE7/IE8/IE9/IE10  |用于属性值前\n\\0         | IE8/IE9/IE10          |用于属性值前\n\\9\\0       | IE9/IE10              |用于属性值前\n\n测试用例：\n\n```css\n＃color{\n\tcolor:#000; /* 所有识别 */\n\tcolor:#000\\9; /* IE识别 */\n\t*color:#000; /* IE7识别 */\n}\n```\n\n### 条件注释法 ###\n\n1. 只在IE下生效\n\n\t```html\n\t<!--[if IE]>\n\t这段文字只在IE浏览器显示\n\t<![endif]-->\n\t```\n\n2. 只在IE6下生效\n\n\t```html\n\t<!--[if IE 6]>\n\t这段文字只在IE6浏览器显示\n\t<![endif]-->\n\t```\n\n3. 只在IE6以上版本生效\n\n\t```html\n\t<!--[if gte IE 6]>\n\t这段文字只在IE6以上(包括)版本IE浏览器显示\n\t<![endif]-->\n\t```\n\n4. 非IE浏览器生效\n\n\t```html\n\t<!--[if !IE]>\n\t这段文字只在非IE浏览器显示\n\t<![endif]-->\n\t```\n\n### 选择器前缀法 ###\n\n阅读了相关文章，觉得基本用不上，不做记录。","slug":"IE hack","published":1,"date":"2021-12-06T06:07:06.123Z","updated":"2021-12-06T06:07:06.123Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokh000gy4v27jmq1l1m","content":"<h1 id=\"IE-hack整理\"><a href=\"#IE-hack整理\" class=\"headerlink\" title=\"IE hack整理\"></a>IE hack整理</h1><h3 id=\"CSS属性前缀法\"><a href=\"#CSS属性前缀法\" class=\"headerlink\" title=\"CSS属性前缀法\"></a>CSS属性前缀法</h3><table>\n<thead>\n<tr>\n<th>hack</th>\n<th>browser</th>\n<th>使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[*+&gt;&lt;]</td>\n<td>IE7</td>\n<td>用于属性值前</td>\n</tr>\n<tr>\n<td>\\9</td>\n<td>IE6/IE7/IE8/IE9/IE10</td>\n<td>用于属性值前</td>\n</tr>\n<tr>\n<td>\\0</td>\n<td>IE8/IE9/IE10</td>\n<td>用于属性值前</td>\n</tr>\n<tr>\n<td>\\9\\0</td>\n<td>IE9/IE10</td>\n<td>用于属性值前</td>\n</tr>\n</tbody></table>\n<p>测试用例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">＃<span class=\"attribute\">color</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">color</span>:<span class=\"number\">#000</span>; <span class=\"comment\">/* 所有识别 */</span></span><br><span class=\"line\">\t<span class=\"attribute\">color</span>:<span class=\"number\">#000</span>\\<span class=\"number\">9</span>; <span class=\"comment\">/* IE识别 */</span></span><br><span class=\"line\">\t*<span class=\"attribute\">color</span>:<span class=\"number\">#000</span>; <span class=\"comment\">/* IE7识别 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件注释法\"><a href=\"#条件注释法\" class=\"headerlink\" title=\"条件注释法\"></a>条件注释法</h3><ol>\n<li><p>只在IE下生效</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">这段文字只在IE浏览器显示</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>只在IE6下生效</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">这段文字只在IE6浏览器显示</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>只在IE6以上版本生效</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if gte IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">这段文字只在IE6以上(包括)版本IE浏览器显示</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>非IE浏览器生效</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if !IE]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">这段文字只在非IE浏览器显示</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"选择器前缀法\"><a href=\"#选择器前缀法\" class=\"headerlink\" title=\"选择器前缀法\"></a>选择器前缀法</h3><p>阅读了相关文章，觉得基本用不上，不做记录。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"IE-hack整理\"><a href=\"#IE-hack整理\" class=\"headerlink\" title=\"IE hack整理\"></a>IE hack整理</h1><h3 id=\"CSS属性前缀法\"><a href=\"#CSS属性前缀法\" class=\"headerlink\" title=\"CSS属性前缀法\"></a>CSS属性前缀法</h3><table>\n<thead>\n<tr>\n<th>hack</th>\n<th>browser</th>\n<th>使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[*+&gt;&lt;]</td>\n<td>IE7</td>\n<td>用于属性值前</td>\n</tr>\n<tr>\n<td>\\9</td>\n<td>IE6/IE7/IE8/IE9/IE10</td>\n<td>用于属性值前</td>\n</tr>\n<tr>\n<td>\\0</td>\n<td>IE8/IE9/IE10</td>\n<td>用于属性值前</td>\n</tr>\n<tr>\n<td>\\9\\0</td>\n<td>IE9/IE10</td>\n<td>用于属性值前</td>\n</tr>\n</tbody></table>\n<p>测试用例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">＃<span class=\"attribute\">color</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">color</span>:<span class=\"number\">#000</span>; <span class=\"comment\">/* 所有识别 */</span></span><br><span class=\"line\">\t<span class=\"attribute\">color</span>:<span class=\"number\">#000</span>\\<span class=\"number\">9</span>; <span class=\"comment\">/* IE识别 */</span></span><br><span class=\"line\">\t*<span class=\"attribute\">color</span>:<span class=\"number\">#000</span>; <span class=\"comment\">/* IE7识别 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件注释法\"><a href=\"#条件注释法\" class=\"headerlink\" title=\"条件注释法\"></a>条件注释法</h3><ol>\n<li><p>只在IE下生效</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">这段文字只在IE浏览器显示</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>只在IE6下生效</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">这段文字只在IE6浏览器显示</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>只在IE6以上版本生效</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if gte IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">这段文字只在IE6以上(包括)版本IE浏览器显示</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>非IE浏览器生效</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if !IE]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">这段文字只在非IE浏览器显示</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"选择器前缀法\"><a href=\"#选择器前缀法\" class=\"headerlink\" title=\"选择器前缀法\"></a>选择器前缀法</h3><p>阅读了相关文章，觉得基本用不上，不做记录。</p>\n"},{"title":"Java多态","date":"2016-04-01T08:37:47.000Z","description":"java面向对象","_content":"\n## 万物皆对象\n\nJava 是一门面向对象的语言，其重要的一个思想就是“万物皆对象”。而类是Java 的核心内容，它是一种逻辑结构，定义了对象的结构，可以由一个类得到众多相似的对象。从某种意义上说，类是Java 面向对象性的基础。\n\n<!-- more -->\n\nJava作为一种面向对象语言。支持以下基本概念：\n + 继承\n + 多态\n + 封装\n + 抽象\n + 类\n + 对象\n + 实例\n + 方法\n + 重载\n\n## 多态\n> 多态是面向对象语言的又一重要特性。多态是同一个行为具有多个不同表现形式或形态的能力。多态性是对象多种表现形式的体现。Java的多态更多的是通过动态绑定体现的。\n\n\n下面的程序演示了动态绑定，定义父类Animal 和子类Tiger 以及Fish\n```java\n/**\n * Created by yuzhigang on 2016/4/1.\n */\nclass Animal {\n    String type;\n    String name;\n    int age;\n    int weight;\n    void breath() {\n        System.out.println(\"动物呼吸\");\n    }\n}\nclass Tiger extends Animal {\n    String tigerType;\n    String from;\n    void breath(){\n        System.out.println(\"老虎是用肺呼吸的\");\n    }\n}\nclass Fish extends Animal{\n    String fishType;\n    void breath(){\n        System.out.println(\"鱼是用腮呼吸的\");\n    }\n}\n\npublic class DuoTai {\n    public static void main(String args[ ]){\n        Animal [ ]animal=new Animal[3];\n       //创建不同的对象，但是都存入Animal 的引用中\n        animal[0]=new Animal();\n        animal[1]=new Tiger();\n        animal[2]=new Fish();\n        animal[0].breath();\n        animal[1].breath();\n        animal[2].breath();\n    }\n}\n\n//动物呼吸\n//老虎是用肺呼吸的\n//鱼是用腮呼吸的\n```\n> 动态绑定是一种机制，通过这种机制，对一个已经被重写的方法的调用将会发生在运行时，而不是在编译时解析。\n\n在 Java 中，对象是多态的，定义一个Animal 对象，它既可以存放Animal 对象，也可以存放Animal 的子类Tiger和Fish 的对象。存放在 Animal 数组中的Tiger 对象和Fish 对象在执行breath 方法时会自动地调用原来对象的方法而不是Animal 的breath 方法，这就是动态绑定。\n\n**注意：通过数组元素访问方法的时候只能访问在Animal 中定义的方法，对于Tiger 类和Fish 中定义的方法时却不能调用，比如这里的breath方法在animal中是定义过的**\n\n\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/Java多态.md","raw":"title: Java多态\ntags: [java面向对象]\ndate: 2016-04-01 16:37:47\ndescription: java面向对象\n---\n\n## 万物皆对象\n\nJava 是一门面向对象的语言，其重要的一个思想就是“万物皆对象”。而类是Java 的核心内容，它是一种逻辑结构，定义了对象的结构，可以由一个类得到众多相似的对象。从某种意义上说，类是Java 面向对象性的基础。\n\n<!-- more -->\n\nJava作为一种面向对象语言。支持以下基本概念：\n + 继承\n + 多态\n + 封装\n + 抽象\n + 类\n + 对象\n + 实例\n + 方法\n + 重载\n\n## 多态\n> 多态是面向对象语言的又一重要特性。多态是同一个行为具有多个不同表现形式或形态的能力。多态性是对象多种表现形式的体现。Java的多态更多的是通过动态绑定体现的。\n\n\n下面的程序演示了动态绑定，定义父类Animal 和子类Tiger 以及Fish\n```java\n/**\n * Created by yuzhigang on 2016/4/1.\n */\nclass Animal {\n    String type;\n    String name;\n    int age;\n    int weight;\n    void breath() {\n        System.out.println(\"动物呼吸\");\n    }\n}\nclass Tiger extends Animal {\n    String tigerType;\n    String from;\n    void breath(){\n        System.out.println(\"老虎是用肺呼吸的\");\n    }\n}\nclass Fish extends Animal{\n    String fishType;\n    void breath(){\n        System.out.println(\"鱼是用腮呼吸的\");\n    }\n}\n\npublic class DuoTai {\n    public static void main(String args[ ]){\n        Animal [ ]animal=new Animal[3];\n       //创建不同的对象，但是都存入Animal 的引用中\n        animal[0]=new Animal();\n        animal[1]=new Tiger();\n        animal[2]=new Fish();\n        animal[0].breath();\n        animal[1].breath();\n        animal[2].breath();\n    }\n}\n\n//动物呼吸\n//老虎是用肺呼吸的\n//鱼是用腮呼吸的\n```\n> 动态绑定是一种机制，通过这种机制，对一个已经被重写的方法的调用将会发生在运行时，而不是在编译时解析。\n\n在 Java 中，对象是多态的，定义一个Animal 对象，它既可以存放Animal 对象，也可以存放Animal 的子类Tiger和Fish 的对象。存放在 Animal 数组中的Tiger 对象和Fish 对象在执行breath 方法时会自动地调用原来对象的方法而不是Animal 的breath 方法，这就是动态绑定。\n\n**注意：通过数组元素访问方法的时候只能访问在Animal 中定义的方法，对于Tiger 类和Fish 中定义的方法时却不能调用，比如这里的breath方法在animal中是定义过的**\n\n\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"Java多态","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoki000hy4v20nyv73kq","content":"<h2 id=\"万物皆对象\"><a href=\"#万物皆对象\" class=\"headerlink\" title=\"万物皆对象\"></a>万物皆对象</h2><p>Java 是一门面向对象的语言，其重要的一个思想就是“万物皆对象”。而类是Java 的核心内容，它是一种逻辑结构，定义了对象的结构，可以由一个类得到众多相似的对象。从某种意义上说，类是Java 面向对象性的基础。</p>\n<span id=\"more\"></span>\n\n<p>Java作为一种面向对象语言。支持以下基本概念：</p>\n<ul>\n<li>继承</li>\n<li>多态</li>\n<li>封装</li>\n<li>抽象</li>\n<li>类</li>\n<li>对象</li>\n<li>实例</li>\n<li>方法</li>\n<li>重载</li>\n</ul>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><blockquote>\n<p>多态是面向对象语言的又一重要特性。多态是同一个行为具有多个不同表现形式或形态的能力。多态性是对象多种表现形式的体现。Java的多态更多的是通过动态绑定体现的。</p>\n</blockquote>\n<p>下面的程序演示了动态绑定，定义父类Animal 和子类Tiger 以及Fish</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by yuzhigang on 2016/4/1.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    String type;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">breath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;动物呼吸&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tiger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    String tigerType;</span><br><span class=\"line\">    String from;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">breath</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;老虎是用肺呼吸的&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fish</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    String fishType;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">breath</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;鱼是用腮呼吸的&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DuoTai</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[ ])</span></span>&#123;</span><br><span class=\"line\">        Animal [ ]animal=<span class=\"keyword\">new</span> Animal[<span class=\"number\">3</span>];</span><br><span class=\"line\">       <span class=\"comment\">//创建不同的对象，但是都存入Animal 的引用中</span></span><br><span class=\"line\">        animal[<span class=\"number\">0</span>]=<span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">        animal[<span class=\"number\">1</span>]=<span class=\"keyword\">new</span> Tiger();</span><br><span class=\"line\">        animal[<span class=\"number\">2</span>]=<span class=\"keyword\">new</span> Fish();</span><br><span class=\"line\">        animal[<span class=\"number\">0</span>].breath();</span><br><span class=\"line\">        animal[<span class=\"number\">1</span>].breath();</span><br><span class=\"line\">        animal[<span class=\"number\">2</span>].breath();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//动物呼吸</span></span><br><span class=\"line\"><span class=\"comment\">//老虎是用肺呼吸的</span></span><br><span class=\"line\"><span class=\"comment\">//鱼是用腮呼吸的</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>动态绑定是一种机制，通过这种机制，对一个已经被重写的方法的调用将会发生在运行时，而不是在编译时解析。</p>\n</blockquote>\n<p>在 Java 中，对象是多态的，定义一个Animal 对象，它既可以存放Animal 对象，也可以存放Animal 的子类Tiger和Fish 的对象。存放在 Animal 数组中的Tiger 对象和Fish 对象在执行breath 方法时会自动地调用原来对象的方法而不是Animal 的breath 方法，这就是动态绑定。</p>\n<p><strong>注意：通过数组元素访问方法的时候只能访问在Animal 中定义的方法，对于Tiger 类和Fish 中定义的方法时却不能调用，比如这里的breath方法在animal中是定义过的</strong></p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"万物皆对象\"><a href=\"#万物皆对象\" class=\"headerlink\" title=\"万物皆对象\"></a>万物皆对象</h2><p>Java 是一门面向对象的语言，其重要的一个思想就是“万物皆对象”。而类是Java 的核心内容，它是一种逻辑结构，定义了对象的结构，可以由一个类得到众多相似的对象。从某种意义上说，类是Java 面向对象性的基础。</p>","more":"<p>Java作为一种面向对象语言。支持以下基本概念：</p>\n<ul>\n<li>继承</li>\n<li>多态</li>\n<li>封装</li>\n<li>抽象</li>\n<li>类</li>\n<li>对象</li>\n<li>实例</li>\n<li>方法</li>\n<li>重载</li>\n</ul>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><blockquote>\n<p>多态是面向对象语言的又一重要特性。多态是同一个行为具有多个不同表现形式或形态的能力。多态性是对象多种表现形式的体现。Java的多态更多的是通过动态绑定体现的。</p>\n</blockquote>\n<p>下面的程序演示了动态绑定，定义父类Animal 和子类Tiger 以及Fish</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by yuzhigang on 2016/4/1.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    String type;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">breath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;动物呼吸&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tiger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    String tigerType;</span><br><span class=\"line\">    String from;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">breath</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;老虎是用肺呼吸的&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fish</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    String fishType;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">breath</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;鱼是用腮呼吸的&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DuoTai</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[ ])</span></span>&#123;</span><br><span class=\"line\">        Animal [ ]animal=<span class=\"keyword\">new</span> Animal[<span class=\"number\">3</span>];</span><br><span class=\"line\">       <span class=\"comment\">//创建不同的对象，但是都存入Animal 的引用中</span></span><br><span class=\"line\">        animal[<span class=\"number\">0</span>]=<span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">        animal[<span class=\"number\">1</span>]=<span class=\"keyword\">new</span> Tiger();</span><br><span class=\"line\">        animal[<span class=\"number\">2</span>]=<span class=\"keyword\">new</span> Fish();</span><br><span class=\"line\">        animal[<span class=\"number\">0</span>].breath();</span><br><span class=\"line\">        animal[<span class=\"number\">1</span>].breath();</span><br><span class=\"line\">        animal[<span class=\"number\">2</span>].breath();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//动物呼吸</span></span><br><span class=\"line\"><span class=\"comment\">//老虎是用肺呼吸的</span></span><br><span class=\"line\"><span class=\"comment\">//鱼是用腮呼吸的</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>动态绑定是一种机制，通过这种机制，对一个已经被重写的方法的调用将会发生在运行时，而不是在编译时解析。</p>\n</blockquote>\n<p>在 Java 中，对象是多态的，定义一个Animal 对象，它既可以存放Animal 对象，也可以存放Animal 的子类Tiger和Fish 的对象。存放在 Animal 数组中的Tiger 对象和Fish 对象在执行breath 方法时会自动地调用原来对象的方法而不是Animal 的breath 方法，这就是动态绑定。</p>\n<p><strong>注意：通过数组元素访问方法的时候只能访问在Animal 中定义的方法，对于Tiger 类和Fish 中定义的方法时却不能调用，比如这里的breath方法在animal中是定义过的</strong></p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"Java封装","date":"2016-04-05T07:52:54.000Z","description":"Java封装","_content":"\n封装（Encapsulation）一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。\n封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n<!-- more -->\n\n### 实现\n```java\npublic class EncapTest{\n    private int age;\n    public int getAge(){\n        return age;\n    }\n    public void setAge( int newAge){\n        age = newAge;\n    }\n}\n```\n上面的例子中，定义了一个私有变量和一个public函数。public方法是外部类访问该类成员变量的入口。通常情况下，这些方法被称为getter和setter方法。因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。\n\n通过如下的例子说明EncapTest类的变量怎样被访问：\n\n```java\npublic static void main(String args[]){\n        EncapTest encap = new EncapTest();\n        encap.setAge(20);\n        System.out.print(\"age : \" + encap.getAge());\n}\n```\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/Java封装.md","raw":"title: Java封装\ntags: [java面向对象]\ndate: 2016-04-05 15:52:54\ndescription: Java封装\n---\n\n封装（Encapsulation）一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。\n封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n<!-- more -->\n\n### 实现\n```java\npublic class EncapTest{\n    private int age;\n    public int getAge(){\n        return age;\n    }\n    public void setAge( int newAge){\n        age = newAge;\n    }\n}\n```\n上面的例子中，定义了一个私有变量和一个public函数。public方法是外部类访问该类成员变量的入口。通常情况下，这些方法被称为getter和setter方法。因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。\n\n通过如下的例子说明EncapTest类的变量怎样被访问：\n\n```java\npublic static void main(String args[]){\n        EncapTest encap = new EncapTest();\n        encap.setAge(20);\n        System.out.print(\"age : \" + encap.getAge());\n}\n```\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"Java封装","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokj000jy4v20jr10nhr","content":"<p>封装（Encapsulation）一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。<br>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EncapTest</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">( <span class=\"keyword\">int</span> newAge)</span></span>&#123;</span><br><span class=\"line\">        age = newAge;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子中，定义了一个私有变量和一个public函数。public方法是外部类访问该类成员变量的入口。通常情况下，这些方法被称为getter和setter方法。因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。</p>\n<p>通过如下的例子说明EncapTest类的变量怎样被访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</span><br><span class=\"line\">        EncapTest encap = <span class=\"keyword\">new</span> EncapTest();</span><br><span class=\"line\">        encap.setAge(<span class=\"number\">20</span>);</span><br><span class=\"line\">        System.out.print(<span class=\"string\">&quot;age : &quot;</span> + encap.getAge());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>封装（Encapsulation）一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。<br>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>","more":"<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EncapTest</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">( <span class=\"keyword\">int</span> newAge)</span></span>&#123;</span><br><span class=\"line\">        age = newAge;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子中，定义了一个私有变量和一个public函数。public方法是外部类访问该类成员变量的入口。通常情况下，这些方法被称为getter和setter方法。因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。</p>\n<p>通过如下的例子说明EncapTest类的变量怎样被访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</span><br><span class=\"line\">        EncapTest encap = <span class=\"keyword\">new</span> EncapTest();</span><br><span class=\"line\">        encap.setAge(<span class=\"number\">20</span>);</span><br><span class=\"line\">        System.out.print(<span class=\"string\">&quot;age : &quot;</span> + encap.getAge());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"Java基本语言","date":"2016-03-28T06:27:08.000Z","description":"Java基本语言","_content":"本章主要包括java的基本语言要素、基本数据类型、变量和常量、数据类型转换以及运算符和表达式。\n<!-- more -->\n## 基本语言要素\n1.标示符\n  标识符给定义的类、方法或者变量等起的名称。\n+ 标识符由大小写字母、数字、下划线（_）和美元符号（$）组成，但\n是不能以数字开头。\n+ 标识符是严格区分大小写的，Hello 和HELLO 是完全不同的标识符\n+ 其他约定俗成：\n + 包名：使用小写字母\n + 类名和接口名：通常定义为由具有含义的单词组成，所有单词的首字母大写。\n + 方法名：通常也是由具有含义的单词组成，第一个单词首字母小写，其他单词的首\n + 字母都大写。\n + 变量名：成员变量和方法相同，局部变量全部使用小写。\n + 常量名：全部使用大写，最好使用下划线分隔单词。\n\n2.关键字\n+ 访问修饰符关键字\n + public：所修饰的类、方法和变量是公共的，其他类可以访问该关键字修饰的类、方法或者变量。\n + protected：用于修饰方法和变量。这些方法和变量可以被同一个包中的类或者子类进行访问。\n + private：同样修饰方法和变量。方法和变量只能由所在类进行访问。\n+ 类、方法和变量修饰符关键字\n + class：告诉系统后面的单词是一个类名，从而定义一个类。\n + interface：告诉系统后面的单词是一个接口名，从而定义一个接口。\n + implements：让类实现接口。\n + extends：用于继承。\n + abstract：抽象修饰符。\n + static：静态修饰符。\n + new：实例化对象。\n+ 流程控制关键字\n + if-else\n + switch-case-default\n + for\n + do-while\n + break\n + continue\n + ruturn\n + instanceof 用于判断对象是否是类或者接口的实例。\n+ 异常处理关键字\n + try-catch-finally\n + throw\n + throws\n + assert\n+ 包控制关键字\n + importinport 用于将包或者类导入到\n + pachage 用于定义包，并将类定义到这个包中。\n+ 数据类型关键字\nboolean、char、byte和数值型（short、int、long、float 和double）。\n+ 特殊类型和方法关键字\n + super 关键字用于引用父类，\n + this 关键字用于应用当前类对象。\n + void 关键字用于定义一般方法，该方法没有任何返回值。\n+ 没有使用的关键字\nconst和goto\n\n3.注释\n+ 单行注释 `//`\n+ 多行注释 `/* */`\n+ 文档注释 `/** */`\n\n## 基本数据类型\nJava 是一门强数据类型语言，Java 程序中定义的所有数据都有一个固定的数据类型。\n\n1.整数类型\n整数类型标示的是整数\n\n| 整数类型       |    位数  | 取值范围      |\n| :--:           | :--:     | :--:          |\n| byte（字节型） |    8     |  -2^7~2^7-1   |\n| short（短整型）|   16     |  -2^15~2^15-1 |\n| int（整型）    |    32    | -2^31~2^31-1  |\n|long（长整型）  |    64    | -2^63~2^63-1  |\n\n2.浮点类型\n浮点类型表示的是浮点数（小数）。\n\n| 浮点类型                  |    位数  | 取值范围           |\n| :--:                      | :--:     | :--:               |\n| float（单精度浮点类型）   |    32    |  1.4e-45~3.4e+38   |\n| double（双精度浮点类型）  |   64     |  4.9e-324~1.7e+308 |\n\n3.字符类型（char）\n4.布尔类型（boolean）\n\n\n## 变量和常量\n常量表示不能改变的数值，而变量表示能够改变的数值。\n\n+ 声明变量：变量类型、变量名以及变量值。\n+ 声明常量：final、常量类型、常量名以及常量值。\n```\npublic static void main(String[ ] args) {\n    final double PI=3.14; //定义一个表示PI 的常量\n    int R=5; //定义一个表示半径的变量\n    double ymj=PI*R*R; //计算圆的面积\n    System.out.println(\"圆的面积等于\"+ymj);\n}\n```\n\n## 数据类型转换\n1.自动类型转换\n + 的数据类型要兼容\n + 转换前的数据类型的位数要低于转换后的数据类型的位数\n```\npublic static void main(String[ ] args) {\n    char c1='a'; //定义一个char 类型\n    int i1=c1; //char自动类型转换为int\n    System.out.println(\"char 自动类型转换为int 后的值等于\"+i1);\n    char c2='A'; //定义一个char 类型\n    int i2=c2+1; //char 类型和int 类型计算\n    System.out.println(\"char 类型和int 类型计算后的值等于\"+i2);\n}\n```\n2.强制类型转换\n+ 转换的数据类型必须兼容\n```\npublic static void main(String[] args){\n    int i = 3;\n    byte j = (byte)i;\n    System.out.println(\"int强制类型转换byte 后值等于\"+j);\n}\n```\n3.隐含强制类型转换\n```\nbyte b=123;\n```\n123 这个数据的类型是int 类型，而定义的b 这个变量是byte 类型。按照前面的理论，这种是需要进行强制类型转换的。这样Java 就提供这种隐含强制类型转换机制，这个工作不再由程序来完成，而是Java 系统自动完成。\n\n## 运算符和表达式\n1.算数运算符\n算术运算符就是用于计算的运算符，包括加（+）、减（-）、乘（*）、除（/）等数学中最基本的运算，还包括数学中没有的求余运算（%）。\n\n2.自增自减运算符\n\n自增自减运算符可以算是一种特殊的算术运算符。在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数，自增运算符`++`表示该操作数递增加1，自减`--`运算符表示该操作数递增减1\n + 前缀方式：先进行自增或者自减运算，再进行表达式运算。\n + 后缀方式：先进行表达式运算，后进行自增或者自减运算。\n\n3.比较运算符\n关系运算符用于计算两个操作数之间的关系，其结果是布尔类型。关系运算符包括等于（==）、不等于（!=）、大于（>）、大于等于（>=）、小于（<）和小于等于（<=）\n\n4.赋值运算符\n + `=`\n + `+=`\n + `-=`\n + `*=`\n + `/=`\n + `%=`\n\n5.逻辑运算符\n + 与（&&）\n + 或（||）\n + 异或（^）\n + 非（!）\n\n6.移位运算符\n+ `<<` 左移运算符 用于将第一个操作数的比特位向左移动第二个操作数指定的位数。\n+ `>>` 右移运算符 用于将第一个操作数的比特位向右移动第二个操作数指定的位数。\n+ `>>>` 无符号右移 和右移运算符的规则是一样的，只是填充时，不管原数是正或是负，都使用0 来填充。\n\n7.条件运算符（三元运算符）\nexpression? statement : statement2\n\n8.运算符优先级\n\n| 运算符         |   优先级                |\n| :--:           | :--:                    |\n| 1              |    ()                   |\n| 2              | !、+(正)、-(负)、++、-- |\n| 3              |    *、/、%              |\n| 4              |    +(加)、-（减）       |\n| 5              |    <、<=、>、=>         |\n| 6              |    ==、!=               |\n| 7              |    ^                    |\n| 8              |    &&                   |\n| 9              |           或            |\n| 10             |    ?:                   |\n| 11             |    =、+=、-=、*=、/=、%=|\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/Java基本语言.md","raw":"title: Java基本语言\ntags: [java基础]\ndate: 2016-03-28 14:27:08\ndescription: Java基本语言\n---\n本章主要包括java的基本语言要素、基本数据类型、变量和常量、数据类型转换以及运算符和表达式。\n<!-- more -->\n## 基本语言要素\n1.标示符\n  标识符给定义的类、方法或者变量等起的名称。\n+ 标识符由大小写字母、数字、下划线（_）和美元符号（$）组成，但\n是不能以数字开头。\n+ 标识符是严格区分大小写的，Hello 和HELLO 是完全不同的标识符\n+ 其他约定俗成：\n + 包名：使用小写字母\n + 类名和接口名：通常定义为由具有含义的单词组成，所有单词的首字母大写。\n + 方法名：通常也是由具有含义的单词组成，第一个单词首字母小写，其他单词的首\n + 字母都大写。\n + 变量名：成员变量和方法相同，局部变量全部使用小写。\n + 常量名：全部使用大写，最好使用下划线分隔单词。\n\n2.关键字\n+ 访问修饰符关键字\n + public：所修饰的类、方法和变量是公共的，其他类可以访问该关键字修饰的类、方法或者变量。\n + protected：用于修饰方法和变量。这些方法和变量可以被同一个包中的类或者子类进行访问。\n + private：同样修饰方法和变量。方法和变量只能由所在类进行访问。\n+ 类、方法和变量修饰符关键字\n + class：告诉系统后面的单词是一个类名，从而定义一个类。\n + interface：告诉系统后面的单词是一个接口名，从而定义一个接口。\n + implements：让类实现接口。\n + extends：用于继承。\n + abstract：抽象修饰符。\n + static：静态修饰符。\n + new：实例化对象。\n+ 流程控制关键字\n + if-else\n + switch-case-default\n + for\n + do-while\n + break\n + continue\n + ruturn\n + instanceof 用于判断对象是否是类或者接口的实例。\n+ 异常处理关键字\n + try-catch-finally\n + throw\n + throws\n + assert\n+ 包控制关键字\n + importinport 用于将包或者类导入到\n + pachage 用于定义包，并将类定义到这个包中。\n+ 数据类型关键字\nboolean、char、byte和数值型（short、int、long、float 和double）。\n+ 特殊类型和方法关键字\n + super 关键字用于引用父类，\n + this 关键字用于应用当前类对象。\n + void 关键字用于定义一般方法，该方法没有任何返回值。\n+ 没有使用的关键字\nconst和goto\n\n3.注释\n+ 单行注释 `//`\n+ 多行注释 `/* */`\n+ 文档注释 `/** */`\n\n## 基本数据类型\nJava 是一门强数据类型语言，Java 程序中定义的所有数据都有一个固定的数据类型。\n\n1.整数类型\n整数类型标示的是整数\n\n| 整数类型       |    位数  | 取值范围      |\n| :--:           | :--:     | :--:          |\n| byte（字节型） |    8     |  -2^7~2^7-1   |\n| short（短整型）|   16     |  -2^15~2^15-1 |\n| int（整型）    |    32    | -2^31~2^31-1  |\n|long（长整型）  |    64    | -2^63~2^63-1  |\n\n2.浮点类型\n浮点类型表示的是浮点数（小数）。\n\n| 浮点类型                  |    位数  | 取值范围           |\n| :--:                      | :--:     | :--:               |\n| float（单精度浮点类型）   |    32    |  1.4e-45~3.4e+38   |\n| double（双精度浮点类型）  |   64     |  4.9e-324~1.7e+308 |\n\n3.字符类型（char）\n4.布尔类型（boolean）\n\n\n## 变量和常量\n常量表示不能改变的数值，而变量表示能够改变的数值。\n\n+ 声明变量：变量类型、变量名以及变量值。\n+ 声明常量：final、常量类型、常量名以及常量值。\n```\npublic static void main(String[ ] args) {\n    final double PI=3.14; //定义一个表示PI 的常量\n    int R=5; //定义一个表示半径的变量\n    double ymj=PI*R*R; //计算圆的面积\n    System.out.println(\"圆的面积等于\"+ymj);\n}\n```\n\n## 数据类型转换\n1.自动类型转换\n + 的数据类型要兼容\n + 转换前的数据类型的位数要低于转换后的数据类型的位数\n```\npublic static void main(String[ ] args) {\n    char c1='a'; //定义一个char 类型\n    int i1=c1; //char自动类型转换为int\n    System.out.println(\"char 自动类型转换为int 后的值等于\"+i1);\n    char c2='A'; //定义一个char 类型\n    int i2=c2+1; //char 类型和int 类型计算\n    System.out.println(\"char 类型和int 类型计算后的值等于\"+i2);\n}\n```\n2.强制类型转换\n+ 转换的数据类型必须兼容\n```\npublic static void main(String[] args){\n    int i = 3;\n    byte j = (byte)i;\n    System.out.println(\"int强制类型转换byte 后值等于\"+j);\n}\n```\n3.隐含强制类型转换\n```\nbyte b=123;\n```\n123 这个数据的类型是int 类型，而定义的b 这个变量是byte 类型。按照前面的理论，这种是需要进行强制类型转换的。这样Java 就提供这种隐含强制类型转换机制，这个工作不再由程序来完成，而是Java 系统自动完成。\n\n## 运算符和表达式\n1.算数运算符\n算术运算符就是用于计算的运算符，包括加（+）、减（-）、乘（*）、除（/）等数学中最基本的运算，还包括数学中没有的求余运算（%）。\n\n2.自增自减运算符\n\n自增自减运算符可以算是一种特殊的算术运算符。在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数，自增运算符`++`表示该操作数递增加1，自减`--`运算符表示该操作数递增减1\n + 前缀方式：先进行自增或者自减运算，再进行表达式运算。\n + 后缀方式：先进行表达式运算，后进行自增或者自减运算。\n\n3.比较运算符\n关系运算符用于计算两个操作数之间的关系，其结果是布尔类型。关系运算符包括等于（==）、不等于（!=）、大于（>）、大于等于（>=）、小于（<）和小于等于（<=）\n\n4.赋值运算符\n + `=`\n + `+=`\n + `-=`\n + `*=`\n + `/=`\n + `%=`\n\n5.逻辑运算符\n + 与（&&）\n + 或（||）\n + 异或（^）\n + 非（!）\n\n6.移位运算符\n+ `<<` 左移运算符 用于将第一个操作数的比特位向左移动第二个操作数指定的位数。\n+ `>>` 右移运算符 用于将第一个操作数的比特位向右移动第二个操作数指定的位数。\n+ `>>>` 无符号右移 和右移运算符的规则是一样的，只是填充时，不管原数是正或是负，都使用0 来填充。\n\n7.条件运算符（三元运算符）\nexpression? statement : statement2\n\n8.运算符优先级\n\n| 运算符         |   优先级                |\n| :--:           | :--:                    |\n| 1              |    ()                   |\n| 2              | !、+(正)、-(负)、++、-- |\n| 3              |    *、/、%              |\n| 4              |    +(加)、-（减）       |\n| 5              |    <、<=、>、=>         |\n| 6              |    ==、!=               |\n| 7              |    ^                    |\n| 8              |    &&                   |\n| 9              |           或            |\n| 10             |    ?:                   |\n| 11             |    =、+=、-=、*=、/=、%=|\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"Java基本语言","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokk000ly4v26o91g8eh","content":"<p>本章主要包括java的基本语言要素、基本数据类型、变量和常量、数据类型转换以及运算符和表达式。</p>\n<span id=\"more\"></span>\n<h2 id=\"基本语言要素\"><a href=\"#基本语言要素\" class=\"headerlink\" title=\"基本语言要素\"></a>基本语言要素</h2><p>1.标示符<br>  标识符给定义的类、方法或者变量等起的名称。</p>\n<ul>\n<li>标识符由大小写字母、数字、下划线（_）和美元符号（$）组成，但<br>是不能以数字开头。</li>\n<li>标识符是严格区分大小写的，Hello 和HELLO 是完全不同的标识符</li>\n<li>其他约定俗成：</li>\n<li>包名：使用小写字母</li>\n<li>类名和接口名：通常定义为由具有含义的单词组成，所有单词的首字母大写。</li>\n<li>方法名：通常也是由具有含义的单词组成，第一个单词首字母小写，其他单词的首</li>\n<li>字母都大写。</li>\n<li>变量名：成员变量和方法相同，局部变量全部使用小写。</li>\n<li>常量名：全部使用大写，最好使用下划线分隔单词。</li>\n</ul>\n<p>2.关键字</p>\n<ul>\n<li>访问修饰符关键字</li>\n<li>public：所修饰的类、方法和变量是公共的，其他类可以访问该关键字修饰的类、方法或者变量。</li>\n<li>protected：用于修饰方法和变量。这些方法和变量可以被同一个包中的类或者子类进行访问。</li>\n<li>private：同样修饰方法和变量。方法和变量只能由所在类进行访问。</li>\n<li>类、方法和变量修饰符关键字</li>\n<li>class：告诉系统后面的单词是一个类名，从而定义一个类。</li>\n<li>interface：告诉系统后面的单词是一个接口名，从而定义一个接口。</li>\n<li>implements：让类实现接口。</li>\n<li>extends：用于继承。</li>\n<li>abstract：抽象修饰符。</li>\n<li>static：静态修饰符。</li>\n<li>new：实例化对象。</li>\n<li>流程控制关键字</li>\n<li>if-else</li>\n<li>switch-case-default</li>\n<li>for</li>\n<li>do-while</li>\n<li>break</li>\n<li>continue</li>\n<li>ruturn</li>\n<li>instanceof 用于判断对象是否是类或者接口的实例。</li>\n<li>异常处理关键字</li>\n<li>try-catch-finally</li>\n<li>throw</li>\n<li>throws</li>\n<li>assert</li>\n<li>包控制关键字</li>\n<li>importinport 用于将包或者类导入到</li>\n<li>pachage 用于定义包，并将类定义到这个包中。</li>\n<li>数据类型关键字<br>boolean、char、byte和数值型（short、int、long、float 和double）。</li>\n<li>特殊类型和方法关键字</li>\n<li>super 关键字用于引用父类，</li>\n<li>this 关键字用于应用当前类对象。</li>\n<li>void 关键字用于定义一般方法，该方法没有任何返回值。</li>\n<li>没有使用的关键字<br>const和goto</li>\n</ul>\n<p>3.注释</p>\n<ul>\n<li>单行注释 <code>//</code></li>\n<li>多行注释 <code>/* */</code></li>\n<li>文档注释 <code>/** */</code></li>\n</ul>\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><p>Java 是一门强数据类型语言，Java 程序中定义的所有数据都有一个固定的数据类型。</p>\n<p>1.整数类型<br>整数类型标示的是整数</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">整数类型</th>\n<th align=\"center\">位数</th>\n<th align=\"center\">取值范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">byte（字节型）</td>\n<td align=\"center\">8</td>\n<td align=\"center\">-2^7~2^7-1</td>\n</tr>\n<tr>\n<td align=\"center\">short（短整型）</td>\n<td align=\"center\">16</td>\n<td align=\"center\">-2^15~2^15-1</td>\n</tr>\n<tr>\n<td align=\"center\">int（整型）</td>\n<td align=\"center\">32</td>\n<td align=\"center\">-2^31~2^31-1</td>\n</tr>\n<tr>\n<td align=\"center\">long（长整型）</td>\n<td align=\"center\">64</td>\n<td align=\"center\">-2^63~2^63-1</td>\n</tr>\n</tbody></table>\n<p>2.浮点类型<br>浮点类型表示的是浮点数（小数）。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">浮点类型</th>\n<th align=\"center\">位数</th>\n<th align=\"center\">取值范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">float（单精度浮点类型）</td>\n<td align=\"center\">32</td>\n<td align=\"center\">1.4e-45~3.4e+38</td>\n</tr>\n<tr>\n<td align=\"center\">double（双精度浮点类型）</td>\n<td align=\"center\">64</td>\n<td align=\"center\">4.9e-324~1.7e+308</td>\n</tr>\n</tbody></table>\n<p>3.字符类型（char）<br>4.布尔类型（boolean）</p>\n<h2 id=\"变量和常量\"><a href=\"#变量和常量\" class=\"headerlink\" title=\"变量和常量\"></a>变量和常量</h2><p>常量表示不能改变的数值，而变量表示能够改变的数值。</p>\n<ul>\n<li>声明变量：变量类型、变量名以及变量值。</li>\n<li>声明常量：final、常量类型、常量名以及常量值。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[ ] args) &#123;</span><br><span class=\"line\">    final double PI=3.14; //定义一个表示PI 的常量</span><br><span class=\"line\">    int R=5; //定义一个表示半径的变量</span><br><span class=\"line\">    double ymj=PI*R*R; //计算圆的面积</span><br><span class=\"line\">    System.out.println(&quot;圆的面积等于&quot;+ymj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h2><p>1.自动类型转换</p>\n<ul>\n<li>的数据类型要兼容</li>\n<li>转换前的数据类型的位数要低于转换后的数据类型的位数<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[ ] args) &#123;</span><br><span class=\"line\">    char c1=&#x27;a&#x27;; //定义一个char 类型</span><br><span class=\"line\">    int i1=c1; //char自动类型转换为int</span><br><span class=\"line\">    System.out.println(&quot;char 自动类型转换为int 后的值等于&quot;+i1);</span><br><span class=\"line\">    char c2=&#x27;A&#x27;; //定义一个char 类型</span><br><span class=\"line\">    int i2=c2+1; //char 类型和int 类型计算</span><br><span class=\"line\">    System.out.println(&quot;char 类型和int 类型计算后的值等于&quot;+i2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>2.强制类型转换</p>\n<ul>\n<li>转换的数据类型必须兼容<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)&#123;</span><br><span class=\"line\">    int i = 3;</span><br><span class=\"line\">    byte j = (byte)i;</span><br><span class=\"line\">    System.out.println(&quot;int强制类型转换byte 后值等于&quot;+j);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>3.隐含强制类型转换</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte b=123;</span><br></pre></td></tr></table></figure>\n<p>123 这个数据的类型是int 类型，而定义的b 这个变量是byte 类型。按照前面的理论，这种是需要进行强制类型转换的。这样Java 就提供这种隐含强制类型转换机制，这个工作不再由程序来完成，而是Java 系统自动完成。</p>\n<h2 id=\"运算符和表达式\"><a href=\"#运算符和表达式\" class=\"headerlink\" title=\"运算符和表达式\"></a>运算符和表达式</h2><p>1.算数运算符<br>算术运算符就是用于计算的运算符，包括加（+）、减（-）、乘（*）、除（/）等数学中最基本的运算，还包括数学中没有的求余运算（%）。</p>\n<p>2.自增自减运算符</p>\n<p>自增自减运算符可以算是一种特殊的算术运算符。在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数，自增运算符<code>++</code>表示该操作数递增加1，自减<code>--</code>运算符表示该操作数递增减1</p>\n<ul>\n<li>前缀方式：先进行自增或者自减运算，再进行表达式运算。</li>\n<li>后缀方式：先进行表达式运算，后进行自增或者自减运算。</li>\n</ul>\n<p>3.比较运算符<br>关系运算符用于计算两个操作数之间的关系，其结果是布尔类型。关系运算符包括等于（==）、不等于（!=）、大于（&gt;）、大于等于（&gt;=）、小于（&lt;）和小于等于（&lt;=）</p>\n<p>4.赋值运算符</p>\n<ul>\n<li><code>=</code></li>\n<li><code>+=</code></li>\n<li><code>-=</code></li>\n<li><code>*=</code></li>\n<li><code>/=</code></li>\n<li><code>%=</code></li>\n</ul>\n<p>5.逻辑运算符</p>\n<ul>\n<li>与（&amp;&amp;）</li>\n<li>或（||）</li>\n<li>异或（^）</li>\n<li>非（!）</li>\n</ul>\n<p>6.移位运算符</p>\n<ul>\n<li><code>&lt;&lt;</code> 左移运算符 用于将第一个操作数的比特位向左移动第二个操作数指定的位数。</li>\n<li><code>&gt;&gt;</code> 右移运算符 用于将第一个操作数的比特位向右移动第二个操作数指定的位数。</li>\n<li><code>&gt;&gt;&gt;</code> 无符号右移 和右移运算符的规则是一样的，只是填充时，不管原数是正或是负，都使用0 来填充。</li>\n</ul>\n<p>7.条件运算符（三元运算符）<br>expression? statement : statement2</p>\n<p>8.运算符优先级</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">优先级</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">()</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">!、+(正)、-(负)、++、–</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">*、/、%</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">+(加)、-（减）</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">&lt;、&lt;=、&gt;、=&gt;</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">==、!=</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">^</td>\n</tr>\n<tr>\n<td align=\"center\">8</td>\n<td align=\"center\">&amp;&amp;</td>\n</tr>\n<tr>\n<td align=\"center\">9</td>\n<td align=\"center\">或</td>\n</tr>\n<tr>\n<td align=\"center\">10</td>\n<td align=\"center\">?:</td>\n</tr>\n<tr>\n<td align=\"center\">11</td>\n<td align=\"center\">=、+=、-=、*=、/=、%=</td>\n</tr>\n</tbody></table>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>本章主要包括java的基本语言要素、基本数据类型、变量和常量、数据类型转换以及运算符和表达式。</p>","more":"<h2 id=\"基本语言要素\"><a href=\"#基本语言要素\" class=\"headerlink\" title=\"基本语言要素\"></a>基本语言要素</h2><p>1.标示符<br>  标识符给定义的类、方法或者变量等起的名称。</p>\n<ul>\n<li>标识符由大小写字母、数字、下划线（_）和美元符号（$）组成，但<br>是不能以数字开头。</li>\n<li>标识符是严格区分大小写的，Hello 和HELLO 是完全不同的标识符</li>\n<li>其他约定俗成：</li>\n<li>包名：使用小写字母</li>\n<li>类名和接口名：通常定义为由具有含义的单词组成，所有单词的首字母大写。</li>\n<li>方法名：通常也是由具有含义的单词组成，第一个单词首字母小写，其他单词的首</li>\n<li>字母都大写。</li>\n<li>变量名：成员变量和方法相同，局部变量全部使用小写。</li>\n<li>常量名：全部使用大写，最好使用下划线分隔单词。</li>\n</ul>\n<p>2.关键字</p>\n<ul>\n<li>访问修饰符关键字</li>\n<li>public：所修饰的类、方法和变量是公共的，其他类可以访问该关键字修饰的类、方法或者变量。</li>\n<li>protected：用于修饰方法和变量。这些方法和变量可以被同一个包中的类或者子类进行访问。</li>\n<li>private：同样修饰方法和变量。方法和变量只能由所在类进行访问。</li>\n<li>类、方法和变量修饰符关键字</li>\n<li>class：告诉系统后面的单词是一个类名，从而定义一个类。</li>\n<li>interface：告诉系统后面的单词是一个接口名，从而定义一个接口。</li>\n<li>implements：让类实现接口。</li>\n<li>extends：用于继承。</li>\n<li>abstract：抽象修饰符。</li>\n<li>static：静态修饰符。</li>\n<li>new：实例化对象。</li>\n<li>流程控制关键字</li>\n<li>if-else</li>\n<li>switch-case-default</li>\n<li>for</li>\n<li>do-while</li>\n<li>break</li>\n<li>continue</li>\n<li>ruturn</li>\n<li>instanceof 用于判断对象是否是类或者接口的实例。</li>\n<li>异常处理关键字</li>\n<li>try-catch-finally</li>\n<li>throw</li>\n<li>throws</li>\n<li>assert</li>\n<li>包控制关键字</li>\n<li>importinport 用于将包或者类导入到</li>\n<li>pachage 用于定义包，并将类定义到这个包中。</li>\n<li>数据类型关键字<br>boolean、char、byte和数值型（short、int、long、float 和double）。</li>\n<li>特殊类型和方法关键字</li>\n<li>super 关键字用于引用父类，</li>\n<li>this 关键字用于应用当前类对象。</li>\n<li>void 关键字用于定义一般方法，该方法没有任何返回值。</li>\n<li>没有使用的关键字<br>const和goto</li>\n</ul>\n<p>3.注释</p>\n<ul>\n<li>单行注释 <code>//</code></li>\n<li>多行注释 <code>/* */</code></li>\n<li>文档注释 <code>/** */</code></li>\n</ul>\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><p>Java 是一门强数据类型语言，Java 程序中定义的所有数据都有一个固定的数据类型。</p>\n<p>1.整数类型<br>整数类型标示的是整数</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">整数类型</th>\n<th align=\"center\">位数</th>\n<th align=\"center\">取值范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">byte（字节型）</td>\n<td align=\"center\">8</td>\n<td align=\"center\">-2^7~2^7-1</td>\n</tr>\n<tr>\n<td align=\"center\">short（短整型）</td>\n<td align=\"center\">16</td>\n<td align=\"center\">-2^15~2^15-1</td>\n</tr>\n<tr>\n<td align=\"center\">int（整型）</td>\n<td align=\"center\">32</td>\n<td align=\"center\">-2^31~2^31-1</td>\n</tr>\n<tr>\n<td align=\"center\">long（长整型）</td>\n<td align=\"center\">64</td>\n<td align=\"center\">-2^63~2^63-1</td>\n</tr>\n</tbody></table>\n<p>2.浮点类型<br>浮点类型表示的是浮点数（小数）。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">浮点类型</th>\n<th align=\"center\">位数</th>\n<th align=\"center\">取值范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">float（单精度浮点类型）</td>\n<td align=\"center\">32</td>\n<td align=\"center\">1.4e-45~3.4e+38</td>\n</tr>\n<tr>\n<td align=\"center\">double（双精度浮点类型）</td>\n<td align=\"center\">64</td>\n<td align=\"center\">4.9e-324~1.7e+308</td>\n</tr>\n</tbody></table>\n<p>3.字符类型（char）<br>4.布尔类型（boolean）</p>\n<h2 id=\"变量和常量\"><a href=\"#变量和常量\" class=\"headerlink\" title=\"变量和常量\"></a>变量和常量</h2><p>常量表示不能改变的数值，而变量表示能够改变的数值。</p>\n<ul>\n<li>声明变量：变量类型、变量名以及变量值。</li>\n<li>声明常量：final、常量类型、常量名以及常量值。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[ ] args) &#123;</span><br><span class=\"line\">    final double PI=3.14; //定义一个表示PI 的常量</span><br><span class=\"line\">    int R=5; //定义一个表示半径的变量</span><br><span class=\"line\">    double ymj=PI*R*R; //计算圆的面积</span><br><span class=\"line\">    System.out.println(&quot;圆的面积等于&quot;+ymj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h2><p>1.自动类型转换</p>\n<ul>\n<li>的数据类型要兼容</li>\n<li>转换前的数据类型的位数要低于转换后的数据类型的位数<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[ ] args) &#123;</span><br><span class=\"line\">    char c1=&#x27;a&#x27;; //定义一个char 类型</span><br><span class=\"line\">    int i1=c1; //char自动类型转换为int</span><br><span class=\"line\">    System.out.println(&quot;char 自动类型转换为int 后的值等于&quot;+i1);</span><br><span class=\"line\">    char c2=&#x27;A&#x27;; //定义一个char 类型</span><br><span class=\"line\">    int i2=c2+1; //char 类型和int 类型计算</span><br><span class=\"line\">    System.out.println(&quot;char 类型和int 类型计算后的值等于&quot;+i2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>2.强制类型转换</p>\n<ul>\n<li>转换的数据类型必须兼容<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)&#123;</span><br><span class=\"line\">    int i = 3;</span><br><span class=\"line\">    byte j = (byte)i;</span><br><span class=\"line\">    System.out.println(&quot;int强制类型转换byte 后值等于&quot;+j);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>3.隐含强制类型转换</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte b=123;</span><br></pre></td></tr></table></figure>\n<p>123 这个数据的类型是int 类型，而定义的b 这个变量是byte 类型。按照前面的理论，这种是需要进行强制类型转换的。这样Java 就提供这种隐含强制类型转换机制，这个工作不再由程序来完成，而是Java 系统自动完成。</p>\n<h2 id=\"运算符和表达式\"><a href=\"#运算符和表达式\" class=\"headerlink\" title=\"运算符和表达式\"></a>运算符和表达式</h2><p>1.算数运算符<br>算术运算符就是用于计算的运算符，包括加（+）、减（-）、乘（*）、除（/）等数学中最基本的运算，还包括数学中没有的求余运算（%）。</p>\n<p>2.自增自减运算符</p>\n<p>自增自减运算符可以算是一种特殊的算术运算符。在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数，自增运算符<code>++</code>表示该操作数递增加1，自减<code>--</code>运算符表示该操作数递增减1</p>\n<ul>\n<li>前缀方式：先进行自增或者自减运算，再进行表达式运算。</li>\n<li>后缀方式：先进行表达式运算，后进行自增或者自减运算。</li>\n</ul>\n<p>3.比较运算符<br>关系运算符用于计算两个操作数之间的关系，其结果是布尔类型。关系运算符包括等于（==）、不等于（!=）、大于（&gt;）、大于等于（&gt;=）、小于（&lt;）和小于等于（&lt;=）</p>\n<p>4.赋值运算符</p>\n<ul>\n<li><code>=</code></li>\n<li><code>+=</code></li>\n<li><code>-=</code></li>\n<li><code>*=</code></li>\n<li><code>/=</code></li>\n<li><code>%=</code></li>\n</ul>\n<p>5.逻辑运算符</p>\n<ul>\n<li>与（&amp;&amp;）</li>\n<li>或（||）</li>\n<li>异或（^）</li>\n<li>非（!）</li>\n</ul>\n<p>6.移位运算符</p>\n<ul>\n<li><code>&lt;&lt;</code> 左移运算符 用于将第一个操作数的比特位向左移动第二个操作数指定的位数。</li>\n<li><code>&gt;&gt;</code> 右移运算符 用于将第一个操作数的比特位向右移动第二个操作数指定的位数。</li>\n<li><code>&gt;&gt;&gt;</code> 无符号右移 和右移运算符的规则是一样的，只是填充时，不管原数是正或是负，都使用0 来填充。</li>\n</ul>\n<p>7.条件运算符（三元运算符）<br>expression? statement : statement2</p>\n<p>8.运算符优先级</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">优先级</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">()</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">!、+(正)、-(负)、++、–</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">*、/、%</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">+(加)、-（减）</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">&lt;、&lt;=、&gt;、=&gt;</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">==、!=</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">^</td>\n</tr>\n<tr>\n<td align=\"center\">8</td>\n<td align=\"center\">&amp;&amp;</td>\n</tr>\n<tr>\n<td align=\"center\">9</td>\n<td align=\"center\">或</td>\n</tr>\n<tr>\n<td align=\"center\">10</td>\n<td align=\"center\">?:</td>\n</tr>\n<tr>\n<td align=\"center\">11</td>\n<td align=\"center\">=、+=、-=、*=、/=、%=</td>\n</tr>\n</tbody></table>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"Java异常处理","date":"2016-04-07T05:37:15.000Z","description":"Java异常处理","_content":"\n由于硬件问题、资源耗尽、输入错误以及程序代码编写不严谨会导致程序运行时产生异常，这些异常会导致程序中断而不能正常继续运行，所以需要对异常的情况进行妥善处理。Java 提供了一套完善的异常处理机制，通过这套机制，可以轻松地写出容错性非常高的代码。\n\n<!-- more -->\n\n## 异常\nJava 的异常实际上是一个对象，这个对象描述了代码中出现的异常情况。在代码运行异常时，在有异常的方法中创建并抛出一个表示异常的对象，然后在相应的异常处理模块中进行处理。\n\n在Java中，所有的异常类是从java.lang.Exception类继承的子类。而Exception类又是Throwable类的子类。除了Exception类外，Throwable还有一个子类Error。如图所示：\n\n![](/images/201601/ErrorClass.png)\n\n+ 它的一个分支是 Error，它定义了Java 运行时的内部错误。通常用Error 类来指明与运行环境相关的错误。应用程序不应该抛出这类异常，发生这类异常时通常是无法处理的，它们在Java程序处理的范畴之外。例如，JVM内存溢出。一般地，程序不会从错误中恢复。\n\n+ 另一分支是 Exception，它用于程序中应该捕获的异常。Exception 类也有两个分支，一个是RuntimeException，另一个分支是IOException。RuntimeException 主要用来描述由于编程产生的错误\n\n**Java有以下三种类型的异常：**\n+ 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。\n+ 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。\n+ 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。\n\n## Java 内置异常类\nJava 语言定义了一些异常类在java.lang标准包中。标准运行时异常类的子类是最常见的异常类。由于java.lang包是默认加载到所有的Java程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。\n\n**非检查性异常**\n![](/images/201601/javaError.png)\n\n**检查性异常类**\n![](/images/201601/javaNotError.png)\n\n## 异常方法\n![](/images/201601/javaErrorMethod.png)\n\n\n**1. 异常捕获**\n使用try和catch关键字可以捕获异常。try-catch代码块放在异常可能发生的地方\n\n> try{\n//可能出现异常代码\n}\ncatch(异常类型1 异常对象)\n{\n//对异常1 的处理\n}\ncatch(异常类型2 异常对象)\n{\n//对异常2 的处理\n}\n┆\ncatch(异常对象n 异常对象)\n{\n//异常对象n 的处理\n}\n\n实例：\n```java\npublic class ExcepTest {\n    public static void main(String args[]){\n        try{\n            int a[] = new int[2];\n            System.out.println(\"Access element three :\" + a[3]);\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"Exception thrown  :\" + e);\n        }\n        System.out.println(\"Out of the block\");\n    }\n}\n//result\n//Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3\n// Out of the block\n```\n**2.获取异常的堆栈信息**\n在异常类中有一个非常重要的方法printStackTrace()，该方法将在Throwable 类中定义，它的作用是把Throwable 对象的堆栈信息输出至输出流。\n示例：\n```\npublic class TestprintStackTraceDemo {\n    public static void main(String args[ ]){\n        try //对method1 方法进行异常处理\n        {\n            method1(); //调用method1 方法\n        }\n        catch(NullPointerException e)\n        {\n            e.printStackTrace(); //获取异常信息\n        }\n    }\n    static void method1()\n    {\n        method2(); //调用method2 方法\n    }\n    static void method2()\n    {\n        method3(); //调用method3 方法\n    }\n    static void method3()\n    {\n        String str=null; //字符串的值为null\n        int n=str.length(); //获取字符串的长度\n    }\n}\n```\n运行结果如下：它打印出了异常的栈信息\n```\njava.lang.NullPointerException\n    at TestprintStackTraceDemo.method3(TestprintStackTraceDemo.java:26)\n    at TestprintStackTraceDemo.method2(TestprintStackTraceDemo.java:21)\n    at TestprintStackTraceDemo.method1(TestprintStackTraceDemo.java:17)\n    at TestprintStackTraceDemo.main(TestprintStackTraceDemo.java:8)\n```\n**3.throws/throw关键字**\n+ throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)throws关键字放在方法签名的尾部。\n+ throw是语句抛出一个异常。\n\n示例：\n```\npublic class className {\n    public static void main(String args[]) throws ArrayIndexOutOfBoundsException{\n        throw new ArrayIndexOutOfBoundsException();\n    }\n}\n```\n**4.finally**\nfinally关键字用来创建在try代码块后面执行的代码块。无论是否发生异常，finally代码块中的代码总会被执行。在finally代码块中，可以运行清理类型等收尾善后性质的语句。finally代码块出现在catch代码块最后，\n> try{\n    // 程序代码\n }catch(异常类型1 异常的变量名1){\n    // 程序代码\n }catch(异常类型2 异常的变量名2){\n    // 程序代码\n }finally{\n    // 程序代码\n }\n\n**Notice:**\n + catch不能独立于try存在。\n + 在try/catch后面添加finally块并非强制性要求的。\n + try代码后不能既没catch块也没finally块。\n + try, catch, finally块之间不能添加任何代码。\n\n\n## 自定义异常类\n在Java中你可以自定义异常。编写自己的异常类时需要记住下面的几点。\n+ 所有异常都必须是Throwable的子类。\n+ 如果希望写一个检查性异常类，则需要继承Exception类。\n+ 如果你想写一个运行时异常类，那么需要继承RuntimeException 类。\n\n示例\n自定义异常类\n```\nclass MyException extends Exception {\n    MyException() {\n    }\n    MyException(String msg) {\n        //调用父类的方法\n        super(msg);\n    }\n}\n```\n使用异常类\n```\npublic class TestMyException {\n    public static void main(String args[ ])\n    {\n        try\n        {\n            String level=null;\n            level=scoreLevel(90);\n            System.out.println(\"90 分的成绩等级为：\"+level);\n            level=scoreLevel(120);\n            System.out.println(\"120 分的成绩等级为：\"+level);\n        }\n        catch(MyException e)\n        {\n            e.printStackTrace();\n        }\n    }\n    static String scoreLevel(int score) throws MyException\n    {\n        if(score>=85&&score<=100)\n            return \"A\";\n        else if(score>=75&&score<85)\n            return \"B\";\n        else if(score>=60&&score<75)\n            return \"C\";\n        else if(score<60&&score>=0)\n            return \"D\";\n        else\n            throw new MyException(\"非法的分数\");\n    }\n}\n```\n\n\n\n## 通用异常\n在Java中定义了两种类型的异常和错误。\n+ JVM(Java虚拟机)异常：由JVM抛出的异常或错误。例如：NullPointerException类，ArrayIndexOutOfBoundsException类，ClassCastException类。\n+ 程序级异常：由程序或者API程序抛出的异常。例如IllegalArgumentException类，IllegalStateException类。\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/Java异常处理.md","raw":"title: Java异常处理\ntags: [java基础]\ndate: 2016-04-07 13:37:15\ndescription: Java异常处理\n---\n\n由于硬件问题、资源耗尽、输入错误以及程序代码编写不严谨会导致程序运行时产生异常，这些异常会导致程序中断而不能正常继续运行，所以需要对异常的情况进行妥善处理。Java 提供了一套完善的异常处理机制，通过这套机制，可以轻松地写出容错性非常高的代码。\n\n<!-- more -->\n\n## 异常\nJava 的异常实际上是一个对象，这个对象描述了代码中出现的异常情况。在代码运行异常时，在有异常的方法中创建并抛出一个表示异常的对象，然后在相应的异常处理模块中进行处理。\n\n在Java中，所有的异常类是从java.lang.Exception类继承的子类。而Exception类又是Throwable类的子类。除了Exception类外，Throwable还有一个子类Error。如图所示：\n\n![](/images/201601/ErrorClass.png)\n\n+ 它的一个分支是 Error，它定义了Java 运行时的内部错误。通常用Error 类来指明与运行环境相关的错误。应用程序不应该抛出这类异常，发生这类异常时通常是无法处理的，它们在Java程序处理的范畴之外。例如，JVM内存溢出。一般地，程序不会从错误中恢复。\n\n+ 另一分支是 Exception，它用于程序中应该捕获的异常。Exception 类也有两个分支，一个是RuntimeException，另一个分支是IOException。RuntimeException 主要用来描述由于编程产生的错误\n\n**Java有以下三种类型的异常：**\n+ 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。\n+ 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。\n+ 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。\n\n## Java 内置异常类\nJava 语言定义了一些异常类在java.lang标准包中。标准运行时异常类的子类是最常见的异常类。由于java.lang包是默认加载到所有的Java程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。\n\n**非检查性异常**\n![](/images/201601/javaError.png)\n\n**检查性异常类**\n![](/images/201601/javaNotError.png)\n\n## 异常方法\n![](/images/201601/javaErrorMethod.png)\n\n\n**1. 异常捕获**\n使用try和catch关键字可以捕获异常。try-catch代码块放在异常可能发生的地方\n\n> try{\n//可能出现异常代码\n}\ncatch(异常类型1 异常对象)\n{\n//对异常1 的处理\n}\ncatch(异常类型2 异常对象)\n{\n//对异常2 的处理\n}\n┆\ncatch(异常对象n 异常对象)\n{\n//异常对象n 的处理\n}\n\n实例：\n```java\npublic class ExcepTest {\n    public static void main(String args[]){\n        try{\n            int a[] = new int[2];\n            System.out.println(\"Access element three :\" + a[3]);\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"Exception thrown  :\" + e);\n        }\n        System.out.println(\"Out of the block\");\n    }\n}\n//result\n//Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3\n// Out of the block\n```\n**2.获取异常的堆栈信息**\n在异常类中有一个非常重要的方法printStackTrace()，该方法将在Throwable 类中定义，它的作用是把Throwable 对象的堆栈信息输出至输出流。\n示例：\n```\npublic class TestprintStackTraceDemo {\n    public static void main(String args[ ]){\n        try //对method1 方法进行异常处理\n        {\n            method1(); //调用method1 方法\n        }\n        catch(NullPointerException e)\n        {\n            e.printStackTrace(); //获取异常信息\n        }\n    }\n    static void method1()\n    {\n        method2(); //调用method2 方法\n    }\n    static void method2()\n    {\n        method3(); //调用method3 方法\n    }\n    static void method3()\n    {\n        String str=null; //字符串的值为null\n        int n=str.length(); //获取字符串的长度\n    }\n}\n```\n运行结果如下：它打印出了异常的栈信息\n```\njava.lang.NullPointerException\n    at TestprintStackTraceDemo.method3(TestprintStackTraceDemo.java:26)\n    at TestprintStackTraceDemo.method2(TestprintStackTraceDemo.java:21)\n    at TestprintStackTraceDemo.method1(TestprintStackTraceDemo.java:17)\n    at TestprintStackTraceDemo.main(TestprintStackTraceDemo.java:8)\n```\n**3.throws/throw关键字**\n+ throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)throws关键字放在方法签名的尾部。\n+ throw是语句抛出一个异常。\n\n示例：\n```\npublic class className {\n    public static void main(String args[]) throws ArrayIndexOutOfBoundsException{\n        throw new ArrayIndexOutOfBoundsException();\n    }\n}\n```\n**4.finally**\nfinally关键字用来创建在try代码块后面执行的代码块。无论是否发生异常，finally代码块中的代码总会被执行。在finally代码块中，可以运行清理类型等收尾善后性质的语句。finally代码块出现在catch代码块最后，\n> try{\n    // 程序代码\n }catch(异常类型1 异常的变量名1){\n    // 程序代码\n }catch(异常类型2 异常的变量名2){\n    // 程序代码\n }finally{\n    // 程序代码\n }\n\n**Notice:**\n + catch不能独立于try存在。\n + 在try/catch后面添加finally块并非强制性要求的。\n + try代码后不能既没catch块也没finally块。\n + try, catch, finally块之间不能添加任何代码。\n\n\n## 自定义异常类\n在Java中你可以自定义异常。编写自己的异常类时需要记住下面的几点。\n+ 所有异常都必须是Throwable的子类。\n+ 如果希望写一个检查性异常类，则需要继承Exception类。\n+ 如果你想写一个运行时异常类，那么需要继承RuntimeException 类。\n\n示例\n自定义异常类\n```\nclass MyException extends Exception {\n    MyException() {\n    }\n    MyException(String msg) {\n        //调用父类的方法\n        super(msg);\n    }\n}\n```\n使用异常类\n```\npublic class TestMyException {\n    public static void main(String args[ ])\n    {\n        try\n        {\n            String level=null;\n            level=scoreLevel(90);\n            System.out.println(\"90 分的成绩等级为：\"+level);\n            level=scoreLevel(120);\n            System.out.println(\"120 分的成绩等级为：\"+level);\n        }\n        catch(MyException e)\n        {\n            e.printStackTrace();\n        }\n    }\n    static String scoreLevel(int score) throws MyException\n    {\n        if(score>=85&&score<=100)\n            return \"A\";\n        else if(score>=75&&score<85)\n            return \"B\";\n        else if(score>=60&&score<75)\n            return \"C\";\n        else if(score<60&&score>=0)\n            return \"D\";\n        else\n            throw new MyException(\"非法的分数\");\n    }\n}\n```\n\n\n\n## 通用异常\n在Java中定义了两种类型的异常和错误。\n+ JVM(Java虚拟机)异常：由JVM抛出的异常或错误。例如：NullPointerException类，ArrayIndexOutOfBoundsException类，ClassCastException类。\n+ 程序级异常：由程序或者API程序抛出的异常。例如IllegalArgumentException类，IllegalStateException类。\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"Java异常处理","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokl000ny4v25azgd4ge","content":"<p>由于硬件问题、资源耗尽、输入错误以及程序代码编写不严谨会导致程序运行时产生异常，这些异常会导致程序中断而不能正常继续运行，所以需要对异常的情况进行妥善处理。Java 提供了一套完善的异常处理机制，通过这套机制，可以轻松地写出容错性非常高的代码。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>Java 的异常实际上是一个对象，这个对象描述了代码中出现的异常情况。在代码运行异常时，在有异常的方法中创建并抛出一个表示异常的对象，然后在相应的异常处理模块中进行处理。</p>\n<p>在Java中，所有的异常类是从java.lang.Exception类继承的子类。而Exception类又是Throwable类的子类。除了Exception类外，Throwable还有一个子类Error。如图所示：</p>\n<p><img src=\"/images/201601/ErrorClass.png\"></p>\n<ul>\n<li><p>它的一个分支是 Error，它定义了Java 运行时的内部错误。通常用Error 类来指明与运行环境相关的错误。应用程序不应该抛出这类异常，发生这类异常时通常是无法处理的，它们在Java程序处理的范畴之外。例如，JVM内存溢出。一般地，程序不会从错误中恢复。</p>\n</li>\n<li><p>另一分支是 Exception，它用于程序中应该捕获的异常。Exception 类也有两个分支，一个是RuntimeException，另一个分支是IOException。RuntimeException 主要用来描述由于编程产生的错误</p>\n</li>\n</ul>\n<p><strong>Java有以下三种类型的异常：</strong></p>\n<ul>\n<li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>\n<li>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>\n<li>错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>\n</ul>\n<h2 id=\"Java-内置异常类\"><a href=\"#Java-内置异常类\" class=\"headerlink\" title=\"Java 内置异常类\"></a>Java 内置异常类</h2><p>Java 语言定义了一些异常类在java.lang标准包中。标准运行时异常类的子类是最常见的异常类。由于java.lang包是默认加载到所有的Java程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p>\n<p><strong>非检查性异常</strong><br><img src=\"/images/201601/javaError.png\"></p>\n<p><strong>检查性异常类</strong><br><img src=\"/images/201601/javaNotError.png\"></p>\n<h2 id=\"异常方法\"><a href=\"#异常方法\" class=\"headerlink\" title=\"异常方法\"></a>异常方法</h2><p><img src=\"/images/201601/javaErrorMethod.png\"></p>\n<p><strong>1. 异常捕获</strong><br>使用try和catch关键字可以捕获异常。try-catch代码块放在异常可能发生的地方</p>\n<blockquote>\n<p>try{<br>//可能出现异常代码<br>}<br>catch(异常类型1 异常对象)<br>{<br>//对异常1 的处理<br>}<br>catch(异常类型2 异常对象)<br>{<br>//对异常2 的处理<br>}<br>┆<br>catch(异常对象n 异常对象)<br>{<br>//异常对象n 的处理<br>}</p>\n</blockquote>\n<p>实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExcepTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Access element three :&quot;</span> + a[<span class=\"number\">3</span>]);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Exception thrown  :&quot;</span> + e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Out of the block&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//result</span></span><br><span class=\"line\"><span class=\"comment\">//Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3</span></span><br><span class=\"line\"><span class=\"comment\">// Out of the block</span></span><br></pre></td></tr></table></figure>\n<p><strong>2.获取异常的堆栈信息</strong><br>在异常类中有一个非常重要的方法printStackTrace()，该方法将在Throwable 类中定义，它的作用是把Throwable 对象的堆栈信息输出至输出流。<br>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestprintStackTraceDemo &#123;</span><br><span class=\"line\">    public static void main(String args[ ])&#123;</span><br><span class=\"line\">        try //对method1 方法进行异常处理</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            method1(); //调用method1 方法</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch(NullPointerException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace(); //获取异常信息</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static void method1()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        method2(); //调用method2 方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static void method2()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        method3(); //调用method3 方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static void method3()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        String str=null; //字符串的值为null</span><br><span class=\"line\">        int n=str.length(); //获取字符串的长度</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：它打印出了异常的栈信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.NullPointerException</span><br><span class=\"line\">    at TestprintStackTraceDemo.method3(TestprintStackTraceDemo.java:26)</span><br><span class=\"line\">    at TestprintStackTraceDemo.method2(TestprintStackTraceDemo.java:21)</span><br><span class=\"line\">    at TestprintStackTraceDemo.method1(TestprintStackTraceDemo.java:17)</span><br><span class=\"line\">    at TestprintStackTraceDemo.main(TestprintStackTraceDemo.java:8)</span><br></pre></td></tr></table></figure>\n<p><strong>3.throws/throw关键字</strong></p>\n<ul>\n<li>throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)throws关键字放在方法签名的尾部。</li>\n<li>throw是语句抛出一个异常。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class className &#123;</span><br><span class=\"line\">    public static void main(String args[]) throws ArrayIndexOutOfBoundsException&#123;</span><br><span class=\"line\">        throw new ArrayIndexOutOfBoundsException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>4.finally</strong><br>finally关键字用来创建在try代码块后面执行的代码块。无论是否发生异常，finally代码块中的代码总会被执行。在finally代码块中，可以运行清理类型等收尾善后性质的语句。finally代码块出现在catch代码块最后，</p>\n<blockquote>\n<p>try{<br>    // 程序代码<br> }catch(异常类型1 异常的变量名1){<br>    // 程序代码<br> }catch(异常类型2 异常的变量名2){<br>    // 程序代码<br> }finally{<br>    // 程序代码<br> }</p>\n</blockquote>\n<p><strong>Notice:</strong></p>\n<ul>\n<li>catch不能独立于try存在。</li>\n<li>在try/catch后面添加finally块并非强制性要求的。</li>\n<li>try代码后不能既没catch块也没finally块。</li>\n<li>try, catch, finally块之间不能添加任何代码。</li>\n</ul>\n<h2 id=\"自定义异常类\"><a href=\"#自定义异常类\" class=\"headerlink\" title=\"自定义异常类\"></a>自定义异常类</h2><p>在Java中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p>\n<ul>\n<li>所有异常都必须是Throwable的子类。</li>\n<li>如果希望写一个检查性异常类，则需要继承Exception类。</li>\n<li>如果你想写一个运行时异常类，那么需要继承RuntimeException 类。</li>\n</ul>\n<p>示例<br>自定义异常类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyException extends Exception &#123;</span><br><span class=\"line\">    MyException() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MyException(String msg) &#123;</span><br><span class=\"line\">        //调用父类的方法</span><br><span class=\"line\">        super(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用异常类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestMyException &#123;</span><br><span class=\"line\">    public static void main(String args[ ])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            String level=null;</span><br><span class=\"line\">            level=scoreLevel(90);</span><br><span class=\"line\">            System.out.println(&quot;90 分的成绩等级为：&quot;+level);</span><br><span class=\"line\">            level=scoreLevel(120);</span><br><span class=\"line\">            System.out.println(&quot;120 分的成绩等级为：&quot;+level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch(MyException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static String scoreLevel(int score) throws MyException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(score&gt;=85&amp;&amp;score&lt;=100)</span><br><span class=\"line\">            return &quot;A&quot;;</span><br><span class=\"line\">        else if(score&gt;=75&amp;&amp;score&lt;85)</span><br><span class=\"line\">            return &quot;B&quot;;</span><br><span class=\"line\">        else if(score&gt;=60&amp;&amp;score&lt;75)</span><br><span class=\"line\">            return &quot;C&quot;;</span><br><span class=\"line\">        else if(score&lt;60&amp;&amp;score&gt;=0)</span><br><span class=\"line\">            return &quot;D&quot;;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            throw new MyException(&quot;非法的分数&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"通用异常\"><a href=\"#通用异常\" class=\"headerlink\" title=\"通用异常\"></a>通用异常</h2><p>在Java中定义了两种类型的异常和错误。</p>\n<ul>\n<li>JVM(Java虚拟机)异常：由JVM抛出的异常或错误。例如：NullPointerException类，ArrayIndexOutOfBoundsException类，ClassCastException类。</li>\n<li>程序级异常：由程序或者API程序抛出的异常。例如IllegalArgumentException类，IllegalStateException类。</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>由于硬件问题、资源耗尽、输入错误以及程序代码编写不严谨会导致程序运行时产生异常，这些异常会导致程序中断而不能正常继续运行，所以需要对异常的情况进行妥善处理。Java 提供了一套完善的异常处理机制，通过这套机制，可以轻松地写出容错性非常高的代码。</p>","more":"<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>Java 的异常实际上是一个对象，这个对象描述了代码中出现的异常情况。在代码运行异常时，在有异常的方法中创建并抛出一个表示异常的对象，然后在相应的异常处理模块中进行处理。</p>\n<p>在Java中，所有的异常类是从java.lang.Exception类继承的子类。而Exception类又是Throwable类的子类。除了Exception类外，Throwable还有一个子类Error。如图所示：</p>\n<p><img src=\"/images/201601/ErrorClass.png\"></p>\n<ul>\n<li><p>它的一个分支是 Error，它定义了Java 运行时的内部错误。通常用Error 类来指明与运行环境相关的错误。应用程序不应该抛出这类异常，发生这类异常时通常是无法处理的，它们在Java程序处理的范畴之外。例如，JVM内存溢出。一般地，程序不会从错误中恢复。</p>\n</li>\n<li><p>另一分支是 Exception，它用于程序中应该捕获的异常。Exception 类也有两个分支，一个是RuntimeException，另一个分支是IOException。RuntimeException 主要用来描述由于编程产生的错误</p>\n</li>\n</ul>\n<p><strong>Java有以下三种类型的异常：</strong></p>\n<ul>\n<li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>\n<li>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>\n<li>错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>\n</ul>\n<h2 id=\"Java-内置异常类\"><a href=\"#Java-内置异常类\" class=\"headerlink\" title=\"Java 内置异常类\"></a>Java 内置异常类</h2><p>Java 语言定义了一些异常类在java.lang标准包中。标准运行时异常类的子类是最常见的异常类。由于java.lang包是默认加载到所有的Java程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p>\n<p><strong>非检查性异常</strong><br><img src=\"/images/201601/javaError.png\"></p>\n<p><strong>检查性异常类</strong><br><img src=\"/images/201601/javaNotError.png\"></p>\n<h2 id=\"异常方法\"><a href=\"#异常方法\" class=\"headerlink\" title=\"异常方法\"></a>异常方法</h2><p><img src=\"/images/201601/javaErrorMethod.png\"></p>\n<p><strong>1. 异常捕获</strong><br>使用try和catch关键字可以捕获异常。try-catch代码块放在异常可能发生的地方</p>\n<blockquote>\n<p>try{<br>//可能出现异常代码<br>}<br>catch(异常类型1 异常对象)<br>{<br>//对异常1 的处理<br>}<br>catch(异常类型2 异常对象)<br>{<br>//对异常2 的处理<br>}<br>┆<br>catch(异常对象n 异常对象)<br>{<br>//异常对象n 的处理<br>}</p>\n</blockquote>\n<p>实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExcepTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Access element three :&quot;</span> + a[<span class=\"number\">3</span>]);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Exception thrown  :&quot;</span> + e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Out of the block&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//result</span></span><br><span class=\"line\"><span class=\"comment\">//Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3</span></span><br><span class=\"line\"><span class=\"comment\">// Out of the block</span></span><br></pre></td></tr></table></figure>\n<p><strong>2.获取异常的堆栈信息</strong><br>在异常类中有一个非常重要的方法printStackTrace()，该方法将在Throwable 类中定义，它的作用是把Throwable 对象的堆栈信息输出至输出流。<br>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestprintStackTraceDemo &#123;</span><br><span class=\"line\">    public static void main(String args[ ])&#123;</span><br><span class=\"line\">        try //对method1 方法进行异常处理</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            method1(); //调用method1 方法</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch(NullPointerException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace(); //获取异常信息</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static void method1()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        method2(); //调用method2 方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static void method2()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        method3(); //调用method3 方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static void method3()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        String str=null; //字符串的值为null</span><br><span class=\"line\">        int n=str.length(); //获取字符串的长度</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：它打印出了异常的栈信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.NullPointerException</span><br><span class=\"line\">    at TestprintStackTraceDemo.method3(TestprintStackTraceDemo.java:26)</span><br><span class=\"line\">    at TestprintStackTraceDemo.method2(TestprintStackTraceDemo.java:21)</span><br><span class=\"line\">    at TestprintStackTraceDemo.method1(TestprintStackTraceDemo.java:17)</span><br><span class=\"line\">    at TestprintStackTraceDemo.main(TestprintStackTraceDemo.java:8)</span><br></pre></td></tr></table></figure>\n<p><strong>3.throws/throw关键字</strong></p>\n<ul>\n<li>throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)throws关键字放在方法签名的尾部。</li>\n<li>throw是语句抛出一个异常。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class className &#123;</span><br><span class=\"line\">    public static void main(String args[]) throws ArrayIndexOutOfBoundsException&#123;</span><br><span class=\"line\">        throw new ArrayIndexOutOfBoundsException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>4.finally</strong><br>finally关键字用来创建在try代码块后面执行的代码块。无论是否发生异常，finally代码块中的代码总会被执行。在finally代码块中，可以运行清理类型等收尾善后性质的语句。finally代码块出现在catch代码块最后，</p>\n<blockquote>\n<p>try{<br>    // 程序代码<br> }catch(异常类型1 异常的变量名1){<br>    // 程序代码<br> }catch(异常类型2 异常的变量名2){<br>    // 程序代码<br> }finally{<br>    // 程序代码<br> }</p>\n</blockquote>\n<p><strong>Notice:</strong></p>\n<ul>\n<li>catch不能独立于try存在。</li>\n<li>在try/catch后面添加finally块并非强制性要求的。</li>\n<li>try代码后不能既没catch块也没finally块。</li>\n<li>try, catch, finally块之间不能添加任何代码。</li>\n</ul>\n<h2 id=\"自定义异常类\"><a href=\"#自定义异常类\" class=\"headerlink\" title=\"自定义异常类\"></a>自定义异常类</h2><p>在Java中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p>\n<ul>\n<li>所有异常都必须是Throwable的子类。</li>\n<li>如果希望写一个检查性异常类，则需要继承Exception类。</li>\n<li>如果你想写一个运行时异常类，那么需要继承RuntimeException 类。</li>\n</ul>\n<p>示例<br>自定义异常类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyException extends Exception &#123;</span><br><span class=\"line\">    MyException() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MyException(String msg) &#123;</span><br><span class=\"line\">        //调用父类的方法</span><br><span class=\"line\">        super(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用异常类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestMyException &#123;</span><br><span class=\"line\">    public static void main(String args[ ])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            String level=null;</span><br><span class=\"line\">            level=scoreLevel(90);</span><br><span class=\"line\">            System.out.println(&quot;90 分的成绩等级为：&quot;+level);</span><br><span class=\"line\">            level=scoreLevel(120);</span><br><span class=\"line\">            System.out.println(&quot;120 分的成绩等级为：&quot;+level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch(MyException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static String scoreLevel(int score) throws MyException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(score&gt;=85&amp;&amp;score&lt;=100)</span><br><span class=\"line\">            return &quot;A&quot;;</span><br><span class=\"line\">        else if(score&gt;=75&amp;&amp;score&lt;85)</span><br><span class=\"line\">            return &quot;B&quot;;</span><br><span class=\"line\">        else if(score&gt;=60&amp;&amp;score&lt;75)</span><br><span class=\"line\">            return &quot;C&quot;;</span><br><span class=\"line\">        else if(score&lt;60&amp;&amp;score&gt;=0)</span><br><span class=\"line\">            return &quot;D&quot;;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            throw new MyException(&quot;非法的分数&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"通用异常\"><a href=\"#通用异常\" class=\"headerlink\" title=\"通用异常\"></a>通用异常</h2><p>在Java中定义了两种类型的异常和错误。</p>\n<ul>\n<li>JVM(Java虚拟机)异常：由JVM抛出的异常或错误。例如：NullPointerException类，ArrayIndexOutOfBoundsException类，ClassCastException类。</li>\n<li>程序级异常：由程序或者API程序抛出的异常。例如IllegalArgumentException类，IllegalStateException类。</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"Java抽象类","date":"2016-04-05T06:56:32.000Z","description":"Java抽象类","_content":"\n\n在面向对象的概念中，所有的对象都是通过类来描绘的，但并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。\n抽象类是指在类中定义方法，但是并不去实现它，而在它的子类中去具体的实现。定义的抽象方法不过是一个方法占位符。继承抽象类的子类必须实现父类的抽象方法，除非子类也被定义成一个抽象类。\n\n<!-- more -->\n\n**关键词：**\n+ 不能实例化对象，但其它功能和普通类一样\n+ 在类中定义方法，但是并不去实现它\n+ 子类必须实现父类的抽象方法\n\n\n### 声明\n1. 抽象类声明\n> 修饰符 abstract 类名{\n//类体\n}\n\n2. 抽象方法声明\n> 修饰符 abstract 返回值类型方法名();\n\n抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。\n\n声明抽象方法会造成以下两个结果：\n+ 如果一个类包含抽象方法，那么该类必须是抽象类。\n+ 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。\n\n**在抽象类中的方法不一定是抽象方法，但是含有抽象方法的类必须被定义成抽象类**\n\n```\n//抽象类声明\nabstract class Animal {\n    String type;\n    String name;\n    int age;\n    int weight;\n    void eat() {\n        System.out.println(\"动物爱吃饭\");\n    }\n    //抽象方法声明\n    abstract void breath();\n}\n\n```\n### 使用\n```\n public static void  main(String args[]){\n    //error\n    //Animal animal1 = new Animal();\n    //抽象类可以创建类对象变量，只是这个变量只能用来指向它的非抽象子类对象\n    Animal animal1 = new Tiger();\n    animal1.breath();\n    //不能直接调用tiger子类的方法\n    //animal1.run();\n    //正确的调用方法\n    ((Tiger)animal1).run();\n}\n```\n\n+ 由于根本不可能构建出Animal 对象，所以animal1存放的对象是Tiger对象，它会动态绑定正确的方法进行调用。\n+ 尽管animal1存放的是Tiger 对象，但是不能直接调用tiger子类的方法，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/Java抽象类.md","raw":"title: Java抽象类\ntags: [java面向对象]\ndate: 2016-04-05 14:56:32\ndescription: Java抽象类\n---\n\n\n在面向对象的概念中，所有的对象都是通过类来描绘的，但并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。\n抽象类是指在类中定义方法，但是并不去实现它，而在它的子类中去具体的实现。定义的抽象方法不过是一个方法占位符。继承抽象类的子类必须实现父类的抽象方法，除非子类也被定义成一个抽象类。\n\n<!-- more -->\n\n**关键词：**\n+ 不能实例化对象，但其它功能和普通类一样\n+ 在类中定义方法，但是并不去实现它\n+ 子类必须实现父类的抽象方法\n\n\n### 声明\n1. 抽象类声明\n> 修饰符 abstract 类名{\n//类体\n}\n\n2. 抽象方法声明\n> 修饰符 abstract 返回值类型方法名();\n\n抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。\n\n声明抽象方法会造成以下两个结果：\n+ 如果一个类包含抽象方法，那么该类必须是抽象类。\n+ 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。\n\n**在抽象类中的方法不一定是抽象方法，但是含有抽象方法的类必须被定义成抽象类**\n\n```\n//抽象类声明\nabstract class Animal {\n    String type;\n    String name;\n    int age;\n    int weight;\n    void eat() {\n        System.out.println(\"动物爱吃饭\");\n    }\n    //抽象方法声明\n    abstract void breath();\n}\n\n```\n### 使用\n```\n public static void  main(String args[]){\n    //error\n    //Animal animal1 = new Animal();\n    //抽象类可以创建类对象变量，只是这个变量只能用来指向它的非抽象子类对象\n    Animal animal1 = new Tiger();\n    animal1.breath();\n    //不能直接调用tiger子类的方法\n    //animal1.run();\n    //正确的调用方法\n    ((Tiger)animal1).run();\n}\n```\n\n+ 由于根本不可能构建出Animal 对象，所以animal1存放的对象是Tiger对象，它会动态绑定正确的方法进行调用。\n+ 尽管animal1存放的是Tiger 对象，但是不能直接调用tiger子类的方法，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"Java抽象类","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokm000qy4v20fl0dm6g","content":"<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。<br>抽象类是指在类中定义方法，但是并不去实现它，而在它的子类中去具体的实现。定义的抽象方法不过是一个方法占位符。继承抽象类的子类必须实现父类的抽象方法，除非子类也被定义成一个抽象类。</p>\n<span id=\"more\"></span>\n\n<p><strong>关键词：</strong></p>\n<ul>\n<li>不能实例化对象，但其它功能和普通类一样</li>\n<li>在类中定义方法，但是并不去实现它</li>\n<li>子类必须实现父类的抽象方法</li>\n</ul>\n<h3 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h3><ol>\n<li><p>抽象类声明</p>\n<blockquote>\n<p>修饰符 abstract 类名{<br>//类体<br>}</p>\n</blockquote>\n</li>\n<li><p>抽象方法声明</p>\n<blockquote>\n<p>修饰符 abstract 返回值类型方法名();</p>\n</blockquote>\n</li>\n</ol>\n<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>\n<p>声明抽象方法会造成以下两个结果：</p>\n<ul>\n<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>\n<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>\n</ul>\n<p><strong>在抽象类中的方法不一定是抽象方法，但是含有抽象方法的类必须被定义成抽象类</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//抽象类声明</span><br><span class=\"line\">abstract class Animal &#123;</span><br><span class=\"line\">    String type;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    int weight;</span><br><span class=\"line\">    void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;动物爱吃饭&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //抽象方法声明</span><br><span class=\"line\">    abstract void breath();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static void  main(String args[])&#123;</span><br><span class=\"line\">    //error</span><br><span class=\"line\">    //Animal animal1 = new Animal();</span><br><span class=\"line\">    //抽象类可以创建类对象变量，只是这个变量只能用来指向它的非抽象子类对象</span><br><span class=\"line\">    Animal animal1 = new Tiger();</span><br><span class=\"line\">    animal1.breath();</span><br><span class=\"line\">    //不能直接调用tiger子类的方法</span><br><span class=\"line\">    //animal1.run();</span><br><span class=\"line\">    //正确的调用方法</span><br><span class=\"line\">    ((Tiger)animal1).run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>由于根本不可能构建出Animal 对象，所以animal1存放的对象是Tiger对象，它会动态绑定正确的方法进行调用。</li>\n<li>尽管animal1存放的是Tiger 对象，但是不能直接调用tiger子类的方法，</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。<br>抽象类是指在类中定义方法，但是并不去实现它，而在它的子类中去具体的实现。定义的抽象方法不过是一个方法占位符。继承抽象类的子类必须实现父类的抽象方法，除非子类也被定义成一个抽象类。</p>","more":"<p><strong>关键词：</strong></p>\n<ul>\n<li>不能实例化对象，但其它功能和普通类一样</li>\n<li>在类中定义方法，但是并不去实现它</li>\n<li>子类必须实现父类的抽象方法</li>\n</ul>\n<h3 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h3><ol>\n<li><p>抽象类声明</p>\n<blockquote>\n<p>修饰符 abstract 类名{<br>//类体<br>}</p>\n</blockquote>\n</li>\n<li><p>抽象方法声明</p>\n<blockquote>\n<p>修饰符 abstract 返回值类型方法名();</p>\n</blockquote>\n</li>\n</ol>\n<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>\n<p>声明抽象方法会造成以下两个结果：</p>\n<ul>\n<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>\n<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>\n</ul>\n<p><strong>在抽象类中的方法不一定是抽象方法，但是含有抽象方法的类必须被定义成抽象类</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//抽象类声明</span><br><span class=\"line\">abstract class Animal &#123;</span><br><span class=\"line\">    String type;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    int weight;</span><br><span class=\"line\">    void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;动物爱吃饭&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //抽象方法声明</span><br><span class=\"line\">    abstract void breath();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static void  main(String args[])&#123;</span><br><span class=\"line\">    //error</span><br><span class=\"line\">    //Animal animal1 = new Animal();</span><br><span class=\"line\">    //抽象类可以创建类对象变量，只是这个变量只能用来指向它的非抽象子类对象</span><br><span class=\"line\">    Animal animal1 = new Tiger();</span><br><span class=\"line\">    animal1.breath();</span><br><span class=\"line\">    //不能直接调用tiger子类的方法</span><br><span class=\"line\">    //animal1.run();</span><br><span class=\"line\">    //正确的调用方法</span><br><span class=\"line\">    ((Tiger)animal1).run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>由于根本不可能构建出Animal 对象，所以animal1存放的对象是Tiger对象，它会动态绑定正确的方法进行调用。</li>\n<li>尽管animal1存放的是Tiger 对象，但是不能直接调用tiger子类的方法，</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"Java数组","date":"2016-03-29T05:37:06.000Z","description":"Java数组","_content":"> Java 语言中的数组是用来存放同一种数据类型数据集的特殊对象。\n\n<!-- more -->\n\n## 数组基础\n**1.声明数组**\n+ ArrayType ArrayName[ ];\n```\nint array1[ ];\n```\n\n+ ArrayType [ ] ArrayName;\n```\nint [ ] array2,array3;\n```\n\n*这两种声明方式没有区别，但是第二种可以同时声明多个数组，使用起来较为方便*\n\n\n**2.分配空间**\nArrayName = new  ArrayType [ ArrayLenth ];\n```\narray1=new int [5];\n```\n\n**3.初始化**\n+ ArrayName[i] = value\n```\narray1[0]=1;\narray1[1]=2;\narray1[2]=3;\narray1[3]=4;\narray1[4]=5;\n```\n+ ArrayType [] ArrayName = {value...}\n```\nint [] array1={1,2,3,4,5};\n```\n\n**4.length**\nJava 中的数组是一种对象，它会有自己的实例变量。数组只有一个公共实例变量，也就是length 变量，这个变量指的是数组的长度。\n\n## 数组的使用\n**1.复制数组**\n+ array1=array2;\n两个数组类型变量都指向同一个数组array2；\n```java\nint [] array1 = {1,2,3,4,5};\nint [] array2 = {1,2,3,4,5,6};\narray1 = array2;\nfor(int i=0;i<array1.length;i++){\n    System.out.println(array1[i]);//123456\n}\narray2[0] = 8;\nSystem.out.println(array1[0]);//8,说明数组1指向了数组2\n```\n\n+ System.arraycopy(fromArray ,fromIndex,toArray,toIndex,length)\n从指定源数组fromArray 中复制一个数组，复制从指定的位置fromIndex 开始，到目标数组toArray，在指定位置toIndex 结束，复制length 个元素,注意目标数组必须有足够的空间来存放复制的数据，如果空间不足的话，会抛出异常，并且不会修改该数组。\n\n```\nint [] array3 = {1,2,3,4,5};\nint [] array4 = {1,2,3,4,5,6};\nSystem.arraycopy(array4 ,0,array3,2,3);\nfor(int i = 0;i<array3.length;i++){\n    System.out.println(array3[i]);//12123\n}\nSystem.arraycopy(array4 ,0,array3,2,3);//error,空间不足，抛出异常\n```\n\n## 数组排序\n**1.选择排序**\n选择排序的基本思路是：对一个长度为n 的数组进行n 趟遍历，第一趟遍历选出最大（或者最小）的元素，将之与数组的第一个元素交换；然后进行第二趟遍历，再从剩余的元素中选出最大（或者最小）的元素，将之与数组的第二个元素交换。这样遍历n 次后，得到的就为降序（或者升序）数组。\n\n**2.冒泡排序**\n冒泡排序的过程，是把数组元素中较小的看作是“较轻”的，对它进行“上浮”操作。从底部开始，反复地对数组进行“上浮”操作n 次，最后得到有序数组。\n\n**3.快速排序**\n通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n## 多维数组\n多维数组类似于空间表示中的一维空间、二维空间、多维空间。Java 是支持多维数组的，并利用多个下标来表示多维\n**1.声明**\nint [ ][ ]twoD=new int[5][5];\n上面的语句声明了一个5 行5 列的二维数组\n\n**2.数组的初始化**\n+ 直接赋值法\n```\ntwoD={\n{1,2,3,4,5},\n{6,7,8,9,10},\n{11,12,13,14,15},\n{16,17,18,19,20},\n{21,22,23,24,25}\n};\n```\n+ 使用循环访问数组的每个元素的方法\n```\nfor(int i=0;i<twoD2.length;i++)\nfor(int j=0;j<twoD2[i].length;j++)\ntwoD2[i][j]=k++;\n```\n*twoD2.length 表示的是数组的行数，而twoD2[i].length 表示的则是数组的列数*\n\n> 在 Java 中实际上只有一维数组，多维数组可看作是数组的数组。例子中，二维数组twoD 的实现是数组类型变量指向一个一维数组，这个数组有5 个元素，而这5个元素都是一个有5个整型数的数组\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/Java数组.md","raw":"title: Java数组\ntags: [java基础]\ndate: 2016-03-29 13:37:06\ndescription: Java数组\n---\n> Java 语言中的数组是用来存放同一种数据类型数据集的特殊对象。\n\n<!-- more -->\n\n## 数组基础\n**1.声明数组**\n+ ArrayType ArrayName[ ];\n```\nint array1[ ];\n```\n\n+ ArrayType [ ] ArrayName;\n```\nint [ ] array2,array3;\n```\n\n*这两种声明方式没有区别，但是第二种可以同时声明多个数组，使用起来较为方便*\n\n\n**2.分配空间**\nArrayName = new  ArrayType [ ArrayLenth ];\n```\narray1=new int [5];\n```\n\n**3.初始化**\n+ ArrayName[i] = value\n```\narray1[0]=1;\narray1[1]=2;\narray1[2]=3;\narray1[3]=4;\narray1[4]=5;\n```\n+ ArrayType [] ArrayName = {value...}\n```\nint [] array1={1,2,3,4,5};\n```\n\n**4.length**\nJava 中的数组是一种对象，它会有自己的实例变量。数组只有一个公共实例变量，也就是length 变量，这个变量指的是数组的长度。\n\n## 数组的使用\n**1.复制数组**\n+ array1=array2;\n两个数组类型变量都指向同一个数组array2；\n```java\nint [] array1 = {1,2,3,4,5};\nint [] array2 = {1,2,3,4,5,6};\narray1 = array2;\nfor(int i=0;i<array1.length;i++){\n    System.out.println(array1[i]);//123456\n}\narray2[0] = 8;\nSystem.out.println(array1[0]);//8,说明数组1指向了数组2\n```\n\n+ System.arraycopy(fromArray ,fromIndex,toArray,toIndex,length)\n从指定源数组fromArray 中复制一个数组，复制从指定的位置fromIndex 开始，到目标数组toArray，在指定位置toIndex 结束，复制length 个元素,注意目标数组必须有足够的空间来存放复制的数据，如果空间不足的话，会抛出异常，并且不会修改该数组。\n\n```\nint [] array3 = {1,2,3,4,5};\nint [] array4 = {1,2,3,4,5,6};\nSystem.arraycopy(array4 ,0,array3,2,3);\nfor(int i = 0;i<array3.length;i++){\n    System.out.println(array3[i]);//12123\n}\nSystem.arraycopy(array4 ,0,array3,2,3);//error,空间不足，抛出异常\n```\n\n## 数组排序\n**1.选择排序**\n选择排序的基本思路是：对一个长度为n 的数组进行n 趟遍历，第一趟遍历选出最大（或者最小）的元素，将之与数组的第一个元素交换；然后进行第二趟遍历，再从剩余的元素中选出最大（或者最小）的元素，将之与数组的第二个元素交换。这样遍历n 次后，得到的就为降序（或者升序）数组。\n\n**2.冒泡排序**\n冒泡排序的过程，是把数组元素中较小的看作是“较轻”的，对它进行“上浮”操作。从底部开始，反复地对数组进行“上浮”操作n 次，最后得到有序数组。\n\n**3.快速排序**\n通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n## 多维数组\n多维数组类似于空间表示中的一维空间、二维空间、多维空间。Java 是支持多维数组的，并利用多个下标来表示多维\n**1.声明**\nint [ ][ ]twoD=new int[5][5];\n上面的语句声明了一个5 行5 列的二维数组\n\n**2.数组的初始化**\n+ 直接赋值法\n```\ntwoD={\n{1,2,3,4,5},\n{6,7,8,9,10},\n{11,12,13,14,15},\n{16,17,18,19,20},\n{21,22,23,24,25}\n};\n```\n+ 使用循环访问数组的每个元素的方法\n```\nfor(int i=0;i<twoD2.length;i++)\nfor(int j=0;j<twoD2[i].length;j++)\ntwoD2[i][j]=k++;\n```\n*twoD2.length 表示的是数组的行数，而twoD2[i].length 表示的则是数组的列数*\n\n> 在 Java 中实际上只有一维数组，多维数组可看作是数组的数组。例子中，二维数组twoD 的实现是数组类型变量指向一个一维数组，这个数组有5 个元素，而这5个元素都是一个有5个整型数的数组\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"Java数组","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokm000sy4v2elwd2dj6","content":"<blockquote>\n<p>Java 语言中的数组是用来存放同一种数据类型数据集的特殊对象。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"数组基础\"><a href=\"#数组基础\" class=\"headerlink\" title=\"数组基础\"></a>数组基础</h2><p><strong>1.声明数组</strong></p>\n<ul>\n<li><p>ArrayType ArrayName[ ];</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int array1[ ];</span><br></pre></td></tr></table></figure></li>\n<li><p>ArrayType [ ] ArrayName;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int [ ] array2,array3;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><em>这两种声明方式没有区别，但是第二种可以同时声明多个数组，使用起来较为方便</em></p>\n<p><strong>2.分配空间</strong><br>ArrayName = new  ArrayType [ ArrayLenth ];</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array1=new int [5];</span><br></pre></td></tr></table></figure>\n\n<p><strong>3.初始化</strong></p>\n<ul>\n<li>ArrayName[i] = value<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array1[0]=1;</span><br><span class=\"line\">array1[1]=2;</span><br><span class=\"line\">array1[2]=3;</span><br><span class=\"line\">array1[3]=4;</span><br><span class=\"line\">array1[4]=5;</span><br></pre></td></tr></table></figure></li>\n<li>ArrayType [] ArrayName = {value…}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int [] array1=&#123;1,2,3,4,5&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>4.length</strong><br>Java 中的数组是一种对象，它会有自己的实例变量。数组只有一个公共实例变量，也就是length 变量，这个变量指的是数组的长度。</p>\n<h2 id=\"数组的使用\"><a href=\"#数组的使用\" class=\"headerlink\" title=\"数组的使用\"></a>数组的使用</h2><p><strong>1.复制数组</strong></p>\n<ul>\n<li><p>array1=array2;<br>两个数组类型变量都指向同一个数组array2；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> [] array1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> [] array2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">array1 = array2;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;array1.length;i++)&#123;</span><br><span class=\"line\">    System.out.println(array1[i]);<span class=\"comment\">//123456</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">array2[<span class=\"number\">0</span>] = <span class=\"number\">8</span>;</span><br><span class=\"line\">System.out.println(array1[<span class=\"number\">0</span>]);<span class=\"comment\">//8,说明数组1指向了数组2</span></span><br></pre></td></tr></table></figure></li>\n<li><p>System.arraycopy(fromArray ,fromIndex,toArray,toIndex,length)<br>从指定源数组fromArray 中复制一个数组，复制从指定的位置fromIndex 开始，到目标数组toArray，在指定位置toIndex 结束，复制length 个元素,注意目标数组必须有足够的空间来存放复制的数据，如果空间不足的话，会抛出异常，并且不会修改该数组。</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int [] array3 = &#123;1,2,3,4,5&#125;;</span><br><span class=\"line\">int [] array4 = &#123;1,2,3,4,5,6&#125;;</span><br><span class=\"line\">System.arraycopy(array4 ,0,array3,2,3);</span><br><span class=\"line\">for(int i = 0;i&lt;array3.length;i++)&#123;</span><br><span class=\"line\">    System.out.println(array3[i]);//12123</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.arraycopy(array4 ,0,array3,2,3);//error,空间不足，抛出异常</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组排序\"><a href=\"#数组排序\" class=\"headerlink\" title=\"数组排序\"></a>数组排序</h2><p><strong>1.选择排序</strong><br>选择排序的基本思路是：对一个长度为n 的数组进行n 趟遍历，第一趟遍历选出最大（或者最小）的元素，将之与数组的第一个元素交换；然后进行第二趟遍历，再从剩余的元素中选出最大（或者最小）的元素，将之与数组的第二个元素交换。这样遍历n 次后，得到的就为降序（或者升序）数组。</p>\n<p><strong>2.冒泡排序</strong><br>冒泡排序的过程，是把数组元素中较小的看作是“较轻”的，对它进行“上浮”操作。从底部开始，反复地对数组进行“上浮”操作n 次，最后得到有序数组。</p>\n<p><strong>3.快速排序</strong><br>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>\n<h2 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h2><p>多维数组类似于空间表示中的一维空间、二维空间、多维空间。Java 是支持多维数组的，并利用多个下标来表示多维<br><strong>1.声明</strong><br>int [ ][ ]twoD=new int[5][5];<br>上面的语句声明了一个5 行5 列的二维数组</p>\n<p><strong>2.数组的初始化</strong></p>\n<ul>\n<li>直接赋值法<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">twoD=&#123;</span><br><span class=\"line\">&#123;1,2,3,4,5&#125;,</span><br><span class=\"line\">&#123;6,7,8,9,10&#125;,</span><br><span class=\"line\">&#123;11,12,13,14,15&#125;,</span><br><span class=\"line\">&#123;16,17,18,19,20&#125;,</span><br><span class=\"line\">&#123;21,22,23,24,25&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>使用循环访问数组的每个元素的方法<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i=0;i&lt;twoD2.length;i++)</span><br><span class=\"line\">for(int j=0;j&lt;twoD2[i].length;j++)</span><br><span class=\"line\">twoD2[i][j]=k++;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><em>twoD2.length 表示的是数组的行数，而twoD2[i].length 表示的则是数组的列数</em></p>\n<blockquote>\n<p>在 Java 中实际上只有一维数组，多维数组可看作是数组的数组。例子中，二维数组twoD 的实现是数组类型变量指向一个一维数组，这个数组有5 个元素，而这5个元素都是一个有5个整型数的数组</p>\n</blockquote>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Java 语言中的数组是用来存放同一种数据类型数据集的特殊对象。</p>\n</blockquote>","more":"<h2 id=\"数组基础\"><a href=\"#数组基础\" class=\"headerlink\" title=\"数组基础\"></a>数组基础</h2><p><strong>1.声明数组</strong></p>\n<ul>\n<li><p>ArrayType ArrayName[ ];</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int array1[ ];</span><br></pre></td></tr></table></figure></li>\n<li><p>ArrayType [ ] ArrayName;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int [ ] array2,array3;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><em>这两种声明方式没有区别，但是第二种可以同时声明多个数组，使用起来较为方便</em></p>\n<p><strong>2.分配空间</strong><br>ArrayName = new  ArrayType [ ArrayLenth ];</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array1=new int [5];</span><br></pre></td></tr></table></figure>\n\n<p><strong>3.初始化</strong></p>\n<ul>\n<li>ArrayName[i] = value<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array1[0]=1;</span><br><span class=\"line\">array1[1]=2;</span><br><span class=\"line\">array1[2]=3;</span><br><span class=\"line\">array1[3]=4;</span><br><span class=\"line\">array1[4]=5;</span><br></pre></td></tr></table></figure></li>\n<li>ArrayType [] ArrayName = {value…}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int [] array1=&#123;1,2,3,4,5&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>4.length</strong><br>Java 中的数组是一种对象，它会有自己的实例变量。数组只有一个公共实例变量，也就是length 变量，这个变量指的是数组的长度。</p>\n<h2 id=\"数组的使用\"><a href=\"#数组的使用\" class=\"headerlink\" title=\"数组的使用\"></a>数组的使用</h2><p><strong>1.复制数组</strong></p>\n<ul>\n<li><p>array1=array2;<br>两个数组类型变量都指向同一个数组array2；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> [] array1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> [] array2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">array1 = array2;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;array1.length;i++)&#123;</span><br><span class=\"line\">    System.out.println(array1[i]);<span class=\"comment\">//123456</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">array2[<span class=\"number\">0</span>] = <span class=\"number\">8</span>;</span><br><span class=\"line\">System.out.println(array1[<span class=\"number\">0</span>]);<span class=\"comment\">//8,说明数组1指向了数组2</span></span><br></pre></td></tr></table></figure></li>\n<li><p>System.arraycopy(fromArray ,fromIndex,toArray,toIndex,length)<br>从指定源数组fromArray 中复制一个数组，复制从指定的位置fromIndex 开始，到目标数组toArray，在指定位置toIndex 结束，复制length 个元素,注意目标数组必须有足够的空间来存放复制的数据，如果空间不足的话，会抛出异常，并且不会修改该数组。</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int [] array3 = &#123;1,2,3,4,5&#125;;</span><br><span class=\"line\">int [] array4 = &#123;1,2,3,4,5,6&#125;;</span><br><span class=\"line\">System.arraycopy(array4 ,0,array3,2,3);</span><br><span class=\"line\">for(int i = 0;i&lt;array3.length;i++)&#123;</span><br><span class=\"line\">    System.out.println(array3[i]);//12123</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.arraycopy(array4 ,0,array3,2,3);//error,空间不足，抛出异常</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组排序\"><a href=\"#数组排序\" class=\"headerlink\" title=\"数组排序\"></a>数组排序</h2><p><strong>1.选择排序</strong><br>选择排序的基本思路是：对一个长度为n 的数组进行n 趟遍历，第一趟遍历选出最大（或者最小）的元素，将之与数组的第一个元素交换；然后进行第二趟遍历，再从剩余的元素中选出最大（或者最小）的元素，将之与数组的第二个元素交换。这样遍历n 次后，得到的就为降序（或者升序）数组。</p>\n<p><strong>2.冒泡排序</strong><br>冒泡排序的过程，是把数组元素中较小的看作是“较轻”的，对它进行“上浮”操作。从底部开始，反复地对数组进行“上浮”操作n 次，最后得到有序数组。</p>\n<p><strong>3.快速排序</strong><br>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>\n<h2 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h2><p>多维数组类似于空间表示中的一维空间、二维空间、多维空间。Java 是支持多维数组的，并利用多个下标来表示多维<br><strong>1.声明</strong><br>int [ ][ ]twoD=new int[5][5];<br>上面的语句声明了一个5 行5 列的二维数组</p>\n<p><strong>2.数组的初始化</strong></p>\n<ul>\n<li>直接赋值法<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">twoD=&#123;</span><br><span class=\"line\">&#123;1,2,3,4,5&#125;,</span><br><span class=\"line\">&#123;6,7,8,9,10&#125;,</span><br><span class=\"line\">&#123;11,12,13,14,15&#125;,</span><br><span class=\"line\">&#123;16,17,18,19,20&#125;,</span><br><span class=\"line\">&#123;21,22,23,24,25&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>使用循环访问数组的每个元素的方法<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i=0;i&lt;twoD2.length;i++)</span><br><span class=\"line\">for(int j=0;j&lt;twoD2[i].length;j++)</span><br><span class=\"line\">twoD2[i][j]=k++;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><em>twoD2.length 表示的是数组的行数，而twoD2[i].length 表示的则是数组的列数</em></p>\n<blockquote>\n<p>在 Java 中实际上只有一维数组，多维数组可看作是数组的数组。例子中，二维数组twoD 的实现是数组类型变量指向一个一维数组，这个数组有5 个元素，而这5个元素都是一个有5个整型数的数组</p>\n</blockquote>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"Java接口","date":"2016-04-06T07:52:57.000Z","description":"Java接口","_content":"\n多重继承是指一个类可以继承多个类，也就是一个类可以有多个直接父类。Java 并不支持多重继承。但是当需要复杂问题时却显得力不从心，于是Java 引入了接口来弥补这点不足。\n\n<!-- more -->\n\n## 接口（Interface）\n接口是 Java 提供的一项非常重要的结构。它定义了一系列的抽象方法和常量，形成一个属性集合。接口定义完成后任何类都可以实现接口，而且一个类可以实现多个接口。实现接口的类必须实现接口中定义的抽象方法，具体实现细节由类自己定义。可以说接口定义了类的框架，它实际上是一种完全的抽象类。\n\n接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n**接口与类相似点：**\n+ 一个接口可以有多个方法。\n+ 接口文件保存在.java结尾的文件中，文件名使用接口名。\n+ 接口的字节码文件保存在.class结尾的文件中。\n+ 接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n\n**接口与类的区别：**\n+ 接口不能用于实例化对象。\n+ 接口没有构造方法。\n+ 接口中所有的方法必须是抽象方法。\n+ 接口不能包含成员变量，除了static和final变量。\n+ 接口不是被类继承了，而是要被类实现。\n+ 接口支持多重继承。\n\n## 接口的定义\n> 修饰符 interface 接口名\n{//接口内容\n//声明变量\n类型 变量名;\n……\n//声明方法\n返回值类型 方法名();\n……\n}\n\n+ 接口的修饰符只能为默认的（无修饰符）或者public。当修饰符为默认时，接口是包可见的，在接口所在的包之外的类不能使用接口。修饰符为public 时，任何类都可以使用该接口。\n+ 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。\n+ 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。\n+ 接口中的方法都是公有的(public)。\n+ 接口内可以声明变量，接口内的变量被自动设置为共有的、静态的、最终的字段\n\n\n```\ninterface Animal {\n   void eat();\n   void travel();\n}\n```\n\n## 接口的实现\n+ 一个类只能继承一个类，但是能实现多个接口。\n+ 一个接口能继承另一个接口，这和类之间的继承比较相似。\n```\n//implements一个类实现一个接口用的关键字\npublic class MammalInt implements Animal{\n\n   public void eat(){\n      System.out.println(\"Mammal eats\");\n   }\n\n   public void travel(){\n      System.out.println(\"Mammal travels\");\n   }\n\n   public static void main(String args[]){\n      MammalInt m = new MammalInt();\n      m.eat();\n      m.travel();\n   }\n}\n```\n\n\n\n\n## 接口的继承\n+ 一个接口能继承另一个接口，和类之间的继承方式比较相似。\n+ 接口允许多重继承。\n\n```java\npublic interface Animal {\n    void eat();\n    void travel();\n}\n\n\ninterface Animal2 {\n    void sleep();\n}\n\n//接口的多重继承\ninterface Animal3 extends Animal, Animal2{\n\n}\n```\n\n## 标记接口\n\n没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：\n+ 建立一个公共的父接口：\n 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。\n+ 向一个类添加数据类型：\n 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。\n\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/Java接口.md","raw":"title: Java接口\ntags: [java面向对象]\ndate: 2016-04-06 15:52:57\ndescription: Java接口\n---\n\n多重继承是指一个类可以继承多个类，也就是一个类可以有多个直接父类。Java 并不支持多重继承。但是当需要复杂问题时却显得力不从心，于是Java 引入了接口来弥补这点不足。\n\n<!-- more -->\n\n## 接口（Interface）\n接口是 Java 提供的一项非常重要的结构。它定义了一系列的抽象方法和常量，形成一个属性集合。接口定义完成后任何类都可以实现接口，而且一个类可以实现多个接口。实现接口的类必须实现接口中定义的抽象方法，具体实现细节由类自己定义。可以说接口定义了类的框架，它实际上是一种完全的抽象类。\n\n接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n**接口与类相似点：**\n+ 一个接口可以有多个方法。\n+ 接口文件保存在.java结尾的文件中，文件名使用接口名。\n+ 接口的字节码文件保存在.class结尾的文件中。\n+ 接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n\n**接口与类的区别：**\n+ 接口不能用于实例化对象。\n+ 接口没有构造方法。\n+ 接口中所有的方法必须是抽象方法。\n+ 接口不能包含成员变量，除了static和final变量。\n+ 接口不是被类继承了，而是要被类实现。\n+ 接口支持多重继承。\n\n## 接口的定义\n> 修饰符 interface 接口名\n{//接口内容\n//声明变量\n类型 变量名;\n……\n//声明方法\n返回值类型 方法名();\n……\n}\n\n+ 接口的修饰符只能为默认的（无修饰符）或者public。当修饰符为默认时，接口是包可见的，在接口所在的包之外的类不能使用接口。修饰符为public 时，任何类都可以使用该接口。\n+ 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。\n+ 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。\n+ 接口中的方法都是公有的(public)。\n+ 接口内可以声明变量，接口内的变量被自动设置为共有的、静态的、最终的字段\n\n\n```\ninterface Animal {\n   void eat();\n   void travel();\n}\n```\n\n## 接口的实现\n+ 一个类只能继承一个类，但是能实现多个接口。\n+ 一个接口能继承另一个接口，这和类之间的继承比较相似。\n```\n//implements一个类实现一个接口用的关键字\npublic class MammalInt implements Animal{\n\n   public void eat(){\n      System.out.println(\"Mammal eats\");\n   }\n\n   public void travel(){\n      System.out.println(\"Mammal travels\");\n   }\n\n   public static void main(String args[]){\n      MammalInt m = new MammalInt();\n      m.eat();\n      m.travel();\n   }\n}\n```\n\n\n\n\n## 接口的继承\n+ 一个接口能继承另一个接口，和类之间的继承方式比较相似。\n+ 接口允许多重继承。\n\n```java\npublic interface Animal {\n    void eat();\n    void travel();\n}\n\n\ninterface Animal2 {\n    void sleep();\n}\n\n//接口的多重继承\ninterface Animal3 extends Animal, Animal2{\n\n}\n```\n\n## 标记接口\n\n没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：\n+ 建立一个公共的父接口：\n 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。\n+ 向一个类添加数据类型：\n 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。\n\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"Java接口","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokn000vy4v2gara975u","content":"<p>多重继承是指一个类可以继承多个类，也就是一个类可以有多个直接父类。Java 并不支持多重继承。但是当需要复杂问题时却显得力不从心，于是Java 引入了接口来弥补这点不足。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"接口（Interface）\"><a href=\"#接口（Interface）\" class=\"headerlink\" title=\"接口（Interface）\"></a>接口（Interface）</h2><p>接口是 Java 提供的一项非常重要的结构。它定义了一系列的抽象方法和常量，形成一个属性集合。接口定义完成后任何类都可以实现接口，而且一个类可以实现多个接口。实现接口的类必须实现接口中定义的抽象方法，具体实现细节由类自己定义。可以说接口定义了类的框架，它实际上是一种完全的抽象类。</p>\n<p>接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。<br>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。<br>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。<br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>\n<p><strong>接口与类相似点：</strong></p>\n<ul>\n<li>一个接口可以有多个方法。</li>\n<li>接口文件保存在.java结尾的文件中，文件名使用接口名。</li>\n<li>接口的字节码文件保存在.class结尾的文件中。</li>\n<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>\n</ul>\n<p><strong>接口与类的区别：</strong></p>\n<ul>\n<li>接口不能用于实例化对象。</li>\n<li>接口没有构造方法。</li>\n<li>接口中所有的方法必须是抽象方法。</li>\n<li>接口不能包含成员变量，除了static和final变量。</li>\n<li>接口不是被类继承了，而是要被类实现。</li>\n<li>接口支持多重继承。</li>\n</ul>\n<h2 id=\"接口的定义\"><a href=\"#接口的定义\" class=\"headerlink\" title=\"接口的定义\"></a>接口的定义</h2><blockquote>\n<p>修饰符 interface 接口名<br>{//接口内容<br>//声明变量<br>类型 变量名;<br>……<br>//声明方法<br>返回值类型 方法名();<br>……<br>}</p>\n</blockquote>\n<ul>\n<li>接口的修饰符只能为默认的（无修饰符）或者public。当修饰符为默认时，接口是包可见的，在接口所在的包之外的类不能使用接口。修饰符为public 时，任何类都可以使用该接口。</li>\n<li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li>\n<li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。</li>\n<li>接口中的方法都是公有的(public)。</li>\n<li>接口内可以声明变量，接口内的变量被自动设置为共有的、静态的、最终的字段</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Animal &#123;</span><br><span class=\"line\">   void eat();</span><br><span class=\"line\">   void travel();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接口的实现\"><a href=\"#接口的实现\" class=\"headerlink\" title=\"接口的实现\"></a>接口的实现</h2><ul>\n<li>一个类只能继承一个类，但是能实现多个接口。</li>\n<li>一个接口能继承另一个接口，这和类之间的继承比较相似。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//implements一个类实现一个接口用的关键字</span><br><span class=\"line\">public class MammalInt implements Animal&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   public void eat()&#123;</span><br><span class=\"line\">      System.out.println(&quot;Mammal eats&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public void travel()&#123;</span><br><span class=\"line\">      System.out.println(&quot;Mammal travels&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public static void main(String args[])&#123;</span><br><span class=\"line\">      MammalInt m = new MammalInt();</span><br><span class=\"line\">      m.eat();</span><br><span class=\"line\">      m.travel();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"接口的继承\"><a href=\"#接口的继承\" class=\"headerlink\" title=\"接口的继承\"></a>接口的继承</h2><ul>\n<li>一个接口能继承另一个接口，和类之间的继承方式比较相似。</li>\n<li>接口允许多重继承。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">travel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Animal2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接口的多重继承</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Animal3</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span>, <span class=\"title\">Animal2</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标记接口\"><a href=\"#标记接口\" class=\"headerlink\" title=\"标记接口\"></a>标记接口</h2><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>\n<ul>\n<li>建立一个公共的父接口：<br>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</li>\n<li>向一个类添加数据类型：<br>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>多重继承是指一个类可以继承多个类，也就是一个类可以有多个直接父类。Java 并不支持多重继承。但是当需要复杂问题时却显得力不从心，于是Java 引入了接口来弥补这点不足。</p>","more":"<h2 id=\"接口（Interface）\"><a href=\"#接口（Interface）\" class=\"headerlink\" title=\"接口（Interface）\"></a>接口（Interface）</h2><p>接口是 Java 提供的一项非常重要的结构。它定义了一系列的抽象方法和常量，形成一个属性集合。接口定义完成后任何类都可以实现接口，而且一个类可以实现多个接口。实现接口的类必须实现接口中定义的抽象方法，具体实现细节由类自己定义。可以说接口定义了类的框架，它实际上是一种完全的抽象类。</p>\n<p>接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。<br>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。<br>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。<br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>\n<p><strong>接口与类相似点：</strong></p>\n<ul>\n<li>一个接口可以有多个方法。</li>\n<li>接口文件保存在.java结尾的文件中，文件名使用接口名。</li>\n<li>接口的字节码文件保存在.class结尾的文件中。</li>\n<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>\n</ul>\n<p><strong>接口与类的区别：</strong></p>\n<ul>\n<li>接口不能用于实例化对象。</li>\n<li>接口没有构造方法。</li>\n<li>接口中所有的方法必须是抽象方法。</li>\n<li>接口不能包含成员变量，除了static和final变量。</li>\n<li>接口不是被类继承了，而是要被类实现。</li>\n<li>接口支持多重继承。</li>\n</ul>\n<h2 id=\"接口的定义\"><a href=\"#接口的定义\" class=\"headerlink\" title=\"接口的定义\"></a>接口的定义</h2><blockquote>\n<p>修饰符 interface 接口名<br>{//接口内容<br>//声明变量<br>类型 变量名;<br>……<br>//声明方法<br>返回值类型 方法名();<br>……<br>}</p>\n</blockquote>\n<ul>\n<li>接口的修饰符只能为默认的（无修饰符）或者public。当修饰符为默认时，接口是包可见的，在接口所在的包之外的类不能使用接口。修饰符为public 时，任何类都可以使用该接口。</li>\n<li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li>\n<li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。</li>\n<li>接口中的方法都是公有的(public)。</li>\n<li>接口内可以声明变量，接口内的变量被自动设置为共有的、静态的、最终的字段</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Animal &#123;</span><br><span class=\"line\">   void eat();</span><br><span class=\"line\">   void travel();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接口的实现\"><a href=\"#接口的实现\" class=\"headerlink\" title=\"接口的实现\"></a>接口的实现</h2><ul>\n<li>一个类只能继承一个类，但是能实现多个接口。</li>\n<li>一个接口能继承另一个接口，这和类之间的继承比较相似。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//implements一个类实现一个接口用的关键字</span><br><span class=\"line\">public class MammalInt implements Animal&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   public void eat()&#123;</span><br><span class=\"line\">      System.out.println(&quot;Mammal eats&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public void travel()&#123;</span><br><span class=\"line\">      System.out.println(&quot;Mammal travels&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public static void main(String args[])&#123;</span><br><span class=\"line\">      MammalInt m = new MammalInt();</span><br><span class=\"line\">      m.eat();</span><br><span class=\"line\">      m.travel();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"接口的继承\"><a href=\"#接口的继承\" class=\"headerlink\" title=\"接口的继承\"></a>接口的继承</h2><ul>\n<li>一个接口能继承另一个接口，和类之间的继承方式比较相似。</li>\n<li>接口允许多重继承。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">travel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Animal2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接口的多重继承</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Animal3</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span>, <span class=\"title\">Animal2</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标记接口\"><a href=\"#标记接口\" class=\"headerlink\" title=\"标记接口\"></a>标记接口</h2><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>\n<ul>\n<li>建立一个公共的父接口：<br>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</li>\n<li>向一个类添加数据类型：<br>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"Java线程","date":"2016-04-12T06:06:05.000Z","description":"Java线程","_content":"\n## 线程\n1. 线程\n> 线程（Thread）是控制线程（Thread of Control）的缩写，是程序运行的基本单位，它是具有一定顺序的指令序列（即所编写的程序代码）、存放方法中定义局部变量的栈和一些共享数据。线程是相互独立的，每个方法的局部变量和其他线程的局部变量是分开的，因此，任何线程都不能访问除自身之外的其他线程的局部变量。如果两个线程同时访问同一个方法，那每个线程将各自得到此方法的一个拷贝。\n\n<!-- more -->\n\n2. 多线程\n> 多进程：多线程实现后台服务程序可以同时处理多个任务，并不发生阻塞现象。多线程是Java 语言的一个很重要的特征。多线程程序设计最大的特点就是能够提高程序执行效率和处理速度。Java 程序可同时并行运行多个相对独立的线程。\n3. 进程\n> 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。\n\n\n## 实现\nJava提供了两种实现线程的方法\n1. 实现Runnable接口\nRunnable 接口提供了run()方法的原型，因此创建新的线程类时，只要实现此接口，即只要特定的程序代码实现Runnable 接口中的run()方法，就可完成新线程类的运行。\n + 创建一个实现Runnable 接口的类，并且在这个类中重写run 方法。\n > class ThreadType implements Runnable{\n    public void run(){\n        ……\n    }\n}\n + 使用关键字new 新建一个ThreadType 的实例\n > Runnable threadName = new ThreadType ();\n + 创建线程（threadOb 是一个实现Runnable 接口的类的实例；threadName指定新线程的名字）\n > Thread(Runnable threadOb,String threadName);\n + 启动线程\n > threadName.start();\n\n实例：\n```\npublic class RunnableDemo implements Runnable {\n    public void run(){\n        for (int count = 1,row = 1; row < 10; row++,count++) //循环计算输出的*数目\n        {\n            for (int i = 0; i < count; i++) //循环输出指定的count 数目的*\n            {\n                System.out.print('*'); //输出*\n            }\n            System.out.println(); //输出换行符\n        }\n    }\n\n    public static void main(String argv[ ]){\n        Runnable rb = new RunnableDemo(); //创建，并初始化RunnableDemo 对象rb\n        Thread td = new Thread(rb); //通过Thread 创建线程\n        td.start(); //启动线程td\n    }\n\n}\n```\n2. 派生Thread类\n继承Thread 类并覆盖Thread 类的run 方法完成线程类的声明，通过new 创建派生线程类的线程对象。\n + 创建一个新的线程类，继承Thread 类并覆盖Thread 类的run()方法\n > class ThreadType extends Thread{\n     public void run(){\n       ……\n     }\n}\n + 创建线程\n > ThreadDemo threadName = new ThreadDemo();\n + 启动线程\n > threadName.start();\n\n实例：\n```\npublic class ThreadDemo extends Thread {\n    //重载run 函数\n    public void run() {\n        for (int count = 1,row = 1; row < 10; row++,count++) //循环计算输出的*数目\n        {\n            for (int i = 0; i < count; i++) //循环输出指定的count 数目的*\n            {\n                System.out.print('*'); //输出*\n            }\n            System.out.println(); //输出换行符\n        }\n    }\n    public static void main(String argv[ ]){\n        ThreadDemo td = new ThreadDemo(); //创建，并初始化ThreadDemo类型对象td\n        td.start(); //调用start()方法执行一个新的线程\n    }\n}\n```\n\n## 线程周期\n\n一个线程有 4 种状态，任何一个线程都处于这4 种状态中的一种状态。\n+ 创建（new）状态：调用new 方法产生一个线程对象后、调用start 方法前所处的状态。线程对象虽然已经创建，但还没有调用start 方法启动，因此无法执行。当线程处于创建状态时，线程对象可以调用start 方法进入启动状态，也可以调用stop 方法进入停止状态。\n+ 可运行（runnable）状态：当线程对象执行start()方法后，线程就转到可运行状态。进入此状态只是说明线程对象具有了可以运行的条件，但线程并不一定处于运行状态。因为在单处理器系统中运行多线程程序时，一个时间点只有一个线程运行，系统通过调度机制实现宏观意义上的运行线程共享处理器。因此一个线程是否在运行，除了线程必须处于Runnable 状态之外，还取决于优先级和调度。\n+ 不可运行（non Runnable）状态：线程处于不可运行状态是由于线程被挂起或者发生阻塞，例如对一个线程调用wait()函数后，它就可能进入阻塞状态；调用线程的notify 或notifyAll 方法后它才能再次回到可执行状态。\n+ 退出（done）状态：一个线程可以从任何一个状态中调用stop 方法进入退出状态。线程一旦进入退出状态就不存在了，不能再返回到其他的状态。除此之外，如果线程执行完run 方法，也会自动进入退出状态。\n来看菜鸟教程的一张图：\n![](/images/201601/process.png)\n\n\n## 线程状态转换函数\n![](/images/201601/state.png)\n注意：stop()、suspend()和resume()方法现在已经不提倡使用，这些方法在虚拟机中可能引起“死锁”现象。suspend()和resume()方法的替代方法是wait()和sleep()。线程的退出通常采用自然终止的方法，建议不要人工调用stop()方法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/Java线程.md","raw":"title: Java线程\ntags: [Java基础]\ndate: 2016-04-12 14:06:05\ndescription: Java线程\n---\n\n## 线程\n1. 线程\n> 线程（Thread）是控制线程（Thread of Control）的缩写，是程序运行的基本单位，它是具有一定顺序的指令序列（即所编写的程序代码）、存放方法中定义局部变量的栈和一些共享数据。线程是相互独立的，每个方法的局部变量和其他线程的局部变量是分开的，因此，任何线程都不能访问除自身之外的其他线程的局部变量。如果两个线程同时访问同一个方法，那每个线程将各自得到此方法的一个拷贝。\n\n<!-- more -->\n\n2. 多线程\n> 多进程：多线程实现后台服务程序可以同时处理多个任务，并不发生阻塞现象。多线程是Java 语言的一个很重要的特征。多线程程序设计最大的特点就是能够提高程序执行效率和处理速度。Java 程序可同时并行运行多个相对独立的线程。\n3. 进程\n> 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。\n\n\n## 实现\nJava提供了两种实现线程的方法\n1. 实现Runnable接口\nRunnable 接口提供了run()方法的原型，因此创建新的线程类时，只要实现此接口，即只要特定的程序代码实现Runnable 接口中的run()方法，就可完成新线程类的运行。\n + 创建一个实现Runnable 接口的类，并且在这个类中重写run 方法。\n > class ThreadType implements Runnable{\n    public void run(){\n        ……\n    }\n}\n + 使用关键字new 新建一个ThreadType 的实例\n > Runnable threadName = new ThreadType ();\n + 创建线程（threadOb 是一个实现Runnable 接口的类的实例；threadName指定新线程的名字）\n > Thread(Runnable threadOb,String threadName);\n + 启动线程\n > threadName.start();\n\n实例：\n```\npublic class RunnableDemo implements Runnable {\n    public void run(){\n        for (int count = 1,row = 1; row < 10; row++,count++) //循环计算输出的*数目\n        {\n            for (int i = 0; i < count; i++) //循环输出指定的count 数目的*\n            {\n                System.out.print('*'); //输出*\n            }\n            System.out.println(); //输出换行符\n        }\n    }\n\n    public static void main(String argv[ ]){\n        Runnable rb = new RunnableDemo(); //创建，并初始化RunnableDemo 对象rb\n        Thread td = new Thread(rb); //通过Thread 创建线程\n        td.start(); //启动线程td\n    }\n\n}\n```\n2. 派生Thread类\n继承Thread 类并覆盖Thread 类的run 方法完成线程类的声明，通过new 创建派生线程类的线程对象。\n + 创建一个新的线程类，继承Thread 类并覆盖Thread 类的run()方法\n > class ThreadType extends Thread{\n     public void run(){\n       ……\n     }\n}\n + 创建线程\n > ThreadDemo threadName = new ThreadDemo();\n + 启动线程\n > threadName.start();\n\n实例：\n```\npublic class ThreadDemo extends Thread {\n    //重载run 函数\n    public void run() {\n        for (int count = 1,row = 1; row < 10; row++,count++) //循环计算输出的*数目\n        {\n            for (int i = 0; i < count; i++) //循环输出指定的count 数目的*\n            {\n                System.out.print('*'); //输出*\n            }\n            System.out.println(); //输出换行符\n        }\n    }\n    public static void main(String argv[ ]){\n        ThreadDemo td = new ThreadDemo(); //创建，并初始化ThreadDemo类型对象td\n        td.start(); //调用start()方法执行一个新的线程\n    }\n}\n```\n\n## 线程周期\n\n一个线程有 4 种状态，任何一个线程都处于这4 种状态中的一种状态。\n+ 创建（new）状态：调用new 方法产生一个线程对象后、调用start 方法前所处的状态。线程对象虽然已经创建，但还没有调用start 方法启动，因此无法执行。当线程处于创建状态时，线程对象可以调用start 方法进入启动状态，也可以调用stop 方法进入停止状态。\n+ 可运行（runnable）状态：当线程对象执行start()方法后，线程就转到可运行状态。进入此状态只是说明线程对象具有了可以运行的条件，但线程并不一定处于运行状态。因为在单处理器系统中运行多线程程序时，一个时间点只有一个线程运行，系统通过调度机制实现宏观意义上的运行线程共享处理器。因此一个线程是否在运行，除了线程必须处于Runnable 状态之外，还取决于优先级和调度。\n+ 不可运行（non Runnable）状态：线程处于不可运行状态是由于线程被挂起或者发生阻塞，例如对一个线程调用wait()函数后，它就可能进入阻塞状态；调用线程的notify 或notifyAll 方法后它才能再次回到可执行状态。\n+ 退出（done）状态：一个线程可以从任何一个状态中调用stop 方法进入退出状态。线程一旦进入退出状态就不存在了，不能再返回到其他的状态。除此之外，如果线程执行完run 方法，也会自动进入退出状态。\n来看菜鸟教程的一张图：\n![](/images/201601/process.png)\n\n\n## 线程状态转换函数\n![](/images/201601/state.png)\n注意：stop()、suspend()和resume()方法现在已经不提倡使用，这些方法在虚拟机中可能引起“死锁”现象。suspend()和resume()方法的替代方法是wait()和sleep()。线程的退出通常采用自然终止的方法，建议不要人工调用stop()方法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"Java线程","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoko000xy4v29fqy4gbd","content":"<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><ol>\n<li>线程<blockquote>\n<p>线程（Thread）是控制线程（Thread of Control）的缩写，是程序运行的基本单位，它是具有一定顺序的指令序列（即所编写的程序代码）、存放方法中定义局部变量的栈和一些共享数据。线程是相互独立的，每个方法的局部变量和其他线程的局部变量是分开的，因此，任何线程都不能访问除自身之外的其他线程的局部变量。如果两个线程同时访问同一个方法，那每个线程将各自得到此方法的一个拷贝。</p>\n</blockquote>\n</li>\n</ol>\n<span id=\"more\"></span>\n\n<ol start=\"2\">\n<li>多线程<blockquote>\n<p>多进程：多线程实现后台服务程序可以同时处理多个任务，并不发生阻塞现象。多线程是Java 语言的一个很重要的特征。多线程程序设计最大的特点就是能够提高程序执行效率和处理速度。Java 程序可同时并行运行多个相对独立的线程。</p>\n</blockquote>\n</li>\n<li>进程<blockquote>\n<p>进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>Java提供了两种实现线程的方法</p>\n<ol>\n<li>实现Runnable接口<br>Runnable 接口提供了run()方法的原型，因此创建新的线程类时，只要实现此接口，即只要特定的程序代码实现Runnable 接口中的run()方法，就可完成新线程类的运行。</li>\n</ol>\n<ul>\n<li>创建一个实现Runnable 接口的类，并且在这个类中重写run 方法。<blockquote>\n<p>class ThreadType implements Runnable{<br> public void run(){</p>\n<pre><code> ……\n</code></pre>\n<p> }<br>}</p>\n</blockquote>\n</li>\n<li>使用关键字new 新建一个ThreadType 的实例<blockquote>\n<p>Runnable threadName = new ThreadType ();</p>\n</blockquote>\n</li>\n<li>创建线程（threadOb 是一个实现Runnable 接口的类的实例；threadName指定新线程的名字）<blockquote>\n<p>Thread(Runnable threadOb,String threadName);</p>\n</blockquote>\n</li>\n<li>启动线程<blockquote>\n<p>threadName.start();</p>\n</blockquote>\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RunnableDemo implements Runnable &#123;</span><br><span class=\"line\">    public void run()&#123;</span><br><span class=\"line\">        for (int count = 1,row = 1; row &lt; 10; row++,count++) //循环计算输出的*数目</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; count; i++) //循环输出指定的count 数目的*</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                System.out.print(&#x27;*&#x27;); //输出*</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(); //输出换行符</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String argv[ ])&#123;</span><br><span class=\"line\">        Runnable rb = new RunnableDemo(); //创建，并初始化RunnableDemo 对象rb</span><br><span class=\"line\">        Thread td = new Thread(rb); //通过Thread 创建线程</span><br><span class=\"line\">        td.start(); //启动线程td</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>派生Thread类<br>继承Thread 类并覆盖Thread 类的run 方法完成线程类的声明，通过new 创建派生线程类的线程对象。</li>\n</ol>\n<ul>\n<li>创建一个新的线程类，继承Thread 类并覆盖Thread 类的run()方法<blockquote>\n<p>class ThreadType extends Thread{<br>  public void run(){</p>\n<pre><code>……\n</code></pre>\n<p>  }<br>}</p>\n</blockquote>\n</li>\n<li>创建线程<blockquote>\n<p>ThreadDemo threadName = new ThreadDemo();</p>\n</blockquote>\n</li>\n<li>启动线程<blockquote>\n<p>threadName.start();</p>\n</blockquote>\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadDemo extends Thread &#123;</span><br><span class=\"line\">    //重载run 函数</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        for (int count = 1,row = 1; row &lt; 10; row++,count++) //循环计算输出的*数目</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; count; i++) //循环输出指定的count 数目的*</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                System.out.print(&#x27;*&#x27;); //输出*</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(); //输出换行符</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String argv[ ])&#123;</span><br><span class=\"line\">        ThreadDemo td = new ThreadDemo(); //创建，并初始化ThreadDemo类型对象td</span><br><span class=\"line\">        td.start(); //调用start()方法执行一个新的线程</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程周期\"><a href=\"#线程周期\" class=\"headerlink\" title=\"线程周期\"></a>线程周期</h2><p>一个线程有 4 种状态，任何一个线程都处于这4 种状态中的一种状态。</p>\n<ul>\n<li>创建（new）状态：调用new 方法产生一个线程对象后、调用start 方法前所处的状态。线程对象虽然已经创建，但还没有调用start 方法启动，因此无法执行。当线程处于创建状态时，线程对象可以调用start 方法进入启动状态，也可以调用stop 方法进入停止状态。</li>\n<li>可运行（runnable）状态：当线程对象执行start()方法后，线程就转到可运行状态。进入此状态只是说明线程对象具有了可以运行的条件，但线程并不一定处于运行状态。因为在单处理器系统中运行多线程程序时，一个时间点只有一个线程运行，系统通过调度机制实现宏观意义上的运行线程共享处理器。因此一个线程是否在运行，除了线程必须处于Runnable 状态之外，还取决于优先级和调度。</li>\n<li>不可运行（non Runnable）状态：线程处于不可运行状态是由于线程被挂起或者发生阻塞，例如对一个线程调用wait()函数后，它就可能进入阻塞状态；调用线程的notify 或notifyAll 方法后它才能再次回到可执行状态。</li>\n<li>退出（done）状态：一个线程可以从任何一个状态中调用stop 方法进入退出状态。线程一旦进入退出状态就不存在了，不能再返回到其他的状态。除此之外，如果线程执行完run 方法，也会自动进入退出状态。<br>来看菜鸟教程的一张图：<br><img src=\"/images/201601/process.png\"></li>\n</ul>\n<h2 id=\"线程状态转换函数\"><a href=\"#线程状态转换函数\" class=\"headerlink\" title=\"线程状态转换函数\"></a>线程状态转换函数</h2><p><img src=\"/images/201601/state.png\"><br>注意：stop()、suspend()和resume()方法现在已经不提倡使用，这些方法在虚拟机中可能引起“死锁”现象。suspend()和resume()方法的替代方法是wait()和sleep()。线程的退出通常采用自然终止的方法，建议不要人工调用stop()方法。</p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><ol>\n<li>线程<blockquote>\n<p>线程（Thread）是控制线程（Thread of Control）的缩写，是程序运行的基本单位，它是具有一定顺序的指令序列（即所编写的程序代码）、存放方法中定义局部变量的栈和一些共享数据。线程是相互独立的，每个方法的局部变量和其他线程的局部变量是分开的，因此，任何线程都不能访问除自身之外的其他线程的局部变量。如果两个线程同时访问同一个方法，那每个线程将各自得到此方法的一个拷贝。</p>\n</blockquote>\n</li>\n</ol>","more":"<ol start=\"2\">\n<li>多线程<blockquote>\n<p>多进程：多线程实现后台服务程序可以同时处理多个任务，并不发生阻塞现象。多线程是Java 语言的一个很重要的特征。多线程程序设计最大的特点就是能够提高程序执行效率和处理速度。Java 程序可同时并行运行多个相对独立的线程。</p>\n</blockquote>\n</li>\n<li>进程<blockquote>\n<p>进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>Java提供了两种实现线程的方法</p>\n<ol>\n<li>实现Runnable接口<br>Runnable 接口提供了run()方法的原型，因此创建新的线程类时，只要实现此接口，即只要特定的程序代码实现Runnable 接口中的run()方法，就可完成新线程类的运行。</li>\n</ol>\n<ul>\n<li>创建一个实现Runnable 接口的类，并且在这个类中重写run 方法。<blockquote>\n<p>class ThreadType implements Runnable{<br> public void run(){</p>\n<pre><code> ……\n</code></pre>\n<p> }<br>}</p>\n</blockquote>\n</li>\n<li>使用关键字new 新建一个ThreadType 的实例<blockquote>\n<p>Runnable threadName = new ThreadType ();</p>\n</blockquote>\n</li>\n<li>创建线程（threadOb 是一个实现Runnable 接口的类的实例；threadName指定新线程的名字）<blockquote>\n<p>Thread(Runnable threadOb,String threadName);</p>\n</blockquote>\n</li>\n<li>启动线程<blockquote>\n<p>threadName.start();</p>\n</blockquote>\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RunnableDemo implements Runnable &#123;</span><br><span class=\"line\">    public void run()&#123;</span><br><span class=\"line\">        for (int count = 1,row = 1; row &lt; 10; row++,count++) //循环计算输出的*数目</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; count; i++) //循环输出指定的count 数目的*</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                System.out.print(&#x27;*&#x27;); //输出*</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(); //输出换行符</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String argv[ ])&#123;</span><br><span class=\"line\">        Runnable rb = new RunnableDemo(); //创建，并初始化RunnableDemo 对象rb</span><br><span class=\"line\">        Thread td = new Thread(rb); //通过Thread 创建线程</span><br><span class=\"line\">        td.start(); //启动线程td</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>派生Thread类<br>继承Thread 类并覆盖Thread 类的run 方法完成线程类的声明，通过new 创建派生线程类的线程对象。</li>\n</ol>\n<ul>\n<li>创建一个新的线程类，继承Thread 类并覆盖Thread 类的run()方法<blockquote>\n<p>class ThreadType extends Thread{<br>  public void run(){</p>\n<pre><code>……\n</code></pre>\n<p>  }<br>}</p>\n</blockquote>\n</li>\n<li>创建线程<blockquote>\n<p>ThreadDemo threadName = new ThreadDemo();</p>\n</blockquote>\n</li>\n<li>启动线程<blockquote>\n<p>threadName.start();</p>\n</blockquote>\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadDemo extends Thread &#123;</span><br><span class=\"line\">    //重载run 函数</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        for (int count = 1,row = 1; row &lt; 10; row++,count++) //循环计算输出的*数目</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; count; i++) //循环输出指定的count 数目的*</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                System.out.print(&#x27;*&#x27;); //输出*</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(); //输出换行符</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String argv[ ])&#123;</span><br><span class=\"line\">        ThreadDemo td = new ThreadDemo(); //创建，并初始化ThreadDemo类型对象td</span><br><span class=\"line\">        td.start(); //调用start()方法执行一个新的线程</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程周期\"><a href=\"#线程周期\" class=\"headerlink\" title=\"线程周期\"></a>线程周期</h2><p>一个线程有 4 种状态，任何一个线程都处于这4 种状态中的一种状态。</p>\n<ul>\n<li>创建（new）状态：调用new 方法产生一个线程对象后、调用start 方法前所处的状态。线程对象虽然已经创建，但还没有调用start 方法启动，因此无法执行。当线程处于创建状态时，线程对象可以调用start 方法进入启动状态，也可以调用stop 方法进入停止状态。</li>\n<li>可运行（runnable）状态：当线程对象执行start()方法后，线程就转到可运行状态。进入此状态只是说明线程对象具有了可以运行的条件，但线程并不一定处于运行状态。因为在单处理器系统中运行多线程程序时，一个时间点只有一个线程运行，系统通过调度机制实现宏观意义上的运行线程共享处理器。因此一个线程是否在运行，除了线程必须处于Runnable 状态之外，还取决于优先级和调度。</li>\n<li>不可运行（non Runnable）状态：线程处于不可运行状态是由于线程被挂起或者发生阻塞，例如对一个线程调用wait()函数后，它就可能进入阻塞状态；调用线程的notify 或notifyAll 方法后它才能再次回到可执行状态。</li>\n<li>退出（done）状态：一个线程可以从任何一个状态中调用stop 方法进入退出状态。线程一旦进入退出状态就不存在了，不能再返回到其他的状态。除此之外，如果线程执行完run 方法，也会自动进入退出状态。<br>来看菜鸟教程的一张图：<br><img src=\"/images/201601/process.png\"></li>\n</ul>\n<h2 id=\"线程状态转换函数\"><a href=\"#线程状态转换函数\" class=\"headerlink\" title=\"线程状态转换函数\"></a>线程状态转换函数</h2><p><img src=\"/images/201601/state.png\"><br>注意：stop()、suspend()和resume()方法现在已经不提倡使用，这些方法在虚拟机中可能引起“死锁”现象。suspend()和resume()方法的替代方法是wait()和sleep()。线程的退出通常采用自然终止的方法，建议不要人工调用stop()方法。</p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"_content":"# Jquery属性获取——attr()与prop()\n今天在项目中使用`<select></select>`下拉菜单时，使用juery操作，使页面加载完菜单默认选中的值为2,我一开始的操作如下：\n\n\t<!--html部分-->\n    <select>\n       <option value=\"1\">1</option>\n       <option value=\"2\" id=\"second\">2</option>\n       <option value=\"3\">3</option>\n    </select>\n\n\t/**js部分**/\n\t$(\"#second\").attr(\"selected\",\"selected\");\n\n咋一看好完美，木问题，但是我发现在Safari浏览器中，根本不起作用！！仔细查看一番发现,在Safari浏览器中，属性确实是设置成功了，既value=2的那一项确实是`<option value=\"2\" selected=\"selected\">2</option>`。那问题出在哪呢？冷静，不要方，万能的stack说只要把`attr`改成`prop`就行了，卧槽还真行了，这是啥诡异事件。好吧，我们需要来研究研究了,不用想，肯定是需要祭出官方文档了。\n\n1. attr() ： 获取匹配的元素集合中的第一个元素的属性的值  或 设置每一个匹配元素的一个或多个属性。\n\t- .attr( attributeName )\n\t\t- .attr( attributeName )\n\t- .attr( attributeName, value )\n\t\t- .attr( attributeName, value )\n\t\t- .attr( attributes )\n\t\t- .attr( attributeName, function(index, attr) )\n\n1. prop() ： 获取匹配的元素集中第一个元素的属性（property）值或设置每一个匹配元素的一个或多个属性。\n\t- .prop( propertyName )\n\t\t- .prop( propertyName )\n\t- .prop( propertyName, value )\n\t\t- .prop( propertyName, value )\n\t\t- .prop( properties )\n\t\t- .prop( propertyName, function(index, oldPropertyValue) )\n\n看出区别了吗，没错，是参数有区别，`attr()`传入的是`attributeName`，而`prop()`传入的是`propertyName`,现在我们的问题转移了，我们需要研究的是`attributeName`和`propertyName`之间的区别了。\n\n\n## Attributes vs. Properties ##\n在这里，我们可以将attribute理解为“特性”，property理解为“属性”从而来区分俩者的差异。\n如果把DOM元素看成是一个普通的Object对象，这个对象在其定义时就具有一些属性（property），比如把select的option当做一个对象：\n\n    var option = {\n\t\tselected:false，\n\t\tdisabled:false，\n\t\tattributes:NamedNodeMap,\n\t\t...\n\t}\n\n\n现在，我们一目了然了，attribute是一个特性节点，每个DOM元素都有一个对应的attributes属性来存放所有的attribute节点，它是一个叫做NameNodeMap的对象。attributes的每个数字索引以名值对(name=”value”)的形式存放了一个attribute节点。而property就是一个属性，是一个以名值对(name=”value”)的形式存放在Object中的属性。\n\n**上例中`<option value='2' selected>2</option>`的`property`为`{0: value, 1: selected, length: 2}`**\n\n\n回到一开始的问题，根据W3C的表单规范 ，在selected属性（property）是一个布尔属性， 这意味着,如果这个特性（attribute）存在， 即使该特性没有对应的值，或者被设置为空字符串值，或甚至是\"false\"，相应的属性（property）都还是为true。 selected特性（attribute）值不会因为复选框的状态而改变，而selected属性（property）会因为复选框的状态而改变。因此，跨浏览器兼容的检索和更改DOM属性,比如元素的checked, selected, 或 disabled状态，请使用.prop()方法。\n\n\n## 为什么会搞混？ ##\n之所以attribute和property容易混倄在一起的原因是，很多attribute节点还有一个相对应的property属性，比如DOM元素的id和class既是attribute，也有对应的property，不管使用哪种方法都可以访问和修改。","source":"_posts/Jquery属性获取——attr()与prop().md","raw":"# Jquery属性获取——attr()与prop()\n今天在项目中使用`<select></select>`下拉菜单时，使用juery操作，使页面加载完菜单默认选中的值为2,我一开始的操作如下：\n\n\t<!--html部分-->\n    <select>\n       <option value=\"1\">1</option>\n       <option value=\"2\" id=\"second\">2</option>\n       <option value=\"3\">3</option>\n    </select>\n\n\t/**js部分**/\n\t$(\"#second\").attr(\"selected\",\"selected\");\n\n咋一看好完美，木问题，但是我发现在Safari浏览器中，根本不起作用！！仔细查看一番发现,在Safari浏览器中，属性确实是设置成功了，既value=2的那一项确实是`<option value=\"2\" selected=\"selected\">2</option>`。那问题出在哪呢？冷静，不要方，万能的stack说只要把`attr`改成`prop`就行了，卧槽还真行了，这是啥诡异事件。好吧，我们需要来研究研究了,不用想，肯定是需要祭出官方文档了。\n\n1. attr() ： 获取匹配的元素集合中的第一个元素的属性的值  或 设置每一个匹配元素的一个或多个属性。\n\t- .attr( attributeName )\n\t\t- .attr( attributeName )\n\t- .attr( attributeName, value )\n\t\t- .attr( attributeName, value )\n\t\t- .attr( attributes )\n\t\t- .attr( attributeName, function(index, attr) )\n\n1. prop() ： 获取匹配的元素集中第一个元素的属性（property）值或设置每一个匹配元素的一个或多个属性。\n\t- .prop( propertyName )\n\t\t- .prop( propertyName )\n\t- .prop( propertyName, value )\n\t\t- .prop( propertyName, value )\n\t\t- .prop( properties )\n\t\t- .prop( propertyName, function(index, oldPropertyValue) )\n\n看出区别了吗，没错，是参数有区别，`attr()`传入的是`attributeName`，而`prop()`传入的是`propertyName`,现在我们的问题转移了，我们需要研究的是`attributeName`和`propertyName`之间的区别了。\n\n\n## Attributes vs. Properties ##\n在这里，我们可以将attribute理解为“特性”，property理解为“属性”从而来区分俩者的差异。\n如果把DOM元素看成是一个普通的Object对象，这个对象在其定义时就具有一些属性（property），比如把select的option当做一个对象：\n\n    var option = {\n\t\tselected:false，\n\t\tdisabled:false，\n\t\tattributes:NamedNodeMap,\n\t\t...\n\t}\n\n\n现在，我们一目了然了，attribute是一个特性节点，每个DOM元素都有一个对应的attributes属性来存放所有的attribute节点，它是一个叫做NameNodeMap的对象。attributes的每个数字索引以名值对(name=”value”)的形式存放了一个attribute节点。而property就是一个属性，是一个以名值对(name=”value”)的形式存放在Object中的属性。\n\n**上例中`<option value='2' selected>2</option>`的`property`为`{0: value, 1: selected, length: 2}`**\n\n\n回到一开始的问题，根据W3C的表单规范 ，在selected属性（property）是一个布尔属性， 这意味着,如果这个特性（attribute）存在， 即使该特性没有对应的值，或者被设置为空字符串值，或甚至是\"false\"，相应的属性（property）都还是为true。 selected特性（attribute）值不会因为复选框的状态而改变，而selected属性（property）会因为复选框的状态而改变。因此，跨浏览器兼容的检索和更改DOM属性,比如元素的checked, selected, 或 disabled状态，请使用.prop()方法。\n\n\n## 为什么会搞混？ ##\n之所以attribute和property容易混倄在一起的原因是，很多attribute节点还有一个相对应的property属性，比如DOM元素的id和class既是attribute，也有对应的property，不管使用哪种方法都可以访问和修改。","slug":"Jquery属性获取——attr()与prop()","published":1,"date":"2021-12-06T06:07:06.123Z","updated":"2021-12-06T06:07:06.123Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokr0010y4v20zym16ta","content":"<h1 id=\"Jquery属性获取——attr-与prop\"><a href=\"#Jquery属性获取——attr-与prop\" class=\"headerlink\" title=\"Jquery属性获取——attr()与prop()\"></a>Jquery属性获取——attr()与prop()</h1><p>今天在项目中使用<code>&lt;select&gt;&lt;/select&gt;</code>下拉菜单时，使用juery操作，使页面加载完菜单默认选中的值为2,我一开始的操作如下：</p>\n<pre><code>&lt;!--html部分--&gt;\n&lt;select&gt;\n   &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\n   &lt;option value=&quot;2&quot; id=&quot;second&quot;&gt;2&lt;/option&gt;\n   &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\n&lt;/select&gt;\n\n/**js部分**/\n$(&quot;#second&quot;).attr(&quot;selected&quot;,&quot;selected&quot;);\n</code></pre>\n<p>咋一看好完美，木问题，但是我发现在Safari浏览器中，根本不起作用！！仔细查看一番发现,在Safari浏览器中，属性确实是设置成功了，既value=2的那一项确实是<code>&lt;option value=&quot;2&quot; selected=&quot;selected&quot;&gt;2&lt;/option&gt;</code>。那问题出在哪呢？冷静，不要方，万能的stack说只要把<code>attr</code>改成<code>prop</code>就行了，卧槽还真行了，这是啥诡异事件。好吧，我们需要来研究研究了,不用想，肯定是需要祭出官方文档了。</p>\n<ol>\n<li><p>attr() ： 获取匹配的元素集合中的第一个元素的属性的值  或 设置每一个匹配元素的一个或多个属性。</p>\n<ul>\n<li>.attr( attributeName )<ul>\n<li>.attr( attributeName )</li>\n</ul>\n</li>\n<li>.attr( attributeName, value )<ul>\n<li>.attr( attributeName, value )</li>\n<li>.attr( attributes )</li>\n<li>.attr( attributeName, function(index, attr) )</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>prop() ： 获取匹配的元素集中第一个元素的属性（property）值或设置每一个匹配元素的一个或多个属性。</p>\n<ul>\n<li>.prop( propertyName )<ul>\n<li>.prop( propertyName )</li>\n</ul>\n</li>\n<li>.prop( propertyName, value )<ul>\n<li>.prop( propertyName, value )</li>\n<li>.prop( properties )</li>\n<li>.prop( propertyName, function(index, oldPropertyValue) )</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>看出区别了吗，没错，是参数有区别，<code>attr()</code>传入的是<code>attributeName</code>，而<code>prop()</code>传入的是<code>propertyName</code>,现在我们的问题转移了，我们需要研究的是<code>attributeName</code>和<code>propertyName</code>之间的区别了。</p>\n<h2 id=\"Attributes-vs-Properties\"><a href=\"#Attributes-vs-Properties\" class=\"headerlink\" title=\"Attributes vs. Properties\"></a>Attributes vs. Properties</h2><p>在这里，我们可以将attribute理解为“特性”，property理解为“属性”从而来区分俩者的差异。<br>如果把DOM元素看成是一个普通的Object对象，这个对象在其定义时就具有一些属性（property），比如把select的option当做一个对象：</p>\n<pre><code>var option = &#123;\n    selected:false，\n    disabled:false，\n    attributes:NamedNodeMap,\n    ...\n&#125;\n</code></pre>\n<p>现在，我们一目了然了，attribute是一个特性节点，每个DOM元素都有一个对应的attributes属性来存放所有的attribute节点，它是一个叫做NameNodeMap的对象。attributes的每个数字索引以名值对(name=”value”)的形式存放了一个attribute节点。而property就是一个属性，是一个以名值对(name=”value”)的形式存放在Object中的属性。</p>\n<p><strong>上例中<code>&lt;option value=&#39;2&#39; selected&gt;2&lt;/option&gt;</code>的<code>property</code>为<code>&#123;0: value, 1: selected, length: 2&#125;</code></strong></p>\n<p>回到一开始的问题，根据W3C的表单规范 ，在selected属性（property）是一个布尔属性， 这意味着,如果这个特性（attribute）存在， 即使该特性没有对应的值，或者被设置为空字符串值，或甚至是”false”，相应的属性（property）都还是为true。 selected特性（attribute）值不会因为复选框的状态而改变，而selected属性（property）会因为复选框的状态而改变。因此，跨浏览器兼容的检索和更改DOM属性,比如元素的checked, selected, 或 disabled状态，请使用.prop()方法。</p>\n<h2 id=\"为什么会搞混？\"><a href=\"#为什么会搞混？\" class=\"headerlink\" title=\"为什么会搞混？\"></a>为什么会搞混？</h2><p>之所以attribute和property容易混倄在一起的原因是，很多attribute节点还有一个相对应的property属性，比如DOM元素的id和class既是attribute，也有对应的property，不管使用哪种方法都可以访问和修改。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Jquery属性获取——attr-与prop\"><a href=\"#Jquery属性获取——attr-与prop\" class=\"headerlink\" title=\"Jquery属性获取——attr()与prop()\"></a>Jquery属性获取——attr()与prop()</h1><p>今天在项目中使用<code>&lt;select&gt;&lt;/select&gt;</code>下拉菜单时，使用juery操作，使页面加载完菜单默认选中的值为2,我一开始的操作如下：</p>\n<pre><code>&lt;!--html部分--&gt;\n&lt;select&gt;\n   &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\n   &lt;option value=&quot;2&quot; id=&quot;second&quot;&gt;2&lt;/option&gt;\n   &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\n&lt;/select&gt;\n\n/**js部分**/\n$(&quot;#second&quot;).attr(&quot;selected&quot;,&quot;selected&quot;);\n</code></pre>\n<p>咋一看好完美，木问题，但是我发现在Safari浏览器中，根本不起作用！！仔细查看一番发现,在Safari浏览器中，属性确实是设置成功了，既value=2的那一项确实是<code>&lt;option value=&quot;2&quot; selected=&quot;selected&quot;&gt;2&lt;/option&gt;</code>。那问题出在哪呢？冷静，不要方，万能的stack说只要把<code>attr</code>改成<code>prop</code>就行了，卧槽还真行了，这是啥诡异事件。好吧，我们需要来研究研究了,不用想，肯定是需要祭出官方文档了。</p>\n<ol>\n<li><p>attr() ： 获取匹配的元素集合中的第一个元素的属性的值  或 设置每一个匹配元素的一个或多个属性。</p>\n<ul>\n<li>.attr( attributeName )<ul>\n<li>.attr( attributeName )</li>\n</ul>\n</li>\n<li>.attr( attributeName, value )<ul>\n<li>.attr( attributeName, value )</li>\n<li>.attr( attributes )</li>\n<li>.attr( attributeName, function(index, attr) )</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>prop() ： 获取匹配的元素集中第一个元素的属性（property）值或设置每一个匹配元素的一个或多个属性。</p>\n<ul>\n<li>.prop( propertyName )<ul>\n<li>.prop( propertyName )</li>\n</ul>\n</li>\n<li>.prop( propertyName, value )<ul>\n<li>.prop( propertyName, value )</li>\n<li>.prop( properties )</li>\n<li>.prop( propertyName, function(index, oldPropertyValue) )</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>看出区别了吗，没错，是参数有区别，<code>attr()</code>传入的是<code>attributeName</code>，而<code>prop()</code>传入的是<code>propertyName</code>,现在我们的问题转移了，我们需要研究的是<code>attributeName</code>和<code>propertyName</code>之间的区别了。</p>\n<h2 id=\"Attributes-vs-Properties\"><a href=\"#Attributes-vs-Properties\" class=\"headerlink\" title=\"Attributes vs. Properties\"></a>Attributes vs. Properties</h2><p>在这里，我们可以将attribute理解为“特性”，property理解为“属性”从而来区分俩者的差异。<br>如果把DOM元素看成是一个普通的Object对象，这个对象在其定义时就具有一些属性（property），比如把select的option当做一个对象：</p>\n<pre><code>var option = &#123;\n    selected:false，\n    disabled:false，\n    attributes:NamedNodeMap,\n    ...\n&#125;\n</code></pre>\n<p>现在，我们一目了然了，attribute是一个特性节点，每个DOM元素都有一个对应的attributes属性来存放所有的attribute节点，它是一个叫做NameNodeMap的对象。attributes的每个数字索引以名值对(name=”value”)的形式存放了一个attribute节点。而property就是一个属性，是一个以名值对(name=”value”)的形式存放在Object中的属性。</p>\n<p><strong>上例中<code>&lt;option value=&#39;2&#39; selected&gt;2&lt;/option&gt;</code>的<code>property</code>为<code>&#123;0: value, 1: selected, length: 2&#125;</code></strong></p>\n<p>回到一开始的问题，根据W3C的表单规范 ，在selected属性（property）是一个布尔属性， 这意味着,如果这个特性（attribute）存在， 即使该特性没有对应的值，或者被设置为空字符串值，或甚至是”false”，相应的属性（property）都还是为true。 selected特性（attribute）值不会因为复选框的状态而改变，而selected属性（property）会因为复选框的状态而改变。因此，跨浏览器兼容的检索和更改DOM属性,比如元素的checked, selected, 或 disabled状态，请使用.prop()方法。</p>\n<h2 id=\"为什么会搞混？\"><a href=\"#为什么会搞混？\" class=\"headerlink\" title=\"为什么会搞混？\"></a>为什么会搞混？</h2><p>之所以attribute和property容易混倄在一起的原因是，很多attribute节点还有一个相对应的property属性，比如DOM元素的id和class既是attribute，也有对应的property，不管使用哪种方法都可以访问和修改。</p>\n"},{"title":"Java的类和对象","date":"2016-03-31T01:25:25.000Z","description":"Java的类和对象","_content":"\n## 类\n类实际上是定义一个模板，而对象是由这个模板产生的一个实例。\n\n<!-- more -->\n\n**类的一般形式**\n>class 类名{\n 类型实例变量名;\n 类型实例变量名;\n ……\n 类型 方法名(参数){\n //方法内容\n }\n ……\n}\n\n这里，在类名面前并没有向以前那样加上修饰符public，在Java 中是允许把许多类的声明放在一个Java 文件中的，但是这些类**只能有一个类被声明为public**，而且这个**类名必须和Java 文件名相同**。\n类修饰符：\n + private：只有本类可见。\n + protected：本类、子类、同一包的类可见。\n + 默认（无修饰符）：本类、同一包的类可见。\n + public：对任何类可见。\n\n```java\nclass Humans {\n    String name;\n    String sex;\n    int age;\n    String address;\n    void work(){\n        System.out.println(\"I am working\");\n    };\n    void eat(){\n        System.out.println(\"I am eating\");\n    };\n    String getState(int time){\n        String state = null;\n        if(time>=0&& time<=24){\n            if(time>8&&time<17){\n                state=\"I am working\";\n            }else if(time>=17&&time<22){\n                state=\"I am studying\";\n            }else{\n                state=\"I am sleeping\";\n            }\n        }else{\n            state = \"it's not correct time\";\n        }\n        return state;\n    }\n}\n//测试类\npublic class Human {\n    public static void main(String args[ ]) {\n        //创建对象\n        Humans wangming = new Humans();\n        //对象的使用\n        wangming.name = \"王明\";\n        wangming.age = 25;\n        wangming.sex = \"男\";\n        wangming.address = \"中国北京\";\n        System.out.println(wangming.name+\"晚上23 点钟你在干嘛\");\n        //调用getState()方法，把返回值打印出来\n        System.out.println(wangming.getState(23));\n        System.out.println(\"下午15 点呢\");\n        System.out.println(wangming.getState(15));\n    }\n}\n```\n\n## 对象\n描述对象的类抽象出来，已经有了建立对象的模板，接下来的工作就是创造这些类的实例，既对象\n**创建对象**\n> className objectName = new className();\n\n1. 上面的创建语句其实是俩个语句合并而成：\n + 左边`className objectName`语句声明一个className类的变量objectName，\n + 右边`new className()`语句通过new 运算符获得一个对象实例并为其分配内存，获得对象实例赋值给wangming\n2. 这句语句实际上是调用了一个方法，这个方法是系统自带的方法，由于这个方法被用来构造对象，所以把它称为构造函数。构造函数的作用是生成对象，并对对象的实例变量进行初始化。系统自带的默认构造函数把所有的数字变量设为0，把所有的boolean 型变量设为false，把所有的对象变量都设为null。\n把例1中的Humans类实例化，即Humans wangming = new Humans();结果如下：\n```java\npublic Humans(){\n    name=null;\n    age=0;\n    sex=null;\n    addr=null;\n}\n```\n最后把这个赋值给wangming变量。\n\n构造函数有一个很明显的特点是它的名字必须跟类名相同，并且没有返回值类型\n\n\n**使用对象**\n对象是使用主要通过设置对象属性和调用对象方法的方式，见例1。\n\n\n## 包\n在大型的项目中，可能需要上千个类甚至上万个类，如果都放在一起，是非常乱的，而且要对这上万个类都起不同的名字，显然这样是很复杂的。Java 提供了一种有效的类的组织结构，这就是包。包机制是为了更好地组织类，用于区别类名的命名空间。\n\n**包的作用**\n+ 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。\n+ 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。\n+ 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。\n\n\n\n**创建**\n + 创建一个新文件夹，这个文件夹就是包；\n + 在这个文件夹下创建各个程序，但在每个程序前加上`package pkg;`声明：\n    ```\n    package pkg;\n    public class PkgTest{\n        public static void main(String args[ ]){\n            System.out.println(\"PkgTest success\");\n        }\n    }\n    ```\n\n**导入包**\n包可以对类进行良好的管理，但是这样的话包就位于不同的文件夹下面了，不能直接在一个文件夹中调用需要的类。Java 的解决方案是导入需要的包，调用包主要通过`import`来实现。\n`import packageName.*`导入包中所有的类\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/Java的类和对象.md","raw":"title: Java的类和对象\ntags: [java面向对象]\ndate: 2016-03-31 09:25:25\ndescription: Java的类和对象\n---\n\n## 类\n类实际上是定义一个模板，而对象是由这个模板产生的一个实例。\n\n<!-- more -->\n\n**类的一般形式**\n>class 类名{\n 类型实例变量名;\n 类型实例变量名;\n ……\n 类型 方法名(参数){\n //方法内容\n }\n ……\n}\n\n这里，在类名面前并没有向以前那样加上修饰符public，在Java 中是允许把许多类的声明放在一个Java 文件中的，但是这些类**只能有一个类被声明为public**，而且这个**类名必须和Java 文件名相同**。\n类修饰符：\n + private：只有本类可见。\n + protected：本类、子类、同一包的类可见。\n + 默认（无修饰符）：本类、同一包的类可见。\n + public：对任何类可见。\n\n```java\nclass Humans {\n    String name;\n    String sex;\n    int age;\n    String address;\n    void work(){\n        System.out.println(\"I am working\");\n    };\n    void eat(){\n        System.out.println(\"I am eating\");\n    };\n    String getState(int time){\n        String state = null;\n        if(time>=0&& time<=24){\n            if(time>8&&time<17){\n                state=\"I am working\";\n            }else if(time>=17&&time<22){\n                state=\"I am studying\";\n            }else{\n                state=\"I am sleeping\";\n            }\n        }else{\n            state = \"it's not correct time\";\n        }\n        return state;\n    }\n}\n//测试类\npublic class Human {\n    public static void main(String args[ ]) {\n        //创建对象\n        Humans wangming = new Humans();\n        //对象的使用\n        wangming.name = \"王明\";\n        wangming.age = 25;\n        wangming.sex = \"男\";\n        wangming.address = \"中国北京\";\n        System.out.println(wangming.name+\"晚上23 点钟你在干嘛\");\n        //调用getState()方法，把返回值打印出来\n        System.out.println(wangming.getState(23));\n        System.out.println(\"下午15 点呢\");\n        System.out.println(wangming.getState(15));\n    }\n}\n```\n\n## 对象\n描述对象的类抽象出来，已经有了建立对象的模板，接下来的工作就是创造这些类的实例，既对象\n**创建对象**\n> className objectName = new className();\n\n1. 上面的创建语句其实是俩个语句合并而成：\n + 左边`className objectName`语句声明一个className类的变量objectName，\n + 右边`new className()`语句通过new 运算符获得一个对象实例并为其分配内存，获得对象实例赋值给wangming\n2. 这句语句实际上是调用了一个方法，这个方法是系统自带的方法，由于这个方法被用来构造对象，所以把它称为构造函数。构造函数的作用是生成对象，并对对象的实例变量进行初始化。系统自带的默认构造函数把所有的数字变量设为0，把所有的boolean 型变量设为false，把所有的对象变量都设为null。\n把例1中的Humans类实例化，即Humans wangming = new Humans();结果如下：\n```java\npublic Humans(){\n    name=null;\n    age=0;\n    sex=null;\n    addr=null;\n}\n```\n最后把这个赋值给wangming变量。\n\n构造函数有一个很明显的特点是它的名字必须跟类名相同，并且没有返回值类型\n\n\n**使用对象**\n对象是使用主要通过设置对象属性和调用对象方法的方式，见例1。\n\n\n## 包\n在大型的项目中，可能需要上千个类甚至上万个类，如果都放在一起，是非常乱的，而且要对这上万个类都起不同的名字，显然这样是很复杂的。Java 提供了一种有效的类的组织结构，这就是包。包机制是为了更好地组织类，用于区别类名的命名空间。\n\n**包的作用**\n+ 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。\n+ 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。\n+ 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。\n\n\n\n**创建**\n + 创建一个新文件夹，这个文件夹就是包；\n + 在这个文件夹下创建各个程序，但在每个程序前加上`package pkg;`声明：\n    ```\n    package pkg;\n    public class PkgTest{\n        public static void main(String args[ ]){\n            System.out.println(\"PkgTest success\");\n        }\n    }\n    ```\n\n**导入包**\n包可以对类进行良好的管理，但是这样的话包就位于不同的文件夹下面了，不能直接在一个文件夹中调用需要的类。Java 的解决方案是导入需要的包，调用包主要通过`import`来实现。\n`import packageName.*`导入包中所有的类\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"Java的类和对象","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoks0012y4v2afhgbkqb","content":"<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>类实际上是定义一个模板，而对象是由这个模板产生的一个实例。</p>\n<span id=\"more\"></span>\n\n<p><strong>类的一般形式</strong></p>\n<blockquote>\n<p>class 类名{<br> 类型实例变量名;<br> 类型实例变量名;<br> ……<br> 类型 方法名(参数){<br> //方法内容<br> }<br> ……<br>}</p>\n</blockquote>\n<p>这里，在类名面前并没有向以前那样加上修饰符public，在Java 中是允许把许多类的声明放在一个Java 文件中的，但是这些类<strong>只能有一个类被声明为public</strong>，而且这个<strong>类名必须和Java 文件名相同</strong>。<br>类修饰符：</p>\n<ul>\n<li>private：只有本类可见。</li>\n<li>protected：本类、子类、同一包的类可见。</li>\n<li>默认（无修饰符）：本类、同一包的类可见。</li>\n<li>public：对任何类可见。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Humans</span> </span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    String sex;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    String address;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">work</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;I am working&quot;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;I am eating&quot;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getState</span><span class=\"params\">(<span class=\"keyword\">int</span> time)</span></span>&#123;</span><br><span class=\"line\">        String state = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(time&gt;=<span class=\"number\">0</span>&amp;&amp; time&lt;=<span class=\"number\">24</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(time&gt;<span class=\"number\">8</span>&amp;&amp;time&lt;<span class=\"number\">17</span>)&#123;</span><br><span class=\"line\">                state=<span class=\"string\">&quot;I am working&quot;</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(time&gt;=<span class=\"number\">17</span>&amp;&amp;time&lt;<span class=\"number\">22</span>)&#123;</span><br><span class=\"line\">                state=<span class=\"string\">&quot;I am studying&quot;</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                state=<span class=\"string\">&quot;I am sleeping&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            state = <span class=\"string\">&quot;it&#x27;s not correct time&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//测试类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[ ])</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建对象</span></span><br><span class=\"line\">        Humans wangming = <span class=\"keyword\">new</span> Humans();</span><br><span class=\"line\">        <span class=\"comment\">//对象的使用</span></span><br><span class=\"line\">        wangming.name = <span class=\"string\">&quot;王明&quot;</span>;</span><br><span class=\"line\">        wangming.age = <span class=\"number\">25</span>;</span><br><span class=\"line\">        wangming.sex = <span class=\"string\">&quot;男&quot;</span>;</span><br><span class=\"line\">        wangming.address = <span class=\"string\">&quot;中国北京&quot;</span>;</span><br><span class=\"line\">        System.out.println(wangming.name+<span class=\"string\">&quot;晚上23 点钟你在干嘛&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//调用getState()方法，把返回值打印出来</span></span><br><span class=\"line\">        System.out.println(wangming.getState(<span class=\"number\">23</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;下午15 点呢&quot;</span>);</span><br><span class=\"line\">        System.out.println(wangming.getState(<span class=\"number\">15</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><p>描述对象的类抽象出来，已经有了建立对象的模板，接下来的工作就是创造这些类的实例，既对象<br><strong>创建对象</strong></p>\n<blockquote>\n<p>className objectName = new className();</p>\n</blockquote>\n<ol>\n<li>上面的创建语句其实是俩个语句合并而成：</li>\n</ol>\n<ul>\n<li>左边<code>className objectName</code>语句声明一个className类的变量objectName，</li>\n<li>右边<code>new className()</code>语句通过new 运算符获得一个对象实例并为其分配内存，获得对象实例赋值给wangming</li>\n</ul>\n<ol start=\"2\">\n<li>这句语句实际上是调用了一个方法，这个方法是系统自带的方法，由于这个方法被用来构造对象，所以把它称为构造函数。构造函数的作用是生成对象，并对对象的实例变量进行初始化。系统自带的默认构造函数把所有的数字变量设为0，把所有的boolean 型变量设为false，把所有的对象变量都设为null。<br>把例1中的Humans类实例化，即Humans wangming = new Humans();结果如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Humans</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    name=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    age=<span class=\"number\">0</span>;</span><br><span class=\"line\">    sex=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    addr=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n最后把这个赋值给wangming变量。</li>\n</ol>\n<p>构造函数有一个很明显的特点是它的名字必须跟类名相同，并且没有返回值类型</p>\n<p><strong>使用对象</strong><br>对象是使用主要通过设置对象属性和调用对象方法的方式，见例1。</p>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>在大型的项目中，可能需要上千个类甚至上万个类，如果都放在一起，是非常乱的，而且要对这上万个类都起不同的名字，显然这样是很复杂的。Java 提供了一种有效的类的组织结构，这就是包。包机制是为了更好地组织类，用于区别类名的命名空间。</p>\n<p><strong>包的作用</strong></p>\n<ul>\n<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>\n<li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>\n<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>\n</ul>\n<p><strong>创建</strong></p>\n<ul>\n<li>创建一个新文件夹，这个文件夹就是包；</li>\n<li>在这个文件夹下创建各个程序，但在每个程序前加上<code>package pkg;</code>声明： <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package pkg;</span><br><span class=\"line\">public class PkgTest&#123;</span><br><span class=\"line\">    public static void main(String args[ ])&#123;</span><br><span class=\"line\">        System.out.println(&quot;PkgTest success&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>导入包</strong><br>包可以对类进行良好的管理，但是这样的话包就位于不同的文件夹下面了，不能直接在一个文件夹中调用需要的类。Java 的解决方案是导入需要的包，调用包主要通过<code>import</code>来实现。<br><code>import packageName.*</code>导入包中所有的类</p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a><br>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>类实际上是定义一个模板，而对象是由这个模板产生的一个实例。</p>","more":"<p><strong>类的一般形式</strong></p>\n<blockquote>\n<p>class 类名{<br> 类型实例变量名;<br> 类型实例变量名;<br> ……<br> 类型 方法名(参数){<br> //方法内容<br> }<br> ……<br>}</p>\n</blockquote>\n<p>这里，在类名面前并没有向以前那样加上修饰符public，在Java 中是允许把许多类的声明放在一个Java 文件中的，但是这些类<strong>只能有一个类被声明为public</strong>，而且这个<strong>类名必须和Java 文件名相同</strong>。<br>类修饰符：</p>\n<ul>\n<li>private：只有本类可见。</li>\n<li>protected：本类、子类、同一包的类可见。</li>\n<li>默认（无修饰符）：本类、同一包的类可见。</li>\n<li>public：对任何类可见。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Humans</span> </span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    String sex;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    String address;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">work</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;I am working&quot;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;I am eating&quot;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getState</span><span class=\"params\">(<span class=\"keyword\">int</span> time)</span></span>&#123;</span><br><span class=\"line\">        String state = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(time&gt;=<span class=\"number\">0</span>&amp;&amp; time&lt;=<span class=\"number\">24</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(time&gt;<span class=\"number\">8</span>&amp;&amp;time&lt;<span class=\"number\">17</span>)&#123;</span><br><span class=\"line\">                state=<span class=\"string\">&quot;I am working&quot;</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(time&gt;=<span class=\"number\">17</span>&amp;&amp;time&lt;<span class=\"number\">22</span>)&#123;</span><br><span class=\"line\">                state=<span class=\"string\">&quot;I am studying&quot;</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                state=<span class=\"string\">&quot;I am sleeping&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            state = <span class=\"string\">&quot;it&#x27;s not correct time&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//测试类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[ ])</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建对象</span></span><br><span class=\"line\">        Humans wangming = <span class=\"keyword\">new</span> Humans();</span><br><span class=\"line\">        <span class=\"comment\">//对象的使用</span></span><br><span class=\"line\">        wangming.name = <span class=\"string\">&quot;王明&quot;</span>;</span><br><span class=\"line\">        wangming.age = <span class=\"number\">25</span>;</span><br><span class=\"line\">        wangming.sex = <span class=\"string\">&quot;男&quot;</span>;</span><br><span class=\"line\">        wangming.address = <span class=\"string\">&quot;中国北京&quot;</span>;</span><br><span class=\"line\">        System.out.println(wangming.name+<span class=\"string\">&quot;晚上23 点钟你在干嘛&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//调用getState()方法，把返回值打印出来</span></span><br><span class=\"line\">        System.out.println(wangming.getState(<span class=\"number\">23</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;下午15 点呢&quot;</span>);</span><br><span class=\"line\">        System.out.println(wangming.getState(<span class=\"number\">15</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><p>描述对象的类抽象出来，已经有了建立对象的模板，接下来的工作就是创造这些类的实例，既对象<br><strong>创建对象</strong></p>\n<blockquote>\n<p>className objectName = new className();</p>\n</blockquote>\n<ol>\n<li>上面的创建语句其实是俩个语句合并而成：</li>\n</ol>\n<ul>\n<li>左边<code>className objectName</code>语句声明一个className类的变量objectName，</li>\n<li>右边<code>new className()</code>语句通过new 运算符获得一个对象实例并为其分配内存，获得对象实例赋值给wangming</li>\n</ul>\n<ol start=\"2\">\n<li>这句语句实际上是调用了一个方法，这个方法是系统自带的方法，由于这个方法被用来构造对象，所以把它称为构造函数。构造函数的作用是生成对象，并对对象的实例变量进行初始化。系统自带的默认构造函数把所有的数字变量设为0，把所有的boolean 型变量设为false，把所有的对象变量都设为null。<br>把例1中的Humans类实例化，即Humans wangming = new Humans();结果如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Humans</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    name=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    age=<span class=\"number\">0</span>;</span><br><span class=\"line\">    sex=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    addr=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n最后把这个赋值给wangming变量。</li>\n</ol>\n<p>构造函数有一个很明显的特点是它的名字必须跟类名相同，并且没有返回值类型</p>\n<p><strong>使用对象</strong><br>对象是使用主要通过设置对象属性和调用对象方法的方式，见例1。</p>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>在大型的项目中，可能需要上千个类甚至上万个类，如果都放在一起，是非常乱的，而且要对这上万个类都起不同的名字，显然这样是很复杂的。Java 提供了一种有效的类的组织结构，这就是包。包机制是为了更好地组织类，用于区别类名的命名空间。</p>\n<p><strong>包的作用</strong></p>\n<ul>\n<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>\n<li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>\n<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>\n</ul>\n<p><strong>创建</strong></p>\n<ul>\n<li>创建一个新文件夹，这个文件夹就是包；</li>\n<li>在这个文件夹下创建各个程序，但在每个程序前加上<code>package pkg;</code>声明： <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package pkg;</span><br><span class=\"line\">public class PkgTest&#123;</span><br><span class=\"line\">    public static void main(String args[ ])&#123;</span><br><span class=\"line\">        System.out.println(&quot;PkgTest success&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>导入包</strong><br>包可以对类进行良好的管理，但是这样的话包就位于不同的文件夹下面了，不能直接在一个文件夹中调用需要的类。Java 的解决方案是导入需要的包，调用包主要通过<code>import</code>来实现。<br><code>import packageName.*</code>导入包中所有的类</p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a><br>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"Java继承","date":"2016-03-31T06:19:14.000Z","description":"Java面向对象-继承","_content":"## 万物皆对象\n\nJava 是一门面向对象的语言，其重要的一个思想就是“万物皆对象”。而类是Java 的核心内容，它是一种逻辑结构，定义了对象的结构，可以由一个类得到众多相似的对象。从某种意义上说，类是Java 面向对象性的基础。\n\n<!-- more -->\n\nJava作为一种面向对象语言。支持以下基本概念：\n + 继承\n + 多态\n + 封装\n + 抽象\n + 类\n + 对象\n + 实例\n + 方法\n + 重载\n\n## 继承\n> 继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承可以理解为一个对象从另一个对象获取属性的过程。在Java中，类的继承是单一继承，也就是说，一个子类(派生类)只能拥有一个父类\n\n### 继承的实现\n继承的实现主要通过`extends`和`implements`来实现\n\n```\nclass Animal{\n}\n//tiger子类继承animal父类\nclass tiger extends Animal{\n\n}\n```\n### 子类对象的构建\n从最顶层的基类开始往下一层层的调用默认构造函数\n```java\nclass Animals{\n    Animals(){  //无参构造器\n        System.out.println(\"animal\");\n    }\n}\n\nclass Mammal extends Animals{\n    Mammal(){\n        System.out.println(\"Mammal\");\n    }\n}\n\nclass Dog extends Mammal{\n    Dog(){\n        System.out.println(\"Dog\");\n    }\n}\npublic class ClassTransmit {\n    public static void main(String args[]){\n        Dog alone = new Dog();\n    }\n}\n\n\n//animal\n//Mammal\n//Dog\n\n```\n在上面的程序中定义了3 个类Animals、Mammal、Dog，其中Mammal继承自Animals，Dog 继承自Mammal，当创建一个Dog 类的对象时候，会自动调用父类的无参构造函数，从上面的函数运行结果可以看出，构造函数的调用顺序为animal、Mammal、Dog。是自顶向下的。\n\n**instanceof 关键字**\n可以使用 instanceof 运算符来检验一个对象是否是一个类的一个实例。\n\n### 方法的覆写\n通过在子类中重写父类的方法，从而达到适应子类的特殊情况的效果。\n```\nclass Tiger extends Animal {\n    void breath(){ //呼吸方法\n        System.out.println(\"tiger breath\");\n    }\n}\n\npublic class OverLoad {\n    public static void main(String args[]){\n        Tiger woods = new Tiger();\n        woods.breath(); //tiger breath\n    }\n}\n```\n上面程序中，animal父类有一个breath方法，输出的是“animal breath”；这里在子类中改写了它的方法，使它输出“tiger breath”\n\n## final\n编写程序时可能需要把类定义为不能继承的，即最终类，或者是有的方法不希望被子类继承，这时候就需要使用final 关键字来声明:\n> final class 类名 extends 父类{\n//类体\n}\n\n方法也可以被声明为final:\n>修饰符 final 返回值类型方法名(){\n//方法体\n}\n\n**实例变量也可以被定义为final，被定义为final 的变量不能被修改。被声明为final 的类的方法自动地被声明为final，但是它的实例变量并不是final。**\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/Java继承.md","raw":"title: Java继承\ntags: [java面向对象]\ndate: 2016-03-31 14:19:14\ndescription: Java面向对象-继承\n---\n## 万物皆对象\n\nJava 是一门面向对象的语言，其重要的一个思想就是“万物皆对象”。而类是Java 的核心内容，它是一种逻辑结构，定义了对象的结构，可以由一个类得到众多相似的对象。从某种意义上说，类是Java 面向对象性的基础。\n\n<!-- more -->\n\nJava作为一种面向对象语言。支持以下基本概念：\n + 继承\n + 多态\n + 封装\n + 抽象\n + 类\n + 对象\n + 实例\n + 方法\n + 重载\n\n## 继承\n> 继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承可以理解为一个对象从另一个对象获取属性的过程。在Java中，类的继承是单一继承，也就是说，一个子类(派生类)只能拥有一个父类\n\n### 继承的实现\n继承的实现主要通过`extends`和`implements`来实现\n\n```\nclass Animal{\n}\n//tiger子类继承animal父类\nclass tiger extends Animal{\n\n}\n```\n### 子类对象的构建\n从最顶层的基类开始往下一层层的调用默认构造函数\n```java\nclass Animals{\n    Animals(){  //无参构造器\n        System.out.println(\"animal\");\n    }\n}\n\nclass Mammal extends Animals{\n    Mammal(){\n        System.out.println(\"Mammal\");\n    }\n}\n\nclass Dog extends Mammal{\n    Dog(){\n        System.out.println(\"Dog\");\n    }\n}\npublic class ClassTransmit {\n    public static void main(String args[]){\n        Dog alone = new Dog();\n    }\n}\n\n\n//animal\n//Mammal\n//Dog\n\n```\n在上面的程序中定义了3 个类Animals、Mammal、Dog，其中Mammal继承自Animals，Dog 继承自Mammal，当创建一个Dog 类的对象时候，会自动调用父类的无参构造函数，从上面的函数运行结果可以看出，构造函数的调用顺序为animal、Mammal、Dog。是自顶向下的。\n\n**instanceof 关键字**\n可以使用 instanceof 运算符来检验一个对象是否是一个类的一个实例。\n\n### 方法的覆写\n通过在子类中重写父类的方法，从而达到适应子类的特殊情况的效果。\n```\nclass Tiger extends Animal {\n    void breath(){ //呼吸方法\n        System.out.println(\"tiger breath\");\n    }\n}\n\npublic class OverLoad {\n    public static void main(String args[]){\n        Tiger woods = new Tiger();\n        woods.breath(); //tiger breath\n    }\n}\n```\n上面程序中，animal父类有一个breath方法，输出的是“animal breath”；这里在子类中改写了它的方法，使它输出“tiger breath”\n\n## final\n编写程序时可能需要把类定义为不能继承的，即最终类，或者是有的方法不希望被子类继承，这时候就需要使用final 关键字来声明:\n> final class 类名 extends 父类{\n//类体\n}\n\n方法也可以被声明为final:\n>修饰符 final 返回值类型方法名(){\n//方法体\n}\n\n**实例变量也可以被定义为final，被定义为final 的变量不能被修改。被声明为final 的类的方法自动地被声明为final，但是它的实例变量并不是final。**\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"Java继承","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokt0015y4v28izw7jj5","content":"<h2 id=\"万物皆对象\"><a href=\"#万物皆对象\" class=\"headerlink\" title=\"万物皆对象\"></a>万物皆对象</h2><p>Java 是一门面向对象的语言，其重要的一个思想就是“万物皆对象”。而类是Java 的核心内容，它是一种逻辑结构，定义了对象的结构，可以由一个类得到众多相似的对象。从某种意义上说，类是Java 面向对象性的基础。</p>\n<span id=\"more\"></span>\n\n<p>Java作为一种面向对象语言。支持以下基本概念：</p>\n<ul>\n<li>继承</li>\n<li>多态</li>\n<li>封装</li>\n<li>抽象</li>\n<li>类</li>\n<li>对象</li>\n<li>实例</li>\n<li>方法</li>\n<li>重载</li>\n</ul>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><blockquote>\n<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承可以理解为一个对象从另一个对象获取属性的过程。在Java中，类的继承是单一继承，也就是说，一个子类(派生类)只能拥有一个父类</p>\n</blockquote>\n<h3 id=\"继承的实现\"><a href=\"#继承的实现\" class=\"headerlink\" title=\"继承的实现\"></a>继承的实现</h3><p>继承的实现主要通过<code>extends</code>和<code>implements</code>来实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//tiger子类继承animal父类</span><br><span class=\"line\">class tiger extends Animal&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"子类对象的构建\"><a href=\"#子类对象的构建\" class=\"headerlink\" title=\"子类对象的构建\"></a>子类对象的构建</h3><p>从最顶层的基类开始往下一层层的调用默认构造函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animals</span></span>&#123;</span><br><span class=\"line\">    Animals()&#123;  <span class=\"comment\">//无参构造器</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;animal&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mammal</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animals</span></span>&#123;</span><br><span class=\"line\">    Mammal()&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Mammal&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mammal</span></span>&#123;</span><br><span class=\"line\">    Dog()&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Dog&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassTransmit</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</span><br><span class=\"line\">        Dog alone = <span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//animal</span></span><br><span class=\"line\"><span class=\"comment\">//Mammal</span></span><br><span class=\"line\"><span class=\"comment\">//Dog</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在上面的程序中定义了3 个类Animals、Mammal、Dog，其中Mammal继承自Animals，Dog 继承自Mammal，当创建一个Dog 类的对象时候，会自动调用父类的无参构造函数，从上面的函数运行结果可以看出，构造函数的调用顺序为animal、Mammal、Dog。是自顶向下的。</p>\n<p><strong>instanceof 关键字</strong><br>可以使用 instanceof 运算符来检验一个对象是否是一个类的一个实例。</p>\n<h3 id=\"方法的覆写\"><a href=\"#方法的覆写\" class=\"headerlink\" title=\"方法的覆写\"></a>方法的覆写</h3><p>通过在子类中重写父类的方法，从而达到适应子类的特殊情况的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Tiger extends Animal &#123;</span><br><span class=\"line\">    void breath()&#123; //呼吸方法</span><br><span class=\"line\">        System.out.println(&quot;tiger breath&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class OverLoad &#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">        Tiger woods = new Tiger();</span><br><span class=\"line\">        woods.breath(); //tiger breath</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面程序中，animal父类有一个breath方法，输出的是“animal breath”；这里在子类中改写了它的方法，使它输出“tiger breath”</p>\n<h2 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h2><p>编写程序时可能需要把类定义为不能继承的，即最终类，或者是有的方法不希望被子类继承，这时候就需要使用final 关键字来声明:</p>\n<blockquote>\n<p>final class 类名 extends 父类{<br>//类体<br>}</p>\n</blockquote>\n<p>方法也可以被声明为final:</p>\n<blockquote>\n<p>修饰符 final 返回值类型方法名(){<br>//方法体<br>}</p>\n</blockquote>\n<p><strong>实例变量也可以被定义为final，被定义为final 的变量不能被修改。被声明为final 的类的方法自动地被声明为final，但是它的实例变量并不是final。</strong></p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"万物皆对象\"><a href=\"#万物皆对象\" class=\"headerlink\" title=\"万物皆对象\"></a>万物皆对象</h2><p>Java 是一门面向对象的语言，其重要的一个思想就是“万物皆对象”。而类是Java 的核心内容，它是一种逻辑结构，定义了对象的结构，可以由一个类得到众多相似的对象。从某种意义上说，类是Java 面向对象性的基础。</p>","more":"<p>Java作为一种面向对象语言。支持以下基本概念：</p>\n<ul>\n<li>继承</li>\n<li>多态</li>\n<li>封装</li>\n<li>抽象</li>\n<li>类</li>\n<li>对象</li>\n<li>实例</li>\n<li>方法</li>\n<li>重载</li>\n</ul>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><blockquote>\n<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承可以理解为一个对象从另一个对象获取属性的过程。在Java中，类的继承是单一继承，也就是说，一个子类(派生类)只能拥有一个父类</p>\n</blockquote>\n<h3 id=\"继承的实现\"><a href=\"#继承的实现\" class=\"headerlink\" title=\"继承的实现\"></a>继承的实现</h3><p>继承的实现主要通过<code>extends</code>和<code>implements</code>来实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//tiger子类继承animal父类</span><br><span class=\"line\">class tiger extends Animal&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"子类对象的构建\"><a href=\"#子类对象的构建\" class=\"headerlink\" title=\"子类对象的构建\"></a>子类对象的构建</h3><p>从最顶层的基类开始往下一层层的调用默认构造函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animals</span></span>&#123;</span><br><span class=\"line\">    Animals()&#123;  <span class=\"comment\">//无参构造器</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;animal&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mammal</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animals</span></span>&#123;</span><br><span class=\"line\">    Mammal()&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Mammal&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mammal</span></span>&#123;</span><br><span class=\"line\">    Dog()&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Dog&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassTransmit</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</span><br><span class=\"line\">        Dog alone = <span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//animal</span></span><br><span class=\"line\"><span class=\"comment\">//Mammal</span></span><br><span class=\"line\"><span class=\"comment\">//Dog</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在上面的程序中定义了3 个类Animals、Mammal、Dog，其中Mammal继承自Animals，Dog 继承自Mammal，当创建一个Dog 类的对象时候，会自动调用父类的无参构造函数，从上面的函数运行结果可以看出，构造函数的调用顺序为animal、Mammal、Dog。是自顶向下的。</p>\n<p><strong>instanceof 关键字</strong><br>可以使用 instanceof 运算符来检验一个对象是否是一个类的一个实例。</p>\n<h3 id=\"方法的覆写\"><a href=\"#方法的覆写\" class=\"headerlink\" title=\"方法的覆写\"></a>方法的覆写</h3><p>通过在子类中重写父类的方法，从而达到适应子类的特殊情况的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Tiger extends Animal &#123;</span><br><span class=\"line\">    void breath()&#123; //呼吸方法</span><br><span class=\"line\">        System.out.println(&quot;tiger breath&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class OverLoad &#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">        Tiger woods = new Tiger();</span><br><span class=\"line\">        woods.breath(); //tiger breath</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面程序中，animal父类有一个breath方法，输出的是“animal breath”；这里在子类中改写了它的方法，使它输出“tiger breath”</p>\n<h2 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h2><p>编写程序时可能需要把类定义为不能继承的，即最终类，或者是有的方法不希望被子类继承，这时候就需要使用final 关键字来声明:</p>\n<blockquote>\n<p>final class 类名 extends 父类{<br>//类体<br>}</p>\n</blockquote>\n<p>方法也可以被声明为final:</p>\n<blockquote>\n<p>修饰符 final 返回值类型方法名(){<br>//方法体<br>}</p>\n</blockquote>\n<p><strong>实例变量也可以被定义为final，被定义为final 的变量不能被修改。被声明为final 的类的方法自动地被声明为final，但是它的实例变量并不是final。</strong></p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"_content":"# Node.js学习笔记（一）：快速开始\n最近接了一个node项目，虽然最后顺利完成了，但是由于第一次实战，整个过程是赶出来的，许多地方一知半解。现在项目结束了，就静下心来系统地学一学，理一理，读书不忘拿笔，既然读书了，当然就要记点东西。一方面：能帮助自己加深印象，更好的理解，另一方面：能有幸帮助到别人也是不甚欢喜的。本人大部分的学习内容来自于以下书籍。\n\n- 《Node入门》\n- 《Node.js开发指南》\n- 《深入浅出Node.js》\n- [《七天学会NodeJS》](http://nqdeng.github.io/7-days-nodejs/)\n\n## Node.js简介\n\n> Node.js不是JS应用、而是JS运行平台 --《深入浅出Node.js》\n\nNode.js采用C++语言编写而成,是一个后端的Javascript的运行环境。它使用了Google的V8虚拟机(Google的Chrome浏览器使用的 JavaScript执行环境),来解释和执行JavaScript代码。\n\n## Node.js特性\n\n1. 基于事件驱动的异步I/O（非阻塞）\n\n\t线程在执行中如果遇到磁盘读写或网络通信(统称为 I/O 操作), 通常要耗费较长的时间,这时操作系统会剥夺这个线程的 CPU 控制权,使其暂停执行,同时将资源让给其他的工作线程,这种线程调度方式称为阻塞。\n\t\n\tNode.js的设计思想中以事件驱动为核心的异步I/O（非阻塞）。所有的磁盘 I/O、网络通信、数据库查询都以非阻塞的方式请求,返回的结果由事件循环来处理\n\t\n\tNode.js 在执行的过程中会维护一个事件队列,程序在执行时进入事件循环等待下一个事件到来,每个异步式 I/O 请求完成后会被推送到事件队列,等待程序进程进行处理。\n\n2. 支持的编程语言是javascript\n\tJavascript的匿名函数和闭包特性非常适合事件驱动、异步编程。同时Javascript在动态语言中性能较好，再加上V8引擎也是同类的佼佼者，所以Node.js的性能也受益其中。\n\t\n\n\n## Node.js & npm的安装与配置\n\nNode.js的安装方法很简单，直接上[官网](https://nodejs.org/en/download/)或者百度一个选择相应版本下载安装就行，就不多说了。安装完后可以通过输入 \"node -v\" 来测试是否成功安装。\n\n*tips: 工作中可能会需要多个node版本之间的相互切换，推荐使用nvm工具（but,暂不支持windows）*\n\nNodejs自身提供了基本的模块。但是在这些基本模块上开发实际应用需要较多的工作,npm的存在解决了该问题，它是Nodejs的包管理器:\n\n+ 允许用户从NPM服务器下载别人编写的第三方包到本地使用。\n+ 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。\n+ 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。\n\n新版的nodejs已经集成了npm，所以不需要再进行安装操作。同样可以通过输入 \"npm -v\" 来测试是否成功安装。\n\n## Hello World\n至此，我们的node开发环境就基本搭建完成了，我们来开始实现第一个 Node.js 程序。打开你常用的文本编辑器,在其中输入: \n\n```console.log('Hello World');```\n\r将文件保存为 helloworld.js,打开终端,进入 helloworld.js 所在的目录,执行以下命令: \n\n```node helloworld.js```\n\n如果一切正常,你将会在终端中看到输出 `Hello World`。\n","source":"_posts/Node.js学习笔记（一）.md","raw":"# Node.js学习笔记（一）：快速开始\n最近接了一个node项目，虽然最后顺利完成了，但是由于第一次实战，整个过程是赶出来的，许多地方一知半解。现在项目结束了，就静下心来系统地学一学，理一理，读书不忘拿笔，既然读书了，当然就要记点东西。一方面：能帮助自己加深印象，更好的理解，另一方面：能有幸帮助到别人也是不甚欢喜的。本人大部分的学习内容来自于以下书籍。\n\n- 《Node入门》\n- 《Node.js开发指南》\n- 《深入浅出Node.js》\n- [《七天学会NodeJS》](http://nqdeng.github.io/7-days-nodejs/)\n\n## Node.js简介\n\n> Node.js不是JS应用、而是JS运行平台 --《深入浅出Node.js》\n\nNode.js采用C++语言编写而成,是一个后端的Javascript的运行环境。它使用了Google的V8虚拟机(Google的Chrome浏览器使用的 JavaScript执行环境),来解释和执行JavaScript代码。\n\n## Node.js特性\n\n1. 基于事件驱动的异步I/O（非阻塞）\n\n\t线程在执行中如果遇到磁盘读写或网络通信(统称为 I/O 操作), 通常要耗费较长的时间,这时操作系统会剥夺这个线程的 CPU 控制权,使其暂停执行,同时将资源让给其他的工作线程,这种线程调度方式称为阻塞。\n\t\n\tNode.js的设计思想中以事件驱动为核心的异步I/O（非阻塞）。所有的磁盘 I/O、网络通信、数据库查询都以非阻塞的方式请求,返回的结果由事件循环来处理\n\t\n\tNode.js 在执行的过程中会维护一个事件队列,程序在执行时进入事件循环等待下一个事件到来,每个异步式 I/O 请求完成后会被推送到事件队列,等待程序进程进行处理。\n\n2. 支持的编程语言是javascript\n\tJavascript的匿名函数和闭包特性非常适合事件驱动、异步编程。同时Javascript在动态语言中性能较好，再加上V8引擎也是同类的佼佼者，所以Node.js的性能也受益其中。\n\t\n\n\n## Node.js & npm的安装与配置\n\nNode.js的安装方法很简单，直接上[官网](https://nodejs.org/en/download/)或者百度一个选择相应版本下载安装就行，就不多说了。安装完后可以通过输入 \"node -v\" 来测试是否成功安装。\n\n*tips: 工作中可能会需要多个node版本之间的相互切换，推荐使用nvm工具（but,暂不支持windows）*\n\nNodejs自身提供了基本的模块。但是在这些基本模块上开发实际应用需要较多的工作,npm的存在解决了该问题，它是Nodejs的包管理器:\n\n+ 允许用户从NPM服务器下载别人编写的第三方包到本地使用。\n+ 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。\n+ 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。\n\n新版的nodejs已经集成了npm，所以不需要再进行安装操作。同样可以通过输入 \"npm -v\" 来测试是否成功安装。\n\n## Hello World\n至此，我们的node开发环境就基本搭建完成了，我们来开始实现第一个 Node.js 程序。打开你常用的文本编辑器,在其中输入: \n\n```console.log('Hello World');```\n\r将文件保存为 helloworld.js,打开终端,进入 helloworld.js 所在的目录,执行以下命令: \n\n```node helloworld.js```\n\n如果一切正常,你将会在终端中看到输出 `Hello World`。\n","slug":"Node.js学习笔记（一）","published":1,"date":"2021-12-06T05:35:02.611Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoku0017y4v2234h0l1j","content":"<h1 id=\"Node-js学习笔记（一）：快速开始\"><a href=\"#Node-js学习笔记（一）：快速开始\" class=\"headerlink\" title=\"Node.js学习笔记（一）：快速开始\"></a>Node.js学习笔记（一）：快速开始</h1><p>最近接了一个node项目，虽然最后顺利完成了，但是由于第一次实战，整个过程是赶出来的，许多地方一知半解。现在项目结束了，就静下心来系统地学一学，理一理，读书不忘拿笔，既然读书了，当然就要记点东西。一方面：能帮助自己加深印象，更好的理解，另一方面：能有幸帮助到别人也是不甚欢喜的。本人大部分的学习内容来自于以下书籍。</p>\n<ul>\n<li>《Node入门》</li>\n<li>《Node.js开发指南》</li>\n<li>《深入浅出Node.js》</li>\n<li><a href=\"http://nqdeng.github.io/7-days-nodejs/\">《七天学会NodeJS》</a></li>\n</ul>\n<h2 id=\"Node-js简介\"><a href=\"#Node-js简介\" class=\"headerlink\" title=\"Node.js简介\"></a>Node.js简介</h2><blockquote>\n<p>Node.js不是JS应用、而是JS运行平台 –《深入浅出Node.js》</p>\n</blockquote>\n<p>Node.js采用C++语言编写而成,是一个后端的Javascript的运行环境。它使用了Google的V8虚拟机(Google的Chrome浏览器使用的 JavaScript执行环境),来解释和执行JavaScript代码。</p>\n<h2 id=\"Node-js特性\"><a href=\"#Node-js特性\" class=\"headerlink\" title=\"Node.js特性\"></a>Node.js特性</h2><ol>\n<li><p>基于事件驱动的异步I/O（非阻塞）</p>\n<p> 线程在执行中如果遇到磁盘读写或网络通信(统称为 I/O 操作), 通常要耗费较长的时间,这时操作系统会剥夺这个线程的 CPU 控制权,使其暂停执行,同时将资源让给其他的工作线程,这种线程调度方式称为阻塞。</p>\n<p> Node.js的设计思想中以事件驱动为核心的异步I/O（非阻塞）。所有的磁盘 I/O、网络通信、数据库查询都以非阻塞的方式请求,返回的结果由事件循环来处理</p>\n<p> Node.js 在执行的过程中会维护一个事件队列,程序在执行时进入事件循环等待下一个事件到来,每个异步式 I/O 请求完成后会被推送到事件队列,等待程序进程进行处理。</p>\n</li>\n<li><p>支持的编程语言是javascript<br> Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。同时Javascript在动态语言中性能较好，再加上V8引擎也是同类的佼佼者，所以Node.js的性能也受益其中。</p>\n</li>\n</ol>\n<h2 id=\"Node-js-amp-npm的安装与配置\"><a href=\"#Node-js-amp-npm的安装与配置\" class=\"headerlink\" title=\"Node.js &amp; npm的安装与配置\"></a>Node.js &amp; npm的安装与配置</h2><p>Node.js的安装方法很简单，直接上<a href=\"https://nodejs.org/en/download/\">官网</a>或者百度一个选择相应版本下载安装就行，就不多说了。安装完后可以通过输入 “node -v” 来测试是否成功安装。</p>\n<p><em>tips: 工作中可能会需要多个node版本之间的相互切换，推荐使用nvm工具（but,暂不支持windows）</em></p>\n<p>Nodejs自身提供了基本的模块。但是在这些基本模块上开发实际应用需要较多的工作,npm的存在解决了该问题，它是Nodejs的包管理器:</p>\n<ul>\n<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>\n<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>\n<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>\n</ul>\n<p>新版的nodejs已经集成了npm，所以不需要再进行安装操作。同样可以通过输入 “npm -v” 来测试是否成功安装。</p>\n<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>至此，我们的node开发环境就基本搭建完成了，我们来开始实现第一个 Node.js 程序。打开你常用的文本编辑器,在其中输入: </p>\n<p><code>console.log(&#39;Hello World&#39;);</code></p>\n<p>将文件保存为 helloworld.js,打开终端,进入 helloworld.js 所在的目录,执行以下命令: </p>\n<p><code>node helloworld.js</code></p>\n<p>如果一切正常,你将会在终端中看到输出 <code>Hello World</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Node-js学习笔记（一）：快速开始\"><a href=\"#Node-js学习笔记（一）：快速开始\" class=\"headerlink\" title=\"Node.js学习笔记（一）：快速开始\"></a>Node.js学习笔记（一）：快速开始</h1><p>最近接了一个node项目，虽然最后顺利完成了，但是由于第一次实战，整个过程是赶出来的，许多地方一知半解。现在项目结束了，就静下心来系统地学一学，理一理，读书不忘拿笔，既然读书了，当然就要记点东西。一方面：能帮助自己加深印象，更好的理解，另一方面：能有幸帮助到别人也是不甚欢喜的。本人大部分的学习内容来自于以下书籍。</p>\n<ul>\n<li>《Node入门》</li>\n<li>《Node.js开发指南》</li>\n<li>《深入浅出Node.js》</li>\n<li><a href=\"http://nqdeng.github.io/7-days-nodejs/\">《七天学会NodeJS》</a></li>\n</ul>\n<h2 id=\"Node-js简介\"><a href=\"#Node-js简介\" class=\"headerlink\" title=\"Node.js简介\"></a>Node.js简介</h2><blockquote>\n<p>Node.js不是JS应用、而是JS运行平台 –《深入浅出Node.js》</p>\n</blockquote>\n<p>Node.js采用C++语言编写而成,是一个后端的Javascript的运行环境。它使用了Google的V8虚拟机(Google的Chrome浏览器使用的 JavaScript执行环境),来解释和执行JavaScript代码。</p>\n<h2 id=\"Node-js特性\"><a href=\"#Node-js特性\" class=\"headerlink\" title=\"Node.js特性\"></a>Node.js特性</h2><ol>\n<li><p>基于事件驱动的异步I/O（非阻塞）</p>\n<p> 线程在执行中如果遇到磁盘读写或网络通信(统称为 I/O 操作), 通常要耗费较长的时间,这时操作系统会剥夺这个线程的 CPU 控制权,使其暂停执行,同时将资源让给其他的工作线程,这种线程调度方式称为阻塞。</p>\n<p> Node.js的设计思想中以事件驱动为核心的异步I/O（非阻塞）。所有的磁盘 I/O、网络通信、数据库查询都以非阻塞的方式请求,返回的结果由事件循环来处理</p>\n<p> Node.js 在执行的过程中会维护一个事件队列,程序在执行时进入事件循环等待下一个事件到来,每个异步式 I/O 请求完成后会被推送到事件队列,等待程序进程进行处理。</p>\n</li>\n<li><p>支持的编程语言是javascript<br> Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。同时Javascript在动态语言中性能较好，再加上V8引擎也是同类的佼佼者，所以Node.js的性能也受益其中。</p>\n</li>\n</ol>\n<h2 id=\"Node-js-amp-npm的安装与配置\"><a href=\"#Node-js-amp-npm的安装与配置\" class=\"headerlink\" title=\"Node.js &amp; npm的安装与配置\"></a>Node.js &amp; npm的安装与配置</h2><p>Node.js的安装方法很简单，直接上<a href=\"https://nodejs.org/en/download/\">官网</a>或者百度一个选择相应版本下载安装就行，就不多说了。安装完后可以通过输入 “node -v” 来测试是否成功安装。</p>\n<p><em>tips: 工作中可能会需要多个node版本之间的相互切换，推荐使用nvm工具（but,暂不支持windows）</em></p>\n<p>Nodejs自身提供了基本的模块。但是在这些基本模块上开发实际应用需要较多的工作,npm的存在解决了该问题，它是Nodejs的包管理器:</p>\n<ul>\n<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>\n<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>\n<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>\n</ul>\n<p>新版的nodejs已经集成了npm，所以不需要再进行安装操作。同样可以通过输入 “npm -v” 来测试是否成功安装。</p>\n<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>至此，我们的node开发环境就基本搭建完成了，我们来开始实现第一个 Node.js 程序。打开你常用的文本编辑器,在其中输入: </p>\n<p><code>console.log(&#39;Hello World&#39;);</code></p>\n<p>将文件保存为 helloworld.js,打开终端,进入 helloworld.js 所在的目录,执行以下命令: </p>\n<p><code>node helloworld.js</code></p>\n<p>如果一切正常,你将会在终端中看到输出 <code>Hello World</code>。</p>\n"},{"_content":"# Node.js学习笔记（三）: 事件机制\n\n\n大部分的nodejs核心api都建立在异步的事件驱动架构之上，所以events是Node.js 最重要的模块,它提供了唯一的接口。events 模块不仅用于用户代码与 Node.js 下层事件循环的交互,还几乎被所有的模块依赖。\n\n## EventEmitter\n\nevents 模块只提供了一个对象: events.EventEmitter。EventEmitter的核心就是事件发射与事件听器功能的封装。所有发射事件的对象都是EventEmitter类的实例，它暴露一个on函数来绑定一个或着多个函数到该对象上。当事件发射时,注册到这个事件的事件监听器被依次调用,事件参数作为回调函数参数传递。\n\n\n```\nconst EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\n```\n\n以上例 中, myEmitter 为事件 event 注册了一个事件监听器, 后发射了 event 事件。运行结果中可以看到这个事件监听器的回调函数被调用。\n\n\n+ EventEmitter.on(event, listener) 为指定事件注册一个监听器,接受一个字\r符串 event 和一个回调函数listener。\r+ EventEmitter.emit(event, [arg1], [arg2], [...]) 发射 event 事件,传\r递若干可选参数到事件监听器的参数表。\r+ EventEmitter.once(event, listener) 为指定事件注册一个单次监听器, 监听\r听器最多只会触发一次,触发后立刻解除该监听器。\r+ EventEmitter.removeListener(event, listener)  移除指定事件的某个监听\r器,listener必须是该事件已经注册过的监听器。\n\n\n\n如果对一个事件添加了超过10个侦听器,将会得到一条警告,这 一处设计与Node.js自身单线程运行有关,设计者认为侦听器太多,可能导致内 存泄漏,所以存在这样一个警告.\n\n\n## error事件\nEventEmitter 定义了一个特殊的事件 error,它包含了“错误”的语义,我们在遇到异常的时候通常会发射 error 事件。当error 被发射时,EventEmitter 规定如果没有响应的监听器,Node.js 会把它当作异常, 退出程序并打印调用栈。我们一般要为会发射 error 事件的对象设置监听器,避免遇到错误后整个个程序崩溃。\n\n最佳实践：\n\n```\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.log('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n```\n\n\n\n\n## http网络操作\n\n## 进程管理","source":"_posts/Node.js学习笔记（三）- 事件机制.md","raw":"# Node.js学习笔记（三）: 事件机制\n\n\n大部分的nodejs核心api都建立在异步的事件驱动架构之上，所以events是Node.js 最重要的模块,它提供了唯一的接口。events 模块不仅用于用户代码与 Node.js 下层事件循环的交互,还几乎被所有的模块依赖。\n\n## EventEmitter\n\nevents 模块只提供了一个对象: events.EventEmitter。EventEmitter的核心就是事件发射与事件听器功能的封装。所有发射事件的对象都是EventEmitter类的实例，它暴露一个on函数来绑定一个或着多个函数到该对象上。当事件发射时,注册到这个事件的事件监听器被依次调用,事件参数作为回调函数参数传递。\n\n\n```\nconst EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\n```\n\n以上例 中, myEmitter 为事件 event 注册了一个事件监听器, 后发射了 event 事件。运行结果中可以看到这个事件监听器的回调函数被调用。\n\n\n+ EventEmitter.on(event, listener) 为指定事件注册一个监听器,接受一个字\r符串 event 和一个回调函数listener。\r+ EventEmitter.emit(event, [arg1], [arg2], [...]) 发射 event 事件,传\r递若干可选参数到事件监听器的参数表。\r+ EventEmitter.once(event, listener) 为指定事件注册一个单次监听器, 监听\r听器最多只会触发一次,触发后立刻解除该监听器。\r+ EventEmitter.removeListener(event, listener)  移除指定事件的某个监听\r器,listener必须是该事件已经注册过的监听器。\n\n\n\n如果对一个事件添加了超过10个侦听器,将会得到一条警告,这 一处设计与Node.js自身单线程运行有关,设计者认为侦听器太多,可能导致内 存泄漏,所以存在这样一个警告.\n\n\n## error事件\nEventEmitter 定义了一个特殊的事件 error,它包含了“错误”的语义,我们在遇到异常的时候通常会发射 error 事件。当error 被发射时,EventEmitter 规定如果没有响应的监听器,Node.js 会把它当作异常, 退出程序并打印调用栈。我们一般要为会发射 error 事件的对象设置监听器,避免遇到错误后整个个程序崩溃。\n\n最佳实践：\n\n```\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.log('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n```\n\n\n\n\n## http网络操作\n\n## 进程管理","slug":"Node.js学习笔记（三）- 事件机制","published":1,"date":"2021-12-06T05:35:02.611Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokv001ay4v26o1u8hn9","content":"<h1 id=\"Node-js学习笔记（三）-事件机制\"><a href=\"#Node-js学习笔记（三）-事件机制\" class=\"headerlink\" title=\"Node.js学习笔记（三）: 事件机制\"></a>Node.js学习笔记（三）: 事件机制</h1><p>大部分的nodejs核心api都建立在异步的事件驱动架构之上，所以events是Node.js 最重要的模块,它提供了唯一的接口。events 模块不仅用于用户代码与 Node.js 下层事件循环的交互,还几乎被所有的模块依赖。</p>\n<h2 id=\"EventEmitter\"><a href=\"#EventEmitter\" class=\"headerlink\" title=\"EventEmitter\"></a>EventEmitter</h2><p>events 模块只提供了一个对象: events.EventEmitter。EventEmitter的核心就是事件发射与事件听器功能的封装。所有发射事件的对象都是EventEmitter类的实例，它暴露一个on函数来绑定一个或着多个函数到该对象上。当事件发射时,注册到这个事件的事件监听器被依次调用,事件参数作为回调函数参数传递。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const EventEmitter = require(&#x27;events&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">class MyEmitter extends EventEmitter &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const myEmitter = new MyEmitter();</span><br><span class=\"line\">myEmitter.on(&#x27;event&#x27;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;an event occurred!&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myEmitter.emit(&#x27;event&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>以上例 中, myEmitter 为事件 event 注册了一个事件监听器, 后发射了 event 事件。运行结果中可以看到这个事件监听器的回调函数被调用。</p>\n<ul>\n<li>EventEmitter.on(event, listener) 为指定事件注册一个监听器,接受一个字<br>符串 event 和一个回调函数listener。</li>\n<li>EventEmitter.emit(event, [arg1], [arg2], […]) 发射 event 事件,传<br>递若干可选参数到事件监听器的参数表。</li>\n<li>EventEmitter.once(event, listener) 为指定事件注册一个单次监听器, 监听<br>听器最多只会触发一次,触发后立刻解除该监听器。</li>\n<li>EventEmitter.removeListener(event, listener)  移除指定事件的某个监听<br>器,listener必须是该事件已经注册过的监听器。</li>\n</ul>\n<p>如果对一个事件添加了超过10个侦听器,将会得到一条警告,这 一处设计与Node.js自身单线程运行有关,设计者认为侦听器太多,可能导致内 存泄漏,所以存在这样一个警告.</p>\n<h2 id=\"error事件\"><a href=\"#error事件\" class=\"headerlink\" title=\"error事件\"></a>error事件</h2><p>EventEmitter 定义了一个特殊的事件 error,它包含了“错误”的语义,我们在遇到异常的时候通常会发射 error 事件。当error 被发射时,EventEmitter 规定如果没有响应的监听器,Node.js 会把它当作异常, 退出程序并打印调用栈。我们一般要为会发射 error 事件的对象设置监听器,避免遇到错误后整个个程序崩溃。</p>\n<p>最佳实践：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const myEmitter = new MyEmitter();</span><br><span class=\"line\">myEmitter.on(&#x27;error&#x27;, (err) =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;whoops! there was an error&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myEmitter.emit(&#x27;error&#x27;, new Error(&#x27;whoops!&#x27;));</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"http网络操作\"><a href=\"#http网络操作\" class=\"headerlink\" title=\"http网络操作\"></a>http网络操作</h2><h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Node-js学习笔记（三）-事件机制\"><a href=\"#Node-js学习笔记（三）-事件机制\" class=\"headerlink\" title=\"Node.js学习笔记（三）: 事件机制\"></a>Node.js学习笔记（三）: 事件机制</h1><p>大部分的nodejs核心api都建立在异步的事件驱动架构之上，所以events是Node.js 最重要的模块,它提供了唯一的接口。events 模块不仅用于用户代码与 Node.js 下层事件循环的交互,还几乎被所有的模块依赖。</p>\n<h2 id=\"EventEmitter\"><a href=\"#EventEmitter\" class=\"headerlink\" title=\"EventEmitter\"></a>EventEmitter</h2><p>events 模块只提供了一个对象: events.EventEmitter。EventEmitter的核心就是事件发射与事件听器功能的封装。所有发射事件的对象都是EventEmitter类的实例，它暴露一个on函数来绑定一个或着多个函数到该对象上。当事件发射时,注册到这个事件的事件监听器被依次调用,事件参数作为回调函数参数传递。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const EventEmitter = require(&#x27;events&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">class MyEmitter extends EventEmitter &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const myEmitter = new MyEmitter();</span><br><span class=\"line\">myEmitter.on(&#x27;event&#x27;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;an event occurred!&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myEmitter.emit(&#x27;event&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>以上例 中, myEmitter 为事件 event 注册了一个事件监听器, 后发射了 event 事件。运行结果中可以看到这个事件监听器的回调函数被调用。</p>\n<ul>\n<li>EventEmitter.on(event, listener) 为指定事件注册一个监听器,接受一个字<br>符串 event 和一个回调函数listener。</li>\n<li>EventEmitter.emit(event, [arg1], [arg2], […]) 发射 event 事件,传<br>递若干可选参数到事件监听器的参数表。</li>\n<li>EventEmitter.once(event, listener) 为指定事件注册一个单次监听器, 监听<br>听器最多只会触发一次,触发后立刻解除该监听器。</li>\n<li>EventEmitter.removeListener(event, listener)  移除指定事件的某个监听<br>器,listener必须是该事件已经注册过的监听器。</li>\n</ul>\n<p>如果对一个事件添加了超过10个侦听器,将会得到一条警告,这 一处设计与Node.js自身单线程运行有关,设计者认为侦听器太多,可能导致内 存泄漏,所以存在这样一个警告.</p>\n<h2 id=\"error事件\"><a href=\"#error事件\" class=\"headerlink\" title=\"error事件\"></a>error事件</h2><p>EventEmitter 定义了一个特殊的事件 error,它包含了“错误”的语义,我们在遇到异常的时候通常会发射 error 事件。当error 被发射时,EventEmitter 规定如果没有响应的监听器,Node.js 会把它当作异常, 退出程序并打印调用栈。我们一般要为会发射 error 事件的对象设置监听器,避免遇到错误后整个个程序崩溃。</p>\n<p>最佳实践：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const myEmitter = new MyEmitter();</span><br><span class=\"line\">myEmitter.on(&#x27;error&#x27;, (err) =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;whoops! there was an error&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myEmitter.emit(&#x27;error&#x27;, new Error(&#x27;whoops!&#x27;));</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"http网络操作\"><a href=\"#http网络操作\" class=\"headerlink\" title=\"http网络操作\"></a>http网络操作</h2><h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2>"},{"_content":"# Node.js学习笔记（二）：模块\n\n\n模块是 Node.js 应用程序的基本组成部分,文件和模块是一一对应的。一个 Node.js 文件就是一个模块,这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。\n\n由于JavaScript没有模块系统，所以Node.js依靠CommonJS规范自身实现了模块系统。\n\n## 模块的简单使用——exports 、require 和 module\n\n在编写和使用每个模块时，Node.js都有require、exports、module三个预先定义好的变量可供使用。\n\n1. exports\n\n\t`exports`对象是当前模块的导出对象，用于导出模块公有方法和属性。\n\t事实上,exports 本身仅仅是一个普通的空对象,即 {},它专门用来声明接口。例如：\n\t\n\t```\n\t//module.js\r\texports.sayHello = function(name) { \n\t\tconsole.log('Hello ' \t+ name);\r\t};\n\t```\t\n2.  require\n\n\t`require`函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。例如：\n\t\n\t```\n\t//index.js\n\tvar myModule = require('./module');\n\tmyModule.sayHello(\"node\");\n\t```\t\n3. module\n\n\t通过module对象可以访问到当前模块的一些相关信息，但最多的用途是覆盖 exports。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话：\n\t\n\t```\n\t//module.js\r\tmodule.exports = function(name) { \n\t\tconsole.log('Hello ' \t+ name);\r\t};\n\t\n\t//index.js\n\tvar sayHello = require('./module');\n\tsayHello(\"node\");\n\t```\t\n\t\n## 模块进阶——模块载入策略\n\nNode.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。原生模块在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类文件模块是动态加载的，加载速度比原生模块慢。\n\n### 内部实现机制\n\n加载文件模块的工作，主要由原生模块module来实现和完成，该原生模块在启动时已经被加载，进程直接调用到runMain静态方法。\n\n**Module源码：**\n\t\n```\nfunction Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent && parent.children) {\n    parent.children.push(this);\n  }\n\t\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n```\n\n模块解析流程：\n\n1. 命令行执行主模块\n\t\n\t命令行执行主模块\n\n\t```\n\t// bootstrap main module.\n\tModule.runMain = function() {\n\t  // Load the main module--the command line argument.\n\t  Module._load(process.argv[1], null, true);\n\t  // Handle any nextTicks added in the first tick of the program\n\t  process._tickCallback();\n\t};\n\t```\n\t\n\t\n\n2. 处理模块\n\n\tModule.runMain方法会在最后执行_load静态方法，该方法又会在分析文件名之后执行:\n\n\t```\n\t//实例化Module函数\n\tvar module = new Module(id, parent);\n\t```\n\t\n\t并根据文件路径**缓存**当前模块对象，该模块实例对象则根据文件名加载。\n\t\n\t```\n\tmodule.load(filename);\n\t```\n\t\n\t这时，Node.js会根据不同文件模块类型的后缀名来决定加载方法。\n\n\t+ js：通过fs模块同步读取js文件并编译执行。\n\t+ node：通过C/C++进行编写的Addon。通过dlopen方法进行加载。\n\t+ json：读取文件，调用JSON.parse解析加载。\n\t\n\t\n\t\n3. 输出结果\n\n\t最后js文件形式的模块会变成以下形式的内容：\n\t\n\t```\n\t(function (exports, require, module, __filename, __dirname) {\n    \tvar circle = require('./circle.js');\n\t    \tconsole.log('The area of a circle of radius 4 is ' +circle.area(4));\n\t});\n\t```\n\t所以此时，主模块内可以使用exports, require, module等变量了，而其他模块又会通过require引进主模块，require方法会同runMain一样调用_load静态方法，以此类推。\n\t\n\t**require源码:**\n\t\n\t```\n\t// 传入模块路径作为参数. 返回 模块的exports属性.\n\t\n\tModule.prototype.require = function(path) {\n\t  assert(path, 'missing path');\n\t  assert(typeof path === 'string', 'path must be a string');\n\t  return Module._load(path, this, /* isMain */ false);\n\t};\n\t```\n\n\n## Q&A\n1. console.log(this)在浏览器和Node中分别打印出什么？\n\t\n\t答：显然浏览器中直接打印this指向Window对象，而在Node中，我们编写的文件其实外面都包裹了一层函数，而且该函数执行时强制apply将this指向了module.exports，因此此处打印为{}。\n\n2. 为什么require、__filename、__dirname、module、exports等几个变量并没有定义在app.js 文件中，但是这个方法却存在的原因。\n\n\t答：这里提到的所有属性均是_load方法中我们编写的js文件外层包裹函数提供给我们的，因此可以直接调用。\n\n","source":"_posts/Node.js学习笔记（二）：模块机制.md","raw":"# Node.js学习笔记（二）：模块\n\n\n模块是 Node.js 应用程序的基本组成部分,文件和模块是一一对应的。一个 Node.js 文件就是一个模块,这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。\n\n由于JavaScript没有模块系统，所以Node.js依靠CommonJS规范自身实现了模块系统。\n\n## 模块的简单使用——exports 、require 和 module\n\n在编写和使用每个模块时，Node.js都有require、exports、module三个预先定义好的变量可供使用。\n\n1. exports\n\n\t`exports`对象是当前模块的导出对象，用于导出模块公有方法和属性。\n\t事实上,exports 本身仅仅是一个普通的空对象,即 {},它专门用来声明接口。例如：\n\t\n\t```\n\t//module.js\r\texports.sayHello = function(name) { \n\t\tconsole.log('Hello ' \t+ name);\r\t};\n\t```\t\n2.  require\n\n\t`require`函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。例如：\n\t\n\t```\n\t//index.js\n\tvar myModule = require('./module');\n\tmyModule.sayHello(\"node\");\n\t```\t\n3. module\n\n\t通过module对象可以访问到当前模块的一些相关信息，但最多的用途是覆盖 exports。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话：\n\t\n\t```\n\t//module.js\r\tmodule.exports = function(name) { \n\t\tconsole.log('Hello ' \t+ name);\r\t};\n\t\n\t//index.js\n\tvar sayHello = require('./module');\n\tsayHello(\"node\");\n\t```\t\n\t\n## 模块进阶——模块载入策略\n\nNode.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。原生模块在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类文件模块是动态加载的，加载速度比原生模块慢。\n\n### 内部实现机制\n\n加载文件模块的工作，主要由原生模块module来实现和完成，该原生模块在启动时已经被加载，进程直接调用到runMain静态方法。\n\n**Module源码：**\n\t\n```\nfunction Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent && parent.children) {\n    parent.children.push(this);\n  }\n\t\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n```\n\n模块解析流程：\n\n1. 命令行执行主模块\n\t\n\t命令行执行主模块\n\n\t```\n\t// bootstrap main module.\n\tModule.runMain = function() {\n\t  // Load the main module--the command line argument.\n\t  Module._load(process.argv[1], null, true);\n\t  // Handle any nextTicks added in the first tick of the program\n\t  process._tickCallback();\n\t};\n\t```\n\t\n\t\n\n2. 处理模块\n\n\tModule.runMain方法会在最后执行_load静态方法，该方法又会在分析文件名之后执行:\n\n\t```\n\t//实例化Module函数\n\tvar module = new Module(id, parent);\n\t```\n\t\n\t并根据文件路径**缓存**当前模块对象，该模块实例对象则根据文件名加载。\n\t\n\t```\n\tmodule.load(filename);\n\t```\n\t\n\t这时，Node.js会根据不同文件模块类型的后缀名来决定加载方法。\n\n\t+ js：通过fs模块同步读取js文件并编译执行。\n\t+ node：通过C/C++进行编写的Addon。通过dlopen方法进行加载。\n\t+ json：读取文件，调用JSON.parse解析加载。\n\t\n\t\n\t\n3. 输出结果\n\n\t最后js文件形式的模块会变成以下形式的内容：\n\t\n\t```\n\t(function (exports, require, module, __filename, __dirname) {\n    \tvar circle = require('./circle.js');\n\t    \tconsole.log('The area of a circle of radius 4 is ' +circle.area(4));\n\t});\n\t```\n\t所以此时，主模块内可以使用exports, require, module等变量了，而其他模块又会通过require引进主模块，require方法会同runMain一样调用_load静态方法，以此类推。\n\t\n\t**require源码:**\n\t\n\t```\n\t// 传入模块路径作为参数. 返回 模块的exports属性.\n\t\n\tModule.prototype.require = function(path) {\n\t  assert(path, 'missing path');\n\t  assert(typeof path === 'string', 'path must be a string');\n\t  return Module._load(path, this, /* isMain */ false);\n\t};\n\t```\n\n\n## Q&A\n1. console.log(this)在浏览器和Node中分别打印出什么？\n\t\n\t答：显然浏览器中直接打印this指向Window对象，而在Node中，我们编写的文件其实外面都包裹了一层函数，而且该函数执行时强制apply将this指向了module.exports，因此此处打印为{}。\n\n2. 为什么require、__filename、__dirname、module、exports等几个变量并没有定义在app.js 文件中，但是这个方法却存在的原因。\n\n\t答：这里提到的所有属性均是_load方法中我们编写的js文件外层包裹函数提供给我们的，因此可以直接调用。\n\n","slug":"Node.js学习笔记（二）：模块机制","published":1,"date":"2021-12-06T05:35:02.611Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokw001cy4v232ay3bz1","content":"<h1 id=\"Node-js学习笔记（二）：模块\"><a href=\"#Node-js学习笔记（二）：模块\" class=\"headerlink\" title=\"Node.js学习笔记（二）：模块\"></a>Node.js学习笔记（二）：模块</h1><p>模块是 Node.js 应用程序的基本组成部分,文件和模块是一一对应的。一个 Node.js 文件就是一个模块,这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。</p>\n<p>由于JavaScript没有模块系统，所以Node.js依靠CommonJS规范自身实现了模块系统。</p>\n<h2 id=\"模块的简单使用——exports-、require-和-module\"><a href=\"#模块的简单使用——exports-、require-和-module\" class=\"headerlink\" title=\"模块的简单使用——exports 、require 和 module\"></a>模块的简单使用——exports 、require 和 module</h2><p>在编写和使用每个模块时，Node.js都有require、exports、module三个预先定义好的变量可供使用。</p>\n<ol>\n<li><p>exports</p>\n<p> <code>exports</code>对象是当前模块的导出对象，用于导出模块公有方法和属性。<br> 事实上,exports 本身仅仅是一个普通的空对象,即 {},它专门用来声明接口。例如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//module.js\rexports.sayHello = function(name) &#123; </span><br><span class=\"line\">\tconsole.log(&#x27;Hello &#x27; \t+ name);\r&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p>require</p>\n<p> <code>require</code>函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。例如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//index.js</span><br><span class=\"line\">var myModule = require(&#x27;./module&#x27;);</span><br><span class=\"line\">myModule.sayHello(&quot;node&quot;);</span><br></pre></td></tr></table></figure></li>\n<li><p>module</p>\n<p> 通过module对象可以访问到当前模块的一些相关信息，但最多的用途是覆盖 exports。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//module.js\rmodule.exports = function(name) &#123; </span><br><span class=\"line\">\tconsole.log(&#x27;Hello &#x27; \t+ name);\r&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//index.js</span><br><span class=\"line\">var sayHello = require(&#x27;./module&#x27;);</span><br><span class=\"line\">sayHello(&quot;node&quot;);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"模块进阶——模块载入策略\"><a href=\"#模块进阶——模块载入策略\" class=\"headerlink\" title=\"模块进阶——模块载入策略\"></a>模块进阶——模块载入策略</h2><p>Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。原生模块在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类文件模块是动态加载的，加载速度比原生模块慢。</p>\n<h3 id=\"内部实现机制\"><a href=\"#内部实现机制\" class=\"headerlink\" title=\"内部实现机制\"></a>内部实现机制</h3><p>加载文件模块的工作，主要由原生模块module来实现和完成，该原生模块在启动时已经被加载，进程直接调用到runMain静态方法。</p>\n<p><strong>Module源码：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Module(id, parent) &#123;</span><br><span class=\"line\">  this.id = id;</span><br><span class=\"line\">  this.exports = &#123;&#125;;</span><br><span class=\"line\">  this.parent = parent;</span><br><span class=\"line\">  if (parent &amp;&amp; parent.children) &#123;</span><br><span class=\"line\">    parent.children.push(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">  this.filename = null;</span><br><span class=\"line\">  this.loaded = false;</span><br><span class=\"line\">  this.children = [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>模块解析流程：</p>\n<ol>\n<li><p>命令行执行主模块</p>\n<p> 命令行执行主模块</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bootstrap main module.</span><br><span class=\"line\">Module.runMain = function() &#123;</span><br><span class=\"line\">  // Load the main module--the command line argument.</span><br><span class=\"line\">  Module._load(process.argv[1], null, true);</span><br><span class=\"line\">  // Handle any nextTicks added in the first tick of the program</span><br><span class=\"line\">  process._tickCallback();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理模块</p>\n<p> Module.runMain方法会在最后执行_load静态方法，该方法又会在分析文件名之后执行:</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//实例化Module函数</span><br><span class=\"line\">var module = new Module(id, parent);</span><br></pre></td></tr></table></figure>\n<p> 并根据文件路径<strong>缓存</strong>当前模块对象，该模块实例对象则根据文件名加载。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.load(filename);</span><br></pre></td></tr></table></figure>\n<p> 这时，Node.js会根据不同文件模块类型的后缀名来决定加载方法。</p>\n<ul>\n<li>js：通过fs模块同步读取js文件并编译执行。</li>\n<li>node：通过C/C++进行编写的Addon。通过dlopen方法进行加载。</li>\n<li>json：读取文件，调用JSON.parse解析加载。</li>\n</ul>\n</li>\n<li><p>输出结果</p>\n<p> 最后js文件形式的模块会变成以下形式的内容：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class=\"line\">   \tvar circle = require(&#x27;./circle.js&#x27;);</span><br><span class=\"line\">    \tconsole.log(&#x27;The area of a circle of radius 4 is &#x27; +circle.area(4));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p> 所以此时，主模块内可以使用exports, require, module等变量了，而其他模块又会通过require引进主模块，require方法会同runMain一样调用_load静态方法，以此类推。</p>\n<p> <strong>require源码:</strong></p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 传入模块路径作为参数. 返回 模块的exports属性.</span><br><span class=\"line\"></span><br><span class=\"line\">Module.prototype.require = function(path) &#123;</span><br><span class=\"line\">  assert(path, &#x27;missing path&#x27;);</span><br><span class=\"line\">  assert(typeof path === &#x27;string&#x27;, &#x27;path must be a string&#x27;);</span><br><span class=\"line\">  return Module._load(path, this, /* isMain */ false);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ol>\n<li><p>console.log(this)在浏览器和Node中分别打印出什么？</p>\n<p> 答：显然浏览器中直接打印this指向Window对象，而在Node中，我们编写的文件其实外面都包裹了一层函数，而且该函数执行时强制apply将this指向了module.exports，因此此处打印为{}。</p>\n</li>\n<li><p>为什么require、__filename、__dirname、module、exports等几个变量并没有定义在app.js 文件中，但是这个方法却存在的原因。</p>\n<p> 答：这里提到的所有属性均是_load方法中我们编写的js文件外层包裹函数提供给我们的，因此可以直接调用。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Node-js学习笔记（二）：模块\"><a href=\"#Node-js学习笔记（二）：模块\" class=\"headerlink\" title=\"Node.js学习笔记（二）：模块\"></a>Node.js学习笔记（二）：模块</h1><p>模块是 Node.js 应用程序的基本组成部分,文件和模块是一一对应的。一个 Node.js 文件就是一个模块,这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。</p>\n<p>由于JavaScript没有模块系统，所以Node.js依靠CommonJS规范自身实现了模块系统。</p>\n<h2 id=\"模块的简单使用——exports-、require-和-module\"><a href=\"#模块的简单使用——exports-、require-和-module\" class=\"headerlink\" title=\"模块的简单使用——exports 、require 和 module\"></a>模块的简单使用——exports 、require 和 module</h2><p>在编写和使用每个模块时，Node.js都有require、exports、module三个预先定义好的变量可供使用。</p>\n<ol>\n<li><p>exports</p>\n<p> <code>exports</code>对象是当前模块的导出对象，用于导出模块公有方法和属性。<br> 事实上,exports 本身仅仅是一个普通的空对象,即 {},它专门用来声明接口。例如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//module.js\rexports.sayHello = function(name) &#123; </span><br><span class=\"line\">\tconsole.log(&#x27;Hello &#x27; \t+ name);\r&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p>require</p>\n<p> <code>require</code>函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。例如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//index.js</span><br><span class=\"line\">var myModule = require(&#x27;./module&#x27;);</span><br><span class=\"line\">myModule.sayHello(&quot;node&quot;);</span><br></pre></td></tr></table></figure></li>\n<li><p>module</p>\n<p> 通过module对象可以访问到当前模块的一些相关信息，但最多的用途是覆盖 exports。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//module.js\rmodule.exports = function(name) &#123; </span><br><span class=\"line\">\tconsole.log(&#x27;Hello &#x27; \t+ name);\r&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//index.js</span><br><span class=\"line\">var sayHello = require(&#x27;./module&#x27;);</span><br><span class=\"line\">sayHello(&quot;node&quot;);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"模块进阶——模块载入策略\"><a href=\"#模块进阶——模块载入策略\" class=\"headerlink\" title=\"模块进阶——模块载入策略\"></a>模块进阶——模块载入策略</h2><p>Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。原生模块在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类文件模块是动态加载的，加载速度比原生模块慢。</p>\n<h3 id=\"内部实现机制\"><a href=\"#内部实现机制\" class=\"headerlink\" title=\"内部实现机制\"></a>内部实现机制</h3><p>加载文件模块的工作，主要由原生模块module来实现和完成，该原生模块在启动时已经被加载，进程直接调用到runMain静态方法。</p>\n<p><strong>Module源码：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Module(id, parent) &#123;</span><br><span class=\"line\">  this.id = id;</span><br><span class=\"line\">  this.exports = &#123;&#125;;</span><br><span class=\"line\">  this.parent = parent;</span><br><span class=\"line\">  if (parent &amp;&amp; parent.children) &#123;</span><br><span class=\"line\">    parent.children.push(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">  this.filename = null;</span><br><span class=\"line\">  this.loaded = false;</span><br><span class=\"line\">  this.children = [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>模块解析流程：</p>\n<ol>\n<li><p>命令行执行主模块</p>\n<p> 命令行执行主模块</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bootstrap main module.</span><br><span class=\"line\">Module.runMain = function() &#123;</span><br><span class=\"line\">  // Load the main module--the command line argument.</span><br><span class=\"line\">  Module._load(process.argv[1], null, true);</span><br><span class=\"line\">  // Handle any nextTicks added in the first tick of the program</span><br><span class=\"line\">  process._tickCallback();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理模块</p>\n<p> Module.runMain方法会在最后执行_load静态方法，该方法又会在分析文件名之后执行:</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//实例化Module函数</span><br><span class=\"line\">var module = new Module(id, parent);</span><br></pre></td></tr></table></figure>\n<p> 并根据文件路径<strong>缓存</strong>当前模块对象，该模块实例对象则根据文件名加载。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.load(filename);</span><br></pre></td></tr></table></figure>\n<p> 这时，Node.js会根据不同文件模块类型的后缀名来决定加载方法。</p>\n<ul>\n<li>js：通过fs模块同步读取js文件并编译执行。</li>\n<li>node：通过C/C++进行编写的Addon。通过dlopen方法进行加载。</li>\n<li>json：读取文件，调用JSON.parse解析加载。</li>\n</ul>\n</li>\n<li><p>输出结果</p>\n<p> 最后js文件形式的模块会变成以下形式的内容：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class=\"line\">   \tvar circle = require(&#x27;./circle.js&#x27;);</span><br><span class=\"line\">    \tconsole.log(&#x27;The area of a circle of radius 4 is &#x27; +circle.area(4));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p> 所以此时，主模块内可以使用exports, require, module等变量了，而其他模块又会通过require引进主模块，require方法会同runMain一样调用_load静态方法，以此类推。</p>\n<p> <strong>require源码:</strong></p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 传入模块路径作为参数. 返回 模块的exports属性.</span><br><span class=\"line\"></span><br><span class=\"line\">Module.prototype.require = function(path) &#123;</span><br><span class=\"line\">  assert(path, &#x27;missing path&#x27;);</span><br><span class=\"line\">  assert(typeof path === &#x27;string&#x27;, &#x27;path must be a string&#x27;);</span><br><span class=\"line\">  return Module._load(path, this, /* isMain */ false);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ol>\n<li><p>console.log(this)在浏览器和Node中分别打印出什么？</p>\n<p> 答：显然浏览器中直接打印this指向Window对象，而在Node中，我们编写的文件其实外面都包裹了一层函数，而且该函数执行时强制apply将this指向了module.exports，因此此处打印为{}。</p>\n</li>\n<li><p>为什么require、__filename、__dirname、module、exports等几个变量并没有定义在app.js 文件中，但是这个方法却存在的原因。</p>\n<p> 答：这里提到的所有属性均是_load方法中我们编写的js文件外层包裹函数提供给我们的，因此可以直接调用。</p>\n</li>\n</ol>\n"},{"_content":"# Node.js学习笔记（四）: 全局对象\n\n在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。\n\n这里列出的所有变量均可以在所有模块中访问。但值得注意的是：它们有些并不是在全局作用域内的，即不在global对象内,而是在模块作用域内的。在模块作用域内的变量会用*表示。\n\n### global\n\n全局对象，全局变量的宿主\n\n### *__filename\n\n表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。\n\n### *__dirname\n\n表示当前执行脚本所在的目录。\n\n### *exports\n\n`module.exports`的引用，用于导出模块对象。\n\n### *module\n\n当前模块的引用，提供`module.exports`方法导出模块，并且允许通过require导入模块。\n\n### *require()\n\n用于导入模块对象。\n\n### *require.cache\n\n缓存模块的对象，当模块被require后缓存在此处。可以通过删除这个模块内的`key`值，删除缓存。\n\n### *require.resolve()\n\n使用node内部的require机制查看本地模块，它会返回模块的文件名但不会引入该模块。\n\n### clearImmediate(immediateObject)\n\n全局函数用于清除一个之前通过 setImmediate() 创建的Immediate对象。 参数 immediateObject 是通过 setImmediate() 函数创建的Immediate对象。\n\n### clearInterval(intervalObject)\n\n全局函数用于清除一个之前通过 setInterval() 创建的定时器。 参数 intervalObject 是通过 setInterval() 函数创建的定时器。\n\n### clearTimeout(timeoutObject)\n\n全局函数用于清除一个之前通过 setTimeout() 创建的定时器。 参数 timeoutObject 是通过 setTimeout() 函数创建的定时器。\n\n### console\n\n用于提供控制台标准输出。\n\n### process\n\n用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。\n\n### setImmediate(callback[, ...args])\n\n立即执行指定函数，它在异步I/O之后、settimeout()和setinterval()定时器之前调用。返回一个供clearImmediate使用的Immediate对象\n\n### setInterval(callback, delay[, ...args])\n\n在指定的毫秒(ms)数后执行指定函数(cb)。返回一个代表定时器的句柄值。setInterval() 方法会不停地调用函数。\n\n### setTimeout(callback, delay[, ...args])\n\n在指定的毫秒(ms)数后执行指定函数(callback)。：setTimeout() 只执行一次指定函数。返回一个代表定时器的句柄值。\n\n### Buffer\n\n用于处理二进制数据，详见buffer部分\n","source":"_posts/Node.js学习笔记（四）- 全局对象.md","raw":"# Node.js学习笔记（四）: 全局对象\n\n在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。\n\n这里列出的所有变量均可以在所有模块中访问。但值得注意的是：它们有些并不是在全局作用域内的，即不在global对象内,而是在模块作用域内的。在模块作用域内的变量会用*表示。\n\n### global\n\n全局对象，全局变量的宿主\n\n### *__filename\n\n表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。\n\n### *__dirname\n\n表示当前执行脚本所在的目录。\n\n### *exports\n\n`module.exports`的引用，用于导出模块对象。\n\n### *module\n\n当前模块的引用，提供`module.exports`方法导出模块，并且允许通过require导入模块。\n\n### *require()\n\n用于导入模块对象。\n\n### *require.cache\n\n缓存模块的对象，当模块被require后缓存在此处。可以通过删除这个模块内的`key`值，删除缓存。\n\n### *require.resolve()\n\n使用node内部的require机制查看本地模块，它会返回模块的文件名但不会引入该模块。\n\n### clearImmediate(immediateObject)\n\n全局函数用于清除一个之前通过 setImmediate() 创建的Immediate对象。 参数 immediateObject 是通过 setImmediate() 函数创建的Immediate对象。\n\n### clearInterval(intervalObject)\n\n全局函数用于清除一个之前通过 setInterval() 创建的定时器。 参数 intervalObject 是通过 setInterval() 函数创建的定时器。\n\n### clearTimeout(timeoutObject)\n\n全局函数用于清除一个之前通过 setTimeout() 创建的定时器。 参数 timeoutObject 是通过 setTimeout() 函数创建的定时器。\n\n### console\n\n用于提供控制台标准输出。\n\n### process\n\n用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。\n\n### setImmediate(callback[, ...args])\n\n立即执行指定函数，它在异步I/O之后、settimeout()和setinterval()定时器之前调用。返回一个供clearImmediate使用的Immediate对象\n\n### setInterval(callback, delay[, ...args])\n\n在指定的毫秒(ms)数后执行指定函数(cb)。返回一个代表定时器的句柄值。setInterval() 方法会不停地调用函数。\n\n### setTimeout(callback, delay[, ...args])\n\n在指定的毫秒(ms)数后执行指定函数(callback)。：setTimeout() 只执行一次指定函数。返回一个代表定时器的句柄值。\n\n### Buffer\n\n用于处理二进制数据，详见buffer部分\n","slug":"Node.js学习笔记（四）- 全局对象","published":1,"date":"2021-12-06T05:35:02.621Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokx001ey4v28yr285sa","content":"<h1 id=\"Node-js学习笔记（四）-全局对象\"><a href=\"#Node-js学习笔记（四）-全局对象\" class=\"headerlink\" title=\"Node.js学习笔记（四）: 全局对象\"></a>Node.js学习笔记（四）: 全局对象</h1><p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>\n<p>这里列出的所有变量均可以在所有模块中访问。但值得注意的是：它们有些并不是在全局作用域内的，即不在global对象内,而是在模块作用域内的。在模块作用域内的变量会用*表示。</p>\n<h3 id=\"global\"><a href=\"#global\" class=\"headerlink\" title=\"global\"></a>global</h3><p>全局对象，全局变量的宿主</p>\n<h3 id=\"filename\"><a href=\"#filename\" class=\"headerlink\" title=\"*__filename\"></a>*__filename</h3><p>表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p>\n<h3 id=\"dirname\"><a href=\"#dirname\" class=\"headerlink\" title=\"*__dirname\"></a>*__dirname</h3><p>表示当前执行脚本所在的目录。</p>\n<h3 id=\"exports\"><a href=\"#exports\" class=\"headerlink\" title=\"*exports\"></a>*exports</h3><p><code>module.exports</code>的引用，用于导出模块对象。</p>\n<h3 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"*module\"></a>*module</h3><p>当前模块的引用，提供<code>module.exports</code>方法导出模块，并且允许通过require导入模块。</p>\n<h3 id=\"require\"><a href=\"#require\" class=\"headerlink\" title=\"*require()\"></a>*require()</h3><p>用于导入模块对象。</p>\n<h3 id=\"require-cache\"><a href=\"#require-cache\" class=\"headerlink\" title=\"*require.cache\"></a>*require.cache</h3><p>缓存模块的对象，当模块被require后缓存在此处。可以通过删除这个模块内的<code>key</code>值，删除缓存。</p>\n<h3 id=\"require-resolve\"><a href=\"#require-resolve\" class=\"headerlink\" title=\"*require.resolve()\"></a>*require.resolve()</h3><p>使用node内部的require机制查看本地模块，它会返回模块的文件名但不会引入该模块。</p>\n<h3 id=\"clearImmediate-immediateObject\"><a href=\"#clearImmediate-immediateObject\" class=\"headerlink\" title=\"clearImmediate(immediateObject)\"></a>clearImmediate(immediateObject)</h3><p>全局函数用于清除一个之前通过 setImmediate() 创建的Immediate对象。 参数 immediateObject 是通过 setImmediate() 函数创建的Immediate对象。</p>\n<h3 id=\"clearInterval-intervalObject\"><a href=\"#clearInterval-intervalObject\" class=\"headerlink\" title=\"clearInterval(intervalObject)\"></a>clearInterval(intervalObject)</h3><p>全局函数用于清除一个之前通过 setInterval() 创建的定时器。 参数 intervalObject 是通过 setInterval() 函数创建的定时器。</p>\n<h3 id=\"clearTimeout-timeoutObject\"><a href=\"#clearTimeout-timeoutObject\" class=\"headerlink\" title=\"clearTimeout(timeoutObject)\"></a>clearTimeout(timeoutObject)</h3><p>全局函数用于清除一个之前通过 setTimeout() 创建的定时器。 参数 timeoutObject 是通过 setTimeout() 函数创建的定时器。</p>\n<h3 id=\"console\"><a href=\"#console\" class=\"headerlink\" title=\"console\"></a>console</h3><p>用于提供控制台标准输出。</p>\n<h3 id=\"process\"><a href=\"#process\" class=\"headerlink\" title=\"process\"></a>process</h3><p>用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。</p>\n<h3 id=\"setImmediate-callback-…args\"><a href=\"#setImmediate-callback-…args\" class=\"headerlink\" title=\"setImmediate(callback[, …args])\"></a>setImmediate(callback[, …args])</h3><p>立即执行指定函数，它在异步I/O之后、settimeout()和setinterval()定时器之前调用。返回一个供clearImmediate使用的Immediate对象</p>\n<h3 id=\"setInterval-callback-delay-…args\"><a href=\"#setInterval-callback-delay-…args\" class=\"headerlink\" title=\"setInterval(callback, delay[, …args])\"></a>setInterval(callback, delay[, …args])</h3><p>在指定的毫秒(ms)数后执行指定函数(cb)。返回一个代表定时器的句柄值。setInterval() 方法会不停地调用函数。</p>\n<h3 id=\"setTimeout-callback-delay-…args\"><a href=\"#setTimeout-callback-delay-…args\" class=\"headerlink\" title=\"setTimeout(callback, delay[, …args])\"></a>setTimeout(callback, delay[, …args])</h3><p>在指定的毫秒(ms)数后执行指定函数(callback)。：setTimeout() 只执行一次指定函数。返回一个代表定时器的句柄值。</p>\n<h3 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h3><p>用于处理二进制数据，详见buffer部分</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Node-js学习笔记（四）-全局对象\"><a href=\"#Node-js学习笔记（四）-全局对象\" class=\"headerlink\" title=\"Node.js学习笔记（四）: 全局对象\"></a>Node.js学习笔记（四）: 全局对象</h1><p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>\n<p>这里列出的所有变量均可以在所有模块中访问。但值得注意的是：它们有些并不是在全局作用域内的，即不在global对象内,而是在模块作用域内的。在模块作用域内的变量会用*表示。</p>\n<h3 id=\"global\"><a href=\"#global\" class=\"headerlink\" title=\"global\"></a>global</h3><p>全局对象，全局变量的宿主</p>\n<h3 id=\"filename\"><a href=\"#filename\" class=\"headerlink\" title=\"*__filename\"></a>*__filename</h3><p>表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p>\n<h3 id=\"dirname\"><a href=\"#dirname\" class=\"headerlink\" title=\"*__dirname\"></a>*__dirname</h3><p>表示当前执行脚本所在的目录。</p>\n<h3 id=\"exports\"><a href=\"#exports\" class=\"headerlink\" title=\"*exports\"></a>*exports</h3><p><code>module.exports</code>的引用，用于导出模块对象。</p>\n<h3 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"*module\"></a>*module</h3><p>当前模块的引用，提供<code>module.exports</code>方法导出模块，并且允许通过require导入模块。</p>\n<h3 id=\"require\"><a href=\"#require\" class=\"headerlink\" title=\"*require()\"></a>*require()</h3><p>用于导入模块对象。</p>\n<h3 id=\"require-cache\"><a href=\"#require-cache\" class=\"headerlink\" title=\"*require.cache\"></a>*require.cache</h3><p>缓存模块的对象，当模块被require后缓存在此处。可以通过删除这个模块内的<code>key</code>值，删除缓存。</p>\n<h3 id=\"require-resolve\"><a href=\"#require-resolve\" class=\"headerlink\" title=\"*require.resolve()\"></a>*require.resolve()</h3><p>使用node内部的require机制查看本地模块，它会返回模块的文件名但不会引入该模块。</p>\n<h3 id=\"clearImmediate-immediateObject\"><a href=\"#clearImmediate-immediateObject\" class=\"headerlink\" title=\"clearImmediate(immediateObject)\"></a>clearImmediate(immediateObject)</h3><p>全局函数用于清除一个之前通过 setImmediate() 创建的Immediate对象。 参数 immediateObject 是通过 setImmediate() 函数创建的Immediate对象。</p>\n<h3 id=\"clearInterval-intervalObject\"><a href=\"#clearInterval-intervalObject\" class=\"headerlink\" title=\"clearInterval(intervalObject)\"></a>clearInterval(intervalObject)</h3><p>全局函数用于清除一个之前通过 setInterval() 创建的定时器。 参数 intervalObject 是通过 setInterval() 函数创建的定时器。</p>\n<h3 id=\"clearTimeout-timeoutObject\"><a href=\"#clearTimeout-timeoutObject\" class=\"headerlink\" title=\"clearTimeout(timeoutObject)\"></a>clearTimeout(timeoutObject)</h3><p>全局函数用于清除一个之前通过 setTimeout() 创建的定时器。 参数 timeoutObject 是通过 setTimeout() 函数创建的定时器。</p>\n<h3 id=\"console\"><a href=\"#console\" class=\"headerlink\" title=\"console\"></a>console</h3><p>用于提供控制台标准输出。</p>\n<h3 id=\"process\"><a href=\"#process\" class=\"headerlink\" title=\"process\"></a>process</h3><p>用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。</p>\n<h3 id=\"setImmediate-callback-…args\"><a href=\"#setImmediate-callback-…args\" class=\"headerlink\" title=\"setImmediate(callback[, …args])\"></a>setImmediate(callback[, …args])</h3><p>立即执行指定函数，它在异步I/O之后、settimeout()和setinterval()定时器之前调用。返回一个供clearImmediate使用的Immediate对象</p>\n<h3 id=\"setInterval-callback-delay-…args\"><a href=\"#setInterval-callback-delay-…args\" class=\"headerlink\" title=\"setInterval(callback, delay[, …args])\"></a>setInterval(callback, delay[, …args])</h3><p>在指定的毫秒(ms)数后执行指定函数(cb)。返回一个代表定时器的句柄值。setInterval() 方法会不停地调用函数。</p>\n<h3 id=\"setTimeout-callback-delay-…args\"><a href=\"#setTimeout-callback-delay-…args\" class=\"headerlink\" title=\"setTimeout(callback, delay[, …args])\"></a>setTimeout(callback, delay[, …args])</h3><p>在指定的毫秒(ms)数后执行指定函数(callback)。：setTimeout() 只执行一次指定函数。返回一个代表定时器的句柄值。</p>\n<h3 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h3><p>用于处理二进制数据，详见buffer部分</p>\n"},{"_content":"# Node.js学习笔记（五）: 文件系统（fs）\n\n\nNode.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 要使用\n这个模块需要require(\"fs\")。fs 模块中所有的操作都提供了异步的和 同步的两个版本。\n\n```\nconst fs = require(\"fs\")\n```\n\n异步形式的API总是将回调函数作为它的最后一个参数，并且回调函数第一个参数总是为异常保留，如果没有发生错误，则第一个参数为`null`或`undefined`。\n\n使用同步形式的API时，任何异常都会立即抛出，您可以使用try/catch来处理异常或允许它们冒泡。\n\n强烈鼓励大家使用这些API的异步版本，同步版本会阻塞整个进程。\n\n异步删除文件：\n\n```\nfs.unlink('/tmp/hello', (err) => {\n  if (err) throw err;\n  console.log('successfully deleted /tmp/hello');\n});\n```\n这里传入了一个回调函数，这个回调函数会在删除文件操作完成后执行。打印'successfully deleted /tmp/hello'；\n\n同步删除文件：\n\n```\nfs.unlinkSync('/tmp/hello');\nconsole.log('successfully deleted /tmp/hello');\n```\n这里是同步函数，所以不需要传回调函数，打印字符串的操作会在删除文件操作开始的同时进行（不管文件删除操作是否已经完成）。\n\nfs 模块提供了文件信息获取，文件读写，关闭文件，截取文件，删除文件，创建目录，读取目录，删除目录等文件系统操作。\n\n\n### API一览：\n\n+ 打开文件 \n\n\t- fs.open(path,flags, [mode], [callback(err, fd)])\n\t- fs.openSync(path, flags, [mode]) fd)])\r+ 关闭文件 \n\n\t- fs.close(fd, [callback(err)]) \n\t- fs.closeSync(fd)\n+ 读取文件(文件描述符） \n\n\t- fs.read(fd,buffer,offset,length,position,[callback(err, bytesRead, buffer)])\n\t- fs.readSync(fd, buffer, offset, length, position)\n\r+ 写入文件(文件描述符)\n\n\t- fs.write(fd,buffer,offset,length,position,  [callback(err, bytesWritten, buffer)])\n\t- fs.writeSync(fd, buffer, offset, length, position)\n\n\r+ 读取文件内容 \n\n\t- fs.readFile(filename,[encoding],[callba ck(err, data)])\n\t- fs.readFileSync(filename,[encoding])\n\r+ 写入文件内容 \n\n\t- fs.writeFile(filename, data,[encoding], [callback(err)])\n\t- fs.writeFileSync(filename, data, [encoding])\n\t\r+ 删除文件 \n\n\t- fs.unlink(path, [callback(err)])\n\t- fs.unlinkSync(path)\n\t\r+ 创建目录 \n\n\t- fs.mkdir(path, [mode], [callback(err)])\n\t- fs.mkdirSync(path, [mode])\n\t\r+ 删除目录 \n\n\t- fs.rmdir(path, [callback(err)])\n\t- fs.rmdirSync(path)\n\t\r+ 读取目录 \n\n\t- fs.readdir(path, [callback(err, files)])\n\t- fs.readdirSync(path)\n\t\r+ 获取真实路  \n\n\t- fs.realpath(path, [callback(err, resolvedPath)])\n\t- fs.realpathSync(path)\n\t\r+ 更名\n\n\t- fs.rename(path1, path2, [callback(err)])\n\t- fs.renameSync(path1, path2)\n\n+ 截断\n\n\t- fs.truncate(fd, len, [callback(err)])\n\t- fs.truncateSync(fd, len)\n\t \r+ 更改所有权\n\n\t- fs.chown(path, uid, gid, [callback(err)])\n\t- fs.chownSync(path, uid, gid)\n\t\r+ 更改所有权(文件描述符）\n\n\t- fs.fchown(fd, uid, gid, [callback(err)])\n\t- fs.fchownSync(fd, uid, gid)\n\t\r+ 更改所有权(不解析符链接) \n\n\t- fs.lchown(path, uid, gid, [callback(err)]) \n\t- fs.lchownSync(path, uid, gid)\n\t\n+ 更改权限\n\n\t- fs.chmod(path, mode, [callback(err)])\n\t- fs.chmodSync(path, mode)\n\t\r+ 更改权限(文件描述符)  \n\n\t- fs.fchmod(fd, mode, [callback(err)])\n\t- fs.fchmodSync(fd, mode)\r+ 获取文件信息\n\n\t- fs.stat(path, [callback(err, stats)]) \n\t- fs.statSync(path)\n\n+ 获取文件信息(文件描述符） \n\n\t- fs.fstat(fd, [callback(err, stats)])\n\t- fs.fstatSync(fd)\r\r+ 创建硬链接 \n\n\t- fs.link(srcpath, dstpath, [callback(err)]) \n\t- fs.linkSync(srcpath, dstpath)\n\t\n+ 创建符号链接 \n\n\t- fs.symlink(linkdata, path, [type],[callback(err)])\n\t- fs.symlinkSync(linkdata, path,[type])\r\r+ 读取链接 \n\n\t- fs.readlink(path, [callback(err, linkString)])\n\t- fs.readlinkSync(path)\n\t\r+ 修改文件时间戳  \n\n\t- fs.utimes(path, atime, mtime, [callback (err)])\n\t- fs.utimesSync(path, atime, mtime)\n\t\r+ 修改文件时间戳（文件描述符）  \n\n\t- fs.futimes(fd, atime, mtime, [callback(err)])\n\t- fs.futimesSync(fd, atime, mtime)\n\r+ 同步磁盘缓存\n\n\t- fs.fsync(fd, [callback(err)])\n\t- fs.fsyncSync(fd)","source":"_posts/Node.js学习笔记（五）- 文件系统.md","raw":"# Node.js学习笔记（五）: 文件系统（fs）\n\n\nNode.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 要使用\n这个模块需要require(\"fs\")。fs 模块中所有的操作都提供了异步的和 同步的两个版本。\n\n```\nconst fs = require(\"fs\")\n```\n\n异步形式的API总是将回调函数作为它的最后一个参数，并且回调函数第一个参数总是为异常保留，如果没有发生错误，则第一个参数为`null`或`undefined`。\n\n使用同步形式的API时，任何异常都会立即抛出，您可以使用try/catch来处理异常或允许它们冒泡。\n\n强烈鼓励大家使用这些API的异步版本，同步版本会阻塞整个进程。\n\n异步删除文件：\n\n```\nfs.unlink('/tmp/hello', (err) => {\n  if (err) throw err;\n  console.log('successfully deleted /tmp/hello');\n});\n```\n这里传入了一个回调函数，这个回调函数会在删除文件操作完成后执行。打印'successfully deleted /tmp/hello'；\n\n同步删除文件：\n\n```\nfs.unlinkSync('/tmp/hello');\nconsole.log('successfully deleted /tmp/hello');\n```\n这里是同步函数，所以不需要传回调函数，打印字符串的操作会在删除文件操作开始的同时进行（不管文件删除操作是否已经完成）。\n\nfs 模块提供了文件信息获取，文件读写，关闭文件，截取文件，删除文件，创建目录，读取目录，删除目录等文件系统操作。\n\n\n### API一览：\n\n+ 打开文件 \n\n\t- fs.open(path,flags, [mode], [callback(err, fd)])\n\t- fs.openSync(path, flags, [mode]) fd)])\r+ 关闭文件 \n\n\t- fs.close(fd, [callback(err)]) \n\t- fs.closeSync(fd)\n+ 读取文件(文件描述符） \n\n\t- fs.read(fd,buffer,offset,length,position,[callback(err, bytesRead, buffer)])\n\t- fs.readSync(fd, buffer, offset, length, position)\n\r+ 写入文件(文件描述符)\n\n\t- fs.write(fd,buffer,offset,length,position,  [callback(err, bytesWritten, buffer)])\n\t- fs.writeSync(fd, buffer, offset, length, position)\n\n\r+ 读取文件内容 \n\n\t- fs.readFile(filename,[encoding],[callba ck(err, data)])\n\t- fs.readFileSync(filename,[encoding])\n\r+ 写入文件内容 \n\n\t- fs.writeFile(filename, data,[encoding], [callback(err)])\n\t- fs.writeFileSync(filename, data, [encoding])\n\t\r+ 删除文件 \n\n\t- fs.unlink(path, [callback(err)])\n\t- fs.unlinkSync(path)\n\t\r+ 创建目录 \n\n\t- fs.mkdir(path, [mode], [callback(err)])\n\t- fs.mkdirSync(path, [mode])\n\t\r+ 删除目录 \n\n\t- fs.rmdir(path, [callback(err)])\n\t- fs.rmdirSync(path)\n\t\r+ 读取目录 \n\n\t- fs.readdir(path, [callback(err, files)])\n\t- fs.readdirSync(path)\n\t\r+ 获取真实路  \n\n\t- fs.realpath(path, [callback(err, resolvedPath)])\n\t- fs.realpathSync(path)\n\t\r+ 更名\n\n\t- fs.rename(path1, path2, [callback(err)])\n\t- fs.renameSync(path1, path2)\n\n+ 截断\n\n\t- fs.truncate(fd, len, [callback(err)])\n\t- fs.truncateSync(fd, len)\n\t \r+ 更改所有权\n\n\t- fs.chown(path, uid, gid, [callback(err)])\n\t- fs.chownSync(path, uid, gid)\n\t\r+ 更改所有权(文件描述符）\n\n\t- fs.fchown(fd, uid, gid, [callback(err)])\n\t- fs.fchownSync(fd, uid, gid)\n\t\r+ 更改所有权(不解析符链接) \n\n\t- fs.lchown(path, uid, gid, [callback(err)]) \n\t- fs.lchownSync(path, uid, gid)\n\t\n+ 更改权限\n\n\t- fs.chmod(path, mode, [callback(err)])\n\t- fs.chmodSync(path, mode)\n\t\r+ 更改权限(文件描述符)  \n\n\t- fs.fchmod(fd, mode, [callback(err)])\n\t- fs.fchmodSync(fd, mode)\r+ 获取文件信息\n\n\t- fs.stat(path, [callback(err, stats)]) \n\t- fs.statSync(path)\n\n+ 获取文件信息(文件描述符） \n\n\t- fs.fstat(fd, [callback(err, stats)])\n\t- fs.fstatSync(fd)\r\r+ 创建硬链接 \n\n\t- fs.link(srcpath, dstpath, [callback(err)]) \n\t- fs.linkSync(srcpath, dstpath)\n\t\n+ 创建符号链接 \n\n\t- fs.symlink(linkdata, path, [type],[callback(err)])\n\t- fs.symlinkSync(linkdata, path,[type])\r\r+ 读取链接 \n\n\t- fs.readlink(path, [callback(err, linkString)])\n\t- fs.readlinkSync(path)\n\t\r+ 修改文件时间戳  \n\n\t- fs.utimes(path, atime, mtime, [callback (err)])\n\t- fs.utimesSync(path, atime, mtime)\n\t\r+ 修改文件时间戳（文件描述符）  \n\n\t- fs.futimes(fd, atime, mtime, [callback(err)])\n\t- fs.futimesSync(fd, atime, mtime)\n\r+ 同步磁盘缓存\n\n\t- fs.fsync(fd, [callback(err)])\n\t- fs.fsyncSync(fd)","slug":"Node.js学习笔记（五）- 文件系统","published":1,"date":"2021-12-06T05:35:02.611Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoky001gy4v20gvhfk2l","content":"<h1 id=\"Node-js学习笔记（五）-文件系统（fs）\"><a href=\"#Node-js学习笔记（五）-文件系统（fs）\" class=\"headerlink\" title=\"Node.js学习笔记（五）: 文件系统（fs）\"></a>Node.js学习笔记（五）: 文件系统（fs）</h1><p>Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 要使用<br>这个模块需要require(“fs”)。fs 模块中所有的操作都提供了异步的和 同步的两个版本。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&quot;fs&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>异步形式的API总是将回调函数作为它的最后一个参数，并且回调函数第一个参数总是为异常保留，如果没有发生错误，则第一个参数为<code>null</code>或<code>undefined</code>。</p>\n<p>使用同步形式的API时，任何异常都会立即抛出，您可以使用try/catch来处理异常或允许它们冒泡。</p>\n<p>强烈鼓励大家使用这些API的异步版本，同步版本会阻塞整个进程。</p>\n<p>异步删除文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.unlink(&#x27;/tmp/hello&#x27;, (err) =&gt; &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&#x27;successfully deleted /tmp/hello&#x27;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里传入了一个回调函数，这个回调函数会在删除文件操作完成后执行。打印’successfully deleted /tmp/hello’；</p>\n<p>同步删除文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.unlinkSync(&#x27;/tmp/hello&#x27;);</span><br><span class=\"line\">console.log(&#x27;successfully deleted /tmp/hello&#x27;);</span><br></pre></td></tr></table></figure>\n<p>这里是同步函数，所以不需要传回调函数，打印字符串的操作会在删除文件操作开始的同时进行（不管文件删除操作是否已经完成）。</p>\n<p>fs 模块提供了文件信息获取，文件读写，关闭文件，截取文件，删除文件，创建目录，读取目录，删除目录等文件系统操作。</p>\n<h3 id=\"API一览：\"><a href=\"#API一览：\" class=\"headerlink\" title=\"API一览：\"></a>API一览：</h3><ul>\n<li><p>打开文件 </p>\n<ul>\n<li>fs.open(path,flags, [mode], [callback(err, fd)])</li>\n<li>fs.openSync(path, flags, [mode]) fd)])</li>\n</ul>\n</li>\n<li><p>关闭文件 </p>\n<ul>\n<li>fs.close(fd, [callback(err)]) </li>\n<li>fs.closeSync(fd)</li>\n</ul>\n</li>\n<li><p>读取文件(文件描述符） </p>\n<ul>\n<li>fs.read(fd,buffer,offset,length,position,[callback(err, bytesRead, buffer)])</li>\n<li>fs.readSync(fd, buffer, offset, length, position)</li>\n</ul>\n</li>\n<li><p>写入文件(文件描述符)</p>\n<ul>\n<li>fs.write(fd,buffer,offset,length,position,  [callback(err, bytesWritten, buffer)])</li>\n<li>fs.writeSync(fd, buffer, offset, length, position)</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>读取文件内容 </p>\n<ul>\n<li>fs.readFile(filename,[encoding],[callba ck(err, data)])</li>\n<li>fs.readFileSync(filename,[encoding])</li>\n</ul>\n</li>\n<li><p>写入文件内容 </p>\n<ul>\n<li>fs.writeFile(filename, data,[encoding], [callback(err)])</li>\n<li>fs.writeFileSync(filename, data, [encoding])</li>\n</ul>\n</li>\n<li><p>删除文件 </p>\n<ul>\n<li>fs.unlink(path, [callback(err)])</li>\n<li>fs.unlinkSync(path)</li>\n</ul>\n</li>\n<li><p>创建目录 </p>\n<ul>\n<li>fs.mkdir(path, [mode], [callback(err)])</li>\n<li>fs.mkdirSync(path, [mode])</li>\n</ul>\n</li>\n<li><p>删除目录 </p>\n<ul>\n<li>fs.rmdir(path, [callback(err)])</li>\n<li>fs.rmdirSync(path)</li>\n</ul>\n</li>\n<li><p>读取目录 </p>\n<ul>\n<li>fs.readdir(path, [callback(err, files)])</li>\n<li>fs.readdirSync(path)</li>\n</ul>\n</li>\n<li><p>获取真实路  </p>\n<ul>\n<li>fs.realpath(path, [callback(err, resolvedPath)])</li>\n<li>fs.realpathSync(path)</li>\n</ul>\n</li>\n<li><p>更名</p>\n<ul>\n<li>fs.rename(path1, path2, [callback(err)])</li>\n<li>fs.renameSync(path1, path2)</li>\n</ul>\n</li>\n<li><p>截断</p>\n<ul>\n<li>fs.truncate(fd, len, [callback(err)])</li>\n<li>fs.truncateSync(fd, len)</li>\n</ul>\n</li>\n<li><p>更改所有权</p>\n<ul>\n<li>fs.chown(path, uid, gid, [callback(err)])</li>\n<li>fs.chownSync(path, uid, gid)</li>\n</ul>\n</li>\n<li><p>更改所有权(文件描述符）</p>\n<ul>\n<li>fs.fchown(fd, uid, gid, [callback(err)])</li>\n<li>fs.fchownSync(fd, uid, gid)</li>\n</ul>\n</li>\n<li><p>更改所有权(不解析符链接) </p>\n<ul>\n<li>fs.lchown(path, uid, gid, [callback(err)]) </li>\n<li>fs.lchownSync(path, uid, gid)</li>\n</ul>\n</li>\n<li><p>更改权限</p>\n<ul>\n<li>fs.chmod(path, mode, [callback(err)])</li>\n<li>fs.chmodSync(path, mode)</li>\n</ul>\n</li>\n<li><p>更改权限(文件描述符)  </p>\n<ul>\n<li>fs.fchmod(fd, mode, [callback(err)])</li>\n<li>fs.fchmodSync(fd, mode)</li>\n</ul>\n</li>\n<li><p>获取文件信息</p>\n<ul>\n<li>fs.stat(path, [callback(err, stats)]) </li>\n<li>fs.statSync(path)</li>\n</ul>\n</li>\n<li><p>获取文件信息(文件描述符） </p>\n<ul>\n<li>fs.fstat(fd, [callback(err, stats)])</li>\n<li>fs.fstatSync(fd)</li>\n</ul>\n</li>\n<li><p>创建硬链接 </p>\n<ul>\n<li>fs.link(srcpath, dstpath, [callback(err)]) </li>\n<li>fs.linkSync(srcpath, dstpath)</li>\n</ul>\n</li>\n<li><p>创建符号链接 </p>\n<ul>\n<li>fs.symlink(linkdata, path, [type],[callback(err)])</li>\n<li>fs.symlinkSync(linkdata, path,[type])</li>\n</ul>\n</li>\n<li><p>读取链接 </p>\n<ul>\n<li>fs.readlink(path, [callback(err, linkString)])</li>\n<li>fs.readlinkSync(path)</li>\n</ul>\n</li>\n<li><p>修改文件时间戳  </p>\n<ul>\n<li>fs.utimes(path, atime, mtime, [callback (err)])</li>\n<li>fs.utimesSync(path, atime, mtime)</li>\n</ul>\n</li>\n<li><p>修改文件时间戳（文件描述符）  </p>\n<ul>\n<li>fs.futimes(fd, atime, mtime, [callback(err)])</li>\n<li>fs.futimesSync(fd, atime, mtime)</li>\n</ul>\n</li>\n<li><p>同步磁盘缓存</p>\n<ul>\n<li>fs.fsync(fd, [callback(err)])</li>\n<li>fs.fsyncSync(fd)</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Node-js学习笔记（五）-文件系统（fs）\"><a href=\"#Node-js学习笔记（五）-文件系统（fs）\" class=\"headerlink\" title=\"Node.js学习笔记（五）: 文件系统（fs）\"></a>Node.js学习笔记（五）: 文件系统（fs）</h1><p>Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 要使用<br>这个模块需要require(“fs”)。fs 模块中所有的操作都提供了异步的和 同步的两个版本。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&quot;fs&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>异步形式的API总是将回调函数作为它的最后一个参数，并且回调函数第一个参数总是为异常保留，如果没有发生错误，则第一个参数为<code>null</code>或<code>undefined</code>。</p>\n<p>使用同步形式的API时，任何异常都会立即抛出，您可以使用try/catch来处理异常或允许它们冒泡。</p>\n<p>强烈鼓励大家使用这些API的异步版本，同步版本会阻塞整个进程。</p>\n<p>异步删除文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.unlink(&#x27;/tmp/hello&#x27;, (err) =&gt; &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&#x27;successfully deleted /tmp/hello&#x27;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里传入了一个回调函数，这个回调函数会在删除文件操作完成后执行。打印’successfully deleted /tmp/hello’；</p>\n<p>同步删除文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.unlinkSync(&#x27;/tmp/hello&#x27;);</span><br><span class=\"line\">console.log(&#x27;successfully deleted /tmp/hello&#x27;);</span><br></pre></td></tr></table></figure>\n<p>这里是同步函数，所以不需要传回调函数，打印字符串的操作会在删除文件操作开始的同时进行（不管文件删除操作是否已经完成）。</p>\n<p>fs 模块提供了文件信息获取，文件读写，关闭文件，截取文件，删除文件，创建目录，读取目录，删除目录等文件系统操作。</p>\n<h3 id=\"API一览：\"><a href=\"#API一览：\" class=\"headerlink\" title=\"API一览：\"></a>API一览：</h3><ul>\n<li><p>打开文件 </p>\n<ul>\n<li>fs.open(path,flags, [mode], [callback(err, fd)])</li>\n<li>fs.openSync(path, flags, [mode]) fd)])</li>\n</ul>\n</li>\n<li><p>关闭文件 </p>\n<ul>\n<li>fs.close(fd, [callback(err)]) </li>\n<li>fs.closeSync(fd)</li>\n</ul>\n</li>\n<li><p>读取文件(文件描述符） </p>\n<ul>\n<li>fs.read(fd,buffer,offset,length,position,[callback(err, bytesRead, buffer)])</li>\n<li>fs.readSync(fd, buffer, offset, length, position)</li>\n</ul>\n</li>\n<li><p>写入文件(文件描述符)</p>\n<ul>\n<li>fs.write(fd,buffer,offset,length,position,  [callback(err, bytesWritten, buffer)])</li>\n<li>fs.writeSync(fd, buffer, offset, length, position)</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>读取文件内容 </p>\n<ul>\n<li>fs.readFile(filename,[encoding],[callba ck(err, data)])</li>\n<li>fs.readFileSync(filename,[encoding])</li>\n</ul>\n</li>\n<li><p>写入文件内容 </p>\n<ul>\n<li>fs.writeFile(filename, data,[encoding], [callback(err)])</li>\n<li>fs.writeFileSync(filename, data, [encoding])</li>\n</ul>\n</li>\n<li><p>删除文件 </p>\n<ul>\n<li>fs.unlink(path, [callback(err)])</li>\n<li>fs.unlinkSync(path)</li>\n</ul>\n</li>\n<li><p>创建目录 </p>\n<ul>\n<li>fs.mkdir(path, [mode], [callback(err)])</li>\n<li>fs.mkdirSync(path, [mode])</li>\n</ul>\n</li>\n<li><p>删除目录 </p>\n<ul>\n<li>fs.rmdir(path, [callback(err)])</li>\n<li>fs.rmdirSync(path)</li>\n</ul>\n</li>\n<li><p>读取目录 </p>\n<ul>\n<li>fs.readdir(path, [callback(err, files)])</li>\n<li>fs.readdirSync(path)</li>\n</ul>\n</li>\n<li><p>获取真实路  </p>\n<ul>\n<li>fs.realpath(path, [callback(err, resolvedPath)])</li>\n<li>fs.realpathSync(path)</li>\n</ul>\n</li>\n<li><p>更名</p>\n<ul>\n<li>fs.rename(path1, path2, [callback(err)])</li>\n<li>fs.renameSync(path1, path2)</li>\n</ul>\n</li>\n<li><p>截断</p>\n<ul>\n<li>fs.truncate(fd, len, [callback(err)])</li>\n<li>fs.truncateSync(fd, len)</li>\n</ul>\n</li>\n<li><p>更改所有权</p>\n<ul>\n<li>fs.chown(path, uid, gid, [callback(err)])</li>\n<li>fs.chownSync(path, uid, gid)</li>\n</ul>\n</li>\n<li><p>更改所有权(文件描述符）</p>\n<ul>\n<li>fs.fchown(fd, uid, gid, [callback(err)])</li>\n<li>fs.fchownSync(fd, uid, gid)</li>\n</ul>\n</li>\n<li><p>更改所有权(不解析符链接) </p>\n<ul>\n<li>fs.lchown(path, uid, gid, [callback(err)]) </li>\n<li>fs.lchownSync(path, uid, gid)</li>\n</ul>\n</li>\n<li><p>更改权限</p>\n<ul>\n<li>fs.chmod(path, mode, [callback(err)])</li>\n<li>fs.chmodSync(path, mode)</li>\n</ul>\n</li>\n<li><p>更改权限(文件描述符)  </p>\n<ul>\n<li>fs.fchmod(fd, mode, [callback(err)])</li>\n<li>fs.fchmodSync(fd, mode)</li>\n</ul>\n</li>\n<li><p>获取文件信息</p>\n<ul>\n<li>fs.stat(path, [callback(err, stats)]) </li>\n<li>fs.statSync(path)</li>\n</ul>\n</li>\n<li><p>获取文件信息(文件描述符） </p>\n<ul>\n<li>fs.fstat(fd, [callback(err, stats)])</li>\n<li>fs.fstatSync(fd)</li>\n</ul>\n</li>\n<li><p>创建硬链接 </p>\n<ul>\n<li>fs.link(srcpath, dstpath, [callback(err)]) </li>\n<li>fs.linkSync(srcpath, dstpath)</li>\n</ul>\n</li>\n<li><p>创建符号链接 </p>\n<ul>\n<li>fs.symlink(linkdata, path, [type],[callback(err)])</li>\n<li>fs.symlinkSync(linkdata, path,[type])</li>\n</ul>\n</li>\n<li><p>读取链接 </p>\n<ul>\n<li>fs.readlink(path, [callback(err, linkString)])</li>\n<li>fs.readlinkSync(path)</li>\n</ul>\n</li>\n<li><p>修改文件时间戳  </p>\n<ul>\n<li>fs.utimes(path, atime, mtime, [callback (err)])</li>\n<li>fs.utimesSync(path, atime, mtime)</li>\n</ul>\n</li>\n<li><p>修改文件时间戳（文件描述符）  </p>\n<ul>\n<li>fs.futimes(fd, atime, mtime, [callback(err)])</li>\n<li>fs.futimesSync(fd, atime, mtime)</li>\n</ul>\n</li>\n<li><p>同步磁盘缓存</p>\n<ul>\n<li>fs.fsync(fd, [callback(err)])</li>\n<li>fs.fsyncSync(fd)</li>\n</ul>\n</li>\n</ul>\n"},{"_content":"","source":"_posts/Object.creat.md","raw":"","slug":"Object.creat","published":1,"date":"2021-12-06T05:35:02.621Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwokz001hy4v2bt9c4xps","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"# React-Redux\n\n## 序\nRedux的作者友情赞助，封装了一个 React 专用的库 `React-Redux`，为 React + Redux 提供了一种更科学的代码组织方式。\n\n本人认为`React-Redux`的中心思想就是实现`Model`与`View`的分离。它将所有组件分成两大类：\n\n+ UI组件（View层）\n\n\t- 只负责 UI 的呈现，不带有任何业务逻辑\n\t- 没有状态（即不使用this.state这个变量）\n\t- 所有数据都由参数（this.props）提供\n\t- 不使用任何 Redux 的 API\n\n+ 容器组件（Model层）\n\n\t- 负责管理数据和业务逻辑，不负责 UI 的呈现\n\t- 带有内部状态\n\t- 使用 Redux 的 API\n\n这样以来也实现了Redux和React分离，UI组件只要书写react的代码，容器组件只负责书写redux相关操作，易于书写与维护。\n\nreact-redux主要提供了倆个关键API：Provider组件 和 connect函数。\n\n\n## connect()\nconnect函数的主要功能是连接 UI组件 与 容器组件。它会自动为您的UI组件生成一个容器组件，并且创立起它们之间的通信。\n\n```\nconst ContainerComponent = connect(\n\tmapStateToProps,\n\tmapDispatchToProps\n)(UIComponent);\n```\n\n上面代码中，UIComponent是 UI组件，containerComponent就是由 React-Redux 通过connect方法自动生成的容器组件。而 `mapStateToProps` 和 `mapDispatchToProps` 则建立起了倆种组件之间的通信机制。\n\n### mapStateToProps（可选参数）\n\n`mapStateToProps(state,[ownProps])`\n\n+ state: state数据\n+ ownProps: 可选参数，容器组件的props对象，使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。\n\n\n这个函数的主要功能是将`state`通过`props`属性传递给UI组件，它会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。\n\nmapStateToProps函数返回一个对象，这个对象中的每一个键值对都会映射到UI组件的`props`上。\n\n```\nconst mapStateToProps = (state) => {\n  return {\n    data: state\n  }\n}\n```\n\n上面的 mapStateToProps 函数将`state`传递给了UI组件的`props`属性，您可以在UI组件内通过this.props.data来访问`state`。这样就实现了容器组件向UI组件方向上的数据传递。\n\n### mapDispatchToProps（可选参数）\n\nmapDispatchToProps可以是一个函数，也可以是一个对象。\n\n作为函数，mapDispatchToProps 会得到 `dispatch` 和 `ownProps` 俩个参数，并且返回一个对象。\n\n```\nconst mapDispatchToProps = (\n  dispatch,\n  ownProps\n) => {\n  return {\n    click: () => {\n    \t//\t可以进行dispatch操作，发出action\n    }\n  };\n}\n```\n\n上面的`mapDispatchToProps`函数会返回一个对象，这个对象的键值依旧会传递给UI组件的`props`，在UI组件内部，您可以通过`this.props.click`来调用这个函数。\n\n\n## Provider 组件\n\nProvider 组件主要作为整个应用的容器，用来传递store给connct所生成的容器组件。\n\n```\n<Provider store={store}>\n    <ContainerComponent />\n</Provider>\n```\n\n上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。\n\n源码：\n\n```\nclass Provider extends Component {\n  getChildContext() {\n    return {\n      store: this.props.store\n    };\n  }\n  render() {\n    return this.props.children;\n  }\n}\n\nProvider.childContextTypes = {\n  store: React.PropTypes.object\n}\n```\n\n解释上面的代码之前先解释下 context 和 contextTypes，\n\n+ context：同state、props一样都是 React 的数据载体，但它可以实现组件间跨级传递数据\n+ contextTypes： 在组件上指定后指定该属性后，方可**访问**该组件context的属性\n+ getChildContext： 在需要向下传递数据的父组件中使用，用于指定传递的数据，\n+ childContextTypes： 在组件上指定后指定该属性后，方可**传递**该组件context的属性\n\n也就是说：指定数据并要将数据传递下去的父组件要定义 `childContextTypes` 和 getChildContext() ；想要接收到数据的子组件 必须定义 `contextTypes` 来使用传递过来的 context 。\n\n所以，上面代码的意思就是：`Provider`组件通过`getChildContext`方法指定向下传递的数据为store，并通过`childContextType`属性使该属性得以传递。`Provider`的子组件可以通过`this.context`取到数据。\n\n\n\n\n\n\n","source":"_posts/React-Redux.md","raw":"# React-Redux\n\n## 序\nRedux的作者友情赞助，封装了一个 React 专用的库 `React-Redux`，为 React + Redux 提供了一种更科学的代码组织方式。\n\n本人认为`React-Redux`的中心思想就是实现`Model`与`View`的分离。它将所有组件分成两大类：\n\n+ UI组件（View层）\n\n\t- 只负责 UI 的呈现，不带有任何业务逻辑\n\t- 没有状态（即不使用this.state这个变量）\n\t- 所有数据都由参数（this.props）提供\n\t- 不使用任何 Redux 的 API\n\n+ 容器组件（Model层）\n\n\t- 负责管理数据和业务逻辑，不负责 UI 的呈现\n\t- 带有内部状态\n\t- 使用 Redux 的 API\n\n这样以来也实现了Redux和React分离，UI组件只要书写react的代码，容器组件只负责书写redux相关操作，易于书写与维护。\n\nreact-redux主要提供了倆个关键API：Provider组件 和 connect函数。\n\n\n## connect()\nconnect函数的主要功能是连接 UI组件 与 容器组件。它会自动为您的UI组件生成一个容器组件，并且创立起它们之间的通信。\n\n```\nconst ContainerComponent = connect(\n\tmapStateToProps,\n\tmapDispatchToProps\n)(UIComponent);\n```\n\n上面代码中，UIComponent是 UI组件，containerComponent就是由 React-Redux 通过connect方法自动生成的容器组件。而 `mapStateToProps` 和 `mapDispatchToProps` 则建立起了倆种组件之间的通信机制。\n\n### mapStateToProps（可选参数）\n\n`mapStateToProps(state,[ownProps])`\n\n+ state: state数据\n+ ownProps: 可选参数，容器组件的props对象，使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。\n\n\n这个函数的主要功能是将`state`通过`props`属性传递给UI组件，它会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。\n\nmapStateToProps函数返回一个对象，这个对象中的每一个键值对都会映射到UI组件的`props`上。\n\n```\nconst mapStateToProps = (state) => {\n  return {\n    data: state\n  }\n}\n```\n\n上面的 mapStateToProps 函数将`state`传递给了UI组件的`props`属性，您可以在UI组件内通过this.props.data来访问`state`。这样就实现了容器组件向UI组件方向上的数据传递。\n\n### mapDispatchToProps（可选参数）\n\nmapDispatchToProps可以是一个函数，也可以是一个对象。\n\n作为函数，mapDispatchToProps 会得到 `dispatch` 和 `ownProps` 俩个参数，并且返回一个对象。\n\n```\nconst mapDispatchToProps = (\n  dispatch,\n  ownProps\n) => {\n  return {\n    click: () => {\n    \t//\t可以进行dispatch操作，发出action\n    }\n  };\n}\n```\n\n上面的`mapDispatchToProps`函数会返回一个对象，这个对象的键值依旧会传递给UI组件的`props`，在UI组件内部，您可以通过`this.props.click`来调用这个函数。\n\n\n## Provider 组件\n\nProvider 组件主要作为整个应用的容器，用来传递store给connct所生成的容器组件。\n\n```\n<Provider store={store}>\n    <ContainerComponent />\n</Provider>\n```\n\n上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。\n\n源码：\n\n```\nclass Provider extends Component {\n  getChildContext() {\n    return {\n      store: this.props.store\n    };\n  }\n  render() {\n    return this.props.children;\n  }\n}\n\nProvider.childContextTypes = {\n  store: React.PropTypes.object\n}\n```\n\n解释上面的代码之前先解释下 context 和 contextTypes，\n\n+ context：同state、props一样都是 React 的数据载体，但它可以实现组件间跨级传递数据\n+ contextTypes： 在组件上指定后指定该属性后，方可**访问**该组件context的属性\n+ getChildContext： 在需要向下传递数据的父组件中使用，用于指定传递的数据，\n+ childContextTypes： 在组件上指定后指定该属性后，方可**传递**该组件context的属性\n\n也就是说：指定数据并要将数据传递下去的父组件要定义 `childContextTypes` 和 getChildContext() ；想要接收到数据的子组件 必须定义 `contextTypes` 来使用传递过来的 context 。\n\n所以，上面代码的意思就是：`Provider`组件通过`getChildContext`方法指定向下传递的数据为store，并通过`childContextType`属性使该属性得以传递。`Provider`的子组件可以通过`this.context`取到数据。\n\n\n\n\n\n\n","slug":"React-Redux","published":1,"date":"2021-12-06T06:07:06.133Z","updated":"2021-12-06T06:07:06.133Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwol0001iy4v2e2thcoir","content":"<h1 id=\"React-Redux\"><a href=\"#React-Redux\" class=\"headerlink\" title=\"React-Redux\"></a>React-Redux</h1><h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>Redux的作者友情赞助，封装了一个 React 专用的库 <code>React-Redux</code>，为 React + Redux 提供了一种更科学的代码组织方式。</p>\n<p>本人认为<code>React-Redux</code>的中心思想就是实现<code>Model</code>与<code>View</code>的分离。它将所有组件分成两大类：</p>\n<ul>\n<li><p>UI组件（View层）</p>\n<ul>\n<li>只负责 UI 的呈现，不带有任何业务逻辑</li>\n<li>没有状态（即不使用this.state这个变量）</li>\n<li>所有数据都由参数（this.props）提供</li>\n<li>不使用任何 Redux 的 API</li>\n</ul>\n</li>\n<li><p>容器组件（Model层）</p>\n<ul>\n<li>负责管理数据和业务逻辑，不负责 UI 的呈现</li>\n<li>带有内部状态</li>\n<li>使用 Redux 的 API</li>\n</ul>\n</li>\n</ul>\n<p>这样以来也实现了Redux和React分离，UI组件只要书写react的代码，容器组件只负责书写redux相关操作，易于书写与维护。</p>\n<p>react-redux主要提供了倆个关键API：Provider组件 和 connect函数。</p>\n<h2 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect()\"></a>connect()</h2><p>connect函数的主要功能是连接 UI组件 与 容器组件。它会自动为您的UI组件生成一个容器组件，并且创立起它们之间的通信。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ContainerComponent = connect(</span><br><span class=\"line\">\tmapStateToProps,</span><br><span class=\"line\">\tmapDispatchToProps</span><br><span class=\"line\">)(UIComponent);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，UIComponent是 UI组件，containerComponent就是由 React-Redux 通过connect方法自动生成的容器组件。而 <code>mapStateToProps</code> 和 <code>mapDispatchToProps</code> 则建立起了倆种组件之间的通信机制。</p>\n<h3 id=\"mapStateToProps（可选参数）\"><a href=\"#mapStateToProps（可选参数）\" class=\"headerlink\" title=\"mapStateToProps（可选参数）\"></a>mapStateToProps（可选参数）</h3><p><code>mapStateToProps(state,[ownProps])</code></p>\n<ul>\n<li>state: state数据</li>\n<li>ownProps: 可选参数，容器组件的props对象，使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。</li>\n</ul>\n<p>这个函数的主要功能是将<code>state</code>通过<code>props</code>属性传递给UI组件，它会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>\n<p>mapStateToProps函数返回一个对象，这个对象中的每一个键值对都会映射到UI组件的<code>props</code>上。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const mapStateToProps = (state) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    data: state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的 mapStateToProps 函数将<code>state</code>传递给了UI组件的<code>props</code>属性，您可以在UI组件内通过this.props.data来访问<code>state</code>。这样就实现了容器组件向UI组件方向上的数据传递。</p>\n<h3 id=\"mapDispatchToProps（可选参数）\"><a href=\"#mapDispatchToProps（可选参数）\" class=\"headerlink\" title=\"mapDispatchToProps（可选参数）\"></a>mapDispatchToProps（可选参数）</h3><p>mapDispatchToProps可以是一个函数，也可以是一个对象。</p>\n<p>作为函数，mapDispatchToProps 会得到 <code>dispatch</code> 和 <code>ownProps</code> 俩个参数，并且返回一个对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const mapDispatchToProps = (</span><br><span class=\"line\">  dispatch,</span><br><span class=\"line\">  ownProps</span><br><span class=\"line\">) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    click: () =&gt; &#123;</span><br><span class=\"line\">    \t//\t可以进行dispatch操作，发出action</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>mapDispatchToProps</code>函数会返回一个对象，这个对象的键值依旧会传递给UI组件的<code>props</code>，在UI组件内部，您可以通过<code>this.props.click</code>来调用这个函数。</p>\n<h2 id=\"Provider-组件\"><a href=\"#Provider-组件\" class=\"headerlink\" title=\"Provider 组件\"></a>Provider 组件</h2><p>Provider 组件主要作为整个应用的容器，用来传递store给connct所生成的容器组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;ContainerComponent /&gt;</span><br><span class=\"line\">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。</p>\n<p>源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Provider extends Component &#123;</span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      store: this.props.store</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return this.props.children;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Provider.childContextTypes = &#123;</span><br><span class=\"line\">  store: React.PropTypes.object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解释上面的代码之前先解释下 context 和 contextTypes，</p>\n<ul>\n<li>context：同state、props一样都是 React 的数据载体，但它可以实现组件间跨级传递数据</li>\n<li>contextTypes： 在组件上指定后指定该属性后，方可<strong>访问</strong>该组件context的属性</li>\n<li>getChildContext： 在需要向下传递数据的父组件中使用，用于指定传递的数据，</li>\n<li>childContextTypes： 在组件上指定后指定该属性后，方可<strong>传递</strong>该组件context的属性</li>\n</ul>\n<p>也就是说：指定数据并要将数据传递下去的父组件要定义 <code>childContextTypes</code> 和 getChildContext() ；想要接收到数据的子组件 必须定义 <code>contextTypes</code> 来使用传递过来的 context 。</p>\n<p>所以，上面代码的意思就是：<code>Provider</code>组件通过<code>getChildContext</code>方法指定向下传递的数据为store，并通过<code>childContextType</code>属性使该属性得以传递。<code>Provider</code>的子组件可以通过<code>this.context</code>取到数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React-Redux\"><a href=\"#React-Redux\" class=\"headerlink\" title=\"React-Redux\"></a>React-Redux</h1><h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>Redux的作者友情赞助，封装了一个 React 专用的库 <code>React-Redux</code>，为 React + Redux 提供了一种更科学的代码组织方式。</p>\n<p>本人认为<code>React-Redux</code>的中心思想就是实现<code>Model</code>与<code>View</code>的分离。它将所有组件分成两大类：</p>\n<ul>\n<li><p>UI组件（View层）</p>\n<ul>\n<li>只负责 UI 的呈现，不带有任何业务逻辑</li>\n<li>没有状态（即不使用this.state这个变量）</li>\n<li>所有数据都由参数（this.props）提供</li>\n<li>不使用任何 Redux 的 API</li>\n</ul>\n</li>\n<li><p>容器组件（Model层）</p>\n<ul>\n<li>负责管理数据和业务逻辑，不负责 UI 的呈现</li>\n<li>带有内部状态</li>\n<li>使用 Redux 的 API</li>\n</ul>\n</li>\n</ul>\n<p>这样以来也实现了Redux和React分离，UI组件只要书写react的代码，容器组件只负责书写redux相关操作，易于书写与维护。</p>\n<p>react-redux主要提供了倆个关键API：Provider组件 和 connect函数。</p>\n<h2 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect()\"></a>connect()</h2><p>connect函数的主要功能是连接 UI组件 与 容器组件。它会自动为您的UI组件生成一个容器组件，并且创立起它们之间的通信。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ContainerComponent = connect(</span><br><span class=\"line\">\tmapStateToProps,</span><br><span class=\"line\">\tmapDispatchToProps</span><br><span class=\"line\">)(UIComponent);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，UIComponent是 UI组件，containerComponent就是由 React-Redux 通过connect方法自动生成的容器组件。而 <code>mapStateToProps</code> 和 <code>mapDispatchToProps</code> 则建立起了倆种组件之间的通信机制。</p>\n<h3 id=\"mapStateToProps（可选参数）\"><a href=\"#mapStateToProps（可选参数）\" class=\"headerlink\" title=\"mapStateToProps（可选参数）\"></a>mapStateToProps（可选参数）</h3><p><code>mapStateToProps(state,[ownProps])</code></p>\n<ul>\n<li>state: state数据</li>\n<li>ownProps: 可选参数，容器组件的props对象，使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。</li>\n</ul>\n<p>这个函数的主要功能是将<code>state</code>通过<code>props</code>属性传递给UI组件，它会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>\n<p>mapStateToProps函数返回一个对象，这个对象中的每一个键值对都会映射到UI组件的<code>props</code>上。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const mapStateToProps = (state) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    data: state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的 mapStateToProps 函数将<code>state</code>传递给了UI组件的<code>props</code>属性，您可以在UI组件内通过this.props.data来访问<code>state</code>。这样就实现了容器组件向UI组件方向上的数据传递。</p>\n<h3 id=\"mapDispatchToProps（可选参数）\"><a href=\"#mapDispatchToProps（可选参数）\" class=\"headerlink\" title=\"mapDispatchToProps（可选参数）\"></a>mapDispatchToProps（可选参数）</h3><p>mapDispatchToProps可以是一个函数，也可以是一个对象。</p>\n<p>作为函数，mapDispatchToProps 会得到 <code>dispatch</code> 和 <code>ownProps</code> 俩个参数，并且返回一个对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const mapDispatchToProps = (</span><br><span class=\"line\">  dispatch,</span><br><span class=\"line\">  ownProps</span><br><span class=\"line\">) =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    click: () =&gt; &#123;</span><br><span class=\"line\">    \t//\t可以进行dispatch操作，发出action</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>mapDispatchToProps</code>函数会返回一个对象，这个对象的键值依旧会传递给UI组件的<code>props</code>，在UI组件内部，您可以通过<code>this.props.click</code>来调用这个函数。</p>\n<h2 id=\"Provider-组件\"><a href=\"#Provider-组件\" class=\"headerlink\" title=\"Provider 组件\"></a>Provider 组件</h2><p>Provider 组件主要作为整个应用的容器，用来传递store给connct所生成的容器组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;ContainerComponent /&gt;</span><br><span class=\"line\">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。</p>\n<p>源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Provider extends Component &#123;</span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      store: this.props.store</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return this.props.children;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Provider.childContextTypes = &#123;</span><br><span class=\"line\">  store: React.PropTypes.object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解释上面的代码之前先解释下 context 和 contextTypes，</p>\n<ul>\n<li>context：同state、props一样都是 React 的数据载体，但它可以实现组件间跨级传递数据</li>\n<li>contextTypes： 在组件上指定后指定该属性后，方可<strong>访问</strong>该组件context的属性</li>\n<li>getChildContext： 在需要向下传递数据的父组件中使用，用于指定传递的数据，</li>\n<li>childContextTypes： 在组件上指定后指定该属性后，方可<strong>传递</strong>该组件context的属性</li>\n</ul>\n<p>也就是说：指定数据并要将数据传递下去的父组件要定义 <code>childContextTypes</code> 和 getChildContext() ；想要接收到数据的子组件 必须定义 <code>contextTypes</code> 来使用传递过来的 context 。</p>\n<p>所以，上面代码的意思就是：<code>Provider</code>组件通过<code>getChildContext</code>方法指定向下传递的数据为store，并通过<code>childContextType</code>属性使该属性得以传递。<code>Provider</code>的子组件可以通过<code>this.context</code>取到数据。</p>\n"},{"_content":"# React-Native性能优化点\n\n## shouldComponentUpdate\n\n确保组件在渲染之后不需要再更新的，即静态组件，尽量在其中增加shouldComponentUpdate方法,防止二次消耗所产生的性能消耗\n\n```\nshouldComponentUpdate() {\r    //完全静态的组件,无需更新\n    return false;\r}\n```\n\n\n## key\nkey是react的一个特殊的属性，它是给React自己用的。如果我们动态地创建 React 元素，而且 React 元素内包含数量或顺序不确定的子元素时，我们就需要提供 key 这个特殊的属性。（包括ListView 和 ScrollView）。\n\n我们知道，当组件的属性发生了变化，其 render 方法会被重新调用，组件会被重新渲染。但是在渲染之前，react都会进行diff，确保高效率的渲染，而这个唯一的key就很好的为每一个react组件确定了id。React会比较更新前后的元素 key 值，如果相同则更新，如果不同则销毁之前的，重新创建一个元素。\n\n## 渲染性能低效\n\n基于ScrollView和ListView两大容器，在渲染上，相当于web端的table布局，需要等整个大table渲染完成才显示页面，也就是说，当容器内有大量的子元素，其白屏时间会非常长。\n\n采用异步渲染的方式，减少首屏加载的数据，实现数据懒加载，使用requestAnimationFrame 或 setTimeout 定时将单个组件push进ScrollView容器。\n\n\n## setNativeProps\n\n使用该方法修改 View 、 Text 等 RN自带的组件 ，则不会触发组件的componentWillReceiveProps 、 shouldComponentUpdate 、 componentWillUpdate 等组件生命周期中的方法。\n\n建议频繁更新的操作，如tabs切换操作时,需要更新改tab的style，则可以使用该属性。\n\n\n代码片段：\n\n```\nme.refs.tabView.setNativeProps({\n    style : {\n        height : 0,\n        opacity : 0\n    }\n});\n```\n\n##  最小化DOM\n类似于html，React Native里虚拟dom结构越复杂，则越低效。\n\n\n## 不要使用阴影效果\nReact Native 里面的 shadow 相关的样式，是非常耗性能的css属性\n\n参考文章：\n[React Native 性能优化建议](http://www.tuicool.com/articles/biUNriA)\n","source":"_posts/React-Native性能优化点.md","raw":"# React-Native性能优化点\n\n## shouldComponentUpdate\n\n确保组件在渲染之后不需要再更新的，即静态组件，尽量在其中增加shouldComponentUpdate方法,防止二次消耗所产生的性能消耗\n\n```\nshouldComponentUpdate() {\r    //完全静态的组件,无需更新\n    return false;\r}\n```\n\n\n## key\nkey是react的一个特殊的属性，它是给React自己用的。如果我们动态地创建 React 元素，而且 React 元素内包含数量或顺序不确定的子元素时，我们就需要提供 key 这个特殊的属性。（包括ListView 和 ScrollView）。\n\n我们知道，当组件的属性发生了变化，其 render 方法会被重新调用，组件会被重新渲染。但是在渲染之前，react都会进行diff，确保高效率的渲染，而这个唯一的key就很好的为每一个react组件确定了id。React会比较更新前后的元素 key 值，如果相同则更新，如果不同则销毁之前的，重新创建一个元素。\n\n## 渲染性能低效\n\n基于ScrollView和ListView两大容器，在渲染上，相当于web端的table布局，需要等整个大table渲染完成才显示页面，也就是说，当容器内有大量的子元素，其白屏时间会非常长。\n\n采用异步渲染的方式，减少首屏加载的数据，实现数据懒加载，使用requestAnimationFrame 或 setTimeout 定时将单个组件push进ScrollView容器。\n\n\n## setNativeProps\n\n使用该方法修改 View 、 Text 等 RN自带的组件 ，则不会触发组件的componentWillReceiveProps 、 shouldComponentUpdate 、 componentWillUpdate 等组件生命周期中的方法。\n\n建议频繁更新的操作，如tabs切换操作时,需要更新改tab的style，则可以使用该属性。\n\n\n代码片段：\n\n```\nme.refs.tabView.setNativeProps({\n    style : {\n        height : 0,\n        opacity : 0\n    }\n});\n```\n\n##  最小化DOM\n类似于html，React Native里虚拟dom结构越复杂，则越低效。\n\n\n## 不要使用阴影效果\nReact Native 里面的 shadow 相关的样式，是非常耗性能的css属性\n\n参考文章：\n[React Native 性能优化建议](http://www.tuicool.com/articles/biUNriA)\n","slug":"React-Native性能优化点","published":1,"date":"2021-12-06T06:07:06.133Z","updated":"2021-12-06T06:07:06.133Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwol0001jy4v2fstx4nd6","content":"<h1 id=\"React-Native性能优化点\"><a href=\"#React-Native性能优化点\" class=\"headerlink\" title=\"React-Native性能优化点\"></a>React-Native性能优化点</h1><h2 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h2><p>确保组件在渲染之后不需要再更新的，即静态组件，尽量在其中增加shouldComponentUpdate方法,防止二次消耗所产生的性能消耗</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate() &#123;\r    //完全静态的组件,无需更新</span><br><span class=\"line\">    return false;\r&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h2><p>key是react的一个特殊的属性，它是给React自己用的。如果我们动态地创建 React 元素，而且 React 元素内包含数量或顺序不确定的子元素时，我们就需要提供 key 这个特殊的属性。（包括ListView 和 ScrollView）。</p>\n<p>我们知道，当组件的属性发生了变化，其 render 方法会被重新调用，组件会被重新渲染。但是在渲染之前，react都会进行diff，确保高效率的渲染，而这个唯一的key就很好的为每一个react组件确定了id。React会比较更新前后的元素 key 值，如果相同则更新，如果不同则销毁之前的，重新创建一个元素。</p>\n<h2 id=\"渲染性能低效\"><a href=\"#渲染性能低效\" class=\"headerlink\" title=\"渲染性能低效\"></a>渲染性能低效</h2><p>基于ScrollView和ListView两大容器，在渲染上，相当于web端的table布局，需要等整个大table渲染完成才显示页面，也就是说，当容器内有大量的子元素，其白屏时间会非常长。</p>\n<p>采用异步渲染的方式，减少首屏加载的数据，实现数据懒加载，使用requestAnimationFrame 或 setTimeout 定时将单个组件push进ScrollView容器。</p>\n<h2 id=\"setNativeProps\"><a href=\"#setNativeProps\" class=\"headerlink\" title=\"setNativeProps\"></a>setNativeProps</h2><p>使用该方法修改 View 、 Text 等 RN自带的组件 ，则不会触发组件的componentWillReceiveProps 、 shouldComponentUpdate 、 componentWillUpdate 等组件生命周期中的方法。</p>\n<p>建议频繁更新的操作，如tabs切换操作时,需要更新改tab的style，则可以使用该属性。</p>\n<p>代码片段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">me.refs.tabView.setNativeProps(&#123;</span><br><span class=\"line\">    style : &#123;</span><br><span class=\"line\">        height : 0,</span><br><span class=\"line\">        opacity : 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最小化DOM\"><a href=\"#最小化DOM\" class=\"headerlink\" title=\"最小化DOM\"></a>最小化DOM</h2><p>类似于html，React Native里虚拟dom结构越复杂，则越低效。</p>\n<h2 id=\"不要使用阴影效果\"><a href=\"#不要使用阴影效果\" class=\"headerlink\" title=\"不要使用阴影效果\"></a>不要使用阴影效果</h2><p>React Native 里面的 shadow 相关的样式，是非常耗性能的css属性</p>\n<p>参考文章：<br><a href=\"http://www.tuicool.com/articles/biUNriA\">React Native 性能优化建议</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React-Native性能优化点\"><a href=\"#React-Native性能优化点\" class=\"headerlink\" title=\"React-Native性能优化点\"></a>React-Native性能优化点</h1><h2 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h2><p>确保组件在渲染之后不需要再更新的，即静态组件，尽量在其中增加shouldComponentUpdate方法,防止二次消耗所产生的性能消耗</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate() &#123;\r    //完全静态的组件,无需更新</span><br><span class=\"line\">    return false;\r&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h2><p>key是react的一个特殊的属性，它是给React自己用的。如果我们动态地创建 React 元素，而且 React 元素内包含数量或顺序不确定的子元素时，我们就需要提供 key 这个特殊的属性。（包括ListView 和 ScrollView）。</p>\n<p>我们知道，当组件的属性发生了变化，其 render 方法会被重新调用，组件会被重新渲染。但是在渲染之前，react都会进行diff，确保高效率的渲染，而这个唯一的key就很好的为每一个react组件确定了id。React会比较更新前后的元素 key 值，如果相同则更新，如果不同则销毁之前的，重新创建一个元素。</p>\n<h2 id=\"渲染性能低效\"><a href=\"#渲染性能低效\" class=\"headerlink\" title=\"渲染性能低效\"></a>渲染性能低效</h2><p>基于ScrollView和ListView两大容器，在渲染上，相当于web端的table布局，需要等整个大table渲染完成才显示页面，也就是说，当容器内有大量的子元素，其白屏时间会非常长。</p>\n<p>采用异步渲染的方式，减少首屏加载的数据，实现数据懒加载，使用requestAnimationFrame 或 setTimeout 定时将单个组件push进ScrollView容器。</p>\n<h2 id=\"setNativeProps\"><a href=\"#setNativeProps\" class=\"headerlink\" title=\"setNativeProps\"></a>setNativeProps</h2><p>使用该方法修改 View 、 Text 等 RN自带的组件 ，则不会触发组件的componentWillReceiveProps 、 shouldComponentUpdate 、 componentWillUpdate 等组件生命周期中的方法。</p>\n<p>建议频繁更新的操作，如tabs切换操作时,需要更新改tab的style，则可以使用该属性。</p>\n<p>代码片段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">me.refs.tabView.setNativeProps(&#123;</span><br><span class=\"line\">    style : &#123;</span><br><span class=\"line\">        height : 0,</span><br><span class=\"line\">        opacity : 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最小化DOM\"><a href=\"#最小化DOM\" class=\"headerlink\" title=\"最小化DOM\"></a>最小化DOM</h2><p>类似于html，React Native里虚拟dom结构越复杂，则越低效。</p>\n<h2 id=\"不要使用阴影效果\"><a href=\"#不要使用阴影效果\" class=\"headerlink\" title=\"不要使用阴影效果\"></a>不要使用阴影效果</h2><p>React Native 里面的 shadow 相关的样式，是非常耗性能的css属性</p>\n<p>参考文章：<br><a href=\"http://www.tuicool.com/articles/biUNriA\">React Native 性能优化建议</a></p>\n"},{"_content":"## class\n\n```js\nclass Welcome {\n    render() {\n        return 1;\n    }\n}\n```\n\n原理：\n\n1. 声明一个构造函数\n1. this 上的属性通过构造函数的 this 挂载\n1. 其他属性通过 Object.defineProperty 挂载到`构造函数/构造函数的原型`上\n\n```js\n\"use strict\";\n\nvar _createClass = (function() {\n    function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true; // 可配置\n            if (\"value\" in descriptor) descriptor.writable = true; // 存在value属性则可编辑\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    return function(Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n    };\n})();\n\nvar Welcome = (function() {\n    function Welcome() {\n        this.a = 1;\n    }\n\n    _createClass(Welcome, [\n        {\n            key: \"render\",\n            value: function render() {\n                return 1;\n            }\n        }\n    ]);\n\n    return Welcome;\n})();\n```\n\n## extends\n\n主要利用了 Object.create。\n\n```js\nclass C extends Welcome {}\n```\n\n```js\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\n            \"Super expression must either be null or a function, not \" +\n                typeof superClass\n        );\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass)\n        Object.setPrototypeOf\n            ? Object.setPrototypeOf(subClass, superClass)\n            : (subClass.__proto__ = superClass);\n}\n\n```\n","source":"_posts/class&extends.md","raw":"## class\n\n```js\nclass Welcome {\n    render() {\n        return 1;\n    }\n}\n```\n\n原理：\n\n1. 声明一个构造函数\n1. this 上的属性通过构造函数的 this 挂载\n1. 其他属性通过 Object.defineProperty 挂载到`构造函数/构造函数的原型`上\n\n```js\n\"use strict\";\n\nvar _createClass = (function() {\n    function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true; // 可配置\n            if (\"value\" in descriptor) descriptor.writable = true; // 存在value属性则可编辑\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    return function(Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n    };\n})();\n\nvar Welcome = (function() {\n    function Welcome() {\n        this.a = 1;\n    }\n\n    _createClass(Welcome, [\n        {\n            key: \"render\",\n            value: function render() {\n                return 1;\n            }\n        }\n    ]);\n\n    return Welcome;\n})();\n```\n\n## extends\n\n主要利用了 Object.create。\n\n```js\nclass C extends Welcome {}\n```\n\n```js\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\n            \"Super expression must either be null or a function, not \" +\n                typeof superClass\n        );\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass)\n        Object.setPrototypeOf\n            ? Object.setPrototypeOf(subClass, superClass)\n            : (subClass.__proto__ = superClass);\n}\n\n```\n","slug":"class&extends","published":1,"date":"2021-12-06T05:35:02.621Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwol1001ky4v27mztdazb","content":"<h2 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原理：</p>\n<ol>\n<li>声明一个构造函数</li>\n<li>this 上的属性通过构造函数的 this 挂载</li>\n<li>其他属性通过 Object.defineProperty 挂载到<code>构造函数/构造函数的原型</code>上</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _createClass = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineProperties</span>(<span class=\"params\">target, props</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; props.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> descriptor = props[i];</span><br><span class=\"line\">            descriptor.enumerable = descriptor.enumerable || <span class=\"literal\">false</span>;</span><br><span class=\"line\">            descriptor.configurable = <span class=\"literal\">true</span>; <span class=\"comment\">// 可配置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;value&quot;</span> <span class=\"keyword\">in</span> descriptor) descriptor.writable = <span class=\"literal\">true</span>; <span class=\"comment\">// 存在value属性则可编辑</span></span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (staticProps) defineProperties(Constructor, staticProps);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Constructor;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Welcome = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _createClass(Welcome, [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">key</span>: <span class=\"string\">&quot;render&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">value</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Welcome;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h2><p>主要利用了 Object.create。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">Welcome</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_inherits</span>(<span class=\"params\">subClass, superClass</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> superClass !== <span class=\"string\">&quot;function&quot;</span> &amp;&amp; superClass !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;Super expression must either be null or a function, not &quot;</span> +</span><br><span class=\"line\">                <span class=\"keyword\">typeof</span> superClass</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    subClass.prototype = <span class=\"built_in\">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class=\"line\">        <span class=\"attr\">constructor</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">value</span>: subClass,</span><br><span class=\"line\">            <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (superClass)</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.setPrototypeOf</span><br><span class=\"line\">            ? <span class=\"built_in\">Object</span>.setPrototypeOf(subClass, superClass)</span><br><span class=\"line\">            : (subClass.__proto__ = superClass);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原理：</p>\n<ol>\n<li>声明一个构造函数</li>\n<li>this 上的属性通过构造函数的 this 挂载</li>\n<li>其他属性通过 Object.defineProperty 挂载到<code>构造函数/构造函数的原型</code>上</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _createClass = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineProperties</span>(<span class=\"params\">target, props</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; props.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> descriptor = props[i];</span><br><span class=\"line\">            descriptor.enumerable = descriptor.enumerable || <span class=\"literal\">false</span>;</span><br><span class=\"line\">            descriptor.configurable = <span class=\"literal\">true</span>; <span class=\"comment\">// 可配置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;value&quot;</span> <span class=\"keyword\">in</span> descriptor) descriptor.writable = <span class=\"literal\">true</span>; <span class=\"comment\">// 存在value属性则可编辑</span></span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (staticProps) defineProperties(Constructor, staticProps);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Constructor;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Welcome = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _createClass(Welcome, [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">key</span>: <span class=\"string\">&quot;render&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">value</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Welcome;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h2><p>主要利用了 Object.create。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">Welcome</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_inherits</span>(<span class=\"params\">subClass, superClass</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> superClass !== <span class=\"string\">&quot;function&quot;</span> &amp;&amp; superClass !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;Super expression must either be null or a function, not &quot;</span> +</span><br><span class=\"line\">                <span class=\"keyword\">typeof</span> superClass</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    subClass.prototype = <span class=\"built_in\">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class=\"line\">        <span class=\"attr\">constructor</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">value</span>: subClass,</span><br><span class=\"line\">            <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (superClass)</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.setPrototypeOf</span><br><span class=\"line\">            ? <span class=\"built_in\">Object</span>.setPrototypeOf(subClass, superClass)</span><br><span class=\"line\">            : (subClass.__proto__ = superClass);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"canvas初探(内含时钟)","date":"2015-12-04T05:06:50.000Z","description":"html5,Canvas,时钟范例","_content":"\n## 一、了解Canvas\n\n`<canvas> `是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。\n\n大多数 Canvas 绘图 API 都没有定义在\t`<canvas> `元素本身上，而是定义在通过画布的 getContext() 方法获得的一个“绘图环境”对象上。\n\nCanvas API 也使用了路径的表示法。但是，路径由一系列的方法调用来定义，而不是描述为字母和数字的字符串，比如调用 beginPath() 和 arc() 方法。\n一旦定义了路径，其他的方法，如 fill()，都是对此路径操作。绘图环境的各种属性，比如 fillStyle，说明了这些操作如何使用。\n\n<!-- more -->\n\n### 属性和方法详情可以翻阅[参考手册](http://www.w3school.com.cn/tags/html_ref_canvas.asp)\n\n## 二、基本图形的绘制\n\n### 1. 矩形\n<canvas id=\"my_canvas1\" height=\"80\"></canvas>\n<script>\n\tvar a = document.getElementById('my_canvas1');\n\tvar txt = a.getContext('2d');\n\ttxt.fillStyle=\"red\"; \n\ttxt.fillRect(0,0,150,75) \n</script>\n\n\n代码解析\n\n\t<canvas id=\"my_canvas1\" height=\"80\"></canvas>\n\t<script>\n\t\tvar a = document.getElementById('my_canvas1');\n\t\t//创建getContext对象,它是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法\n\t\tvar axt = a.getContext('2d');\n\t\t//fillStyle属性设置或返回用于填充绘画的颜色、渐变或模式\n\t\ttxt.fillStyle=\"red\"; \n\t\t//fillRect(x,y,w,h)绘制“被填充”的矩形。参数分别为(起始位置横坐标，纵坐标,宽度,高度)\n\t\ttxt.fillRect(0,0,150,75) \n\t</script>\n\n\n### 2.路径\n\n<canvas id=\"my_canvas2\" height=\"60\"></canvas>\n<script>\n\tvar b = document.getElementById('my_canvas2');\n\tvar bxt = b.getContext('2d');\n\tbxt.beginPath()\n\tbxt.moveTo(10,10); \n\tbxt.lineTo(150,50); \n\tbxt.lineTo(10,50);\n\tbxt.closePath();\n\tbxt.stroke();\n</script>\n\n代码解析\n\n\t<canvas id=\"my_canvas2\" height=\"60\"></canvas>\n\t<script>\n\tvar b = document.getElementById('my_canvas2');\n\tvar bxt = b.getContext('2d');\n\t//起始一条路径，或重置当前路径\n\tbxt.beginPath()\n\t//把路径移动到画布中的指定点，不创建线条\n\tbxt.moveTo(10,10);\n\t//添加一个新点，然后在画布中创建从该点到最后指定点的线条 \n\tbxt.lineTo(150,50); \n\tbxt.lineTo(10,50);\n\t//创建从当前点回到起始点的路径\n\tbxt.closePath();\n\t//绘制已定义的路径\n\tbxt.stroke();\n</script>\n\n### 3.圆\n\n<canvas id=\"my_canvas3\" height=\"40\"></canvas>\n<script>\n\tvar e = document.getElementById('my_canvas3');\n\tvar cxt = e.getContext('2d');\n\tcxt.beginPath();\n\tcxt.arc(70,18,15,0,Math.PI*2,true);\n\tcxt.closePath();\n\tcxt.stroke();\n</script>\n\n代码解析\n\n\t<canvas id=\"my_canvas3\" height=\"40\"></canvas>\n\t<script>\n\t\tvar e = document.getElementById('my_canvas3');\n\t\tvar cxt = e.getContext('2d');\n\t\tcxt.beginPath();\n\t\t<!--\n\t\tarc(x,y,r,sAngle,eAngle,counterclockwise)\t创建弧/曲线（用于创建圆形或部分圆）\n\t\tx\t圆心的 x 坐标。\n\t\ty\t圆心的 y 坐标。\n\t\tr\t圆半径。\n\t\tsAngle\t起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。\n\t\teAngle\t结束角，以弧度计。\n\t\tcounterclockwise\t可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。\n\t\tMath.PI*2:圆周率\n\t\t -->\n\t\tcxt.arc(70,18,15,0,Math.PI*2,true);\n\t\tcxt.closePath();\n\t\tcxt.stroke();\n\t</script>\n\n### 4.文本\n\n<canvas id=\"my_canvas4\" height=\"20\"></canvas>\n<script>\n\tvar f = document.getElementById('my_canvas4');\n\tvar axt = f.getContext('2d');\n\taxt.font=\"30px Arial\";\n\taxt.strokeText(\"hello world\",150,20)\n</script>\n\n代码解析\n\n\t<canvas id=\"my_canvas4\" height=\"20\"></canvas>\n\t<script>\n\t\tvar f = document.getElementById('my_canvas4');\n\t\tvar axt = f.getContext('2d');\n\t\t//设置或返回文本内容的当前字体属性\n\t\taxt.font=\"30px Arial\";\n\t\t//在画布上绘制文本（无填充）\n\t\taxt.strokeText(\"hello world\",150,20)\n\t</script>\n<b style=\"color:red\">注意：font属性设置语句必须置于绘制文本方法(strokeText)之前</b>\n\n### 5.渐变\n\n+ 线性渐变\n\n<canvas id=\"my_canvas5\" height=\"20\"></canvas>\n<script>\n\tvar g = document.getElementById('my_canvas5');\n\tvar gxt = g.getContext('2d');\n\tvar grd=gxt.createLinearGradient(0,0,200,0);\n\tgrd.addColorStop(0,\"red\");\n\tgrd.addColorStop(1,\"white\");\n\tgxt.fillStyle=grd;\n\tgxt.fillRect(10,10,150,20);\n</script>\n\n代码解析\n\n\t<canvas id=\"my_canvas5\" height=\"20\"></canvas>\n\t<script>\n\t\tvar g = document.getElementById('my_canvas5');\n\t\tvar gxt = g.getContext('2d');\n\t\t//createLinearGradient(x,y,x1,y1) - 创建线性渐变,坐标是起点和终点\n\t\tvar grd=gxt.createLinearGradient(0,0,200,0);\n\t\t//addColorStop()方法规定渐变对象中的颜色和停止位置，可以是0至1.\n\t\tgrd.addColorStop(0,\"red\");\n\t\tgrd.addColorStop(1,\"white\");\n\t\tgxt.fillStyle=grd;\n\t\tgxt.fillRect(10,10,150,20);\n\t</script>\n\n---\n\n+ 径向渐变\n\n<canvas id=\"my_canvas6\" height=\"50\"></canvas>\n<script>\n\tvar h = document.getElementById('my_canvas6');\n\tvar hxt = h.getContext('2d');\n\tvar hrd=gxt.createRadialGradient(25,25,5,25,25,25);\n\thrd.addColorStop(0,\"red\")\n\thrd.addColorStop(1,\"white\");\n\thxt.fillStyle=hrd;\n\thxt.arc(25,25,25,0,Math.PI*2,true);\n\thxt.fill()\n</script>\n\n\n代码解析\n\n\t<canvas id=\"my_canvas6\" height=\"50\"></canvas>\n\t<script>\n\t\tvar h = document.getElementById('my_canvas6');\n\t\tvar hxt = h.getContext('2d');\n\t\t<!-- \n\t\tcreateRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变- \n\t\tx\t渐变开始点的 x 坐标\n\t\ty\t渐变开始点的 y 坐标\n\t\tx1\t渐变结束点的 x 坐标\n\t\ty1\t渐变结束点的 y 坐标 \n\t\tr   渐变开始点的渐变半径\n\t\tr1  渐变结束点的渐变半径\n\t\t-->\n\t\tvar hrd=gxt.createRadialGradient(25,25,5,25,25,25);\n\t\thrd.addColorStop(0,\"red\")\n\t\thrd.addColorStop(1,\"white\");\n\t\thxt.fillStyle=hrd;\n\t\thxt.arc(25,25,25,0,Math.PI*2,true);\n\t\thxt.fill()\n\t</script>\n\n\n### 6.图像\n<canvas id=\"my_canvas7\" ></canvas>\n<script>\n\tvar j=document.getElementById(\"my_canvas7\");\n\tvar jxt=j.getContext(\"2d\");\n\tvar img1=new Image()\n\timg1.src=\"http://bigdots.github.io/img/thumb.jpg\";\n\timg1.onload = function(){\n\t\t/*\n\t\tdrawImage(img,sx,sy,swidth,sheight,x,y,width,height)向画布上绘制图像、画布或视频\n\t\timg\t规定要使用的图像、画布或视频。\n\t\tsx\t可选。开始剪切的 x 坐标位置。\n\t\tsy\t可选。开始剪切的 y 坐标位置。\n\t\tswidth\t可选。被剪切图像的宽度。\n\t\tsheight\t可选。被剪切图像的高度。\n\t\tx\t在画布上放置图像的 x 坐标位置。\n\t\ty\t在画布上放置图像的 y 坐标位置。\n\t\twidth\t可选。要使用的图像的宽度。（伸展或缩小图像）\n\t\theight\t可选。要使用的图像的高度。（伸展或缩小图像）\n\t\t*/\n\t\tjxt.drawImage(img1,0,0);\n\t}\n</script>\n\n\n\n代码解析\n\n\t<canvas id=\"my_canvas7\" ></canvas>\n\t<script>\n\t\tvar j=document.getElementById(\"my_canvas7\");\n\t\tvar jxt=j.getContext(\"2d\");\n\t\tvar img1=new Image()\n\t\timg1.src=\"http://bigdots.github.io/img/thumb.jpg\";\n\t\timg1.onload = function(){\n\t\t\t/*\n\t\t\tdrawImage(img,sx,sy,swidth,sheight,x,y,width,height)向画布上绘制图像、画布或视频\n\t\t\timg\t规定要使用的图像、画布或视频。\n\t\t\tsx\t可选。开始剪切的 x 坐标位置。\n\t\t\tsy\t可选。开始剪切的 y 坐标位置。\n\t\t\tswidth\t可选。被剪切图像的宽度。\n\t\t\tsheight\t可选。被剪切图像的高度。\n\t\t\tx\t在画布上放置图像的 x 坐标位置。\n\t\t\ty\t在画布上放置图像的 y 坐标位置。\n\t\t\twidth\t可选。要使用的图像的宽度。（伸展或缩小图像）\n\t\t\theight\t可选。要使用的图像的高度。（伸展或缩小图像）\n\t\t\t*/\n\t\t\tjxt.drawImage(img1,0,0);\n\t\t}\n\t</script>\n\n<b style=\"color:red\">因为我这里是通过js设置src加载图片，可能会存在图片没有加载成功，就执行了drawImage，导致画布上没有图片，所以，我用了onload</b>\n\n\n## 三、时钟范例\n\n<canvas id=\"time\" width=\"520\" height=\"520\"></canvas>\n<script>\n\tvar mycanvas = document.getElementById('time');\n\tvar time = mycanvas.getContext('2d');\n\n\tfunction clock(){\n\t\ttime.clearRect(0, 0, 800, 800);\n\n\t\t//获取时间\n\t\tvar now = new Date();\n\t\tvar secd = now.getSeconds();\n\t\tvar min = now.getMinutes();\n\t\tvar hour = now.getHours();\n\n\t\t//转为12时制\n\t\thour = hour > 12 ? hour-12 : hour;\n\n\t\t//先画个大圆\n\t\ttime.beginPath();\n\t\ttime.lineWidth = 10;\n\t\ttime.strokeStyle = \"#000\";\n\t\ttime.arc(250, 250, 200, 0, 360, false);\n\t\ttime.closePath();\n\t\ttime.stroke();\n\n\t\t//画出刻度\n\t\tfor(var i=0;i<12;i++){\n\t\t\t//保存当前环境的状态\n\t\t\ttime.save();\n\t\t\t//设置粗细和颜色\n\t\t\ttime.lineWidth = 6;\n\t\t\ttime.strokeStyle = '#000';\n\n\t\t\t//translate(x,y) 方法重新映射画布上的 (0,0) 位置。\n\t\t\t//x\t添加到水平坐标（x）上的值\n\t\t\t// y\t添加到垂直坐标（y）上的值\n\t\t\ttime.translate(250, 250);\n\t\t\t//rotate() 方法旋转当前的绘图，以弧度计。\n\t\t\t\n\t\t\t time.font = \"20px Verdana\";//必须前置\n\t\t\t time.fillText('12',-12,-150);\n\t\t\t time.fillText('3',150,6);\n\t\t\t time.fillText('6',-6,160);\n\t\t\t time.fillText('9',-150,6);\n\n\t\t\ttime.rotate((i * 30) * Math.PI / 180);//角度*Math.PI/180=弧度\n\t\t\ttime.beginPath();\n\t\t\ttime.moveTo(0, -170);\n\t\t\ttime.lineTo(0, -190);\n\t\t\ttime.closePath();\n\n\t\t\ttime.stroke();\n\t\t\t\n\t\t\ttime.restore();\n\t\t}\n\n\n\t\t/*\n\t\t1.save() 方法保存当前图像状态的一份拷贝。\n\t\t2.设置刻度的粗细和颜色\n\t\t3.利用translate把新的参照坐标设为(250,250)，即下面的坐标就是以(250,250)【圆心】为参照了；所以下面的(0,-170)其实就是(250,70)\n\t\t4.旋转30度【360/12=每个小时的度数】\n\t\t5.画线，(0, -170)至(0, -190)的线条，其实就是12点的那个刻度，然后通过旋转和循环来画出所有刻度\n\t\t6.restore() 方法将绘图状态置为保存值。\n\t\t */\n\n\t\t//时针\n\t\t\ttime.save();\n\t\t\ttime.lineWidth = 7;\n\t\t\ttime.strokeStyle = \"black\";\n\t\t\ttime.translate(250, 250);\n\t\t\t//【360/12】设定指针指向位置\n\t\t\ttime.rotate(hour * 30 * Math.PI / 180);\n\t\t\ttime.beginPath();\n\t\t\ttime.moveTo(0, -140);\n\t\t\ttime.lineTo(0, 10);\n\t\t\ttime.stroke();\n\t\t\ttime.closePath();\n\t\t\ttime.restore();\n\t\t//分针\n\t\t\ttime.save();\n\t\t\ttime.lineWidth = 5;\n\t\t\ttime.strokeStyle = \"black\";\n\t\t\ttime.translate(250, 250);\n\t\t\t//【360/60】\n\t\t\ttime.rotate(min * 6 * Math.PI / 180);\n\t\t\ttime.beginPath();\n\t\t\ttime.moveTo(0, -160);\n\t\t\ttime.lineTo(0, 10);\n\t\t\ttime.stroke();\n\t\t\ttime.closePath();\n\t\t\ttime.restore();\n\t\t//秒针\n\t\t\ttime.save();\n\t\t\ttime.lineWidth = 3;\n\t\t\ttime.strokeStyle = \"red\";\n\t\t\ttime.translate(250, 250);\n\t\t\t//【360/60】\n\t\t\ttime.rotate(secd * 6 * Math.PI / 180);\n\t\t\ttime.beginPath();\n\t\t\ttime.moveTo(0, -170);\n\t\t\ttime.lineTo(0, 10);\n\t\t\ttime.closePath();\n\t\t\ttime.stroke();\n\t\t//画交叉点\n\t\t\ttime.beginPath();\n\t\t\ttime.arc(0, 0, 5, 0, 360, false);\n\t\t\ttime.closePath();\n\t\t\ttime.fillStyle = \"gray\";\n\t\t\ttime.fill();\n\t\t\ttime.stroke();\n\t\t\ttime.beginPath();\n\t\t\ttime.arc(0, -150, 5, 0, 360, false);\n\t\t\ttime.closePath();\n\t\t\ttime.fillStyle = \"gray\";\n\t\t\ttime.fill();\n\t\t\ttime.stroke();\n\t\t\ttime.restore();\n\t\t\n\n\t}\n\n\tclock();\n\tsetInterval(clock,1000)\n</script>\n\n基础也看完了，是时候动手了。上面是一个canvas写的时钟。just do it!\n\n\n\t<canvas id=\"time\" width=\"520\" height=\"520\"></canvas>\n\t<script>\n\t\tvar mycanvas = document.getElementById('time');\n\t\tvar time = mycanvas.getContext('2d');\n\n\t\tfunction clock(){\n\t\t\ttime.clearRect(0, 0, 800, 800);\n\t\t\t//获取时间\n\t\t\tvar now = new Date();\n\t\t\tvar secd = now.getSeconds();\n\t\t\tvar min = now.getMinutes();\n\t\t\tvar hour = now.getHours();\n\t\t\t//转为12时制\n\t\t\thour = hour > 12 ? hour-12 : hour;\n\t\t\t//先画个大圆\n\t\t\ttime.beginPath();\n\t\t\ttime.lineWidth = 10;\n\t\t\ttime.strokeStyle = \"#000\";\n\t\t\ttime.arc(250, 250, 200, 0, 360, false);\n\t\t\ttime.closePath();\n\t\t\ttime.stroke();\n\t\t\t//画出刻度\n\t\t\tfor(var i=0;i<12;i++){\n\t\t\t\t//保存当前环境的状态\n\t\t\t\ttime.save();\n\t\t\t\t//设置粗细和颜色\n\t\t\t\ttime.lineWidth = 6;\n\t\t\t\ttime.strokeStyle = '#000';\n\t\t\t\t//translate(x,y) 方法重新映射画布上的 (0,0) 位置。\n\t\t\t\t//x\t添加到水平坐标（x）上的值\n\t\t\t\t// y\t添加到垂直坐标（y）上的值\n\t\t\t\ttime.translate(250, 250);\n\t\t\t\t//rotate() 方法旋转当前的绘图，以弧度计。\n\t\t\t\t time.font = \"20px Verdana\";//必须前置\n\t\t\t\t time.fillText('12',-12,-150);\n\t\t\t\t time.fillText('3',150,6);\n\t\t\t\t time.fillText('6',-6,160);\n\t\t\t\t time.fillText('9',-150,6);\n\t\t\t\ttime.rotate((i * 30) * Math.PI / 180);//角度*Math.PI/180=弧度\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.moveTo(0, -170);\n\t\t\t\ttime.lineTo(0, -190);\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.stroke();\n\t\t\t\ttime.restore();\n\t\t\t}\n\t\t\t/*\n\t\t\t1.save() 方法保存当前图像状态的一份拷贝。\n\t\t\t2.设置刻度的粗细和颜色\n\t\t\t3.利用translate把新的参照坐标设为(250,250)，即下面的坐标就是以(250,250)【圆心】为参照了；所以下面的(0,-170)其实就是(250,70)\n\t\t\t4.旋转30度【360/12=每个小时的度数】\n\t\t\t5.画线，(0, -170)至(0, -190)的线条，其实就是12点的那个刻度，然后通过旋转和循环来画出所有刻度\n\t\t\t6.restore() 方法将绘图状态置为保存值。\n\t\t\t */\n\t\t\t//时针\n\t\t\t\ttime.save();\n\t\t\t\ttime.lineWidth = 7;\n\t\t\t\ttime.strokeStyle = \"black\";\n\t\t\t\ttime.translate(250, 250);\n\t\t\t\t//【360/12】设定指针指向位置\n\t\t\t\ttime.rotate(hour * 30 * Math.PI / 180);\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.moveTo(0, -140);\n\t\t\t\ttime.lineTo(0, 10);\n\t\t\t\ttime.stroke();\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.restore();\n\t\t\t//分针\n\t\t\t\ttime.save();\n\t\t\t\ttime.lineWidth = 5;\n\t\t\t\ttime.strokeStyle = \"black\";\n\t\t\t\ttime.translate(250, 250);\n\t\t\t\t//【360/60】\n\t\t\t\ttime.rotate(min * 6 * Math.PI / 180);\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.moveTo(0, -160);\n\t\t\t\ttime.lineTo(0, 10);\n\t\t\t\ttime.stroke();\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.restore();\n\t\t\t//秒针\n\t\t\t\ttime.save();\n\t\t\t\ttime.lineWidth = 3;\n\t\t\t\ttime.strokeStyle = \"red\";\n\t\t\t\ttime.translate(250, 250);\n\t\t\t\t//【360/60】\n\t\t\t\ttime.rotate(secd * 6 * Math.PI / 180);\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.moveTo(0, -170);\n\t\t\t\ttime.lineTo(0, 10);\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.stroke();\n\t\t\t//画交叉点\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.arc(0, 0, 5, 0, 360, false);\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.fillStyle = \"gray\";\n\t\t\t\ttime.fill();\n\t\t\t\ttime.stroke();\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.arc(0, -150, 5, 0, 360, false);\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.fillStyle = \"gray\";\n\t\t\t\ttime.fill();\n\t\t\t\ttime.stroke();\n\t\t\t\ttime.restore();\n\t\t}\n\n\t\tclock();\n\t\t//每一秒执行一次\n\t\tsetInterval(clock,1000)\n\t</script>","source":"_posts/canvas初探.md","raw":"title: canvas初探(内含时钟)\ndate: 2015-12-04 13:06:50\ntags: [web,H5]\ndescription: html5,Canvas,时钟范例\n\n---\n\n## 一、了解Canvas\n\n`<canvas> `是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。\n\n大多数 Canvas 绘图 API 都没有定义在\t`<canvas> `元素本身上，而是定义在通过画布的 getContext() 方法获得的一个“绘图环境”对象上。\n\nCanvas API 也使用了路径的表示法。但是，路径由一系列的方法调用来定义，而不是描述为字母和数字的字符串，比如调用 beginPath() 和 arc() 方法。\n一旦定义了路径，其他的方法，如 fill()，都是对此路径操作。绘图环境的各种属性，比如 fillStyle，说明了这些操作如何使用。\n\n<!-- more -->\n\n### 属性和方法详情可以翻阅[参考手册](http://www.w3school.com.cn/tags/html_ref_canvas.asp)\n\n## 二、基本图形的绘制\n\n### 1. 矩形\n<canvas id=\"my_canvas1\" height=\"80\"></canvas>\n<script>\n\tvar a = document.getElementById('my_canvas1');\n\tvar txt = a.getContext('2d');\n\ttxt.fillStyle=\"red\"; \n\ttxt.fillRect(0,0,150,75) \n</script>\n\n\n代码解析\n\n\t<canvas id=\"my_canvas1\" height=\"80\"></canvas>\n\t<script>\n\t\tvar a = document.getElementById('my_canvas1');\n\t\t//创建getContext对象,它是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法\n\t\tvar axt = a.getContext('2d');\n\t\t//fillStyle属性设置或返回用于填充绘画的颜色、渐变或模式\n\t\ttxt.fillStyle=\"red\"; \n\t\t//fillRect(x,y,w,h)绘制“被填充”的矩形。参数分别为(起始位置横坐标，纵坐标,宽度,高度)\n\t\ttxt.fillRect(0,0,150,75) \n\t</script>\n\n\n### 2.路径\n\n<canvas id=\"my_canvas2\" height=\"60\"></canvas>\n<script>\n\tvar b = document.getElementById('my_canvas2');\n\tvar bxt = b.getContext('2d');\n\tbxt.beginPath()\n\tbxt.moveTo(10,10); \n\tbxt.lineTo(150,50); \n\tbxt.lineTo(10,50);\n\tbxt.closePath();\n\tbxt.stroke();\n</script>\n\n代码解析\n\n\t<canvas id=\"my_canvas2\" height=\"60\"></canvas>\n\t<script>\n\tvar b = document.getElementById('my_canvas2');\n\tvar bxt = b.getContext('2d');\n\t//起始一条路径，或重置当前路径\n\tbxt.beginPath()\n\t//把路径移动到画布中的指定点，不创建线条\n\tbxt.moveTo(10,10);\n\t//添加一个新点，然后在画布中创建从该点到最后指定点的线条 \n\tbxt.lineTo(150,50); \n\tbxt.lineTo(10,50);\n\t//创建从当前点回到起始点的路径\n\tbxt.closePath();\n\t//绘制已定义的路径\n\tbxt.stroke();\n</script>\n\n### 3.圆\n\n<canvas id=\"my_canvas3\" height=\"40\"></canvas>\n<script>\n\tvar e = document.getElementById('my_canvas3');\n\tvar cxt = e.getContext('2d');\n\tcxt.beginPath();\n\tcxt.arc(70,18,15,0,Math.PI*2,true);\n\tcxt.closePath();\n\tcxt.stroke();\n</script>\n\n代码解析\n\n\t<canvas id=\"my_canvas3\" height=\"40\"></canvas>\n\t<script>\n\t\tvar e = document.getElementById('my_canvas3');\n\t\tvar cxt = e.getContext('2d');\n\t\tcxt.beginPath();\n\t\t<!--\n\t\tarc(x,y,r,sAngle,eAngle,counterclockwise)\t创建弧/曲线（用于创建圆形或部分圆）\n\t\tx\t圆心的 x 坐标。\n\t\ty\t圆心的 y 坐标。\n\t\tr\t圆半径。\n\t\tsAngle\t起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。\n\t\teAngle\t结束角，以弧度计。\n\t\tcounterclockwise\t可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。\n\t\tMath.PI*2:圆周率\n\t\t -->\n\t\tcxt.arc(70,18,15,0,Math.PI*2,true);\n\t\tcxt.closePath();\n\t\tcxt.stroke();\n\t</script>\n\n### 4.文本\n\n<canvas id=\"my_canvas4\" height=\"20\"></canvas>\n<script>\n\tvar f = document.getElementById('my_canvas4');\n\tvar axt = f.getContext('2d');\n\taxt.font=\"30px Arial\";\n\taxt.strokeText(\"hello world\",150,20)\n</script>\n\n代码解析\n\n\t<canvas id=\"my_canvas4\" height=\"20\"></canvas>\n\t<script>\n\t\tvar f = document.getElementById('my_canvas4');\n\t\tvar axt = f.getContext('2d');\n\t\t//设置或返回文本内容的当前字体属性\n\t\taxt.font=\"30px Arial\";\n\t\t//在画布上绘制文本（无填充）\n\t\taxt.strokeText(\"hello world\",150,20)\n\t</script>\n<b style=\"color:red\">注意：font属性设置语句必须置于绘制文本方法(strokeText)之前</b>\n\n### 5.渐变\n\n+ 线性渐变\n\n<canvas id=\"my_canvas5\" height=\"20\"></canvas>\n<script>\n\tvar g = document.getElementById('my_canvas5');\n\tvar gxt = g.getContext('2d');\n\tvar grd=gxt.createLinearGradient(0,0,200,0);\n\tgrd.addColorStop(0,\"red\");\n\tgrd.addColorStop(1,\"white\");\n\tgxt.fillStyle=grd;\n\tgxt.fillRect(10,10,150,20);\n</script>\n\n代码解析\n\n\t<canvas id=\"my_canvas5\" height=\"20\"></canvas>\n\t<script>\n\t\tvar g = document.getElementById('my_canvas5');\n\t\tvar gxt = g.getContext('2d');\n\t\t//createLinearGradient(x,y,x1,y1) - 创建线性渐变,坐标是起点和终点\n\t\tvar grd=gxt.createLinearGradient(0,0,200,0);\n\t\t//addColorStop()方法规定渐变对象中的颜色和停止位置，可以是0至1.\n\t\tgrd.addColorStop(0,\"red\");\n\t\tgrd.addColorStop(1,\"white\");\n\t\tgxt.fillStyle=grd;\n\t\tgxt.fillRect(10,10,150,20);\n\t</script>\n\n---\n\n+ 径向渐变\n\n<canvas id=\"my_canvas6\" height=\"50\"></canvas>\n<script>\n\tvar h = document.getElementById('my_canvas6');\n\tvar hxt = h.getContext('2d');\n\tvar hrd=gxt.createRadialGradient(25,25,5,25,25,25);\n\thrd.addColorStop(0,\"red\")\n\thrd.addColorStop(1,\"white\");\n\thxt.fillStyle=hrd;\n\thxt.arc(25,25,25,0,Math.PI*2,true);\n\thxt.fill()\n</script>\n\n\n代码解析\n\n\t<canvas id=\"my_canvas6\" height=\"50\"></canvas>\n\t<script>\n\t\tvar h = document.getElementById('my_canvas6');\n\t\tvar hxt = h.getContext('2d');\n\t\t<!-- \n\t\tcreateRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变- \n\t\tx\t渐变开始点的 x 坐标\n\t\ty\t渐变开始点的 y 坐标\n\t\tx1\t渐变结束点的 x 坐标\n\t\ty1\t渐变结束点的 y 坐标 \n\t\tr   渐变开始点的渐变半径\n\t\tr1  渐变结束点的渐变半径\n\t\t-->\n\t\tvar hrd=gxt.createRadialGradient(25,25,5,25,25,25);\n\t\thrd.addColorStop(0,\"red\")\n\t\thrd.addColorStop(1,\"white\");\n\t\thxt.fillStyle=hrd;\n\t\thxt.arc(25,25,25,0,Math.PI*2,true);\n\t\thxt.fill()\n\t</script>\n\n\n### 6.图像\n<canvas id=\"my_canvas7\" ></canvas>\n<script>\n\tvar j=document.getElementById(\"my_canvas7\");\n\tvar jxt=j.getContext(\"2d\");\n\tvar img1=new Image()\n\timg1.src=\"http://bigdots.github.io/img/thumb.jpg\";\n\timg1.onload = function(){\n\t\t/*\n\t\tdrawImage(img,sx,sy,swidth,sheight,x,y,width,height)向画布上绘制图像、画布或视频\n\t\timg\t规定要使用的图像、画布或视频。\n\t\tsx\t可选。开始剪切的 x 坐标位置。\n\t\tsy\t可选。开始剪切的 y 坐标位置。\n\t\tswidth\t可选。被剪切图像的宽度。\n\t\tsheight\t可选。被剪切图像的高度。\n\t\tx\t在画布上放置图像的 x 坐标位置。\n\t\ty\t在画布上放置图像的 y 坐标位置。\n\t\twidth\t可选。要使用的图像的宽度。（伸展或缩小图像）\n\t\theight\t可选。要使用的图像的高度。（伸展或缩小图像）\n\t\t*/\n\t\tjxt.drawImage(img1,0,0);\n\t}\n</script>\n\n\n\n代码解析\n\n\t<canvas id=\"my_canvas7\" ></canvas>\n\t<script>\n\t\tvar j=document.getElementById(\"my_canvas7\");\n\t\tvar jxt=j.getContext(\"2d\");\n\t\tvar img1=new Image()\n\t\timg1.src=\"http://bigdots.github.io/img/thumb.jpg\";\n\t\timg1.onload = function(){\n\t\t\t/*\n\t\t\tdrawImage(img,sx,sy,swidth,sheight,x,y,width,height)向画布上绘制图像、画布或视频\n\t\t\timg\t规定要使用的图像、画布或视频。\n\t\t\tsx\t可选。开始剪切的 x 坐标位置。\n\t\t\tsy\t可选。开始剪切的 y 坐标位置。\n\t\t\tswidth\t可选。被剪切图像的宽度。\n\t\t\tsheight\t可选。被剪切图像的高度。\n\t\t\tx\t在画布上放置图像的 x 坐标位置。\n\t\t\ty\t在画布上放置图像的 y 坐标位置。\n\t\t\twidth\t可选。要使用的图像的宽度。（伸展或缩小图像）\n\t\t\theight\t可选。要使用的图像的高度。（伸展或缩小图像）\n\t\t\t*/\n\t\t\tjxt.drawImage(img1,0,0);\n\t\t}\n\t</script>\n\n<b style=\"color:red\">因为我这里是通过js设置src加载图片，可能会存在图片没有加载成功，就执行了drawImage，导致画布上没有图片，所以，我用了onload</b>\n\n\n## 三、时钟范例\n\n<canvas id=\"time\" width=\"520\" height=\"520\"></canvas>\n<script>\n\tvar mycanvas = document.getElementById('time');\n\tvar time = mycanvas.getContext('2d');\n\n\tfunction clock(){\n\t\ttime.clearRect(0, 0, 800, 800);\n\n\t\t//获取时间\n\t\tvar now = new Date();\n\t\tvar secd = now.getSeconds();\n\t\tvar min = now.getMinutes();\n\t\tvar hour = now.getHours();\n\n\t\t//转为12时制\n\t\thour = hour > 12 ? hour-12 : hour;\n\n\t\t//先画个大圆\n\t\ttime.beginPath();\n\t\ttime.lineWidth = 10;\n\t\ttime.strokeStyle = \"#000\";\n\t\ttime.arc(250, 250, 200, 0, 360, false);\n\t\ttime.closePath();\n\t\ttime.stroke();\n\n\t\t//画出刻度\n\t\tfor(var i=0;i<12;i++){\n\t\t\t//保存当前环境的状态\n\t\t\ttime.save();\n\t\t\t//设置粗细和颜色\n\t\t\ttime.lineWidth = 6;\n\t\t\ttime.strokeStyle = '#000';\n\n\t\t\t//translate(x,y) 方法重新映射画布上的 (0,0) 位置。\n\t\t\t//x\t添加到水平坐标（x）上的值\n\t\t\t// y\t添加到垂直坐标（y）上的值\n\t\t\ttime.translate(250, 250);\n\t\t\t//rotate() 方法旋转当前的绘图，以弧度计。\n\t\t\t\n\t\t\t time.font = \"20px Verdana\";//必须前置\n\t\t\t time.fillText('12',-12,-150);\n\t\t\t time.fillText('3',150,6);\n\t\t\t time.fillText('6',-6,160);\n\t\t\t time.fillText('9',-150,6);\n\n\t\t\ttime.rotate((i * 30) * Math.PI / 180);//角度*Math.PI/180=弧度\n\t\t\ttime.beginPath();\n\t\t\ttime.moveTo(0, -170);\n\t\t\ttime.lineTo(0, -190);\n\t\t\ttime.closePath();\n\n\t\t\ttime.stroke();\n\t\t\t\n\t\t\ttime.restore();\n\t\t}\n\n\n\t\t/*\n\t\t1.save() 方法保存当前图像状态的一份拷贝。\n\t\t2.设置刻度的粗细和颜色\n\t\t3.利用translate把新的参照坐标设为(250,250)，即下面的坐标就是以(250,250)【圆心】为参照了；所以下面的(0,-170)其实就是(250,70)\n\t\t4.旋转30度【360/12=每个小时的度数】\n\t\t5.画线，(0, -170)至(0, -190)的线条，其实就是12点的那个刻度，然后通过旋转和循环来画出所有刻度\n\t\t6.restore() 方法将绘图状态置为保存值。\n\t\t */\n\n\t\t//时针\n\t\t\ttime.save();\n\t\t\ttime.lineWidth = 7;\n\t\t\ttime.strokeStyle = \"black\";\n\t\t\ttime.translate(250, 250);\n\t\t\t//【360/12】设定指针指向位置\n\t\t\ttime.rotate(hour * 30 * Math.PI / 180);\n\t\t\ttime.beginPath();\n\t\t\ttime.moveTo(0, -140);\n\t\t\ttime.lineTo(0, 10);\n\t\t\ttime.stroke();\n\t\t\ttime.closePath();\n\t\t\ttime.restore();\n\t\t//分针\n\t\t\ttime.save();\n\t\t\ttime.lineWidth = 5;\n\t\t\ttime.strokeStyle = \"black\";\n\t\t\ttime.translate(250, 250);\n\t\t\t//【360/60】\n\t\t\ttime.rotate(min * 6 * Math.PI / 180);\n\t\t\ttime.beginPath();\n\t\t\ttime.moveTo(0, -160);\n\t\t\ttime.lineTo(0, 10);\n\t\t\ttime.stroke();\n\t\t\ttime.closePath();\n\t\t\ttime.restore();\n\t\t//秒针\n\t\t\ttime.save();\n\t\t\ttime.lineWidth = 3;\n\t\t\ttime.strokeStyle = \"red\";\n\t\t\ttime.translate(250, 250);\n\t\t\t//【360/60】\n\t\t\ttime.rotate(secd * 6 * Math.PI / 180);\n\t\t\ttime.beginPath();\n\t\t\ttime.moveTo(0, -170);\n\t\t\ttime.lineTo(0, 10);\n\t\t\ttime.closePath();\n\t\t\ttime.stroke();\n\t\t//画交叉点\n\t\t\ttime.beginPath();\n\t\t\ttime.arc(0, 0, 5, 0, 360, false);\n\t\t\ttime.closePath();\n\t\t\ttime.fillStyle = \"gray\";\n\t\t\ttime.fill();\n\t\t\ttime.stroke();\n\t\t\ttime.beginPath();\n\t\t\ttime.arc(0, -150, 5, 0, 360, false);\n\t\t\ttime.closePath();\n\t\t\ttime.fillStyle = \"gray\";\n\t\t\ttime.fill();\n\t\t\ttime.stroke();\n\t\t\ttime.restore();\n\t\t\n\n\t}\n\n\tclock();\n\tsetInterval(clock,1000)\n</script>\n\n基础也看完了，是时候动手了。上面是一个canvas写的时钟。just do it!\n\n\n\t<canvas id=\"time\" width=\"520\" height=\"520\"></canvas>\n\t<script>\n\t\tvar mycanvas = document.getElementById('time');\n\t\tvar time = mycanvas.getContext('2d');\n\n\t\tfunction clock(){\n\t\t\ttime.clearRect(0, 0, 800, 800);\n\t\t\t//获取时间\n\t\t\tvar now = new Date();\n\t\t\tvar secd = now.getSeconds();\n\t\t\tvar min = now.getMinutes();\n\t\t\tvar hour = now.getHours();\n\t\t\t//转为12时制\n\t\t\thour = hour > 12 ? hour-12 : hour;\n\t\t\t//先画个大圆\n\t\t\ttime.beginPath();\n\t\t\ttime.lineWidth = 10;\n\t\t\ttime.strokeStyle = \"#000\";\n\t\t\ttime.arc(250, 250, 200, 0, 360, false);\n\t\t\ttime.closePath();\n\t\t\ttime.stroke();\n\t\t\t//画出刻度\n\t\t\tfor(var i=0;i<12;i++){\n\t\t\t\t//保存当前环境的状态\n\t\t\t\ttime.save();\n\t\t\t\t//设置粗细和颜色\n\t\t\t\ttime.lineWidth = 6;\n\t\t\t\ttime.strokeStyle = '#000';\n\t\t\t\t//translate(x,y) 方法重新映射画布上的 (0,0) 位置。\n\t\t\t\t//x\t添加到水平坐标（x）上的值\n\t\t\t\t// y\t添加到垂直坐标（y）上的值\n\t\t\t\ttime.translate(250, 250);\n\t\t\t\t//rotate() 方法旋转当前的绘图，以弧度计。\n\t\t\t\t time.font = \"20px Verdana\";//必须前置\n\t\t\t\t time.fillText('12',-12,-150);\n\t\t\t\t time.fillText('3',150,6);\n\t\t\t\t time.fillText('6',-6,160);\n\t\t\t\t time.fillText('9',-150,6);\n\t\t\t\ttime.rotate((i * 30) * Math.PI / 180);//角度*Math.PI/180=弧度\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.moveTo(0, -170);\n\t\t\t\ttime.lineTo(0, -190);\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.stroke();\n\t\t\t\ttime.restore();\n\t\t\t}\n\t\t\t/*\n\t\t\t1.save() 方法保存当前图像状态的一份拷贝。\n\t\t\t2.设置刻度的粗细和颜色\n\t\t\t3.利用translate把新的参照坐标设为(250,250)，即下面的坐标就是以(250,250)【圆心】为参照了；所以下面的(0,-170)其实就是(250,70)\n\t\t\t4.旋转30度【360/12=每个小时的度数】\n\t\t\t5.画线，(0, -170)至(0, -190)的线条，其实就是12点的那个刻度，然后通过旋转和循环来画出所有刻度\n\t\t\t6.restore() 方法将绘图状态置为保存值。\n\t\t\t */\n\t\t\t//时针\n\t\t\t\ttime.save();\n\t\t\t\ttime.lineWidth = 7;\n\t\t\t\ttime.strokeStyle = \"black\";\n\t\t\t\ttime.translate(250, 250);\n\t\t\t\t//【360/12】设定指针指向位置\n\t\t\t\ttime.rotate(hour * 30 * Math.PI / 180);\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.moveTo(0, -140);\n\t\t\t\ttime.lineTo(0, 10);\n\t\t\t\ttime.stroke();\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.restore();\n\t\t\t//分针\n\t\t\t\ttime.save();\n\t\t\t\ttime.lineWidth = 5;\n\t\t\t\ttime.strokeStyle = \"black\";\n\t\t\t\ttime.translate(250, 250);\n\t\t\t\t//【360/60】\n\t\t\t\ttime.rotate(min * 6 * Math.PI / 180);\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.moveTo(0, -160);\n\t\t\t\ttime.lineTo(0, 10);\n\t\t\t\ttime.stroke();\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.restore();\n\t\t\t//秒针\n\t\t\t\ttime.save();\n\t\t\t\ttime.lineWidth = 3;\n\t\t\t\ttime.strokeStyle = \"red\";\n\t\t\t\ttime.translate(250, 250);\n\t\t\t\t//【360/60】\n\t\t\t\ttime.rotate(secd * 6 * Math.PI / 180);\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.moveTo(0, -170);\n\t\t\t\ttime.lineTo(0, 10);\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.stroke();\n\t\t\t//画交叉点\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.arc(0, 0, 5, 0, 360, false);\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.fillStyle = \"gray\";\n\t\t\t\ttime.fill();\n\t\t\t\ttime.stroke();\n\t\t\t\ttime.beginPath();\n\t\t\t\ttime.arc(0, -150, 5, 0, 360, false);\n\t\t\t\ttime.closePath();\n\t\t\t\ttime.fillStyle = \"gray\";\n\t\t\t\ttime.fill();\n\t\t\t\ttime.stroke();\n\t\t\t\ttime.restore();\n\t\t}\n\n\t\tclock();\n\t\t//每一秒执行一次\n\t\tsetInterval(clock,1000)\n\t</script>","slug":"canvas初探","published":1,"updated":"2021-12-06T06:07:06.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwol2001ly4v201r0gn99","content":"<h2 id=\"一、了解Canvas\"><a href=\"#一、了解Canvas\" class=\"headerlink\" title=\"一、了解Canvas\"></a>一、了解Canvas</h2><p><code>&lt;canvas&gt; </code>是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。</p>\n<p>大多数 Canvas 绘图 API 都没有定义在    <code>&lt;canvas&gt; </code>元素本身上，而是定义在通过画布的 getContext() 方法获得的一个“绘图环境”对象上。</p>\n<p>Canvas API 也使用了路径的表示法。但是，路径由一系列的方法调用来定义，而不是描述为字母和数字的字符串，比如调用 beginPath() 和 arc() 方法。<br>一旦定义了路径，其他的方法，如 fill()，都是对此路径操作。绘图环境的各种属性，比如 fillStyle，说明了这些操作如何使用。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"属性和方法详情可以翻阅参考手册\"><a href=\"#属性和方法详情可以翻阅参考手册\" class=\"headerlink\" title=\"属性和方法详情可以翻阅参考手册\"></a>属性和方法详情可以翻阅<a href=\"http://www.w3school.com.cn/tags/html_ref_canvas.asp\">参考手册</a></h3><h2 id=\"二、基本图形的绘制\"><a href=\"#二、基本图形的绘制\" class=\"headerlink\" title=\"二、基本图形的绘制\"></a>二、基本图形的绘制</h2><h3 id=\"1-矩形\"><a href=\"#1-矩形\" class=\"headerlink\" title=\"1. 矩形\"></a>1. 矩形</h3><p><canvas id=\"my_canvas1\" height=\"80\"></canvas></p>\n<script>\n    var a = document.getElementById('my_canvas1');\n    var txt = a.getContext('2d');\n    txt.fillStyle=\"red\"; \n    txt.fillRect(0,0,150,75) \n</script>\n\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas1&quot; height=&quot;80&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var a = document.getElementById(&#39;my_canvas1&#39;);\n    //创建getContext对象,它是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法\n    var axt = a.getContext(&#39;2d&#39;);\n    //fillStyle属性设置或返回用于填充绘画的颜色、渐变或模式\n    txt.fillStyle=&quot;red&quot;; \n    //fillRect(x,y,w,h)绘制“被填充”的矩形。参数分别为(起始位置横坐标，纵坐标,宽度,高度)\n    txt.fillRect(0,0,150,75) \n&lt;/script&gt;\n</code></pre>\n<h3 id=\"2-路径\"><a href=\"#2-路径\" class=\"headerlink\" title=\"2.路径\"></a>2.路径</h3><p><canvas id=\"my_canvas2\" height=\"60\"></canvas></p>\n<script>\n    var b = document.getElementById('my_canvas2');\n    var bxt = b.getContext('2d');\n    bxt.beginPath()\n    bxt.moveTo(10,10); \n    bxt.lineTo(150,50); \n    bxt.lineTo(10,50);\n    bxt.closePath();\n    bxt.stroke();\n</script>\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas2&quot; height=&quot;60&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\nvar b = document.getElementById(&#39;my_canvas2&#39;);\nvar bxt = b.getContext(&#39;2d&#39;);\n//起始一条路径，或重置当前路径\nbxt.beginPath()\n//把路径移动到画布中的指定点，不创建线条\nbxt.moveTo(10,10);\n//添加一个新点，然后在画布中创建从该点到最后指定点的线条 \nbxt.lineTo(150,50); \nbxt.lineTo(10,50);\n//创建从当前点回到起始点的路径\nbxt.closePath();\n//绘制已定义的路径\nbxt.stroke();\n</code></pre>\n<p></script></p>\n<h3 id=\"3-圆\"><a href=\"#3-圆\" class=\"headerlink\" title=\"3.圆\"></a>3.圆</h3><p><canvas id=\"my_canvas3\" height=\"40\"></canvas></p>\n<script>\n    var e = document.getElementById('my_canvas3');\n    var cxt = e.getContext('2d');\n    cxt.beginPath();\n    cxt.arc(70,18,15,0,Math.PI*2,true);\n    cxt.closePath();\n    cxt.stroke();\n</script>\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas3&quot; height=&quot;40&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var e = document.getElementById(&#39;my_canvas3&#39;);\n    var cxt = e.getContext(&#39;2d&#39;);\n    cxt.beginPath();\n    &lt;!--\n    arc(x,y,r,sAngle,eAngle,counterclockwise)    创建弧/曲线（用于创建圆形或部分圆）\n    x    圆心的 x 坐标。\n    y    圆心的 y 坐标。\n    r    圆半径。\n    sAngle    起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。\n    eAngle    结束角，以弧度计。\n    counterclockwise    可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。\n    Math.PI*2:圆周率\n     --&gt;\n    cxt.arc(70,18,15,0,Math.PI*2,true);\n    cxt.closePath();\n    cxt.stroke();\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"4-文本\"><a href=\"#4-文本\" class=\"headerlink\" title=\"4.文本\"></a>4.文本</h3><p><canvas id=\"my_canvas4\" height=\"20\"></canvas></p>\n<script>\n    var f = document.getElementById('my_canvas4');\n    var axt = f.getContext('2d');\n    axt.font=\"30px Arial\";\n    axt.strokeText(\"hello world\",150,20)\n</script>\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas4&quot; height=&quot;20&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var f = document.getElementById(&#39;my_canvas4&#39;);\n    var axt = f.getContext(&#39;2d&#39;);\n    //设置或返回文本内容的当前字体属性\n    axt.font=&quot;30px Arial&quot;;\n    //在画布上绘制文本（无填充）\n    axt.strokeText(&quot;hello world&quot;,150,20)\n&lt;/script&gt;\n</code></pre>\n<p><b style=\"color:red\">注意：font属性设置语句必须置于绘制文本方法(strokeText)之前</b></p>\n<h3 id=\"5-渐变\"><a href=\"#5-渐变\" class=\"headerlink\" title=\"5.渐变\"></a>5.渐变</h3><ul>\n<li>线性渐变</li>\n</ul>\n<p><canvas id=\"my_canvas5\" height=\"20\"></canvas></p>\n<script>\n    var g = document.getElementById('my_canvas5');\n    var gxt = g.getContext('2d');\n    var grd=gxt.createLinearGradient(0,0,200,0);\n    grd.addColorStop(0,\"red\");\n    grd.addColorStop(1,\"white\");\n    gxt.fillStyle=grd;\n    gxt.fillRect(10,10,150,20);\n</script>\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas5&quot; height=&quot;20&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var g = document.getElementById(&#39;my_canvas5&#39;);\n    var gxt = g.getContext(&#39;2d&#39;);\n    //createLinearGradient(x,y,x1,y1) - 创建线性渐变,坐标是起点和终点\n    var grd=gxt.createLinearGradient(0,0,200,0);\n    //addColorStop()方法规定渐变对象中的颜色和停止位置，可以是0至1.\n    grd.addColorStop(0,&quot;red&quot;);\n    grd.addColorStop(1,&quot;white&quot;);\n    gxt.fillStyle=grd;\n    gxt.fillRect(10,10,150,20);\n&lt;/script&gt;\n</code></pre>\n<hr>\n<ul>\n<li>径向渐变</li>\n</ul>\n<p><canvas id=\"my_canvas6\" height=\"50\"></canvas></p>\n<script>\n    var h = document.getElementById('my_canvas6');\n    var hxt = h.getContext('2d');\n    var hrd=gxt.createRadialGradient(25,25,5,25,25,25);\n    hrd.addColorStop(0,\"red\")\n    hrd.addColorStop(1,\"white\");\n    hxt.fillStyle=hrd;\n    hxt.arc(25,25,25,0,Math.PI*2,true);\n    hxt.fill()\n</script>\n\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas6&quot; height=&quot;50&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var h = document.getElementById(&#39;my_canvas6&#39;);\n    var hxt = h.getContext(&#39;2d&#39;);\n    &lt;!-- \n    createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变- \n    x    渐变开始点的 x 坐标\n    y    渐变开始点的 y 坐标\n    x1    渐变结束点的 x 坐标\n    y1    渐变结束点的 y 坐标 \n    r   渐变开始点的渐变半径\n    r1  渐变结束点的渐变半径\n    --&gt;\n    var hrd=gxt.createRadialGradient(25,25,5,25,25,25);\n    hrd.addColorStop(0,&quot;red&quot;)\n    hrd.addColorStop(1,&quot;white&quot;);\n    hxt.fillStyle=hrd;\n    hxt.arc(25,25,25,0,Math.PI*2,true);\n    hxt.fill()\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"6-图像\"><a href=\"#6-图像\" class=\"headerlink\" title=\"6.图像\"></a>6.图像</h3><p><canvas id=\"my_canvas7\" ></canvas></p>\n<script>\n    var j=document.getElementById(\"my_canvas7\");\n    var jxt=j.getContext(\"2d\");\n    var img1=new Image()\n    img1.src=\"http://bigdots.github.io/img/thumb.jpg\";\n    img1.onload = function(){\n        /*\n        drawImage(img,sx,sy,swidth,sheight,x,y,width,height)向画布上绘制图像、画布或视频\n        img    规定要使用的图像、画布或视频。\n        sx    可选。开始剪切的 x 坐标位置。\n        sy    可选。开始剪切的 y 坐标位置。\n        swidth    可选。被剪切图像的宽度。\n        sheight    可选。被剪切图像的高度。\n        x    在画布上放置图像的 x 坐标位置。\n        y    在画布上放置图像的 y 坐标位置。\n        width    可选。要使用的图像的宽度。（伸展或缩小图像）\n        height    可选。要使用的图像的高度。（伸展或缩小图像）\n        */\n        jxt.drawImage(img1,0,0);\n    }\n</script>\n\n\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas7&quot; &gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var j=document.getElementById(&quot;my_canvas7&quot;);\n    var jxt=j.getContext(&quot;2d&quot;);\n    var img1=new Image()\n    img1.src=&quot;http://bigdots.github.io/img/thumb.jpg&quot;;\n    img1.onload = function()&#123;\n        /*\n        drawImage(img,sx,sy,swidth,sheight,x,y,width,height)向画布上绘制图像、画布或视频\n        img    规定要使用的图像、画布或视频。\n        sx    可选。开始剪切的 x 坐标位置。\n        sy    可选。开始剪切的 y 坐标位置。\n        swidth    可选。被剪切图像的宽度。\n        sheight    可选。被剪切图像的高度。\n        x    在画布上放置图像的 x 坐标位置。\n        y    在画布上放置图像的 y 坐标位置。\n        width    可选。要使用的图像的宽度。（伸展或缩小图像）\n        height    可选。要使用的图像的高度。（伸展或缩小图像）\n        */\n        jxt.drawImage(img1,0,0);\n    &#125;\n&lt;/script&gt;\n</code></pre>\n<p><b style=\"color:red\">因为我这里是通过js设置src加载图片，可能会存在图片没有加载成功，就执行了drawImage，导致画布上没有图片，所以，我用了onload</b></p>\n<h2 id=\"三、时钟范例\"><a href=\"#三、时钟范例\" class=\"headerlink\" title=\"三、时钟范例\"></a>三、时钟范例</h2><p><canvas id=\"time\" width=\"520\" height=\"520\"></canvas></p>\n<script>\n    var mycanvas = document.getElementById('time');\n    var time = mycanvas.getContext('2d');\n\n    function clock(){\n        time.clearRect(0, 0, 800, 800);\n\n        //获取时间\n        var now = new Date();\n        var secd = now.getSeconds();\n        var min = now.getMinutes();\n        var hour = now.getHours();\n\n        //转为12时制\n        hour = hour > 12 ? hour-12 : hour;\n\n        //先画个大圆\n        time.beginPath();\n        time.lineWidth = 10;\n        time.strokeStyle = \"#000\";\n        time.arc(250, 250, 200, 0, 360, false);\n        time.closePath();\n        time.stroke();\n\n        //画出刻度\n        for(var i=0;i<12;i++){\n            //保存当前环境的状态\n            time.save();\n            //设置粗细和颜色\n            time.lineWidth = 6;\n            time.strokeStyle = '#000';\n\n            //translate(x,y) 方法重新映射画布上的 (0,0) 位置。\n            //x    添加到水平坐标（x）上的值\n            // y    添加到垂直坐标（y）上的值\n            time.translate(250, 250);\n            //rotate() 方法旋转当前的绘图，以弧度计。\n            \n             time.font = \"20px Verdana\";//必须前置\n             time.fillText('12',-12,-150);\n             time.fillText('3',150,6);\n             time.fillText('6',-6,160);\n             time.fillText('9',-150,6);\n\n            time.rotate((i * 30) * Math.PI / 180);//角度*Math.PI/180=弧度\n            time.beginPath();\n            time.moveTo(0, -170);\n            time.lineTo(0, -190);\n            time.closePath();\n\n            time.stroke();\n            \n            time.restore();\n        }\n\n\n        /*\n        1.save() 方法保存当前图像状态的一份拷贝。\n        2.设置刻度的粗细和颜色\n        3.利用translate把新的参照坐标设为(250,250)，即下面的坐标就是以(250,250)【圆心】为参照了；所以下面的(0,-170)其实就是(250,70)\n        4.旋转30度【360/12=每个小时的度数】\n        5.画线，(0, -170)至(0, -190)的线条，其实就是12点的那个刻度，然后通过旋转和循环来画出所有刻度\n        6.restore() 方法将绘图状态置为保存值。\n         */\n\n        //时针\n            time.save();\n            time.lineWidth = 7;\n            time.strokeStyle = \"black\";\n            time.translate(250, 250);\n            //【360/12】设定指针指向位置\n            time.rotate(hour * 30 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -140);\n            time.lineTo(0, 10);\n            time.stroke();\n            time.closePath();\n            time.restore();\n        //分针\n            time.save();\n            time.lineWidth = 5;\n            time.strokeStyle = \"black\";\n            time.translate(250, 250);\n            //【360/60】\n            time.rotate(min * 6 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -160);\n            time.lineTo(0, 10);\n            time.stroke();\n            time.closePath();\n            time.restore();\n        //秒针\n            time.save();\n            time.lineWidth = 3;\n            time.strokeStyle = \"red\";\n            time.translate(250, 250);\n            //【360/60】\n            time.rotate(secd * 6 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -170);\n            time.lineTo(0, 10);\n            time.closePath();\n            time.stroke();\n        //画交叉点\n            time.beginPath();\n            time.arc(0, 0, 5, 0, 360, false);\n            time.closePath();\n            time.fillStyle = \"gray\";\n            time.fill();\n            time.stroke();\n            time.beginPath();\n            time.arc(0, -150, 5, 0, 360, false);\n            time.closePath();\n            time.fillStyle = \"gray\";\n            time.fill();\n            time.stroke();\n            time.restore();\n        \n\n    }\n\n    clock();\n    setInterval(clock,1000)\n</script>\n\n<p>基础也看完了，是时候动手了。上面是一个canvas写的时钟。just do it!</p>\n<pre><code>&lt;canvas id=&quot;time&quot; width=&quot;520&quot; height=&quot;520&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var mycanvas = document.getElementById(&#39;time&#39;);\n    var time = mycanvas.getContext(&#39;2d&#39;);\n\n    function clock()&#123;\n        time.clearRect(0, 0, 800, 800);\n        //获取时间\n        var now = new Date();\n        var secd = now.getSeconds();\n        var min = now.getMinutes();\n        var hour = now.getHours();\n        //转为12时制\n        hour = hour &gt; 12 ? hour-12 : hour;\n        //先画个大圆\n        time.beginPath();\n        time.lineWidth = 10;\n        time.strokeStyle = &quot;#000&quot;;\n        time.arc(250, 250, 200, 0, 360, false);\n        time.closePath();\n        time.stroke();\n        //画出刻度\n        for(var i=0;i&lt;12;i++)&#123;\n            //保存当前环境的状态\n            time.save();\n            //设置粗细和颜色\n            time.lineWidth = 6;\n            time.strokeStyle = &#39;#000&#39;;\n            //translate(x,y) 方法重新映射画布上的 (0,0) 位置。\n            //x    添加到水平坐标（x）上的值\n            // y    添加到垂直坐标（y）上的值\n            time.translate(250, 250);\n            //rotate() 方法旋转当前的绘图，以弧度计。\n             time.font = &quot;20px Verdana&quot;;//必须前置\n             time.fillText(&#39;12&#39;,-12,-150);\n             time.fillText(&#39;3&#39;,150,6);\n             time.fillText(&#39;6&#39;,-6,160);\n             time.fillText(&#39;9&#39;,-150,6);\n            time.rotate((i * 30) * Math.PI / 180);//角度*Math.PI/180=弧度\n            time.beginPath();\n            time.moveTo(0, -170);\n            time.lineTo(0, -190);\n            time.closePath();\n            time.stroke();\n            time.restore();\n        &#125;\n        /*\n        1.save() 方法保存当前图像状态的一份拷贝。\n        2.设置刻度的粗细和颜色\n        3.利用translate把新的参照坐标设为(250,250)，即下面的坐标就是以(250,250)【圆心】为参照了；所以下面的(0,-170)其实就是(250,70)\n        4.旋转30度【360/12=每个小时的度数】\n        5.画线，(0, -170)至(0, -190)的线条，其实就是12点的那个刻度，然后通过旋转和循环来画出所有刻度\n        6.restore() 方法将绘图状态置为保存值。\n         */\n        //时针\n            time.save();\n            time.lineWidth = 7;\n            time.strokeStyle = &quot;black&quot;;\n            time.translate(250, 250);\n            //【360/12】设定指针指向位置\n            time.rotate(hour * 30 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -140);\n            time.lineTo(0, 10);\n            time.stroke();\n            time.closePath();\n            time.restore();\n        //分针\n            time.save();\n            time.lineWidth = 5;\n            time.strokeStyle = &quot;black&quot;;\n            time.translate(250, 250);\n            //【360/60】\n            time.rotate(min * 6 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -160);\n            time.lineTo(0, 10);\n            time.stroke();\n            time.closePath();\n            time.restore();\n        //秒针\n            time.save();\n            time.lineWidth = 3;\n            time.strokeStyle = &quot;red&quot;;\n            time.translate(250, 250);\n            //【360/60】\n            time.rotate(secd * 6 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -170);\n            time.lineTo(0, 10);\n            time.closePath();\n            time.stroke();\n        //画交叉点\n            time.beginPath();\n            time.arc(0, 0, 5, 0, 360, false);\n            time.closePath();\n            time.fillStyle = &quot;gray&quot;;\n            time.fill();\n            time.stroke();\n            time.beginPath();\n            time.arc(0, -150, 5, 0, 360, false);\n            time.closePath();\n            time.fillStyle = &quot;gray&quot;;\n            time.fill();\n            time.stroke();\n            time.restore();\n    &#125;\n\n    clock();\n    //每一秒执行一次\n    setInterval(clock,1000)\n&lt;/script&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、了解Canvas\"><a href=\"#一、了解Canvas\" class=\"headerlink\" title=\"一、了解Canvas\"></a>一、了解Canvas</h2><p><code>&lt;canvas&gt; </code>是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。</p>\n<p>大多数 Canvas 绘图 API 都没有定义在    <code>&lt;canvas&gt; </code>元素本身上，而是定义在通过画布的 getContext() 方法获得的一个“绘图环境”对象上。</p>\n<p>Canvas API 也使用了路径的表示法。但是，路径由一系列的方法调用来定义，而不是描述为字母和数字的字符串，比如调用 beginPath() 和 arc() 方法。<br>一旦定义了路径，其他的方法，如 fill()，都是对此路径操作。绘图环境的各种属性，比如 fillStyle，说明了这些操作如何使用。</p>","more":"<h3 id=\"属性和方法详情可以翻阅参考手册\"><a href=\"#属性和方法详情可以翻阅参考手册\" class=\"headerlink\" title=\"属性和方法详情可以翻阅参考手册\"></a>属性和方法详情可以翻阅<a href=\"http://www.w3school.com.cn/tags/html_ref_canvas.asp\">参考手册</a></h3><h2 id=\"二、基本图形的绘制\"><a href=\"#二、基本图形的绘制\" class=\"headerlink\" title=\"二、基本图形的绘制\"></a>二、基本图形的绘制</h2><h3 id=\"1-矩形\"><a href=\"#1-矩形\" class=\"headerlink\" title=\"1. 矩形\"></a>1. 矩形</h3><p><canvas id=\"my_canvas1\" height=\"80\"></canvas></p>\n<script>\n    var a = document.getElementById('my_canvas1');\n    var txt = a.getContext('2d');\n    txt.fillStyle=\"red\"; \n    txt.fillRect(0,0,150,75) \n</script>\n\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas1&quot; height=&quot;80&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var a = document.getElementById(&#39;my_canvas1&#39;);\n    //创建getContext对象,它是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法\n    var axt = a.getContext(&#39;2d&#39;);\n    //fillStyle属性设置或返回用于填充绘画的颜色、渐变或模式\n    txt.fillStyle=&quot;red&quot;; \n    //fillRect(x,y,w,h)绘制“被填充”的矩形。参数分别为(起始位置横坐标，纵坐标,宽度,高度)\n    txt.fillRect(0,0,150,75) \n&lt;/script&gt;\n</code></pre>\n<h3 id=\"2-路径\"><a href=\"#2-路径\" class=\"headerlink\" title=\"2.路径\"></a>2.路径</h3><p><canvas id=\"my_canvas2\" height=\"60\"></canvas></p>\n<script>\n    var b = document.getElementById('my_canvas2');\n    var bxt = b.getContext('2d');\n    bxt.beginPath()\n    bxt.moveTo(10,10); \n    bxt.lineTo(150,50); \n    bxt.lineTo(10,50);\n    bxt.closePath();\n    bxt.stroke();\n</script>\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas2&quot; height=&quot;60&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\nvar b = document.getElementById(&#39;my_canvas2&#39;);\nvar bxt = b.getContext(&#39;2d&#39;);\n//起始一条路径，或重置当前路径\nbxt.beginPath()\n//把路径移动到画布中的指定点，不创建线条\nbxt.moveTo(10,10);\n//添加一个新点，然后在画布中创建从该点到最后指定点的线条 \nbxt.lineTo(150,50); \nbxt.lineTo(10,50);\n//创建从当前点回到起始点的路径\nbxt.closePath();\n//绘制已定义的路径\nbxt.stroke();\n</code></pre>\n<p></script></p>\n<h3 id=\"3-圆\"><a href=\"#3-圆\" class=\"headerlink\" title=\"3.圆\"></a>3.圆</h3><p><canvas id=\"my_canvas3\" height=\"40\"></canvas></p>\n<script>\n    var e = document.getElementById('my_canvas3');\n    var cxt = e.getContext('2d');\n    cxt.beginPath();\n    cxt.arc(70,18,15,0,Math.PI*2,true);\n    cxt.closePath();\n    cxt.stroke();\n</script>\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas3&quot; height=&quot;40&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var e = document.getElementById(&#39;my_canvas3&#39;);\n    var cxt = e.getContext(&#39;2d&#39;);\n    cxt.beginPath();\n    &lt;!--\n    arc(x,y,r,sAngle,eAngle,counterclockwise)    创建弧/曲线（用于创建圆形或部分圆）\n    x    圆心的 x 坐标。\n    y    圆心的 y 坐标。\n    r    圆半径。\n    sAngle    起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。\n    eAngle    结束角，以弧度计。\n    counterclockwise    可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。\n    Math.PI*2:圆周率\n     --&gt;\n    cxt.arc(70,18,15,0,Math.PI*2,true);\n    cxt.closePath();\n    cxt.stroke();\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"4-文本\"><a href=\"#4-文本\" class=\"headerlink\" title=\"4.文本\"></a>4.文本</h3><p><canvas id=\"my_canvas4\" height=\"20\"></canvas></p>\n<script>\n    var f = document.getElementById('my_canvas4');\n    var axt = f.getContext('2d');\n    axt.font=\"30px Arial\";\n    axt.strokeText(\"hello world\",150,20)\n</script>\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas4&quot; height=&quot;20&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var f = document.getElementById(&#39;my_canvas4&#39;);\n    var axt = f.getContext(&#39;2d&#39;);\n    //设置或返回文本内容的当前字体属性\n    axt.font=&quot;30px Arial&quot;;\n    //在画布上绘制文本（无填充）\n    axt.strokeText(&quot;hello world&quot;,150,20)\n&lt;/script&gt;\n</code></pre>\n<p><b style=\"color:red\">注意：font属性设置语句必须置于绘制文本方法(strokeText)之前</b></p>\n<h3 id=\"5-渐变\"><a href=\"#5-渐变\" class=\"headerlink\" title=\"5.渐变\"></a>5.渐变</h3><ul>\n<li>线性渐变</li>\n</ul>\n<p><canvas id=\"my_canvas5\" height=\"20\"></canvas></p>\n<script>\n    var g = document.getElementById('my_canvas5');\n    var gxt = g.getContext('2d');\n    var grd=gxt.createLinearGradient(0,0,200,0);\n    grd.addColorStop(0,\"red\");\n    grd.addColorStop(1,\"white\");\n    gxt.fillStyle=grd;\n    gxt.fillRect(10,10,150,20);\n</script>\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas5&quot; height=&quot;20&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var g = document.getElementById(&#39;my_canvas5&#39;);\n    var gxt = g.getContext(&#39;2d&#39;);\n    //createLinearGradient(x,y,x1,y1) - 创建线性渐变,坐标是起点和终点\n    var grd=gxt.createLinearGradient(0,0,200,0);\n    //addColorStop()方法规定渐变对象中的颜色和停止位置，可以是0至1.\n    grd.addColorStop(0,&quot;red&quot;);\n    grd.addColorStop(1,&quot;white&quot;);\n    gxt.fillStyle=grd;\n    gxt.fillRect(10,10,150,20);\n&lt;/script&gt;\n</code></pre>\n<hr>\n<ul>\n<li>径向渐变</li>\n</ul>\n<p><canvas id=\"my_canvas6\" height=\"50\"></canvas></p>\n<script>\n    var h = document.getElementById('my_canvas6');\n    var hxt = h.getContext('2d');\n    var hrd=gxt.createRadialGradient(25,25,5,25,25,25);\n    hrd.addColorStop(0,\"red\")\n    hrd.addColorStop(1,\"white\");\n    hxt.fillStyle=hrd;\n    hxt.arc(25,25,25,0,Math.PI*2,true);\n    hxt.fill()\n</script>\n\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas6&quot; height=&quot;50&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var h = document.getElementById(&#39;my_canvas6&#39;);\n    var hxt = h.getContext(&#39;2d&#39;);\n    &lt;!-- \n    createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变- \n    x    渐变开始点的 x 坐标\n    y    渐变开始点的 y 坐标\n    x1    渐变结束点的 x 坐标\n    y1    渐变结束点的 y 坐标 \n    r   渐变开始点的渐变半径\n    r1  渐变结束点的渐变半径\n    --&gt;\n    var hrd=gxt.createRadialGradient(25,25,5,25,25,25);\n    hrd.addColorStop(0,&quot;red&quot;)\n    hrd.addColorStop(1,&quot;white&quot;);\n    hxt.fillStyle=hrd;\n    hxt.arc(25,25,25,0,Math.PI*2,true);\n    hxt.fill()\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"6-图像\"><a href=\"#6-图像\" class=\"headerlink\" title=\"6.图像\"></a>6.图像</h3><p><canvas id=\"my_canvas7\" ></canvas></p>\n<script>\n    var j=document.getElementById(\"my_canvas7\");\n    var jxt=j.getContext(\"2d\");\n    var img1=new Image()\n    img1.src=\"http://bigdots.github.io/img/thumb.jpg\";\n    img1.onload = function(){\n        /*\n        drawImage(img,sx,sy,swidth,sheight,x,y,width,height)向画布上绘制图像、画布或视频\n        img    规定要使用的图像、画布或视频。\n        sx    可选。开始剪切的 x 坐标位置。\n        sy    可选。开始剪切的 y 坐标位置。\n        swidth    可选。被剪切图像的宽度。\n        sheight    可选。被剪切图像的高度。\n        x    在画布上放置图像的 x 坐标位置。\n        y    在画布上放置图像的 y 坐标位置。\n        width    可选。要使用的图像的宽度。（伸展或缩小图像）\n        height    可选。要使用的图像的高度。（伸展或缩小图像）\n        */\n        jxt.drawImage(img1,0,0);\n    }\n</script>\n\n\n\n<p>代码解析</p>\n<pre><code>&lt;canvas id=&quot;my_canvas7&quot; &gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var j=document.getElementById(&quot;my_canvas7&quot;);\n    var jxt=j.getContext(&quot;2d&quot;);\n    var img1=new Image()\n    img1.src=&quot;http://bigdots.github.io/img/thumb.jpg&quot;;\n    img1.onload = function()&#123;\n        /*\n        drawImage(img,sx,sy,swidth,sheight,x,y,width,height)向画布上绘制图像、画布或视频\n        img    规定要使用的图像、画布或视频。\n        sx    可选。开始剪切的 x 坐标位置。\n        sy    可选。开始剪切的 y 坐标位置。\n        swidth    可选。被剪切图像的宽度。\n        sheight    可选。被剪切图像的高度。\n        x    在画布上放置图像的 x 坐标位置。\n        y    在画布上放置图像的 y 坐标位置。\n        width    可选。要使用的图像的宽度。（伸展或缩小图像）\n        height    可选。要使用的图像的高度。（伸展或缩小图像）\n        */\n        jxt.drawImage(img1,0,0);\n    &#125;\n&lt;/script&gt;\n</code></pre>\n<p><b style=\"color:red\">因为我这里是通过js设置src加载图片，可能会存在图片没有加载成功，就执行了drawImage，导致画布上没有图片，所以，我用了onload</b></p>\n<h2 id=\"三、时钟范例\"><a href=\"#三、时钟范例\" class=\"headerlink\" title=\"三、时钟范例\"></a>三、时钟范例</h2><p><canvas id=\"time\" width=\"520\" height=\"520\"></canvas></p>\n<script>\n    var mycanvas = document.getElementById('time');\n    var time = mycanvas.getContext('2d');\n\n    function clock(){\n        time.clearRect(0, 0, 800, 800);\n\n        //获取时间\n        var now = new Date();\n        var secd = now.getSeconds();\n        var min = now.getMinutes();\n        var hour = now.getHours();\n\n        //转为12时制\n        hour = hour > 12 ? hour-12 : hour;\n\n        //先画个大圆\n        time.beginPath();\n        time.lineWidth = 10;\n        time.strokeStyle = \"#000\";\n        time.arc(250, 250, 200, 0, 360, false);\n        time.closePath();\n        time.stroke();\n\n        //画出刻度\n        for(var i=0;i<12;i++){\n            //保存当前环境的状态\n            time.save();\n            //设置粗细和颜色\n            time.lineWidth = 6;\n            time.strokeStyle = '#000';\n\n            //translate(x,y) 方法重新映射画布上的 (0,0) 位置。\n            //x    添加到水平坐标（x）上的值\n            // y    添加到垂直坐标（y）上的值\n            time.translate(250, 250);\n            //rotate() 方法旋转当前的绘图，以弧度计。\n            \n             time.font = \"20px Verdana\";//必须前置\n             time.fillText('12',-12,-150);\n             time.fillText('3',150,6);\n             time.fillText('6',-6,160);\n             time.fillText('9',-150,6);\n\n            time.rotate((i * 30) * Math.PI / 180);//角度*Math.PI/180=弧度\n            time.beginPath();\n            time.moveTo(0, -170);\n            time.lineTo(0, -190);\n            time.closePath();\n\n            time.stroke();\n            \n            time.restore();\n        }\n\n\n        /*\n        1.save() 方法保存当前图像状态的一份拷贝。\n        2.设置刻度的粗细和颜色\n        3.利用translate把新的参照坐标设为(250,250)，即下面的坐标就是以(250,250)【圆心】为参照了；所以下面的(0,-170)其实就是(250,70)\n        4.旋转30度【360/12=每个小时的度数】\n        5.画线，(0, -170)至(0, -190)的线条，其实就是12点的那个刻度，然后通过旋转和循环来画出所有刻度\n        6.restore() 方法将绘图状态置为保存值。\n         */\n\n        //时针\n            time.save();\n            time.lineWidth = 7;\n            time.strokeStyle = \"black\";\n            time.translate(250, 250);\n            //【360/12】设定指针指向位置\n            time.rotate(hour * 30 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -140);\n            time.lineTo(0, 10);\n            time.stroke();\n            time.closePath();\n            time.restore();\n        //分针\n            time.save();\n            time.lineWidth = 5;\n            time.strokeStyle = \"black\";\n            time.translate(250, 250);\n            //【360/60】\n            time.rotate(min * 6 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -160);\n            time.lineTo(0, 10);\n            time.stroke();\n            time.closePath();\n            time.restore();\n        //秒针\n            time.save();\n            time.lineWidth = 3;\n            time.strokeStyle = \"red\";\n            time.translate(250, 250);\n            //【360/60】\n            time.rotate(secd * 6 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -170);\n            time.lineTo(0, 10);\n            time.closePath();\n            time.stroke();\n        //画交叉点\n            time.beginPath();\n            time.arc(0, 0, 5, 0, 360, false);\n            time.closePath();\n            time.fillStyle = \"gray\";\n            time.fill();\n            time.stroke();\n            time.beginPath();\n            time.arc(0, -150, 5, 0, 360, false);\n            time.closePath();\n            time.fillStyle = \"gray\";\n            time.fill();\n            time.stroke();\n            time.restore();\n        \n\n    }\n\n    clock();\n    setInterval(clock,1000)\n</script>\n\n<p>基础也看完了，是时候动手了。上面是一个canvas写的时钟。just do it!</p>\n<pre><code>&lt;canvas id=&quot;time&quot; width=&quot;520&quot; height=&quot;520&quot;&gt;&lt;/canvas&gt;\n&lt;script&gt;\n    var mycanvas = document.getElementById(&#39;time&#39;);\n    var time = mycanvas.getContext(&#39;2d&#39;);\n\n    function clock()&#123;\n        time.clearRect(0, 0, 800, 800);\n        //获取时间\n        var now = new Date();\n        var secd = now.getSeconds();\n        var min = now.getMinutes();\n        var hour = now.getHours();\n        //转为12时制\n        hour = hour &gt; 12 ? hour-12 : hour;\n        //先画个大圆\n        time.beginPath();\n        time.lineWidth = 10;\n        time.strokeStyle = &quot;#000&quot;;\n        time.arc(250, 250, 200, 0, 360, false);\n        time.closePath();\n        time.stroke();\n        //画出刻度\n        for(var i=0;i&lt;12;i++)&#123;\n            //保存当前环境的状态\n            time.save();\n            //设置粗细和颜色\n            time.lineWidth = 6;\n            time.strokeStyle = &#39;#000&#39;;\n            //translate(x,y) 方法重新映射画布上的 (0,0) 位置。\n            //x    添加到水平坐标（x）上的值\n            // y    添加到垂直坐标（y）上的值\n            time.translate(250, 250);\n            //rotate() 方法旋转当前的绘图，以弧度计。\n             time.font = &quot;20px Verdana&quot;;//必须前置\n             time.fillText(&#39;12&#39;,-12,-150);\n             time.fillText(&#39;3&#39;,150,6);\n             time.fillText(&#39;6&#39;,-6,160);\n             time.fillText(&#39;9&#39;,-150,6);\n            time.rotate((i * 30) * Math.PI / 180);//角度*Math.PI/180=弧度\n            time.beginPath();\n            time.moveTo(0, -170);\n            time.lineTo(0, -190);\n            time.closePath();\n            time.stroke();\n            time.restore();\n        &#125;\n        /*\n        1.save() 方法保存当前图像状态的一份拷贝。\n        2.设置刻度的粗细和颜色\n        3.利用translate把新的参照坐标设为(250,250)，即下面的坐标就是以(250,250)【圆心】为参照了；所以下面的(0,-170)其实就是(250,70)\n        4.旋转30度【360/12=每个小时的度数】\n        5.画线，(0, -170)至(0, -190)的线条，其实就是12点的那个刻度，然后通过旋转和循环来画出所有刻度\n        6.restore() 方法将绘图状态置为保存值。\n         */\n        //时针\n            time.save();\n            time.lineWidth = 7;\n            time.strokeStyle = &quot;black&quot;;\n            time.translate(250, 250);\n            //【360/12】设定指针指向位置\n            time.rotate(hour * 30 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -140);\n            time.lineTo(0, 10);\n            time.stroke();\n            time.closePath();\n            time.restore();\n        //分针\n            time.save();\n            time.lineWidth = 5;\n            time.strokeStyle = &quot;black&quot;;\n            time.translate(250, 250);\n            //【360/60】\n            time.rotate(min * 6 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -160);\n            time.lineTo(0, 10);\n            time.stroke();\n            time.closePath();\n            time.restore();\n        //秒针\n            time.save();\n            time.lineWidth = 3;\n            time.strokeStyle = &quot;red&quot;;\n            time.translate(250, 250);\n            //【360/60】\n            time.rotate(secd * 6 * Math.PI / 180);\n            time.beginPath();\n            time.moveTo(0, -170);\n            time.lineTo(0, 10);\n            time.closePath();\n            time.stroke();\n        //画交叉点\n            time.beginPath();\n            time.arc(0, 0, 5, 0, 360, false);\n            time.closePath();\n            time.fillStyle = &quot;gray&quot;;\n            time.fill();\n            time.stroke();\n            time.beginPath();\n            time.arc(0, -150, 5, 0, 360, false);\n            time.closePath();\n            time.fillStyle = &quot;gray&quot;;\n            time.fill();\n            time.stroke();\n            time.restore();\n    &#125;\n\n    clock();\n    //每一秒执行一次\n    setInterval(clock,1000)\n&lt;/script&gt;\n</code></pre>"},{"title":"css三角形的实现","date":"2015-07-07T10:22:32.000Z","description":"css三角形","_content":"\n### 实心三角形\n原理：\n\n![](/images/201511/1.jpg)\n<!-- more -->\n\n上图为盒子的边框模型。当中间的conten部分的宽和高为0时，就变成了下图这样。\n\n![](/images/201511/2.jpg)\n接着，我们让左右边框为透明，上边框为0；即为如下三角形\n<div style=\"width:0;height:0;border-left: 160px solid \n            transparent;border-right: 160px solid transparent;\n\t\t\tborder-bottom: 130px solid #eeeeee;\">\n\t\t\t</div>\n\n_代码实现_\n\n\t\tdiv{\n\t\t\twidth:0;height:0;\n\t\t\tborder-left: 160px solid transparent;\n            border-right: 160px solid transparent;\n\t\t\tborder-bottom: 130px solid #eeeeee;\n\t\t}\n\t\n\n\n\n网上有人做了个动图，解释了全过程\n![](/images/201511/2.gif)\n\n\n### 空心三角形\n\n原理：用俩个三角形进行叠加\n<style>\n\t.triangle:before{\n\t        top:0;\n\t        left:0;\n\t        content: '';\n\t        position: absolute;\n\t        display: block;\n\t        width: 0;\n\t        height: 0;\n\t        border-left: 50px solid transparent;\n\t        border-right: 50px solid transparent;\n\t        border-bottom: 50px solid red;\n\t    }\n\t    .triangle:after{\n\t        top:1px;\n\t        left:2px;\n\t        content: '';\n\t        position: absolute;\n\t        display: block;\n\t        width: 0;\n\t        height: 0;\n\t        border-left: 48px solid transparent;\n\t        border-right: 48px solid transparent;\n\t        border-bottom: 48px solid #fff;\n\t    }\n\t    .triangle{\n\t        position: relative;\n\t        height: 60px;\n\t    }\n</style>\n\n<div class=\"triangle\"></div>\n\n\t\n代码实现\n\n\t<div class=\"triangle\"></div>\n\n\t.triangle:before{\n        top:0;\n        left:0;\n        content: '';\n        position: absolute;\n        display: block;\n        width: 0;\n        height: 0;\n        border-left: 50px solid transparent;\n        border-right: 50px solid transparent;\n        border-bottom: 50px solid red;\n    }\n\n    .triangle:after{\n        top:1px;\n        left:2px;\n        content: '';\n        position: absolute;\n        display: block;\n        width: 0;\n        height: 0;\n        border-left: 48px solid transparent;\n        border-right: 48px solid transparent;\n        border-bottom: 48px solid #fff;\n    }\n\n    .triangle{\n        position: relative;\n    }\n\t\n\n---\n<p style=\"text-align:right\">整理于2015-11-30 14:08:14</p>\n","source":"_posts/css三角形的实现.md","raw":"title: css三角形的实现\ndate: 2015-07-07 18:22:32\ntags: [css]\ndescription: css三角形\n\n---\n\n### 实心三角形\n原理：\n\n![](/images/201511/1.jpg)\n<!-- more -->\n\n上图为盒子的边框模型。当中间的conten部分的宽和高为0时，就变成了下图这样。\n\n![](/images/201511/2.jpg)\n接着，我们让左右边框为透明，上边框为0；即为如下三角形\n<div style=\"width:0;height:0;border-left: 160px solid \n            transparent;border-right: 160px solid transparent;\n\t\t\tborder-bottom: 130px solid #eeeeee;\">\n\t\t\t</div>\n\n_代码实现_\n\n\t\tdiv{\n\t\t\twidth:0;height:0;\n\t\t\tborder-left: 160px solid transparent;\n            border-right: 160px solid transparent;\n\t\t\tborder-bottom: 130px solid #eeeeee;\n\t\t}\n\t\n\n\n\n网上有人做了个动图，解释了全过程\n![](/images/201511/2.gif)\n\n\n### 空心三角形\n\n原理：用俩个三角形进行叠加\n<style>\n\t.triangle:before{\n\t        top:0;\n\t        left:0;\n\t        content: '';\n\t        position: absolute;\n\t        display: block;\n\t        width: 0;\n\t        height: 0;\n\t        border-left: 50px solid transparent;\n\t        border-right: 50px solid transparent;\n\t        border-bottom: 50px solid red;\n\t    }\n\t    .triangle:after{\n\t        top:1px;\n\t        left:2px;\n\t        content: '';\n\t        position: absolute;\n\t        display: block;\n\t        width: 0;\n\t        height: 0;\n\t        border-left: 48px solid transparent;\n\t        border-right: 48px solid transparent;\n\t        border-bottom: 48px solid #fff;\n\t    }\n\t    .triangle{\n\t        position: relative;\n\t        height: 60px;\n\t    }\n</style>\n\n<div class=\"triangle\"></div>\n\n\t\n代码实现\n\n\t<div class=\"triangle\"></div>\n\n\t.triangle:before{\n        top:0;\n        left:0;\n        content: '';\n        position: absolute;\n        display: block;\n        width: 0;\n        height: 0;\n        border-left: 50px solid transparent;\n        border-right: 50px solid transparent;\n        border-bottom: 50px solid red;\n    }\n\n    .triangle:after{\n        top:1px;\n        left:2px;\n        content: '';\n        position: absolute;\n        display: block;\n        width: 0;\n        height: 0;\n        border-left: 48px solid transparent;\n        border-right: 48px solid transparent;\n        border-bottom: 48px solid #fff;\n    }\n\n    .triangle{\n        position: relative;\n    }\n\t\n\n---\n<p style=\"text-align:right\">整理于2015-11-30 14:08:14</p>\n","slug":"css三角形的实现","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwol3001my4v28hqk5apu","content":"<h3 id=\"实心三角形\"><a href=\"#实心三角形\" class=\"headerlink\" title=\"实心三角形\"></a>实心三角形</h3><p>原理：</p>\n<p><img src=\"/images/201511/1.jpg\"></p>\n<span id=\"more\"></span>\n\n<p>上图为盒子的边框模型。当中间的conten部分的宽和高为0时，就变成了下图这样。</p>\n<p><img src=\"/images/201511/2.jpg\"><br>接着，我们让左右边框为透明，上边框为0；即为如下三角形</p>\n<div style=\"width:0;height:0;border-left: 160px solid \n            transparent;border-right: 160px solid transparent;\n            border-bottom: 130px solid #eeeeee;\">\n            </div>\n\n<p><em>代码实现</em></p>\n<pre><code>    div&#123;\n        width:0;height:0;\n        border-left: 160px solid transparent;\n        border-right: 160px solid transparent;\n        border-bottom: 130px solid #eeeeee;\n    &#125;\n</code></pre>\n<p>网上有人做了个动图，解释了全过程<br><img src=\"/images/201511/2.gif\"></p>\n<h3 id=\"空心三角形\"><a href=\"#空心三角形\" class=\"headerlink\" title=\"空心三角形\"></a>空心三角形</h3><p>原理：用俩个三角形进行叠加</p>\n<style>\n    .triangle:before{\n            top:0;\n            left:0;\n            content: '';\n            position: absolute;\n            display: block;\n            width: 0;\n            height: 0;\n            border-left: 50px solid transparent;\n            border-right: 50px solid transparent;\n            border-bottom: 50px solid red;\n        }\n        .triangle:after{\n            top:1px;\n            left:2px;\n            content: '';\n            position: absolute;\n            display: block;\n            width: 0;\n            height: 0;\n            border-left: 48px solid transparent;\n            border-right: 48px solid transparent;\n            border-bottom: 48px solid #fff;\n        }\n        .triangle{\n            position: relative;\n            height: 60px;\n        }\n</style>\n\n<div class=\"triangle\"></div>\n\n    \n<p>代码实现</p>\n<pre><code>&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;\n\n.triangle:before&#123;\n    top:0;\n    left:0;\n    content: &#39;&#39;;\n    position: absolute;\n    display: block;\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 50px solid red;\n&#125;\n\n.triangle:after&#123;\n    top:1px;\n    left:2px;\n    content: &#39;&#39;;\n    position: absolute;\n    display: block;\n    width: 0;\n    height: 0;\n    border-left: 48px solid transparent;\n    border-right: 48px solid transparent;\n    border-bottom: 48px solid #fff;\n&#125;\n\n.triangle&#123;\n    position: relative;\n&#125;\n</code></pre>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-30 14:08:14</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"实心三角形\"><a href=\"#实心三角形\" class=\"headerlink\" title=\"实心三角形\"></a>实心三角形</h3><p>原理：</p>\n<p><img src=\"/images/201511/1.jpg\"></p>","more":"<p>上图为盒子的边框模型。当中间的conten部分的宽和高为0时，就变成了下图这样。</p>\n<p><img src=\"/images/201511/2.jpg\"><br>接着，我们让左右边框为透明，上边框为0；即为如下三角形</p>\n<div style=\"width:0;height:0;border-left: 160px solid \n            transparent;border-right: 160px solid transparent;\n            border-bottom: 130px solid #eeeeee;\">\n            </div>\n\n<p><em>代码实现</em></p>\n<pre><code>    div&#123;\n        width:0;height:0;\n        border-left: 160px solid transparent;\n        border-right: 160px solid transparent;\n        border-bottom: 130px solid #eeeeee;\n    &#125;\n</code></pre>\n<p>网上有人做了个动图，解释了全过程<br><img src=\"/images/201511/2.gif\"></p>\n<h3 id=\"空心三角形\"><a href=\"#空心三角形\" class=\"headerlink\" title=\"空心三角形\"></a>空心三角形</h3><p>原理：用俩个三角形进行叠加</p>\n<style>\n    .triangle:before{\n            top:0;\n            left:0;\n            content: '';\n            position: absolute;\n            display: block;\n            width: 0;\n            height: 0;\n            border-left: 50px solid transparent;\n            border-right: 50px solid transparent;\n            border-bottom: 50px solid red;\n        }\n        .triangle:after{\n            top:1px;\n            left:2px;\n            content: '';\n            position: absolute;\n            display: block;\n            width: 0;\n            height: 0;\n            border-left: 48px solid transparent;\n            border-right: 48px solid transparent;\n            border-bottom: 48px solid #fff;\n        }\n        .triangle{\n            position: relative;\n            height: 60px;\n        }\n</style>\n\n<div class=\"triangle\"></div>\n\n    \n<p>代码实现</p>\n<pre><code>&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;\n\n.triangle:before&#123;\n    top:0;\n    left:0;\n    content: &#39;&#39;;\n    position: absolute;\n    display: block;\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 50px solid red;\n&#125;\n\n.triangle:after&#123;\n    top:1px;\n    left:2px;\n    content: &#39;&#39;;\n    position: absolute;\n    display: block;\n    width: 0;\n    height: 0;\n    border-left: 48px solid transparent;\n    border-right: 48px solid transparent;\n    border-bottom: 48px solid #fff;\n&#125;\n\n.triangle&#123;\n    position: relative;\n&#125;\n</code></pre>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-30 14:08:14</p>"},{"title":"github+hexo构建静态博客（一）","date":"2015-11-23T09:40:57.000Z","description":"静态建站 hexo github 免费建站 自己的博客","_content":"\n## 一、GithubPages\n\n#### 1.申请[github](https://github.com/)账号\n\n#### 2.点击 new repository，建立一个仓库\n\n![](/images/201511/1.png)\n\n<!-- more -->\n\n#### 3.输入文件名。必须是username.github.io的形式\n\n![](/images/201511/2.png)\n\n#### 4.成功以后进入该项目，点击右侧的seetings\n\n![](/images/201511/3.png)\n\n#### 5.点击Launch  automatic page generator\n\n![](/images/201511/4.png)\n\n#### 6.一直点击continue直至选择主题结束\n\n完成后你就可以通过username.github.io来访问你的githubPages了\n\n## 二、SSH设置\n\n``` bash\n$ ssh-keygen -t rsa -C \"自己邮箱\"    \n```\n(C一定要大写，接下来会有三次需要内容输入)\n第一次：设置ssh生成位置，可以直接Enter；\n第二次：输入密码；可以直接Enter；密码为空\n第三次：确认密码；\n\n\n完成！打开生成位置即可查看.ssh文件。也可再通过命令行验证是否成功，输入\n$ ssh git@github.com\n\n![](/images/201511/5.png)\n显示如上则说明成功\n\n---\n接下来，打开github。进入settings页面，点击Deploy keys，\n![](/images/201511/6.png)\n点击add deploy key ,将.ssh文件中生成的id_rsa.pub中的内容复制粘贴到key框中；\n至此，github部分就OK了\n\n\n最后，使用ssh将git链接到远程仓库\n``` bash\n$ssh -T git@github.com   \n```\n\n输入就大功告成了！呼~\n\n\n\n<p style=\"text-align:right;color:#f9a037\">to be continued......</p>","source":"_posts/github-hexo构建静态博客（一）.md","raw":"title: github+hexo构建静态博客（一）\ndate: 2015-11-23 17:40:57\ndescription: 静态建站 hexo github 免费建站 自己的博客\ntags: [其他]\n---\n\n## 一、GithubPages\n\n#### 1.申请[github](https://github.com/)账号\n\n#### 2.点击 new repository，建立一个仓库\n\n![](/images/201511/1.png)\n\n<!-- more -->\n\n#### 3.输入文件名。必须是username.github.io的形式\n\n![](/images/201511/2.png)\n\n#### 4.成功以后进入该项目，点击右侧的seetings\n\n![](/images/201511/3.png)\n\n#### 5.点击Launch  automatic page generator\n\n![](/images/201511/4.png)\n\n#### 6.一直点击continue直至选择主题结束\n\n完成后你就可以通过username.github.io来访问你的githubPages了\n\n## 二、SSH设置\n\n``` bash\n$ ssh-keygen -t rsa -C \"自己邮箱\"    \n```\n(C一定要大写，接下来会有三次需要内容输入)\n第一次：设置ssh生成位置，可以直接Enter；\n第二次：输入密码；可以直接Enter；密码为空\n第三次：确认密码；\n\n\n完成！打开生成位置即可查看.ssh文件。也可再通过命令行验证是否成功，输入\n$ ssh git@github.com\n\n![](/images/201511/5.png)\n显示如上则说明成功\n\n---\n接下来，打开github。进入settings页面，点击Deploy keys，\n![](/images/201511/6.png)\n点击add deploy key ,将.ssh文件中生成的id_rsa.pub中的内容复制粘贴到key框中；\n至此，github部分就OK了\n\n\n最后，使用ssh将git链接到远程仓库\n``` bash\n$ssh -T git@github.com   \n```\n\n输入就大功告成了！呼~\n\n\n\n<p style=\"text-align:right;color:#f9a037\">to be continued......</p>","slug":"github-hexo构建静态博客（一）","published":1,"updated":"2021-12-06T06:07:06.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwol4001oy4v201zo7q5u","content":"<h2 id=\"一、GithubPages\"><a href=\"#一、GithubPages\" class=\"headerlink\" title=\"一、GithubPages\"></a>一、GithubPages</h2><h4 id=\"1-申请github账号\"><a href=\"#1-申请github账号\" class=\"headerlink\" title=\"1.申请github账号\"></a>1.申请<a href=\"https://github.com/\">github</a>账号</h4><h4 id=\"2-点击-new-repository，建立一个仓库\"><a href=\"#2-点击-new-repository，建立一个仓库\" class=\"headerlink\" title=\"2.点击 new repository，建立一个仓库\"></a>2.点击 new repository，建立一个仓库</h4><p><img src=\"/images/201511/1.png\"></p>\n<span id=\"more\"></span>\n\n<h4 id=\"3-输入文件名。必须是username-github-io的形式\"><a href=\"#3-输入文件名。必须是username-github-io的形式\" class=\"headerlink\" title=\"3.输入文件名。必须是username.github.io的形式\"></a>3.输入文件名。必须是username.github.io的形式</h4><p><img src=\"/images/201511/2.png\"></p>\n<h4 id=\"4-成功以后进入该项目，点击右侧的seetings\"><a href=\"#4-成功以后进入该项目，点击右侧的seetings\" class=\"headerlink\" title=\"4.成功以后进入该项目，点击右侧的seetings\"></a>4.成功以后进入该项目，点击右侧的seetings</h4><p><img src=\"/images/201511/3.png\"></p>\n<h4 id=\"5-点击Launch-automatic-page-generator\"><a href=\"#5-点击Launch-automatic-page-generator\" class=\"headerlink\" title=\"5.点击Launch  automatic page generator\"></a>5.点击Launch  automatic page generator</h4><p><img src=\"/images/201511/4.png\"></p>\n<h4 id=\"6-一直点击continue直至选择主题结束\"><a href=\"#6-一直点击continue直至选择主题结束\" class=\"headerlink\" title=\"6.一直点击continue直至选择主题结束\"></a>6.一直点击continue直至选择主题结束</h4><p>完成后你就可以通过username.github.io来访问你的githubPages了</p>\n<h2 id=\"二、SSH设置\"><a href=\"#二、SSH设置\" class=\"headerlink\" title=\"二、SSH设置\"></a>二、SSH设置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">&quot;自己邮箱&quot;</span>    </span><br></pre></td></tr></table></figure>\n<p>(C一定要大写，接下来会有三次需要内容输入)<br>第一次：设置ssh生成位置，可以直接Enter；<br>第二次：输入密码；可以直接Enter；密码为空<br>第三次：确认密码；</p>\n<p>完成！打开生成位置即可查看.ssh文件。也可再通过命令行验证是否成功，输入<br>$ ssh <a href=\"mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;\">&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;</a></p>\n<p><img src=\"/images/201511/5.png\"><br>显示如上则说明成功</p>\n<hr>\n<p>接下来，打开github。进入settings页面，点击Deploy keys，<br><img src=\"/images/201511/6.png\"><br>点击add deploy key ,将.ssh文件中生成的id_rsa.pub中的内容复制粘贴到key框中；<br>至此，github部分就OK了</p>\n<p>最后，使用ssh将git链接到远程仓库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ssh</span> -T git@github.com   </span><br></pre></td></tr></table></figure>\n\n<p>输入就大功告成了！呼~</p>\n<p style=\"text-align:right;color:#f9a037\">to be continued......</p>","site":{"data":{}},"excerpt":"<h2 id=\"一、GithubPages\"><a href=\"#一、GithubPages\" class=\"headerlink\" title=\"一、GithubPages\"></a>一、GithubPages</h2><h4 id=\"1-申请github账号\"><a href=\"#1-申请github账号\" class=\"headerlink\" title=\"1.申请github账号\"></a>1.申请<a href=\"https://github.com/\">github</a>账号</h4><h4 id=\"2-点击-new-repository，建立一个仓库\"><a href=\"#2-点击-new-repository，建立一个仓库\" class=\"headerlink\" title=\"2.点击 new repository，建立一个仓库\"></a>2.点击 new repository，建立一个仓库</h4><p><img src=\"/images/201511/1.png\"></p>","more":"<h4 id=\"3-输入文件名。必须是username-github-io的形式\"><a href=\"#3-输入文件名。必须是username-github-io的形式\" class=\"headerlink\" title=\"3.输入文件名。必须是username.github.io的形式\"></a>3.输入文件名。必须是username.github.io的形式</h4><p><img src=\"/images/201511/2.png\"></p>\n<h4 id=\"4-成功以后进入该项目，点击右侧的seetings\"><a href=\"#4-成功以后进入该项目，点击右侧的seetings\" class=\"headerlink\" title=\"4.成功以后进入该项目，点击右侧的seetings\"></a>4.成功以后进入该项目，点击右侧的seetings</h4><p><img src=\"/images/201511/3.png\"></p>\n<h4 id=\"5-点击Launch-automatic-page-generator\"><a href=\"#5-点击Launch-automatic-page-generator\" class=\"headerlink\" title=\"5.点击Launch  automatic page generator\"></a>5.点击Launch  automatic page generator</h4><p><img src=\"/images/201511/4.png\"></p>\n<h4 id=\"6-一直点击continue直至选择主题结束\"><a href=\"#6-一直点击continue直至选择主题结束\" class=\"headerlink\" title=\"6.一直点击continue直至选择主题结束\"></a>6.一直点击continue直至选择主题结束</h4><p>完成后你就可以通过username.github.io来访问你的githubPages了</p>\n<h2 id=\"二、SSH设置\"><a href=\"#二、SSH设置\" class=\"headerlink\" title=\"二、SSH设置\"></a>二、SSH设置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">&quot;自己邮箱&quot;</span>    </span><br></pre></td></tr></table></figure>\n<p>(C一定要大写，接下来会有三次需要内容输入)<br>第一次：设置ssh生成位置，可以直接Enter；<br>第二次：输入密码；可以直接Enter；密码为空<br>第三次：确认密码；</p>\n<p>完成！打开生成位置即可查看.ssh文件。也可再通过命令行验证是否成功，输入<br>$ ssh <a href=\"mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;\">&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;</a></p>\n<p><img src=\"/images/201511/5.png\"><br>显示如上则说明成功</p>\n<hr>\n<p>接下来，打开github。进入settings页面，点击Deploy keys，<br><img src=\"/images/201511/6.png\"><br>点击add deploy key ,将.ssh文件中生成的id_rsa.pub中的内容复制粘贴到key框中；<br>至此，github部分就OK了</p>\n<p>最后，使用ssh将git链接到远程仓库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ssh</span> -T git@github.com   </span><br></pre></td></tr></table></figure>\n\n<p>输入就大功告成了！呼~</p>\n<p style=\"text-align:right;color:#f9a037\">to be continued......</p>"},{"title":"iScroll-js—\"smooth scrolling for the web\"","date":"2015-12-15T07:09:11.000Z","description":"iScroll","_content":"\n## 一、什么是iScroll\n\n[官方文档](http://iscrolljs.com/)的解释：\n`iScroll`是一个高性能、占用空间小、依赖免费的多平台javascrip脚本库。它应用于桌面设备、移动设备和智能电视。它一直在大力优化性能和大小以便在现代设备和旧设备上提供流畅的运行。`iScroll`不仅仅只是用来滚动。它还可以处理任何用户交互需要的元素移动。它增加了滚动,缩放,平移,无限滚动、视差滚动、旋转木马,并且它仅仅只有4 kb。\n\n<!-- more -->\n## 二、为什么要用iScroll\n由于不同的手机版本造成页面的弹性滚动条兼容性不好，iscroll封装了弹性滚动条插件可以跨手机版本实现弹性滚动UI设计\n\n## 三、Getting started\n\n注意事项：\n\n+ `IScroll`需要对所要进行滚动的元素进行初始化。\n+ `iScroll`的数量没有限制，你可以在每个页面使用任意数量的`iScroll`(如果硬件允许的话)　　\n+ 保持DOM尽可能简单。最优的HTML结构是:\n\n滚动区域必须包裹在Iscroll中。在上面的例子中,UL元素将滚动。只有第一个子元素是滚动的,额外的子元素则会被忽略掉。\n\n\t<div id=\"wrapper\">\n\t    <ul>\n\t        <li>...</li>\n\t        <li>...</li>\n\t        ...\n\t    </ul>\n\t</div>\n\n---\n\n实例化：\n\n\t<script type=\"text/javascript\">\n\t\tvar wrapper = document.getElementById('wrapper');\n\t\tvar myScroll = new IScroll(wrapper);\n\t</script>\n\n<p style=\"color:red\">注意：\n1.iScroll使用querySelector而不是querySelectorAll,所以选中的是第一个选择器元素。如果你需要iScroll适用于多个对象你要构建循环。\n2.iScroll需要在DOM加载完毕时启动,最安全的办法是绑定在窗口onload事件。\n3.iScroll需要知道滚动区域的高度/宽度\n</p>\n\n\n## 四、配置iScroll\n在初始化阶段可以通过第二个参数来配置iScroll\n\n\tvar myScroll = new IScroll('#wrapper', {\n\t    mouseWheel: true,\n\t    scrollbars: true\n\t});\n\n上面的示例打开了鼠标滚轮和滚动条支持。\n\n常用参数：\n`hScroll` :                false 禁止横向滚动 true横向滚动 默认为true\n`vScroll`  :               false 精致垂直滚动 true垂直滚动 默认为true\n`hScrollbar`:            false隐藏水平方向上的滚动条\n`vScrollbar` :           false 隐藏垂直方向上的滚动条\n`fixedScrollbar`:      在iOS系统上，当元素拖动超出了scroller的边界时，滚动条会收缩，设置为true可以禁止滚动条超出scroller的可见区域。默认在Android上为true， iOS上为false\n`fadeScrollbar`  :　  false 指定在无渐隐效果时隐藏滚动条\n`hideScrollbar`  :　  在没有用户交互时隐藏滚动条 默认为true\n`bounce`         :  　启用或禁用边界的反弹，默认为true\n`momentum`   　 :启用或禁用惯性，默认为true，此参数在你想要保存资源的时候非常有用\n`lockDirection`    :   false取消拖动方向的锁定， true拖动只能在一个方向上（up/down 或者left/right）","source":"_posts/iScroll-js——smooth scrolling for the web.md","raw":"title: iScroll-js—\"smooth scrolling for the web\"\ndate: 2015-12-15 15:09:11\ntags: [插件,移动端开发]\ndescription: iScroll\n\n---\n\n## 一、什么是iScroll\n\n[官方文档](http://iscrolljs.com/)的解释：\n`iScroll`是一个高性能、占用空间小、依赖免费的多平台javascrip脚本库。它应用于桌面设备、移动设备和智能电视。它一直在大力优化性能和大小以便在现代设备和旧设备上提供流畅的运行。`iScroll`不仅仅只是用来滚动。它还可以处理任何用户交互需要的元素移动。它增加了滚动,缩放,平移,无限滚动、视差滚动、旋转木马,并且它仅仅只有4 kb。\n\n<!-- more -->\n## 二、为什么要用iScroll\n由于不同的手机版本造成页面的弹性滚动条兼容性不好，iscroll封装了弹性滚动条插件可以跨手机版本实现弹性滚动UI设计\n\n## 三、Getting started\n\n注意事项：\n\n+ `IScroll`需要对所要进行滚动的元素进行初始化。\n+ `iScroll`的数量没有限制，你可以在每个页面使用任意数量的`iScroll`(如果硬件允许的话)　　\n+ 保持DOM尽可能简单。最优的HTML结构是:\n\n滚动区域必须包裹在Iscroll中。在上面的例子中,UL元素将滚动。只有第一个子元素是滚动的,额外的子元素则会被忽略掉。\n\n\t<div id=\"wrapper\">\n\t    <ul>\n\t        <li>...</li>\n\t        <li>...</li>\n\t        ...\n\t    </ul>\n\t</div>\n\n---\n\n实例化：\n\n\t<script type=\"text/javascript\">\n\t\tvar wrapper = document.getElementById('wrapper');\n\t\tvar myScroll = new IScroll(wrapper);\n\t</script>\n\n<p style=\"color:red\">注意：\n1.iScroll使用querySelector而不是querySelectorAll,所以选中的是第一个选择器元素。如果你需要iScroll适用于多个对象你要构建循环。\n2.iScroll需要在DOM加载完毕时启动,最安全的办法是绑定在窗口onload事件。\n3.iScroll需要知道滚动区域的高度/宽度\n</p>\n\n\n## 四、配置iScroll\n在初始化阶段可以通过第二个参数来配置iScroll\n\n\tvar myScroll = new IScroll('#wrapper', {\n\t    mouseWheel: true,\n\t    scrollbars: true\n\t});\n\n上面的示例打开了鼠标滚轮和滚动条支持。\n\n常用参数：\n`hScroll` :                false 禁止横向滚动 true横向滚动 默认为true\n`vScroll`  :               false 精致垂直滚动 true垂直滚动 默认为true\n`hScrollbar`:            false隐藏水平方向上的滚动条\n`vScrollbar` :           false 隐藏垂直方向上的滚动条\n`fixedScrollbar`:      在iOS系统上，当元素拖动超出了scroller的边界时，滚动条会收缩，设置为true可以禁止滚动条超出scroller的可见区域。默认在Android上为true， iOS上为false\n`fadeScrollbar`  :　  false 指定在无渐隐效果时隐藏滚动条\n`hideScrollbar`  :　  在没有用户交互时隐藏滚动条 默认为true\n`bounce`         :  　启用或禁用边界的反弹，默认为true\n`momentum`   　 :启用或禁用惯性，默认为true，此参数在你想要保存资源的时候非常有用\n`lockDirection`    :   false取消拖动方向的锁定， true拖动只能在一个方向上（up/down 或者left/right）","slug":"iScroll-js——smooth scrolling for the web","published":1,"updated":"2021-12-06T06:07:06.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwol5001qy4v20yar0nj7","content":"<h2 id=\"一、什么是iScroll\"><a href=\"#一、什么是iScroll\" class=\"headerlink\" title=\"一、什么是iScroll\"></a>一、什么是iScroll</h2><p><a href=\"http://iscrolljs.com/\">官方文档</a>的解释：<br><code>iScroll</code>是一个高性能、占用空间小、依赖免费的多平台javascrip脚本库。它应用于桌面设备、移动设备和智能电视。它一直在大力优化性能和大小以便在现代设备和旧设备上提供流畅的运行。<code>iScroll</code>不仅仅只是用来滚动。它还可以处理任何用户交互需要的元素移动。它增加了滚动,缩放,平移,无限滚动、视差滚动、旋转木马,并且它仅仅只有4 kb。</p>\n<span id=\"more\"></span>\n<h2 id=\"二、为什么要用iScroll\"><a href=\"#二、为什么要用iScroll\" class=\"headerlink\" title=\"二、为什么要用iScroll\"></a>二、为什么要用iScroll</h2><p>由于不同的手机版本造成页面的弹性滚动条兼容性不好，iscroll封装了弹性滚动条插件可以跨手机版本实现弹性滚动UI设计</p>\n<h2 id=\"三、Getting-started\"><a href=\"#三、Getting-started\" class=\"headerlink\" title=\"三、Getting started\"></a>三、Getting started</h2><p>注意事项：</p>\n<ul>\n<li><code>IScroll</code>需要对所要进行滚动的元素进行初始化。</li>\n<li><code>iScroll</code>的数量没有限制，你可以在每个页面使用任意数量的<code>iScroll</code>(如果硬件允许的话)　　</li>\n<li>保持DOM尽可能简单。最优的HTML结构是:</li>\n</ul>\n<p>滚动区域必须包裹在Iscroll中。在上面的例子中,UL元素将滚动。只有第一个子元素是滚动的,额外的子元素则会被忽略掉。</p>\n<pre><code>&lt;div id=&quot;wrapper&quot;&gt;\n    &lt;ul&gt;\n        &lt;li&gt;...&lt;/li&gt;\n        &lt;li&gt;...&lt;/li&gt;\n        ...\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre>\n<hr>\n<p>实例化：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    var wrapper = document.getElementById(&#39;wrapper&#39;);\n    var myScroll = new IScroll(wrapper);\n&lt;/script&gt;\n</code></pre>\n<p style=\"color:red\">注意：\n1.iScroll使用querySelector而不是querySelectorAll,所以选中的是第一个选择器元素。如果你需要iScroll适用于多个对象你要构建循环。\n2.iScroll需要在DOM加载完毕时启动,最安全的办法是绑定在窗口onload事件。\n3.iScroll需要知道滚动区域的高度/宽度\n</p>\n\n\n<h2 id=\"四、配置iScroll\"><a href=\"#四、配置iScroll\" class=\"headerlink\" title=\"四、配置iScroll\"></a>四、配置iScroll</h2><p>在初始化阶段可以通过第二个参数来配置iScroll</p>\n<pre><code>var myScroll = new IScroll(&#39;#wrapper&#39;, &#123;\n    mouseWheel: true,\n    scrollbars: true\n&#125;);\n</code></pre>\n<p>上面的示例打开了鼠标滚轮和滚动条支持。</p>\n<p>常用参数：<br><code>hScroll</code> :                false 禁止横向滚动 true横向滚动 默认为true<br><code>vScroll</code>  :               false 精致垂直滚动 true垂直滚动 默认为true<br><code>hScrollbar</code>:            false隐藏水平方向上的滚动条<br><code>vScrollbar</code> :           false 隐藏垂直方向上的滚动条<br><code>fixedScrollbar</code>:      在iOS系统上，当元素拖动超出了scroller的边界时，滚动条会收缩，设置为true可以禁止滚动条超出scroller的可见区域。默认在Android上为true， iOS上为false<br><code>fadeScrollbar</code>  :　  false 指定在无渐隐效果时隐藏滚动条<br><code>hideScrollbar</code>  :　  在没有用户交互时隐藏滚动条 默认为true<br><code>bounce</code>         :  　启用或禁用边界的反弹，默认为true<br><code>momentum</code>   　 :启用或禁用惯性，默认为true，此参数在你想要保存资源的时候非常有用<br><code>lockDirection</code>    :   false取消拖动方向的锁定， true拖动只能在一个方向上（up/down 或者left/right）</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、什么是iScroll\"><a href=\"#一、什么是iScroll\" class=\"headerlink\" title=\"一、什么是iScroll\"></a>一、什么是iScroll</h2><p><a href=\"http://iscrolljs.com/\">官方文档</a>的解释：<br><code>iScroll</code>是一个高性能、占用空间小、依赖免费的多平台javascrip脚本库。它应用于桌面设备、移动设备和智能电视。它一直在大力优化性能和大小以便在现代设备和旧设备上提供流畅的运行。<code>iScroll</code>不仅仅只是用来滚动。它还可以处理任何用户交互需要的元素移动。它增加了滚动,缩放,平移,无限滚动、视差滚动、旋转木马,并且它仅仅只有4 kb。</p>","more":"<h2 id=\"二、为什么要用iScroll\"><a href=\"#二、为什么要用iScroll\" class=\"headerlink\" title=\"二、为什么要用iScroll\"></a>二、为什么要用iScroll</h2><p>由于不同的手机版本造成页面的弹性滚动条兼容性不好，iscroll封装了弹性滚动条插件可以跨手机版本实现弹性滚动UI设计</p>\n<h2 id=\"三、Getting-started\"><a href=\"#三、Getting-started\" class=\"headerlink\" title=\"三、Getting started\"></a>三、Getting started</h2><p>注意事项：</p>\n<ul>\n<li><code>IScroll</code>需要对所要进行滚动的元素进行初始化。</li>\n<li><code>iScroll</code>的数量没有限制，你可以在每个页面使用任意数量的<code>iScroll</code>(如果硬件允许的话)　　</li>\n<li>保持DOM尽可能简单。最优的HTML结构是:</li>\n</ul>\n<p>滚动区域必须包裹在Iscroll中。在上面的例子中,UL元素将滚动。只有第一个子元素是滚动的,额外的子元素则会被忽略掉。</p>\n<pre><code>&lt;div id=&quot;wrapper&quot;&gt;\n    &lt;ul&gt;\n        &lt;li&gt;...&lt;/li&gt;\n        &lt;li&gt;...&lt;/li&gt;\n        ...\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre>\n<hr>\n<p>实例化：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    var wrapper = document.getElementById(&#39;wrapper&#39;);\n    var myScroll = new IScroll(wrapper);\n&lt;/script&gt;\n</code></pre>\n<p style=\"color:red\">注意：\n1.iScroll使用querySelector而不是querySelectorAll,所以选中的是第一个选择器元素。如果你需要iScroll适用于多个对象你要构建循环。\n2.iScroll需要在DOM加载完毕时启动,最安全的办法是绑定在窗口onload事件。\n3.iScroll需要知道滚动区域的高度/宽度\n</p>\n\n\n<h2 id=\"四、配置iScroll\"><a href=\"#四、配置iScroll\" class=\"headerlink\" title=\"四、配置iScroll\"></a>四、配置iScroll</h2><p>在初始化阶段可以通过第二个参数来配置iScroll</p>\n<pre><code>var myScroll = new IScroll(&#39;#wrapper&#39;, &#123;\n    mouseWheel: true,\n    scrollbars: true\n&#125;);\n</code></pre>\n<p>上面的示例打开了鼠标滚轮和滚动条支持。</p>\n<p>常用参数：<br><code>hScroll</code> :                false 禁止横向滚动 true横向滚动 默认为true<br><code>vScroll</code>  :               false 精致垂直滚动 true垂直滚动 默认为true<br><code>hScrollbar</code>:            false隐藏水平方向上的滚动条<br><code>vScrollbar</code> :           false 隐藏垂直方向上的滚动条<br><code>fixedScrollbar</code>:      在iOS系统上，当元素拖动超出了scroller的边界时，滚动条会收缩，设置为true可以禁止滚动条超出scroller的可见区域。默认在Android上为true， iOS上为false<br><code>fadeScrollbar</code>  :　  false 指定在无渐隐效果时隐藏滚动条<br><code>hideScrollbar</code>  :　  在没有用户交互时隐藏滚动条 默认为true<br><code>bounce</code>         :  　启用或禁用边界的反弹，默认为true<br><code>momentum</code>   　 :启用或禁用惯性，默认为true，此参数在你想要保存资源的时候非常有用<br><code>lockDirection</code>    :   false取消拖动方向的锁定， true拖动只能在一个方向上（up/down 或者left/right）</p>"},{"title":"github+hexo构建静态博客（二）","date":"2015-11-23T10:46:49.000Z","description":"静态建站 hexo github 免费建站 自己的博客","_content":"\n## 一、安装Hexo\n\n在本机全局安装hexo\n``` bash\n$ npm install –g hexo\n```\n创建并初始化blog、文件\n``` bash\n$ hexo init blog   \n```\n\n进入blog文件夹\n``` bash\n$ cd blog    \n```\n<!-- more -->\n安装npm模块\n``` bash\n$ npm install   \n```\n启动服务\n``` bash\n$ hexo server   \n```\n\n#### 目录结构\n\t_config.yml       配置文件\n\tnode_modules      模块\n\tpublic            执行hexo -g后生成的最终文件\n\tscaffolds\t\t  文章模版格式\n\tsource  \t\t  新文章生成，以及资源文件存放处\n\tthemes\t\t\t  主题\n\tdb.json     \n\tpackage.json  \n\tREADME.md  \n\n#### 配置文件 blog/_config.yml\n\t# Hexo Configuration\n\t## Docs: http://hexo.io/docs/configuration.html\n\t## Source: https://github.com/hexojs/hexo/\n\n\t# Site 站点\n\ttitle: bigdots\n\tsubtitle:\n\tdescription:\n\tauthor: Brand\n\tlanguage:\n\ttimezone:\n\n\t# URL 设置根路径和网站地址\n\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://bigdots.github.io\n\troot: /\n\tpermalink: :year/:month/:day/:title/\n\tpermalink_defaults:\n\n\t# Directory 设置各个文件路径地址\n\tsource_dir: source\n\tpublic_dir: public\n\ttag_dir: tags\n\tarchive_dir: archives\n\tcategory_dir: categories\n\tcode_dir: downloads/code\n\ti18n_dir: :lang\n\tskip_render:\n\n\t# Writing \n\tnew_post_name: :title.md # File name of new posts\n\tdefault_layout: post\n\ttitlecase: false # Transform title into titlecase\n\texternal_link: true # Open external links in new tab\n\tfilename_case: 0\n\trender_drafts: false\n\tpost_asset_folder: false\n\trelative_link: false\n\tfuture: true\n\thighlight:\n\t  enable: true\n\t  line_number: true\n\t  auto_detect: true\n\t  tab_replace:\n\n\t# Category & Tag  分类和标签\n\tdefault_category: uncategorized\n\tcategory_map:\n\ttag_map:\n\n\t# Date / Time format  时间格式\n\t## Hexo uses Moment.js to parse and display date\n\t## You can customize the date format as defined in\n\t## http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY-MM-DD\n\ttime_format: HH:mm:ss\n\n\t# Pagination\n\t## Set per_page to 0 to disable pagination\n\tper_page: 10\n\tpagination_dir: page\n\n\t# Extensions  主题和插件\n\t## Plugins: http://hexo.io/plugins/\n\t## Themes: http://hexo.io/themes/\n\ttheme: yilia\n\n\t# Deployment  部署\n\t## Docs: http://hexo.io/docs/deployment.html\n\tdeploy: \n\t  type: git\n\t  repository: git@github.com:bigdots/bigdots.github.io.git\n\t  branch: master\n\n## 二、更换主题\n*我这里使用的是[litten](http://litten.github.io/)的[yilia](https://github.com/litten/hexo-theme-yilia)主题，我们要对所有分享的人心怀感恩，没有他们就没有宇宙发展的今天!*\n\n#### 安装\n``` bash\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n修改blog根目录中的配置文件中的theme参数\n\n#### 配置文件 blog/themes/yilia/_config.yml\n\t# Header\n\tmenu:\n\t  主页: /\n\t  所有文章: /archives\n\t  随笔: /tags/随笔\n\n\t # SubNav\n\tsubnav:\n\t  github: https://github.com/bigdots\n\t  weibo: \"#\"\n\t  rss: \"#\"\n\t  zhihu: \"#\"\n\t  #douban: \"#\"\n\t  #mail: \"#\"\n\t  #facebook: \"#\"\n\t  #google: \"#\"\n\t  #twitter: \"#\"\n\t  #linkedin: \"#\"\n\n\t rss: /atom.xml\n\n\t # Content\n\texcerpt_link: more\n\tfancybox: true\n\tmathjax: true\n\n\t #是否开启动画效果\n\tanimate: true\n\n\t #是否在新窗口打开链接\n\topen_in_new: false\n\n\t #Miscellaneous 谷歌统计，考虑到谷歌被强我用的是百度统计\n\tgoogle_analytics: ''\n\tfavicon: /img/favicon.ico\n\n\t #你的头像url  ‘/’为根目录\n\tavatar: /img/thumb.jpg\n\t#是否开启分享\n\tshare: true\n\t#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n\t#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\n\tduoshuo: true\n\t#是否开启云标签\n\ttagcloud: true\n\n\t #是否开启友情链接\n\t#不开启——\n\t#friends: false\n\t#开启——\n\t#friends:\n\t#奥巴马的博客: http://localhost:4000/\n\t#卡卡的美丽传说: http://localhost:4000/\n\t#本泽马的博客: http://localhost:4000/\n\t#吉格斯的博客: http://localhost:4000/\n\t#习大大大不同: http://localhost:4000/\n\t#托蒂的博客: http://localhost:4000/\n\n\t #是否开启“关于我”。\n\t#不开启——\n\t#aboutme: false\n\t#开启——\n\taboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n\n## 最后一役\n\n#### 1.修改配置文件中的Deployment一项\n\t# Deployment  \n\tdeploy: \n\t  type: git\n\t  repository: yoursshsite\n\t  branch: master\n\n其中repository参数的值直接在github上复制即可，如图。\n![](/images/201511/7.png)\n\n#### 2.清除github上篇所建仓库的原文件\n由于上篇（一）选过了主题，所以我们得先清除其原文件，将文件clone到本地，删除除readme之外的所有文件，然后将修改提交到github。\n\n#### 3.部署\n在blog根目录下执行：\n`生成public文件`\n``` bash\n$ hexo g   \n```\n`部署到github`\n``` bash\n$ hexo d  \n```\n\n但我这里用git执行上面的命令行报了一个下面的错误\n``` bash\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n最后我是用git shell来执行上诉命令行成功部署的。据网上说产生上面问题的原因是git版本过高，愿意的可以试试git1.9。\n\n---\n<b>That'all</b>","source":"_posts/github-hexo构建静态博客（二）.md","raw":"title: github+hexo构建静态博客（二）\ndate: 2015-11-23 18:46:49\ndescription: 静态建站 hexo github 免费建站 自己的博客\ntags: [其他]\n---\n\n## 一、安装Hexo\n\n在本机全局安装hexo\n``` bash\n$ npm install –g hexo\n```\n创建并初始化blog、文件\n``` bash\n$ hexo init blog   \n```\n\n进入blog文件夹\n``` bash\n$ cd blog    \n```\n<!-- more -->\n安装npm模块\n``` bash\n$ npm install   \n```\n启动服务\n``` bash\n$ hexo server   \n```\n\n#### 目录结构\n\t_config.yml       配置文件\n\tnode_modules      模块\n\tpublic            执行hexo -g后生成的最终文件\n\tscaffolds\t\t  文章模版格式\n\tsource  \t\t  新文章生成，以及资源文件存放处\n\tthemes\t\t\t  主题\n\tdb.json     \n\tpackage.json  \n\tREADME.md  \n\n#### 配置文件 blog/_config.yml\n\t# Hexo Configuration\n\t## Docs: http://hexo.io/docs/configuration.html\n\t## Source: https://github.com/hexojs/hexo/\n\n\t# Site 站点\n\ttitle: bigdots\n\tsubtitle:\n\tdescription:\n\tauthor: Brand\n\tlanguage:\n\ttimezone:\n\n\t# URL 设置根路径和网站地址\n\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://bigdots.github.io\n\troot: /\n\tpermalink: :year/:month/:day/:title/\n\tpermalink_defaults:\n\n\t# Directory 设置各个文件路径地址\n\tsource_dir: source\n\tpublic_dir: public\n\ttag_dir: tags\n\tarchive_dir: archives\n\tcategory_dir: categories\n\tcode_dir: downloads/code\n\ti18n_dir: :lang\n\tskip_render:\n\n\t# Writing \n\tnew_post_name: :title.md # File name of new posts\n\tdefault_layout: post\n\ttitlecase: false # Transform title into titlecase\n\texternal_link: true # Open external links in new tab\n\tfilename_case: 0\n\trender_drafts: false\n\tpost_asset_folder: false\n\trelative_link: false\n\tfuture: true\n\thighlight:\n\t  enable: true\n\t  line_number: true\n\t  auto_detect: true\n\t  tab_replace:\n\n\t# Category & Tag  分类和标签\n\tdefault_category: uncategorized\n\tcategory_map:\n\ttag_map:\n\n\t# Date / Time format  时间格式\n\t## Hexo uses Moment.js to parse and display date\n\t## You can customize the date format as defined in\n\t## http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY-MM-DD\n\ttime_format: HH:mm:ss\n\n\t# Pagination\n\t## Set per_page to 0 to disable pagination\n\tper_page: 10\n\tpagination_dir: page\n\n\t# Extensions  主题和插件\n\t## Plugins: http://hexo.io/plugins/\n\t## Themes: http://hexo.io/themes/\n\ttheme: yilia\n\n\t# Deployment  部署\n\t## Docs: http://hexo.io/docs/deployment.html\n\tdeploy: \n\t  type: git\n\t  repository: git@github.com:bigdots/bigdots.github.io.git\n\t  branch: master\n\n## 二、更换主题\n*我这里使用的是[litten](http://litten.github.io/)的[yilia](https://github.com/litten/hexo-theme-yilia)主题，我们要对所有分享的人心怀感恩，没有他们就没有宇宙发展的今天!*\n\n#### 安装\n``` bash\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n修改blog根目录中的配置文件中的theme参数\n\n#### 配置文件 blog/themes/yilia/_config.yml\n\t# Header\n\tmenu:\n\t  主页: /\n\t  所有文章: /archives\n\t  随笔: /tags/随笔\n\n\t # SubNav\n\tsubnav:\n\t  github: https://github.com/bigdots\n\t  weibo: \"#\"\n\t  rss: \"#\"\n\t  zhihu: \"#\"\n\t  #douban: \"#\"\n\t  #mail: \"#\"\n\t  #facebook: \"#\"\n\t  #google: \"#\"\n\t  #twitter: \"#\"\n\t  #linkedin: \"#\"\n\n\t rss: /atom.xml\n\n\t # Content\n\texcerpt_link: more\n\tfancybox: true\n\tmathjax: true\n\n\t #是否开启动画效果\n\tanimate: true\n\n\t #是否在新窗口打开链接\n\topen_in_new: false\n\n\t #Miscellaneous 谷歌统计，考虑到谷歌被强我用的是百度统计\n\tgoogle_analytics: ''\n\tfavicon: /img/favicon.ico\n\n\t #你的头像url  ‘/’为根目录\n\tavatar: /img/thumb.jpg\n\t#是否开启分享\n\tshare: true\n\t#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n\t#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\n\tduoshuo: true\n\t#是否开启云标签\n\ttagcloud: true\n\n\t #是否开启友情链接\n\t#不开启——\n\t#friends: false\n\t#开启——\n\t#friends:\n\t#奥巴马的博客: http://localhost:4000/\n\t#卡卡的美丽传说: http://localhost:4000/\n\t#本泽马的博客: http://localhost:4000/\n\t#吉格斯的博客: http://localhost:4000/\n\t#习大大大不同: http://localhost:4000/\n\t#托蒂的博客: http://localhost:4000/\n\n\t #是否开启“关于我”。\n\t#不开启——\n\t#aboutme: false\n\t#开启——\n\taboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n\n## 最后一役\n\n#### 1.修改配置文件中的Deployment一项\n\t# Deployment  \n\tdeploy: \n\t  type: git\n\t  repository: yoursshsite\n\t  branch: master\n\n其中repository参数的值直接在github上复制即可，如图。\n![](/images/201511/7.png)\n\n#### 2.清除github上篇所建仓库的原文件\n由于上篇（一）选过了主题，所以我们得先清除其原文件，将文件clone到本地，删除除readme之外的所有文件，然后将修改提交到github。\n\n#### 3.部署\n在blog根目录下执行：\n`生成public文件`\n``` bash\n$ hexo g   \n```\n`部署到github`\n``` bash\n$ hexo d  \n```\n\n但我这里用git执行上面的命令行报了一个下面的错误\n``` bash\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n最后我是用git shell来执行上诉命令行成功部署的。据网上说产生上面问题的原因是git版本过高，愿意的可以试试git1.9。\n\n---\n<b>That'all</b>","slug":"github-hexo构建静态博客（二）","published":1,"updated":"2021-12-06T06:07:06.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwola001ry4v2ejeubr98","content":"<h2 id=\"一、安装Hexo\"><a href=\"#一、安装Hexo\" class=\"headerlink\" title=\"一、安装Hexo\"></a>一、安装Hexo</h2><p>在本机全局安装hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install –g hexo</span><br></pre></td></tr></table></figure>\n<p>创建并初始化blog、文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog   </span><br></pre></td></tr></table></figure>\n\n<p>进入blog文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> blog    </span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>安装npm模块</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install   </span><br></pre></td></tr></table></figure>\n<p>启动服务</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server   </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><pre><code>_config.yml       配置文件\nnode_modules      模块\npublic            执行hexo -g后生成的最终文件\nscaffolds          文章模版格式\nsource            新文章生成，以及资源文件存放处\nthemes              主题\ndb.json     \npackage.json  \nREADME.md  \n</code></pre>\n<h4 id=\"配置文件-blog-config-yml\"><a href=\"#配置文件-blog-config-yml\" class=\"headerlink\" title=\"配置文件 blog/_config.yml\"></a>配置文件 blog/_config.yml</h4><pre><code># Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site 站点\ntitle: bigdots\nsubtitle:\ndescription:\nauthor: Brand\nlanguage:\ntimezone:\n\n# URL 设置根路径和网站地址\n## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;\nurl: http://bigdots.github.io\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory 设置各个文件路径地址\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing \nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category &amp; Tag  分类和标签\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format  时间格式\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions  主题和插件\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: yilia\n\n# Deployment  部署\n## Docs: http://hexo.io/docs/deployment.html\ndeploy: \n  type: git\n  repository: git@github.com:bigdots/bigdots.github.io.git\n  branch: master\n</code></pre>\n<h2 id=\"二、更换主题\"><a href=\"#二、更换主题\" class=\"headerlink\" title=\"二、更换主题\"></a>二、更换主题</h2><p><em>我这里使用的是<a href=\"http://litten.github.io/\">litten</a>的<a href=\"https://github.com/litten/hexo-theme-yilia\">yilia</a>主题，我们要对所有分享的人心怀感恩，没有他们就没有宇宙发展的今天!</em></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>\n\n<p>修改blog根目录中的配置文件中的theme参数</p>\n<h4 id=\"配置文件-blog-themes-yilia-config-yml\"><a href=\"#配置文件-blog-themes-yilia-config-yml\" class=\"headerlink\" title=\"配置文件 blog/themes/yilia/_config.yml\"></a>配置文件 blog/themes/yilia/_config.yml</h4><pre><code># Header\nmenu:\n  主页: /\n  所有文章: /archives\n  随笔: /tags/随笔\n\n # SubNav\nsubnav:\n  github: https://github.com/bigdots\n  weibo: &quot;#&quot;\n  rss: &quot;#&quot;\n  zhihu: &quot;#&quot;\n  #douban: &quot;#&quot;\n  #mail: &quot;#&quot;\n  #facebook: &quot;#&quot;\n  #google: &quot;#&quot;\n  #twitter: &quot;#&quot;\n  #linkedin: &quot;#&quot;\n\n rss: /atom.xml\n\n # Content\nexcerpt_link: more\nfancybox: true\nmathjax: true\n\n #是否开启动画效果\nanimate: true\n\n #是否在新窗口打开链接\nopen_in_new: false\n\n #Miscellaneous 谷歌统计，考虑到谷歌被强我用的是百度统计\ngoogle_analytics: &#39;&#39;\nfavicon: /img/favicon.ico\n\n #你的头像url  ‘/’为根目录\navatar: /img/thumb.jpg\n#是否开启分享\nshare: true\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: true\n#是否开启云标签\ntagcloud: true\n\n #是否开启友情链接\n#不开启——\n#friends: false\n#开启——\n#friends:\n#奥巴马的博客: http://localhost:4000/\n#卡卡的美丽传说: http://localhost:4000/\n#本泽马的博客: http://localhost:4000/\n#吉格斯的博客: http://localhost:4000/\n#习大大大不同: http://localhost:4000/\n#托蒂的博客: http://localhost:4000/\n\n #是否开启“关于我”。\n#不开启——\n#aboutme: false\n#开启——\naboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n</code></pre>\n<h2 id=\"最后一役\"><a href=\"#最后一役\" class=\"headerlink\" title=\"最后一役\"></a>最后一役</h2><h4 id=\"1-修改配置文件中的Deployment一项\"><a href=\"#1-修改配置文件中的Deployment一项\" class=\"headerlink\" title=\"1.修改配置文件中的Deployment一项\"></a>1.修改配置文件中的Deployment一项</h4><pre><code># Deployment  \ndeploy: \n  type: git\n  repository: yoursshsite\n  branch: master\n</code></pre>\n<p>其中repository参数的值直接在github上复制即可，如图。<br><img src=\"/images/201511/7.png\"></p>\n<h4 id=\"2-清除github上篇所建仓库的原文件\"><a href=\"#2-清除github上篇所建仓库的原文件\" class=\"headerlink\" title=\"2.清除github上篇所建仓库的原文件\"></a>2.清除github上篇所建仓库的原文件</h4><p>由于上篇（一）选过了主题，所以我们得先清除其原文件，将文件clone到本地，删除除readme之外的所有文件，然后将修改提交到github。</p>\n<h4 id=\"3-部署\"><a href=\"#3-部署\" class=\"headerlink\" title=\"3.部署\"></a>3.部署</h4><p>在blog根目录下执行：<br><code>生成public文件</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g   </span><br></pre></td></tr></table></figure>\n<p><code>部署到github</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d  </span><br></pre></td></tr></table></figure>\n\n<p>但我这里用git执行上面的命令行报了一个下面的错误</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fatal: Could not <span class=\"built_in\">read</span> from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br><span class=\"line\">FATAL Something<span class=\"string\">&#x27;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span></span><br><span class=\"line\"><span class=\"string\">Error: Permission denied (publickey).</span></span><br><span class=\"line\"><span class=\"string\">fatal: Could not read from remote repository.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Please make sure you have the correct access rights</span></span><br><span class=\"line\"><span class=\"string\">and the repository exists.</span></span><br></pre></td></tr></table></figure>\n\n<p>最后我是用git shell来执行上诉命令行成功部署的。据网上说产生上面问题的原因是git版本过高，愿意的可以试试git1.9。</p>\n<hr>\n<p><b>That’all</b></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、安装Hexo\"><a href=\"#一、安装Hexo\" class=\"headerlink\" title=\"一、安装Hexo\"></a>一、安装Hexo</h2><p>在本机全局安装hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install –g hexo</span><br></pre></td></tr></table></figure>\n<p>创建并初始化blog、文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog   </span><br></pre></td></tr></table></figure>\n\n<p>进入blog文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> blog    </span><br></pre></td></tr></table></figure>","more":"<p>安装npm模块</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install   </span><br></pre></td></tr></table></figure>\n<p>启动服务</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server   </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><pre><code>_config.yml       配置文件\nnode_modules      模块\npublic            执行hexo -g后生成的最终文件\nscaffolds          文章模版格式\nsource            新文章生成，以及资源文件存放处\nthemes              主题\ndb.json     \npackage.json  \nREADME.md  \n</code></pre>\n<h4 id=\"配置文件-blog-config-yml\"><a href=\"#配置文件-blog-config-yml\" class=\"headerlink\" title=\"配置文件 blog/_config.yml\"></a>配置文件 blog/_config.yml</h4><pre><code># Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site 站点\ntitle: bigdots\nsubtitle:\ndescription:\nauthor: Brand\nlanguage:\ntimezone:\n\n# URL 设置根路径和网站地址\n## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;\nurl: http://bigdots.github.io\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory 设置各个文件路径地址\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing \nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category &amp; Tag  分类和标签\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format  时间格式\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions  主题和插件\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: yilia\n\n# Deployment  部署\n## Docs: http://hexo.io/docs/deployment.html\ndeploy: \n  type: git\n  repository: git@github.com:bigdots/bigdots.github.io.git\n  branch: master\n</code></pre>\n<h2 id=\"二、更换主题\"><a href=\"#二、更换主题\" class=\"headerlink\" title=\"二、更换主题\"></a>二、更换主题</h2><p><em>我这里使用的是<a href=\"http://litten.github.io/\">litten</a>的<a href=\"https://github.com/litten/hexo-theme-yilia\">yilia</a>主题，我们要对所有分享的人心怀感恩，没有他们就没有宇宙发展的今天!</em></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>\n\n<p>修改blog根目录中的配置文件中的theme参数</p>\n<h4 id=\"配置文件-blog-themes-yilia-config-yml\"><a href=\"#配置文件-blog-themes-yilia-config-yml\" class=\"headerlink\" title=\"配置文件 blog/themes/yilia/_config.yml\"></a>配置文件 blog/themes/yilia/_config.yml</h4><pre><code># Header\nmenu:\n  主页: /\n  所有文章: /archives\n  随笔: /tags/随笔\n\n # SubNav\nsubnav:\n  github: https://github.com/bigdots\n  weibo: &quot;#&quot;\n  rss: &quot;#&quot;\n  zhihu: &quot;#&quot;\n  #douban: &quot;#&quot;\n  #mail: &quot;#&quot;\n  #facebook: &quot;#&quot;\n  #google: &quot;#&quot;\n  #twitter: &quot;#&quot;\n  #linkedin: &quot;#&quot;\n\n rss: /atom.xml\n\n # Content\nexcerpt_link: more\nfancybox: true\nmathjax: true\n\n #是否开启动画效果\nanimate: true\n\n #是否在新窗口打开链接\nopen_in_new: false\n\n #Miscellaneous 谷歌统计，考虑到谷歌被强我用的是百度统计\ngoogle_analytics: &#39;&#39;\nfavicon: /img/favicon.ico\n\n #你的头像url  ‘/’为根目录\navatar: /img/thumb.jpg\n#是否开启分享\nshare: true\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: true\n#是否开启云标签\ntagcloud: true\n\n #是否开启友情链接\n#不开启——\n#friends: false\n#开启——\n#friends:\n#奥巴马的博客: http://localhost:4000/\n#卡卡的美丽传说: http://localhost:4000/\n#本泽马的博客: http://localhost:4000/\n#吉格斯的博客: http://localhost:4000/\n#习大大大不同: http://localhost:4000/\n#托蒂的博客: http://localhost:4000/\n\n #是否开启“关于我”。\n#不开启——\n#aboutme: false\n#开启——\naboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n</code></pre>\n<h2 id=\"最后一役\"><a href=\"#最后一役\" class=\"headerlink\" title=\"最后一役\"></a>最后一役</h2><h4 id=\"1-修改配置文件中的Deployment一项\"><a href=\"#1-修改配置文件中的Deployment一项\" class=\"headerlink\" title=\"1.修改配置文件中的Deployment一项\"></a>1.修改配置文件中的Deployment一项</h4><pre><code># Deployment  \ndeploy: \n  type: git\n  repository: yoursshsite\n  branch: master\n</code></pre>\n<p>其中repository参数的值直接在github上复制即可，如图。<br><img src=\"/images/201511/7.png\"></p>\n<h4 id=\"2-清除github上篇所建仓库的原文件\"><a href=\"#2-清除github上篇所建仓库的原文件\" class=\"headerlink\" title=\"2.清除github上篇所建仓库的原文件\"></a>2.清除github上篇所建仓库的原文件</h4><p>由于上篇（一）选过了主题，所以我们得先清除其原文件，将文件clone到本地，删除除readme之外的所有文件，然后将修改提交到github。</p>\n<h4 id=\"3-部署\"><a href=\"#3-部署\" class=\"headerlink\" title=\"3.部署\"></a>3.部署</h4><p>在blog根目录下执行：<br><code>生成public文件</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g   </span><br></pre></td></tr></table></figure>\n<p><code>部署到github</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d  </span><br></pre></td></tr></table></figure>\n\n<p>但我这里用git执行上面的命令行报了一个下面的错误</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fatal: Could not <span class=\"built_in\">read</span> from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br><span class=\"line\">FATAL Something<span class=\"string\">&#x27;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span></span><br><span class=\"line\"><span class=\"string\">Error: Permission denied (publickey).</span></span><br><span class=\"line\"><span class=\"string\">fatal: Could not read from remote repository.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Please make sure you have the correct access rights</span></span><br><span class=\"line\"><span class=\"string\">and the repository exists.</span></span><br></pre></td></tr></table></figure>\n\n<p>最后我是用git shell来执行上诉命令行成功部署的。据网上说产生上面问题的原因是git版本过高，愿意的可以试试git1.9。</p>\n<hr>\n<p><b>That’all</b></p>"},{"_content":"# javascript中的prototype和constructor #\n\n## 构造函数 ##\n我们知道，ECMAScript5中的Object、Array、Date、RegExp、Function等引用类型都是基于构造函数的,他们本身就是ECMAScript5原生的构造函数。比如，我们可以这样申明一个对象：\n\n\tvar person = new Object();\n这里的Object类型的构造函数就是一个名为Object的构造函数，然后通过new来实例化这个构造函数，从而获得一个新的实例对象。同理，Array、Date等其他类型也是一样。\n\n我们又知道，原型对象包含了特定类型的所有实例共享的属性和方法，这样一来，对于toString()、toValue()这些函数是不是也豁然开朗了，这些函数就是定义在上述特定类型的原型对象上的，所以它们的每一个实例都可以访问。\n\n## prototype和constructor ##\n\n1. prototype\n\n\t每一个函数都包含prototype属性，这个属性是一个指针，指向原型对象()。对于引用类型而言，prototype 是保存它们所有实例方法的真正所在。\n\n\n2. constructor\n\n\t每一个object对象都包含有constructor属性，该属性保存着用于创建当前对象的函数。\n\n> 构造函数每个实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第5 版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari 和Chrome 在每个对象上都支持一个属性__proto__\n\n看了几遍还是觉得绕，还是画个图看下：\n\n![](http://images.cnblogs.com/cnblogs_com/yzg1/855692/o_prototype_constructor.png)","source":"_posts/javascript中的prototype和constructor.md","raw":"# javascript中的prototype和constructor #\n\n## 构造函数 ##\n我们知道，ECMAScript5中的Object、Array、Date、RegExp、Function等引用类型都是基于构造函数的,他们本身就是ECMAScript5原生的构造函数。比如，我们可以这样申明一个对象：\n\n\tvar person = new Object();\n这里的Object类型的构造函数就是一个名为Object的构造函数，然后通过new来实例化这个构造函数，从而获得一个新的实例对象。同理，Array、Date等其他类型也是一样。\n\n我们又知道，原型对象包含了特定类型的所有实例共享的属性和方法，这样一来，对于toString()、toValue()这些函数是不是也豁然开朗了，这些函数就是定义在上述特定类型的原型对象上的，所以它们的每一个实例都可以访问。\n\n## prototype和constructor ##\n\n1. prototype\n\n\t每一个函数都包含prototype属性，这个属性是一个指针，指向原型对象()。对于引用类型而言，prototype 是保存它们所有实例方法的真正所在。\n\n\n2. constructor\n\n\t每一个object对象都包含有constructor属性，该属性保存着用于创建当前对象的函数。\n\n> 构造函数每个实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第5 版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari 和Chrome 在每个对象上都支持一个属性__proto__\n\n看了几遍还是觉得绕，还是画个图看下：\n\n![](http://images.cnblogs.com/cnblogs_com/yzg1/855692/o_prototype_constructor.png)","slug":"javascript中的prototype和constructor","published":1,"date":"2021-12-06T06:07:06.153Z","updated":"2021-12-06T06:07:06.153Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolb001uy4v22jnfax5z","content":"<h1 id=\"javascript中的prototype和constructor\"><a href=\"#javascript中的prototype和constructor\" class=\"headerlink\" title=\"javascript中的prototype和constructor\"></a>javascript中的prototype和constructor</h1><h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>我们知道，ECMAScript5中的Object、Array、Date、RegExp、Function等引用类型都是基于构造函数的,他们本身就是ECMAScript5原生的构造函数。比如，我们可以这样申明一个对象：</p>\n<pre><code>var person = new Object();\n</code></pre>\n<p>这里的Object类型的构造函数就是一个名为Object的构造函数，然后通过new来实例化这个构造函数，从而获得一个新的实例对象。同理，Array、Date等其他类型也是一样。</p>\n<p>我们又知道，原型对象包含了特定类型的所有实例共享的属性和方法，这样一来，对于toString()、toValue()这些函数是不是也豁然开朗了，这些函数就是定义在上述特定类型的原型对象上的，所以它们的每一个实例都可以访问。</p>\n<h2 id=\"prototype和constructor\"><a href=\"#prototype和constructor\" class=\"headerlink\" title=\"prototype和constructor\"></a>prototype和constructor</h2><ol>\n<li><p>prototype</p>\n<p> 每一个函数都包含prototype属性，这个属性是一个指针，指向原型对象()。对于引用类型而言，prototype 是保存它们所有实例方法的真正所在。</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>constructor</p>\n<p> 每一个object对象都包含有constructor属性，该属性保存着用于创建当前对象的函数。</p>\n</li>\n</ol>\n<blockquote>\n<p>构造函数每个实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第5 版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari 和Chrome 在每个对象上都支持一个属性__proto__</p>\n</blockquote>\n<p>看了几遍还是觉得绕，还是画个图看下：</p>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/yzg1/855692/o_prototype_constructor.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"javascript中的prototype和constructor\"><a href=\"#javascript中的prototype和constructor\" class=\"headerlink\" title=\"javascript中的prototype和constructor\"></a>javascript中的prototype和constructor</h1><h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>我们知道，ECMAScript5中的Object、Array、Date、RegExp、Function等引用类型都是基于构造函数的,他们本身就是ECMAScript5原生的构造函数。比如，我们可以这样申明一个对象：</p>\n<pre><code>var person = new Object();\n</code></pre>\n<p>这里的Object类型的构造函数就是一个名为Object的构造函数，然后通过new来实例化这个构造函数，从而获得一个新的实例对象。同理，Array、Date等其他类型也是一样。</p>\n<p>我们又知道，原型对象包含了特定类型的所有实例共享的属性和方法，这样一来，对于toString()、toValue()这些函数是不是也豁然开朗了，这些函数就是定义在上述特定类型的原型对象上的，所以它们的每一个实例都可以访问。</p>\n<h2 id=\"prototype和constructor\"><a href=\"#prototype和constructor\" class=\"headerlink\" title=\"prototype和constructor\"></a>prototype和constructor</h2><ol>\n<li><p>prototype</p>\n<p> 每一个函数都包含prototype属性，这个属性是一个指针，指向原型对象()。对于引用类型而言，prototype 是保存它们所有实例方法的真正所在。</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>constructor</p>\n<p> 每一个object对象都包含有constructor属性，该属性保存着用于创建当前对象的函数。</p>\n</li>\n</ol>\n<blockquote>\n<p>构造函数每个实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第5 版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari 和Chrome 在每个对象上都支持一个属性__proto__</p>\n</blockquote>\n<p>看了几遍还是觉得绕，还是画个图看下：</p>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/yzg1/855692/o_prototype_constructor.png\"></p>\n"},{"title":"javascript中的继承","date":"2016-03-18T02:36:42.000Z","description":null,"_content":"\n继承有什么好处？很简单，继承了你爸的财产，自己就可以少奋斗点嘛。开玩笑，言归正传，继承使子类拥有超类的作用域、属性与方法，可以节省程序设计的时间。ECMAScript实现继承主要方式是依靠原型链。\n\n<!-- more -->\n\n## 原型链方式——不建议使用\n\n```js\nfunction SuperType(){\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nfunction SubType(){\n}\n//利用原型链继承\nSubType.prototype = new SuperType();\nvar instance1 = new SubType();\nconsole.log(instance1.colors) //[\"red\", \"blue\", \"green\"]\n```\n\n上例中，通过`SubType.prototype = new SuperType()`使SubType的原型链上增加了SuperType()这一环。从而使SubType 通过原型链继承了SuperType的`color`属性。\n\n**存在的问题：**\n\n1. 实例共享\n在上面的例子中加入以下代码，发现SubType()的实例1对`color`属性做出改变后，实例2获取到的`color`属性是改变后的值。这是因为：\n >每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。\n```\ninstance1.colors.push(\"black\");\nconsole.log(instance1.colors); //[\"red\", \"blue\", \"green\", \"black\", \"black\"]\nvar instance2 = new SubType();\nconsole.log(instance2.colors);//[\"red\", \"blue\", \"green\", \"black\", \"black\"]\n```\n + 首先，instance1和instance2都是SubType()的实例，这俩个实例都会包含一个指向原型对象的内部指针\n + SubType()的原型指向SuperType()的一个实例，而且这个实例指向的是SuperType()的原型对象\n + SuperType()的原型对象又指向SuperType()。最终，instance1.colors和instance2.colors的指向都是SuperType()的colors。\n2. 没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数，原理同上。\n\n\n## 构造函数方式——不建议使用\n\n```\nfunction SuperType(){\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nfunction SubType(){\n    //继承了SuperType\n    SuperType.call(this);\n}\nvar instance1 = new SubType();\nconsole.log(instance1.color)//[\"red\", \"blue\", \"green\"]\n```\n> 基本思想即在子类型构造函数的内部调用超类型构造函数。\n\n**call和apply**\n全局函数apply和call可以用来改变函数中this的指向。\n\n\n**存在的问题：**\n\n1. 子类型无法继承超类原型链，导致所有类型都只能使用构造函数模式；\n2. 方法都在构造函数中定义，函数无法复用。\n\n\n## 组合继承——最常用的继承模式\n\n```\nfunction SuperType(name){\n    this.name = name;\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function(){\n    console.log(this.name);\n};\nfunction SubType(name, age){\n    //继承属性\n    SuperType.call(this, name);   //第二次调用SuperType()\n    this.age = age;\n}\n//继承方法\nSubType.prototype = new SuperType(); //第一次调用SuperType()\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n};\nvar instance1 = new SubType(\"Nicholas\", 29);\ninstance1.colors.push(\"black\");\nconsole.log(instance1.colors); //\"red,blue,green,black\"\ninstance1.sayName(); //\"Nicholas\";\ninstance1.sayAge(); //29\nvar instance2 = new SubType(\"Greg\", 27);\nconsole.log(instance2.colors); //\"red,blue,green\"\ninstance2.sayName(); //\"Greg\";\ninstance2.sayAge();\n```\n基本思想：\n + 通过原型链来继承超类的sayName()方法；\n + 通过构造函数的方式来使SuperType()里的属性私有化；\n\n为什么可以实现属性私有化？\n + 第一次调用超类，SubType.prototype 会得到两个属性：name 和colors；它们都是SuperType 的实例属性，位于SubType 的原型中；\n + 第二次调用超类，在新对象上创建了实例属性name 和colors。于是，这两个属性就屏蔽了原型中的两个同名属性；\n\n**存在的问题：**\n无论什么情况下，都会调用两次超类型构造函数:：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部\n\n\n## 原型式继承\n```\nfunction object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\nvar person = {\n    name: \"Nicholas\",\n    friends: [\"Shelby\", \"Court\", \"Van\"]\n};\nvar anotherPerson = Object.create(person);\nanotherPerson.name = \"Greg\";\nanotherPerson.friends.push(\"Rob\");\nvar yetAnotherPerson = Object.create(person);\nyetAnotherPerson.name = \"Linda\";\nyetAnotherPerson.friends.push(\"Barbie\");\nconsole.log(person.friends); //[\"Shelby\", \"Court\", \"Van\", \"Rob\", \"Barbie\"]\n```\n*ECMAScript 5 通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象*\n\n+ 将person对象作为基础对象\n+ 把person对象传入到object()函数中，然后该函数就会返回一个新对象F()，这个新对象将person 作为原型\n+ 适用于让一个对象与另一个对象保持类似的情况\n\n**存在同原型链方式一样的问题**\n\n## 寄生式基础\n```\nfunction object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\nfunction createAnother(original){\n    var clone = object(original); //通过调用函数创建一个新对象\n    clone.sayHi = function(){ //以某种方式来增强这个对象\n    console.log(\"hi\");\n};\nreturn clone; //返回这个对象\n}\nvar person = {\n    name: \"Nicholas\",\n    friends: [\"Shelby\", \"Court\", \"Van\"]\n};\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi(); //\"hi\"\n```\n\n+ 将person对象作为基础对象\n+ 将基础对象传递给object()函数，将返回的新对象赋值给clone；（示范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。）\n+ 为clone 对象添加一个新方法sayHi()，最后返回clone 对象\n\n## 寄生组合式继承——被认为是引用类型最理想的继承范式\n\n```\nfunction object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\nfunction inheritPrototype(subType, superType){\n    var prototype = object(superType.prototype); //创建对象\n    prototype.constructor = subType; //增强对象\n    subType.prototype = prototype; //指定对象\n}\n\nfunction SuperType(name){\n    this.name = name;\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function(){\n    console.log(this.name);\n};\nfunction SubType(name, age){\n    SuperType.call(this, name); //调用一次SuperType()\n    this.age = age;\n}\ninheritPrototype(SubType, SuperType);\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n};\n\nvar instance1 = new SubType(\"Nicholas\", 29);\ninstance1.sayName();\nconsole.log(instance1.colors);\n```\n\n+ 将超类的原型对位基础对象，并且传递给object()函数，返回新对象赋值给prototype；\n+ 将子类的原型指向prototype，即超类的原型，这里继承了超类的sayName方法\n+ 子类中利用构造方法使子类上创建了name和colors属性\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n参考书籍：[《javascript高级程序设计》](#)","source":"_posts/javascript中的继承.md","raw":"title: javascript中的继承\ntags: [javascript]\ndate: 2016-03-18 10:36:42\ndescription:\n\n---\n\n继承有什么好处？很简单，继承了你爸的财产，自己就可以少奋斗点嘛。开玩笑，言归正传，继承使子类拥有超类的作用域、属性与方法，可以节省程序设计的时间。ECMAScript实现继承主要方式是依靠原型链。\n\n<!-- more -->\n\n## 原型链方式——不建议使用\n\n```js\nfunction SuperType(){\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nfunction SubType(){\n}\n//利用原型链继承\nSubType.prototype = new SuperType();\nvar instance1 = new SubType();\nconsole.log(instance1.colors) //[\"red\", \"blue\", \"green\"]\n```\n\n上例中，通过`SubType.prototype = new SuperType()`使SubType的原型链上增加了SuperType()这一环。从而使SubType 通过原型链继承了SuperType的`color`属性。\n\n**存在的问题：**\n\n1. 实例共享\n在上面的例子中加入以下代码，发现SubType()的实例1对`color`属性做出改变后，实例2获取到的`color`属性是改变后的值。这是因为：\n >每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。\n```\ninstance1.colors.push(\"black\");\nconsole.log(instance1.colors); //[\"red\", \"blue\", \"green\", \"black\", \"black\"]\nvar instance2 = new SubType();\nconsole.log(instance2.colors);//[\"red\", \"blue\", \"green\", \"black\", \"black\"]\n```\n + 首先，instance1和instance2都是SubType()的实例，这俩个实例都会包含一个指向原型对象的内部指针\n + SubType()的原型指向SuperType()的一个实例，而且这个实例指向的是SuperType()的原型对象\n + SuperType()的原型对象又指向SuperType()。最终，instance1.colors和instance2.colors的指向都是SuperType()的colors。\n2. 没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数，原理同上。\n\n\n## 构造函数方式——不建议使用\n\n```\nfunction SuperType(){\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nfunction SubType(){\n    //继承了SuperType\n    SuperType.call(this);\n}\nvar instance1 = new SubType();\nconsole.log(instance1.color)//[\"red\", \"blue\", \"green\"]\n```\n> 基本思想即在子类型构造函数的内部调用超类型构造函数。\n\n**call和apply**\n全局函数apply和call可以用来改变函数中this的指向。\n\n\n**存在的问题：**\n\n1. 子类型无法继承超类原型链，导致所有类型都只能使用构造函数模式；\n2. 方法都在构造函数中定义，函数无法复用。\n\n\n## 组合继承——最常用的继承模式\n\n```\nfunction SuperType(name){\n    this.name = name;\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function(){\n    console.log(this.name);\n};\nfunction SubType(name, age){\n    //继承属性\n    SuperType.call(this, name);   //第二次调用SuperType()\n    this.age = age;\n}\n//继承方法\nSubType.prototype = new SuperType(); //第一次调用SuperType()\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n};\nvar instance1 = new SubType(\"Nicholas\", 29);\ninstance1.colors.push(\"black\");\nconsole.log(instance1.colors); //\"red,blue,green,black\"\ninstance1.sayName(); //\"Nicholas\";\ninstance1.sayAge(); //29\nvar instance2 = new SubType(\"Greg\", 27);\nconsole.log(instance2.colors); //\"red,blue,green\"\ninstance2.sayName(); //\"Greg\";\ninstance2.sayAge();\n```\n基本思想：\n + 通过原型链来继承超类的sayName()方法；\n + 通过构造函数的方式来使SuperType()里的属性私有化；\n\n为什么可以实现属性私有化？\n + 第一次调用超类，SubType.prototype 会得到两个属性：name 和colors；它们都是SuperType 的实例属性，位于SubType 的原型中；\n + 第二次调用超类，在新对象上创建了实例属性name 和colors。于是，这两个属性就屏蔽了原型中的两个同名属性；\n\n**存在的问题：**\n无论什么情况下，都会调用两次超类型构造函数:：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部\n\n\n## 原型式继承\n```\nfunction object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\nvar person = {\n    name: \"Nicholas\",\n    friends: [\"Shelby\", \"Court\", \"Van\"]\n};\nvar anotherPerson = Object.create(person);\nanotherPerson.name = \"Greg\";\nanotherPerson.friends.push(\"Rob\");\nvar yetAnotherPerson = Object.create(person);\nyetAnotherPerson.name = \"Linda\";\nyetAnotherPerson.friends.push(\"Barbie\");\nconsole.log(person.friends); //[\"Shelby\", \"Court\", \"Van\", \"Rob\", \"Barbie\"]\n```\n*ECMAScript 5 通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象*\n\n+ 将person对象作为基础对象\n+ 把person对象传入到object()函数中，然后该函数就会返回一个新对象F()，这个新对象将person 作为原型\n+ 适用于让一个对象与另一个对象保持类似的情况\n\n**存在同原型链方式一样的问题**\n\n## 寄生式基础\n```\nfunction object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\nfunction createAnother(original){\n    var clone = object(original); //通过调用函数创建一个新对象\n    clone.sayHi = function(){ //以某种方式来增强这个对象\n    console.log(\"hi\");\n};\nreturn clone; //返回这个对象\n}\nvar person = {\n    name: \"Nicholas\",\n    friends: [\"Shelby\", \"Court\", \"Van\"]\n};\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi(); //\"hi\"\n```\n\n+ 将person对象作为基础对象\n+ 将基础对象传递给object()函数，将返回的新对象赋值给clone；（示范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。）\n+ 为clone 对象添加一个新方法sayHi()，最后返回clone 对象\n\n## 寄生组合式继承——被认为是引用类型最理想的继承范式\n\n```\nfunction object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\nfunction inheritPrototype(subType, superType){\n    var prototype = object(superType.prototype); //创建对象\n    prototype.constructor = subType; //增强对象\n    subType.prototype = prototype; //指定对象\n}\n\nfunction SuperType(name){\n    this.name = name;\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function(){\n    console.log(this.name);\n};\nfunction SubType(name, age){\n    SuperType.call(this, name); //调用一次SuperType()\n    this.age = age;\n}\ninheritPrototype(SubType, SuperType);\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n};\n\nvar instance1 = new SubType(\"Nicholas\", 29);\ninstance1.sayName();\nconsole.log(instance1.colors);\n```\n\n+ 将超类的原型对位基础对象，并且传递给object()函数，返回新对象赋值给prototype；\n+ 将子类的原型指向prototype，即超类的原型，这里继承了超类的sayName方法\n+ 子类中利用构造方法使子类上创建了name和colors属性\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n参考书籍：[《javascript高级程序设计》](#)","slug":"javascript中的继承","published":1,"updated":"2021-12-06T06:07:06.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolb001wy4v28r1ohfrb","content":"<p>继承有什么好处？很简单，继承了你爸的财产，自己就可以少奋斗点嘛。开玩笑，言归正传，继承使子类拥有超类的作用域、属性与方法，可以节省程序设计的时间。ECMAScript实现继承主要方式是依靠原型链。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"原型链方式——不建议使用\"><a href=\"#原型链方式——不建议使用\" class=\"headerlink\" title=\"原型链方式——不建议使用\"></a>原型链方式——不建议使用</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.colors = [<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>, <span class=\"string\">&quot;green&quot;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//利用原型链继承</span></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors) <span class=\"comment\">//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<p>上例中，通过<code>SubType.prototype = new SuperType()</code>使SubType的原型链上增加了SuperType()这一环。从而使SubType 通过原型链继承了SuperType的<code>color</code>属性。</p>\n<p><strong>存在的问题：</strong></p>\n<ol>\n<li>实例共享<br>在上面的例子中加入以下代码，发现SubType()的实例1对<code>color</code>属性做出改变后，实例2获取到的<code>color</code>属性是改变后的值。这是因为：<blockquote>\n<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instance1.colors.push(&quot;black&quot;);</span><br><span class=\"line\">console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;black&quot;]</span><br><span class=\"line\">var instance2 = new SubType();</span><br><span class=\"line\">console.log(instance2.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;black&quot;]</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>首先，instance1和instance2都是SubType()的实例，这俩个实例都会包含一个指向原型对象的内部指针</li>\n<li>SubType()的原型指向SuperType()的一个实例，而且这个实例指向的是SuperType()的原型对象</li>\n<li>SuperType()的原型对象又指向SuperType()。最终，instance1.colors和instance2.colors的指向都是SuperType()的colors。</li>\n</ul>\n<ol start=\"2\">\n<li>没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数，原理同上。</li>\n</ol>\n<h2 id=\"构造函数方式——不建议使用\"><a href=\"#构造函数方式——不建议使用\" class=\"headerlink\" title=\"构造函数方式——不建议使用\"></a>构造函数方式——不建议使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function SuperType()&#123;</span><br><span class=\"line\">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function SubType()&#123;</span><br><span class=\"line\">    //继承了SuperType</span><br><span class=\"line\">    SuperType.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var instance1 = new SubType();</span><br><span class=\"line\">console.log(instance1.color)//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>基本思想即在子类型构造函数的内部调用超类型构造函数。</p>\n</blockquote>\n<p><strong>call和apply</strong><br>全局函数apply和call可以用来改变函数中this的指向。</p>\n<p><strong>存在的问题：</strong></p>\n<ol>\n<li>子类型无法继承超类原型链，导致所有类型都只能使用构造函数模式；</li>\n<li>方法都在构造函数中定义，函数无法复用。</li>\n</ol>\n<h2 id=\"组合继承——最常用的继承模式\"><a href=\"#组合继承——最常用的继承模式\" class=\"headerlink\" title=\"组合继承——最常用的继承模式\"></a>组合继承——最常用的继承模式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function SuperType(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function SubType(name, age)&#123;</span><br><span class=\"line\">    //继承属性</span><br><span class=\"line\">    SuperType.call(this, name);   //第二次调用SuperType()</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//继承方法</span><br><span class=\"line\">SubType.prototype = new SuperType(); //第一次调用SuperType()</span><br><span class=\"line\">SubType.prototype.constructor = SubType;</span><br><span class=\"line\">SubType.prototype.sayAge = function()&#123;</span><br><span class=\"line\">    console.log(this.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var instance1 = new SubType(&quot;Nicholas&quot;, 29);</span><br><span class=\"line\">instance1.colors.push(&quot;black&quot;);</span><br><span class=\"line\">console.log(instance1.colors); //&quot;red,blue,green,black&quot;</span><br><span class=\"line\">instance1.sayName(); //&quot;Nicholas&quot;;</span><br><span class=\"line\">instance1.sayAge(); //29</span><br><span class=\"line\">var instance2 = new SubType(&quot;Greg&quot;, 27);</span><br><span class=\"line\">console.log(instance2.colors); //&quot;red,blue,green&quot;</span><br><span class=\"line\">instance2.sayName(); //&quot;Greg&quot;;</span><br><span class=\"line\">instance2.sayAge();</span><br></pre></td></tr></table></figure>\n<p>基本思想：</p>\n<ul>\n<li>通过原型链来继承超类的sayName()方法；</li>\n<li>通过构造函数的方式来使SuperType()里的属性私有化；</li>\n</ul>\n<p>为什么可以实现属性私有化？</p>\n<ul>\n<li>第一次调用超类，SubType.prototype 会得到两个属性：name 和colors；它们都是SuperType 的实例属性，位于SubType 的原型中；</li>\n<li>第二次调用超类，在新对象上创建了实例属性name 和colors。于是，这两个属性就屏蔽了原型中的两个同名属性；</li>\n</ul>\n<p><strong>存在的问题：</strong><br>无论什么情况下，都会调用两次超类型构造函数:：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部</p>\n<h2 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function object(o)&#123;</span><br><span class=\"line\">    function F()&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    name: &quot;Nicholas&quot;,</span><br><span class=\"line\">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var anotherPerson = Object.create(person);</span><br><span class=\"line\">anotherPerson.name = &quot;Greg&quot;;</span><br><span class=\"line\">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class=\"line\">var yetAnotherPerson = Object.create(person);</span><br><span class=\"line\">yetAnotherPerson.name = &quot;Linda&quot;;</span><br><span class=\"line\">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class=\"line\">console.log(person.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;]</span><br></pre></td></tr></table></figure>\n<p><em>ECMAScript 5 通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象</em></p>\n<ul>\n<li>将person对象作为基础对象</li>\n<li>把person对象传入到object()函数中，然后该函数就会返回一个新对象F()，这个新对象将person 作为原型</li>\n<li>适用于让一个对象与另一个对象保持类似的情况</li>\n</ul>\n<p><strong>存在同原型链方式一样的问题</strong></p>\n<h2 id=\"寄生式基础\"><a href=\"#寄生式基础\" class=\"headerlink\" title=\"寄生式基础\"></a>寄生式基础</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function object(o)&#123;</span><br><span class=\"line\">    function F()&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function createAnother(original)&#123;</span><br><span class=\"line\">    var clone = object(original); //通过调用函数创建一个新对象</span><br><span class=\"line\">    clone.sayHi = function()&#123; //以某种方式来增强这个对象</span><br><span class=\"line\">    console.log(&quot;hi&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">return clone; //返回这个对象</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    name: &quot;Nicholas&quot;,</span><br><span class=\"line\">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var anotherPerson = createAnother(person);</span><br><span class=\"line\">anotherPerson.sayHi(); //&quot;hi&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>将person对象作为基础对象</li>\n<li>将基础对象传递给object()函数，将返回的新对象赋值给clone；（示范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。）</li>\n<li>为clone 对象添加一个新方法sayHi()，最后返回clone 对象</li>\n</ul>\n<h2 id=\"寄生组合式继承——被认为是引用类型最理想的继承范式\"><a href=\"#寄生组合式继承——被认为是引用类型最理想的继承范式\" class=\"headerlink\" title=\"寄生组合式继承——被认为是引用类型最理想的继承范式\"></a>寄生组合式继承——被认为是引用类型最理想的继承范式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function object(o)&#123;</span><br><span class=\"line\">    function F()&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function inheritPrototype(subType, superType)&#123;</span><br><span class=\"line\">    var prototype = object(superType.prototype); //创建对象</span><br><span class=\"line\">    prototype.constructor = subType; //增强对象</span><br><span class=\"line\">    subType.prototype = prototype; //指定对象</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function SuperType(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function SubType(name, age)&#123;</span><br><span class=\"line\">    SuperType.call(this, name); //调用一次SuperType()</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">inheritPrototype(SubType, SuperType);</span><br><span class=\"line\">SubType.prototype.sayAge = function()&#123;</span><br><span class=\"line\">    console.log(this.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var instance1 = new SubType(&quot;Nicholas&quot;, 29);</span><br><span class=\"line\">instance1.sayName();</span><br><span class=\"line\">console.log(instance1.colors);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>将超类的原型对位基础对象，并且传递给object()函数，返回新对象赋值给prototype；</li>\n<li>将子类的原型指向prototype，即超类的原型，这里继承了超类的sayName方法</li>\n<li>子类中利用构造方法使子类上创建了name和colors属性</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>参考书籍：<a href=\"#\">《javascript高级程序设计》</a></p>\n","site":{"data":{}},"excerpt":"<p>继承有什么好处？很简单，继承了你爸的财产，自己就可以少奋斗点嘛。开玩笑，言归正传，继承使子类拥有超类的作用域、属性与方法，可以节省程序设计的时间。ECMAScript实现继承主要方式是依靠原型链。</p>","more":"<h2 id=\"原型链方式——不建议使用\"><a href=\"#原型链方式——不建议使用\" class=\"headerlink\" title=\"原型链方式——不建议使用\"></a>原型链方式——不建议使用</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.colors = [<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>, <span class=\"string\">&quot;green&quot;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//利用原型链继承</span></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors) <span class=\"comment\">//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<p>上例中，通过<code>SubType.prototype = new SuperType()</code>使SubType的原型链上增加了SuperType()这一环。从而使SubType 通过原型链继承了SuperType的<code>color</code>属性。</p>\n<p><strong>存在的问题：</strong></p>\n<ol>\n<li>实例共享<br>在上面的例子中加入以下代码，发现SubType()的实例1对<code>color</code>属性做出改变后，实例2获取到的<code>color</code>属性是改变后的值。这是因为：<blockquote>\n<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instance1.colors.push(&quot;black&quot;);</span><br><span class=\"line\">console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;black&quot;]</span><br><span class=\"line\">var instance2 = new SubType();</span><br><span class=\"line\">console.log(instance2.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;black&quot;]</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>首先，instance1和instance2都是SubType()的实例，这俩个实例都会包含一个指向原型对象的内部指针</li>\n<li>SubType()的原型指向SuperType()的一个实例，而且这个实例指向的是SuperType()的原型对象</li>\n<li>SuperType()的原型对象又指向SuperType()。最终，instance1.colors和instance2.colors的指向都是SuperType()的colors。</li>\n</ul>\n<ol start=\"2\">\n<li>没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数，原理同上。</li>\n</ol>\n<h2 id=\"构造函数方式——不建议使用\"><a href=\"#构造函数方式——不建议使用\" class=\"headerlink\" title=\"构造函数方式——不建议使用\"></a>构造函数方式——不建议使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function SuperType()&#123;</span><br><span class=\"line\">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function SubType()&#123;</span><br><span class=\"line\">    //继承了SuperType</span><br><span class=\"line\">    SuperType.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var instance1 = new SubType();</span><br><span class=\"line\">console.log(instance1.color)//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>基本思想即在子类型构造函数的内部调用超类型构造函数。</p>\n</blockquote>\n<p><strong>call和apply</strong><br>全局函数apply和call可以用来改变函数中this的指向。</p>\n<p><strong>存在的问题：</strong></p>\n<ol>\n<li>子类型无法继承超类原型链，导致所有类型都只能使用构造函数模式；</li>\n<li>方法都在构造函数中定义，函数无法复用。</li>\n</ol>\n<h2 id=\"组合继承——最常用的继承模式\"><a href=\"#组合继承——最常用的继承模式\" class=\"headerlink\" title=\"组合继承——最常用的继承模式\"></a>组合继承——最常用的继承模式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function SuperType(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function SubType(name, age)&#123;</span><br><span class=\"line\">    //继承属性</span><br><span class=\"line\">    SuperType.call(this, name);   //第二次调用SuperType()</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//继承方法</span><br><span class=\"line\">SubType.prototype = new SuperType(); //第一次调用SuperType()</span><br><span class=\"line\">SubType.prototype.constructor = SubType;</span><br><span class=\"line\">SubType.prototype.sayAge = function()&#123;</span><br><span class=\"line\">    console.log(this.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var instance1 = new SubType(&quot;Nicholas&quot;, 29);</span><br><span class=\"line\">instance1.colors.push(&quot;black&quot;);</span><br><span class=\"line\">console.log(instance1.colors); //&quot;red,blue,green,black&quot;</span><br><span class=\"line\">instance1.sayName(); //&quot;Nicholas&quot;;</span><br><span class=\"line\">instance1.sayAge(); //29</span><br><span class=\"line\">var instance2 = new SubType(&quot;Greg&quot;, 27);</span><br><span class=\"line\">console.log(instance2.colors); //&quot;red,blue,green&quot;</span><br><span class=\"line\">instance2.sayName(); //&quot;Greg&quot;;</span><br><span class=\"line\">instance2.sayAge();</span><br></pre></td></tr></table></figure>\n<p>基本思想：</p>\n<ul>\n<li>通过原型链来继承超类的sayName()方法；</li>\n<li>通过构造函数的方式来使SuperType()里的属性私有化；</li>\n</ul>\n<p>为什么可以实现属性私有化？</p>\n<ul>\n<li>第一次调用超类，SubType.prototype 会得到两个属性：name 和colors；它们都是SuperType 的实例属性，位于SubType 的原型中；</li>\n<li>第二次调用超类，在新对象上创建了实例属性name 和colors。于是，这两个属性就屏蔽了原型中的两个同名属性；</li>\n</ul>\n<p><strong>存在的问题：</strong><br>无论什么情况下，都会调用两次超类型构造函数:：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部</p>\n<h2 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function object(o)&#123;</span><br><span class=\"line\">    function F()&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    name: &quot;Nicholas&quot;,</span><br><span class=\"line\">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var anotherPerson = Object.create(person);</span><br><span class=\"line\">anotherPerson.name = &quot;Greg&quot;;</span><br><span class=\"line\">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class=\"line\">var yetAnotherPerson = Object.create(person);</span><br><span class=\"line\">yetAnotherPerson.name = &quot;Linda&quot;;</span><br><span class=\"line\">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class=\"line\">console.log(person.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;]</span><br></pre></td></tr></table></figure>\n<p><em>ECMAScript 5 通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象</em></p>\n<ul>\n<li>将person对象作为基础对象</li>\n<li>把person对象传入到object()函数中，然后该函数就会返回一个新对象F()，这个新对象将person 作为原型</li>\n<li>适用于让一个对象与另一个对象保持类似的情况</li>\n</ul>\n<p><strong>存在同原型链方式一样的问题</strong></p>\n<h2 id=\"寄生式基础\"><a href=\"#寄生式基础\" class=\"headerlink\" title=\"寄生式基础\"></a>寄生式基础</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function object(o)&#123;</span><br><span class=\"line\">    function F()&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function createAnother(original)&#123;</span><br><span class=\"line\">    var clone = object(original); //通过调用函数创建一个新对象</span><br><span class=\"line\">    clone.sayHi = function()&#123; //以某种方式来增强这个对象</span><br><span class=\"line\">    console.log(&quot;hi&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">return clone; //返回这个对象</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    name: &quot;Nicholas&quot;,</span><br><span class=\"line\">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var anotherPerson = createAnother(person);</span><br><span class=\"line\">anotherPerson.sayHi(); //&quot;hi&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>将person对象作为基础对象</li>\n<li>将基础对象传递给object()函数，将返回的新对象赋值给clone；（示范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。）</li>\n<li>为clone 对象添加一个新方法sayHi()，最后返回clone 对象</li>\n</ul>\n<h2 id=\"寄生组合式继承——被认为是引用类型最理想的继承范式\"><a href=\"#寄生组合式继承——被认为是引用类型最理想的继承范式\" class=\"headerlink\" title=\"寄生组合式继承——被认为是引用类型最理想的继承范式\"></a>寄生组合式继承——被认为是引用类型最理想的继承范式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function object(o)&#123;</span><br><span class=\"line\">    function F()&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function inheritPrototype(subType, superType)&#123;</span><br><span class=\"line\">    var prototype = object(superType.prototype); //创建对象</span><br><span class=\"line\">    prototype.constructor = subType; //增强对象</span><br><span class=\"line\">    subType.prototype = prototype; //指定对象</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function SuperType(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function SubType(name, age)&#123;</span><br><span class=\"line\">    SuperType.call(this, name); //调用一次SuperType()</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">inheritPrototype(SubType, SuperType);</span><br><span class=\"line\">SubType.prototype.sayAge = function()&#123;</span><br><span class=\"line\">    console.log(this.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var instance1 = new SubType(&quot;Nicholas&quot;, 29);</span><br><span class=\"line\">instance1.sayName();</span><br><span class=\"line\">console.log(instance1.colors);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>将超类的原型对位基础对象，并且传递给object()函数，返回新对象赋值给prototype；</li>\n<li>将子类的原型指向prototype，即超类的原型，这里继承了超类的sayName方法</li>\n<li>子类中利用构造方法使子类上创建了name和colors属性</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>参考书籍：<a href=\"#\">《javascript高级程序设计》</a></p>"},{"title":"java控制流程语句","date":"2016-03-29T02:03:31.000Z","description":"java控制流程语句","_content":"\nJava 主要的控制语句有3 种，选择语句、循环语句、跳转语句。\n<!-- more -->\n\n## 条件语句\n + `if(){}else{}`\n```\nint a = 0;\nint b = 1;\nif(a>b){\n    System.out.println(\"a\");\n}else{\n    System.out.println(\"b\");\n};\n```\n + `if(){}else if(){}else{}`\n```\nif(a>b){\n    System.out.println(\"a\");\n}else if(a<b){\n    System.out.println(\"b\");\n}else{\n    System.out.println(\"相等\");\n};\n```\n + `switch`\n```\nint k = 3;\nswitch(k) {\n    case 1:\n        System.out.println(1);\n    case 2:\n        System.out.println(2);\n    case 3:\n        System.out.println(3);\n}\n```\n\n## 循环语句\n\n+ `while`\n```\nint a = 0;\nwhile (a<5){\n    System.out.println(a);\n    a++;\n};\n```\n+ `do...while`\n```\ndo{\n    System.out.println(a);\n    a++;\n}while(a<5);\n```\n+ `for`\n```\nfor(a=0 ;a<5;a++){\n    System.out.println(a);\n}\n```\n## 跳转语句\n+ `break`\n```\nfor(int i=0;i<50;i++) {\n    System.out.println(\"i=\"+i);\n    //当n 等于10 的时候，跳出循环语句\n    if(i==10)\n        break;\n};\n```\n\n+ `continue`\n```\nfor (int i = 1; i <51; i++) {\n    System.out.print(i+\" \");\n    if(i%5!=0)\n        //当n 不能整除5 的时候继续进行循环\n        continue;\n    else\n        System.out.println(\"*****\");\n};\n```\n\n+ `return`\n\n```\nfor(int i=0;i<10;i++)\n    if(i<5)\n        System.out.println(\"第\"+i+\"次循环\");\n    else if(i==5)\n        return;\n        //下面的语句永远不会执行\n    else\n        System.out.println(\"第\"+i+\"次循环\");\n\n```\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/java控制流程语句.md","raw":"title: java控制流程语句\ntags: [java基础]\ndate: 2016-03-29 10:03:31\ndescription: java控制流程语句\n---\n\nJava 主要的控制语句有3 种，选择语句、循环语句、跳转语句。\n<!-- more -->\n\n## 条件语句\n + `if(){}else{}`\n```\nint a = 0;\nint b = 1;\nif(a>b){\n    System.out.println(\"a\");\n}else{\n    System.out.println(\"b\");\n};\n```\n + `if(){}else if(){}else{}`\n```\nif(a>b){\n    System.out.println(\"a\");\n}else if(a<b){\n    System.out.println(\"b\");\n}else{\n    System.out.println(\"相等\");\n};\n```\n + `switch`\n```\nint k = 3;\nswitch(k) {\n    case 1:\n        System.out.println(1);\n    case 2:\n        System.out.println(2);\n    case 3:\n        System.out.println(3);\n}\n```\n\n## 循环语句\n\n+ `while`\n```\nint a = 0;\nwhile (a<5){\n    System.out.println(a);\n    a++;\n};\n```\n+ `do...while`\n```\ndo{\n    System.out.println(a);\n    a++;\n}while(a<5);\n```\n+ `for`\n```\nfor(a=0 ;a<5;a++){\n    System.out.println(a);\n}\n```\n## 跳转语句\n+ `break`\n```\nfor(int i=0;i<50;i++) {\n    System.out.println(\"i=\"+i);\n    //当n 等于10 的时候，跳出循环语句\n    if(i==10)\n        break;\n};\n```\n\n+ `continue`\n```\nfor (int i = 1; i <51; i++) {\n    System.out.print(i+\" \");\n    if(i%5!=0)\n        //当n 不能整除5 的时候继续进行循环\n        continue;\n    else\n        System.out.println(\"*****\");\n};\n```\n\n+ `return`\n\n```\nfor(int i=0;i<10;i++)\n    if(i<5)\n        System.out.println(\"第\"+i+\"次循环\");\n    else if(i==5)\n        return;\n        //下面的语句永远不会执行\n    else\n        System.out.println(\"第\"+i+\"次循环\");\n\n```\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"java控制流程语句","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolc001yy4v25gld711z","content":"<p>Java 主要的控制语句有3 种，选择语句、循环语句、跳转语句。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><ul>\n<li><code>if()&#123;&#125;else&#123;&#125;</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 0;</span><br><span class=\"line\">int b = 1;</span><br><span class=\"line\">if(a&gt;b)&#123;</span><br><span class=\"line\">    System.out.println(&quot;a&quot;);</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">    System.out.println(&quot;b&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><code>if()&#123;&#125;else if()&#123;&#125;else&#123;&#125;</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(a&gt;b)&#123;</span><br><span class=\"line\">    System.out.println(&quot;a&quot;);</span><br><span class=\"line\">&#125;else if(a&lt;b)&#123;</span><br><span class=\"line\">    System.out.println(&quot;b&quot;);</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">    System.out.println(&quot;相等&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><code>switch</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int k = 3;</span><br><span class=\"line\">switch(k) &#123;</span><br><span class=\"line\">    case 1:</span><br><span class=\"line\">        System.out.println(1);</span><br><span class=\"line\">    case 2:</span><br><span class=\"line\">        System.out.println(2);</span><br><span class=\"line\">    case 3:</span><br><span class=\"line\">        System.out.println(3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><ul>\n<li><p><code>while</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 0;</span><br><span class=\"line\">while (a&lt;5)&#123;</span><br><span class=\"line\">    System.out.println(a);</span><br><span class=\"line\">    a++;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>do...while</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do&#123;</span><br><span class=\"line\">    System.out.println(a);</span><br><span class=\"line\">    a++;</span><br><span class=\"line\">&#125;while(a&lt;5);</span><br></pre></td></tr></table></figure></li>\n<li><p><code>for</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(a=0 ;a&lt;5;a++)&#123;</span><br><span class=\"line\">    System.out.println(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"跳转语句\"><a href=\"#跳转语句\" class=\"headerlink\" title=\"跳转语句\"></a>跳转语句</h2></li>\n<li><p><code>break</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i=0;i&lt;50;i++) &#123;</span><br><span class=\"line\">    System.out.println(&quot;i=&quot;+i);</span><br><span class=\"line\">    //当n 等于10 的时候，跳出循环语句</span><br><span class=\"line\">    if(i==10)</span><br><span class=\"line\">        break;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>continue</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt;51; i++) &#123;</span><br><span class=\"line\">    System.out.print(i+&quot; &quot;);</span><br><span class=\"line\">    if(i%5!=0)</span><br><span class=\"line\">        //当n 不能整除5 的时候继续进行循环</span><br><span class=\"line\">        continue;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        System.out.println(&quot;*****&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>return</code></p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i=0;i&lt;10;i++)</span><br><span class=\"line\">    if(i&lt;5)</span><br><span class=\"line\">        System.out.println(&quot;第&quot;+i+&quot;次循环&quot;);</span><br><span class=\"line\">    else if(i==5)</span><br><span class=\"line\">        return;</span><br><span class=\"line\">        //下面的语句永远不会执行</span><br><span class=\"line\">    else</span><br><span class=\"line\">        System.out.println(&quot;第&quot;+i+&quot;次循环&quot;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>Java 主要的控制语句有3 种，选择语句、循环语句、跳转语句。</p>","more":"<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><ul>\n<li><code>if()&#123;&#125;else&#123;&#125;</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 0;</span><br><span class=\"line\">int b = 1;</span><br><span class=\"line\">if(a&gt;b)&#123;</span><br><span class=\"line\">    System.out.println(&quot;a&quot;);</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">    System.out.println(&quot;b&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><code>if()&#123;&#125;else if()&#123;&#125;else&#123;&#125;</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(a&gt;b)&#123;</span><br><span class=\"line\">    System.out.println(&quot;a&quot;);</span><br><span class=\"line\">&#125;else if(a&lt;b)&#123;</span><br><span class=\"line\">    System.out.println(&quot;b&quot;);</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">    System.out.println(&quot;相等&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><code>switch</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int k = 3;</span><br><span class=\"line\">switch(k) &#123;</span><br><span class=\"line\">    case 1:</span><br><span class=\"line\">        System.out.println(1);</span><br><span class=\"line\">    case 2:</span><br><span class=\"line\">        System.out.println(2);</span><br><span class=\"line\">    case 3:</span><br><span class=\"line\">        System.out.println(3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><ul>\n<li><p><code>while</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 0;</span><br><span class=\"line\">while (a&lt;5)&#123;</span><br><span class=\"line\">    System.out.println(a);</span><br><span class=\"line\">    a++;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>do...while</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do&#123;</span><br><span class=\"line\">    System.out.println(a);</span><br><span class=\"line\">    a++;</span><br><span class=\"line\">&#125;while(a&lt;5);</span><br></pre></td></tr></table></figure></li>\n<li><p><code>for</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(a=0 ;a&lt;5;a++)&#123;</span><br><span class=\"line\">    System.out.println(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"跳转语句\"><a href=\"#跳转语句\" class=\"headerlink\" title=\"跳转语句\"></a>跳转语句</h2></li>\n<li><p><code>break</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i=0;i&lt;50;i++) &#123;</span><br><span class=\"line\">    System.out.println(&quot;i=&quot;+i);</span><br><span class=\"line\">    //当n 等于10 的时候，跳出循环语句</span><br><span class=\"line\">    if(i==10)</span><br><span class=\"line\">        break;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>continue</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt;51; i++) &#123;</span><br><span class=\"line\">    System.out.print(i+&quot; &quot;);</span><br><span class=\"line\">    if(i%5!=0)</span><br><span class=\"line\">        //当n 不能整除5 的时候继续进行循环</span><br><span class=\"line\">        continue;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        System.out.println(&quot;*****&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>return</code></p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i=0;i&lt;10;i++)</span><br><span class=\"line\">    if(i&lt;5)</span><br><span class=\"line\">        System.out.println(&quot;第&quot;+i+&quot;次循环&quot;);</span><br><span class=\"line\">    else if(i==5)</span><br><span class=\"line\">        return;</span><br><span class=\"line\">        //下面的语句永远不会执行</span><br><span class=\"line\">    else</span><br><span class=\"line\">        System.out.println(&quot;第&quot;+i+&quot;次循环&quot;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"javascript模块化","date":"2016-03-25T07:49:58.000Z","description":"javascript模块化","_content":"\n\n模块化是一个通用的编程最佳实践。程序的模块化使我们可以更方便地使用别人的代码，想要什么功能，就加载什么模块，从而提高代码的利用效率，增加开发速度。\n\n模块就像积木，有了它，我们可以搭出各种各种功能样式的程序。积木有什么特点？小而简单。同样的，我们程序中的模块也要做到这一点，确保自己创建的函数一次只完成一个工作，这样其他开发者可以简单地调试与修改你的代码，而不需浏览所有代码才能弄清每一个代码块执行了什么功能。只有做到像这样地小而简单，才能实现其通用功能。\n\n<!-- more -->\n\n## javascript模块化的方法\n\n**函数封装**\nJavaScript的作用域就是基于函数的，所以我们可以把函数作为模块。\n```js\nfunction fn1(){\n    //code\n}\n\nfunction fn2(){\n    //code\n}\n```\n缺点：\"污染\"了全局变量，无法保证不与其他模块发生变量名冲突\n\n**对象**\n```js\nvar myModule1 = {\n    fn1: function(){\n        //code\n    },\n    fn2: function(){\n        //code\n    }\n}\n```\n缺点：会暴露所有模块成员，内部状态可以被外部改写\n\n**立即自执行函数——推荐**\n```js\nvar myModule = (function(){\n    function fn1(){\n        //code\n    },\n    function fn2(){\n        //code\n    },\n    return {\n        fn1: fn1,\n        fn2: fn2\n    };\n})();\n```\n\n## 小而简单\n\n关于小而简单，我们看一个例子，比如我们现在想编写一个创建新链接的函数，并且为类型是\"mailto\"超链接添加一个class。可以这样做：\n```js\nfunction addLink(text, url, parentElement) {\n    var newLink = document.createElement('a');//创建a标签\n    newLink.setAttribute('href', url);//为a标签设置href属性\n    newLink.appendChild(document.createTextNode(text));//为a标签添加文本\n    if(url.indexOf(\"mailto:\")==-1){\n        newLink.className = 'mail';\n    }\n    parentElement.appendChild(newLink);//将a标签添加到页面\n}\n```\n这样写能够工作，但你或许会发现自己又不得进行其他的功能添加，于是，这个函数又不适用了。所以，函数越特殊，越难以适用于不同情形。\n这里的函数写法没有达到模块化的要求——一个函数只干一件事。我们将函数改编下：\n```\nfunction createLink(text,url) {\n    var newLink = document.createElement('a');\n    newLink.setAttribute('href', url);\n    newLink.appendChild(document.createTextNode(text));\n    return newLink;\n}\n```\n这里createLink函数只做一件事——创建并返回要添加到页面中的a标签（小而简单），这样我们就可以在任何需要创建超链接的情况下调用这样函数。\n\n## CommonJS\n在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块与操作系统和其他应用程序互动，否则根本没法编程。虽然JavaScript在web端发展这么多年，但是第一个流行的模块化规范却由服务器端的JavaScript应用带来，CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。\nnode.js的模块系统，就是依据CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。\n加载模块：\n```js\nvar math = require('math');\n```\n调用模块：\n```\n  math.add(2,3)\n```\nCommonJS规范不适用于浏览器环境，因为它存在一个重大的局限，上例中第二行math.add(2, 3)必须要在math.js加载完成后才能运行，而模块都放在服务器端，所以可能要等很长时间，等待时间取决于网速的快慢。\n\nCommonJS规范适用于服务器端，因为对于服务端来说，所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间\n\n## 模块应该怎么定义和怎么加载?\n\n**[AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)**\n`Asynchronous Module Definition`异步模块定义,主要代表：[require.js](http://requirejs.org/docs/)\n目的：\n（1）实现js文件的异步加载，避免网页失去响应；\n（2）管理模块之间的依赖性，便于代码的编写和维护。\n1. 定义模块\n```\ndefine([\"./cart\", \"./inventory\"], function(cart, inventory) {\n        //通过[]引入依赖\n        return {\n            color: \"blue\",\n            size: \"large\",\n            addToCart: function() {\n                inventory.decrement(this);\n                cart.add(this);\n            }\n        }\n    }\n);\n```\n2. 加载模块\n```\nrequire( [\"some/module\", \"my/module\", \"a.js\", \"b.js\"],\n    function(someModule,    myModule) {\n        //This function will be called when all the dependencies\n        //listed above are loaded. Note that this function could\n        //be called before the page is loaded.\n        //This callback is optional.\n    }\n  );\n```\n\n**[CMD](https://github.com/cmdjs/specification/blob/master/draft/module.md)**\n`Common Module Definition`通用模块定义，CMD规范是国内发展出来的。主要代表：[sea.js](http://seajs.org/docs/)\n1. 定义模块\n```\ndefine(function(require, exports, module) {\n\n  // 通过 require 引入依赖\n  var $ = require('jquery');\n  var Spinning = require('./spinning');\n\n  // 通过 exports 对外提供接口\n  exports.doSomething = ...\n\n  // 或者通过 module.exports 提供整个接口\n  module.exports = ...\n\n});\n```\n2. 加载模块\n```\nseajs.use(\"../static/hello/src/main\")\n```\n\n区别：\n\n1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n\n2. CMD 推崇依赖就近，AMD 推崇依赖前置。\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/javascript模块化.md","raw":"title: javascript模块化\ntags: [javascript]\ndate: 2016-03-25 15:49:58\ndescription: javascript模块化\n---\n\n\n模块化是一个通用的编程最佳实践。程序的模块化使我们可以更方便地使用别人的代码，想要什么功能，就加载什么模块，从而提高代码的利用效率，增加开发速度。\n\n模块就像积木，有了它，我们可以搭出各种各种功能样式的程序。积木有什么特点？小而简单。同样的，我们程序中的模块也要做到这一点，确保自己创建的函数一次只完成一个工作，这样其他开发者可以简单地调试与修改你的代码，而不需浏览所有代码才能弄清每一个代码块执行了什么功能。只有做到像这样地小而简单，才能实现其通用功能。\n\n<!-- more -->\n\n## javascript模块化的方法\n\n**函数封装**\nJavaScript的作用域就是基于函数的，所以我们可以把函数作为模块。\n```js\nfunction fn1(){\n    //code\n}\n\nfunction fn2(){\n    //code\n}\n```\n缺点：\"污染\"了全局变量，无法保证不与其他模块发生变量名冲突\n\n**对象**\n```js\nvar myModule1 = {\n    fn1: function(){\n        //code\n    },\n    fn2: function(){\n        //code\n    }\n}\n```\n缺点：会暴露所有模块成员，内部状态可以被外部改写\n\n**立即自执行函数——推荐**\n```js\nvar myModule = (function(){\n    function fn1(){\n        //code\n    },\n    function fn2(){\n        //code\n    },\n    return {\n        fn1: fn1,\n        fn2: fn2\n    };\n})();\n```\n\n## 小而简单\n\n关于小而简单，我们看一个例子，比如我们现在想编写一个创建新链接的函数，并且为类型是\"mailto\"超链接添加一个class。可以这样做：\n```js\nfunction addLink(text, url, parentElement) {\n    var newLink = document.createElement('a');//创建a标签\n    newLink.setAttribute('href', url);//为a标签设置href属性\n    newLink.appendChild(document.createTextNode(text));//为a标签添加文本\n    if(url.indexOf(\"mailto:\")==-1){\n        newLink.className = 'mail';\n    }\n    parentElement.appendChild(newLink);//将a标签添加到页面\n}\n```\n这样写能够工作，但你或许会发现自己又不得进行其他的功能添加，于是，这个函数又不适用了。所以，函数越特殊，越难以适用于不同情形。\n这里的函数写法没有达到模块化的要求——一个函数只干一件事。我们将函数改编下：\n```\nfunction createLink(text,url) {\n    var newLink = document.createElement('a');\n    newLink.setAttribute('href', url);\n    newLink.appendChild(document.createTextNode(text));\n    return newLink;\n}\n```\n这里createLink函数只做一件事——创建并返回要添加到页面中的a标签（小而简单），这样我们就可以在任何需要创建超链接的情况下调用这样函数。\n\n## CommonJS\n在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块与操作系统和其他应用程序互动，否则根本没法编程。虽然JavaScript在web端发展这么多年，但是第一个流行的模块化规范却由服务器端的JavaScript应用带来，CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。\nnode.js的模块系统，就是依据CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。\n加载模块：\n```js\nvar math = require('math');\n```\n调用模块：\n```\n  math.add(2,3)\n```\nCommonJS规范不适用于浏览器环境，因为它存在一个重大的局限，上例中第二行math.add(2, 3)必须要在math.js加载完成后才能运行，而模块都放在服务器端，所以可能要等很长时间，等待时间取决于网速的快慢。\n\nCommonJS规范适用于服务器端，因为对于服务端来说，所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间\n\n## 模块应该怎么定义和怎么加载?\n\n**[AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)**\n`Asynchronous Module Definition`异步模块定义,主要代表：[require.js](http://requirejs.org/docs/)\n目的：\n（1）实现js文件的异步加载，避免网页失去响应；\n（2）管理模块之间的依赖性，便于代码的编写和维护。\n1. 定义模块\n```\ndefine([\"./cart\", \"./inventory\"], function(cart, inventory) {\n        //通过[]引入依赖\n        return {\n            color: \"blue\",\n            size: \"large\",\n            addToCart: function() {\n                inventory.decrement(this);\n                cart.add(this);\n            }\n        }\n    }\n);\n```\n2. 加载模块\n```\nrequire( [\"some/module\", \"my/module\", \"a.js\", \"b.js\"],\n    function(someModule,    myModule) {\n        //This function will be called when all the dependencies\n        //listed above are loaded. Note that this function could\n        //be called before the page is loaded.\n        //This callback is optional.\n    }\n  );\n```\n\n**[CMD](https://github.com/cmdjs/specification/blob/master/draft/module.md)**\n`Common Module Definition`通用模块定义，CMD规范是国内发展出来的。主要代表：[sea.js](http://seajs.org/docs/)\n1. 定义模块\n```\ndefine(function(require, exports, module) {\n\n  // 通过 require 引入依赖\n  var $ = require('jquery');\n  var Spinning = require('./spinning');\n\n  // 通过 exports 对外提供接口\n  exports.doSomething = ...\n\n  // 或者通过 module.exports 提供整个接口\n  module.exports = ...\n\n});\n```\n2. 加载模块\n```\nseajs.use(\"../static/hello/src/main\")\n```\n\n区别：\n\n1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n\n2. CMD 推崇依赖就近，AMD 推崇依赖前置。\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"javascript模块化","published":1,"updated":"2021-12-06T06:07:06.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwole0020y4v2d8othnup","content":"<p>模块化是一个通用的编程最佳实践。程序的模块化使我们可以更方便地使用别人的代码，想要什么功能，就加载什么模块，从而提高代码的利用效率，增加开发速度。</p>\n<p>模块就像积木，有了它，我们可以搭出各种各种功能样式的程序。积木有什么特点？小而简单。同样的，我们程序中的模块也要做到这一点，确保自己创建的函数一次只完成一个工作，这样其他开发者可以简单地调试与修改你的代码，而不需浏览所有代码才能弄清每一个代码块执行了什么功能。只有做到像这样地小而简单，才能实现其通用功能。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"javascript模块化的方法\"><a href=\"#javascript模块化的方法\" class=\"headerlink\" title=\"javascript模块化的方法\"></a>javascript模块化的方法</h2><p><strong>函数封装</strong><br>JavaScript的作用域就是基于函数的，所以我们可以把函数作为模块。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：”污染”了全局变量，无法保证不与其他模块发生变量名冲突</p>\n<p><strong>对象</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myModule1 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">fn1</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//code</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">fn2</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//code</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：会暴露所有模块成员，内部状态可以被外部改写</p>\n<p><strong>立即自执行函数——推荐</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myModule = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//code</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//code</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">fn1</span>: fn1,</span><br><span class=\"line\">        <span class=\"attr\">fn2</span>: fn2</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小而简单\"><a href=\"#小而简单\" class=\"headerlink\" title=\"小而简单\"></a>小而简单</h2><p>关于小而简单，我们看一个例子，比如我们现在想编写一个创建新链接的函数，并且为类型是”mailto”超链接添加一个class。可以这样做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addLink</span>(<span class=\"params\">text, url, parentElement</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newLink = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//创建a标签</span></span><br><span class=\"line\">    newLink.setAttribute(<span class=\"string\">&#x27;href&#x27;</span>, url);<span class=\"comment\">//为a标签设置href属性</span></span><br><span class=\"line\">    newLink.appendChild(<span class=\"built_in\">document</span>.createTextNode(text));<span class=\"comment\">//为a标签添加文本</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(url.indexOf(<span class=\"string\">&quot;mailto:&quot;</span>)==-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        newLink.className = <span class=\"string\">&#x27;mail&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parentElement.appendChild(newLink);<span class=\"comment\">//将a标签添加到页面</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样写能够工作，但你或许会发现自己又不得进行其他的功能添加，于是，这个函数又不适用了。所以，函数越特殊，越难以适用于不同情形。<br>这里的函数写法没有达到模块化的要求——一个函数只干一件事。我们将函数改编下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createLink(text,url) &#123;</span><br><span class=\"line\">    var newLink = document.createElement(&#x27;a&#x27;);</span><br><span class=\"line\">    newLink.setAttribute(&#x27;href&#x27;, url);</span><br><span class=\"line\">    newLink.appendChild(document.createTextNode(text));</span><br><span class=\"line\">    return newLink;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里createLink函数只做一件事——创建并返回要添加到页面中的a标签（小而简单），这样我们就可以在任何需要创建超链接的情况下调用这样函数。</p>\n<h2 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h2><p>在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块与操作系统和其他应用程序互动，否则根本没法编程。虽然JavaScript在web端发展这么多年，但是第一个流行的模块化规范却由服务器端的JavaScript应用带来，CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。<br>node.js的模块系统，就是依据CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。<br>加载模块：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;math&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>调用模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math.add(2,3)</span><br></pre></td></tr></table></figure>\n<p>CommonJS规范不适用于浏览器环境，因为它存在一个重大的局限，上例中第二行math.add(2, 3)必须要在math.js加载完成后才能运行，而模块都放在服务器端，所以可能要等很长时间，等待时间取决于网速的快慢。</p>\n<p>CommonJS规范适用于服务器端，因为对于服务端来说，所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间</p>\n<h2 id=\"模块应该怎么定义和怎么加载\"><a href=\"#模块应该怎么定义和怎么加载\" class=\"headerlink\" title=\"模块应该怎么定义和怎么加载?\"></a>模块应该怎么定义和怎么加载?</h2><p><strong><a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\">AMD</a></strong><br><code>Asynchronous Module Definition</code>异步模块定义,主要代表：<a href=\"http://requirejs.org/docs/\">require.js</a><br>目的：<br>（1）实现js文件的异步加载，避免网页失去响应；<br>（2）管理模块之间的依赖性，便于代码的编写和维护。</p>\n<ol>\n<li>定义模块<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([&quot;./cart&quot;, &quot;./inventory&quot;], function(cart, inventory) &#123;</span><br><span class=\"line\">        //通过[]引入依赖</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            color: &quot;blue&quot;,</span><br><span class=\"line\">            size: &quot;large&quot;,</span><br><span class=\"line\">            addToCart: function() &#123;</span><br><span class=\"line\">                inventory.decrement(this);</span><br><span class=\"line\">                cart.add(this);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li>加载模块<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require( [&quot;some/module&quot;, &quot;my/module&quot;, &quot;a.js&quot;, &quot;b.js&quot;],</span><br><span class=\"line\">    function(someModule,    myModule) &#123;</span><br><span class=\"line\">        //This function will be called when all the dependencies</span><br><span class=\"line\">        //listed above are loaded. Note that this function could</span><br><span class=\"line\">        //be called before the page is loaded.</span><br><span class=\"line\">        //This callback is optional.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\">CMD</a></strong><br><code>Common Module Definition</code>通用模块定义，CMD规范是国内发展出来的。主要代表：<a href=\"http://seajs.org/docs/\">sea.js</a></p>\n<ol>\n<li>定义模块<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 通过 require 引入依赖</span><br><span class=\"line\">  var $ = require(&#x27;jquery&#x27;);</span><br><span class=\"line\">  var Spinning = require(&#x27;./spinning&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 通过 exports 对外提供接口</span><br><span class=\"line\">  exports.doSomething = ...</span><br><span class=\"line\"></span><br><span class=\"line\">  // 或者通过 module.exports 提供整个接口</span><br><span class=\"line\">  module.exports = ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>加载模块<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seajs.use(&quot;../static/hello/src/main&quot;)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>区别：</p>\n<ol>\n<li><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p>\n</li>\n<li><p>CMD 推崇依赖就近，AMD 推崇依赖前置。</p>\n</li>\n</ol>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>模块化是一个通用的编程最佳实践。程序的模块化使我们可以更方便地使用别人的代码，想要什么功能，就加载什么模块，从而提高代码的利用效率，增加开发速度。</p>\n<p>模块就像积木，有了它，我们可以搭出各种各种功能样式的程序。积木有什么特点？小而简单。同样的，我们程序中的模块也要做到这一点，确保自己创建的函数一次只完成一个工作，这样其他开发者可以简单地调试与修改你的代码，而不需浏览所有代码才能弄清每一个代码块执行了什么功能。只有做到像这样地小而简单，才能实现其通用功能。</p>","more":"<h2 id=\"javascript模块化的方法\"><a href=\"#javascript模块化的方法\" class=\"headerlink\" title=\"javascript模块化的方法\"></a>javascript模块化的方法</h2><p><strong>函数封装</strong><br>JavaScript的作用域就是基于函数的，所以我们可以把函数作为模块。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：”污染”了全局变量，无法保证不与其他模块发生变量名冲突</p>\n<p><strong>对象</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myModule1 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">fn1</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//code</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">fn2</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//code</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：会暴露所有模块成员，内部状态可以被外部改写</p>\n<p><strong>立即自执行函数——推荐</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myModule = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//code</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//code</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">fn1</span>: fn1,</span><br><span class=\"line\">        <span class=\"attr\">fn2</span>: fn2</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小而简单\"><a href=\"#小而简单\" class=\"headerlink\" title=\"小而简单\"></a>小而简单</h2><p>关于小而简单，我们看一个例子，比如我们现在想编写一个创建新链接的函数，并且为类型是”mailto”超链接添加一个class。可以这样做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addLink</span>(<span class=\"params\">text, url, parentElement</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newLink = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//创建a标签</span></span><br><span class=\"line\">    newLink.setAttribute(<span class=\"string\">&#x27;href&#x27;</span>, url);<span class=\"comment\">//为a标签设置href属性</span></span><br><span class=\"line\">    newLink.appendChild(<span class=\"built_in\">document</span>.createTextNode(text));<span class=\"comment\">//为a标签添加文本</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(url.indexOf(<span class=\"string\">&quot;mailto:&quot;</span>)==-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        newLink.className = <span class=\"string\">&#x27;mail&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parentElement.appendChild(newLink);<span class=\"comment\">//将a标签添加到页面</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样写能够工作，但你或许会发现自己又不得进行其他的功能添加，于是，这个函数又不适用了。所以，函数越特殊，越难以适用于不同情形。<br>这里的函数写法没有达到模块化的要求——一个函数只干一件事。我们将函数改编下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createLink(text,url) &#123;</span><br><span class=\"line\">    var newLink = document.createElement(&#x27;a&#x27;);</span><br><span class=\"line\">    newLink.setAttribute(&#x27;href&#x27;, url);</span><br><span class=\"line\">    newLink.appendChild(document.createTextNode(text));</span><br><span class=\"line\">    return newLink;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里createLink函数只做一件事——创建并返回要添加到页面中的a标签（小而简单），这样我们就可以在任何需要创建超链接的情况下调用这样函数。</p>\n<h2 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h2><p>在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块与操作系统和其他应用程序互动，否则根本没法编程。虽然JavaScript在web端发展这么多年，但是第一个流行的模块化规范却由服务器端的JavaScript应用带来，CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。<br>node.js的模块系统，就是依据CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。<br>加载模块：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;math&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>调用模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math.add(2,3)</span><br></pre></td></tr></table></figure>\n<p>CommonJS规范不适用于浏览器环境，因为它存在一个重大的局限，上例中第二行math.add(2, 3)必须要在math.js加载完成后才能运行，而模块都放在服务器端，所以可能要等很长时间，等待时间取决于网速的快慢。</p>\n<p>CommonJS规范适用于服务器端，因为对于服务端来说，所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间</p>\n<h2 id=\"模块应该怎么定义和怎么加载\"><a href=\"#模块应该怎么定义和怎么加载\" class=\"headerlink\" title=\"模块应该怎么定义和怎么加载?\"></a>模块应该怎么定义和怎么加载?</h2><p><strong><a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\">AMD</a></strong><br><code>Asynchronous Module Definition</code>异步模块定义,主要代表：<a href=\"http://requirejs.org/docs/\">require.js</a><br>目的：<br>（1）实现js文件的异步加载，避免网页失去响应；<br>（2）管理模块之间的依赖性，便于代码的编写和维护。</p>\n<ol>\n<li>定义模块<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([&quot;./cart&quot;, &quot;./inventory&quot;], function(cart, inventory) &#123;</span><br><span class=\"line\">        //通过[]引入依赖</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            color: &quot;blue&quot;,</span><br><span class=\"line\">            size: &quot;large&quot;,</span><br><span class=\"line\">            addToCart: function() &#123;</span><br><span class=\"line\">                inventory.decrement(this);</span><br><span class=\"line\">                cart.add(this);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li>加载模块<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require( [&quot;some/module&quot;, &quot;my/module&quot;, &quot;a.js&quot;, &quot;b.js&quot;],</span><br><span class=\"line\">    function(someModule,    myModule) &#123;</span><br><span class=\"line\">        //This function will be called when all the dependencies</span><br><span class=\"line\">        //listed above are loaded. Note that this function could</span><br><span class=\"line\">        //be called before the page is loaded.</span><br><span class=\"line\">        //This callback is optional.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\">CMD</a></strong><br><code>Common Module Definition</code>通用模块定义，CMD规范是国内发展出来的。主要代表：<a href=\"http://seajs.org/docs/\">sea.js</a></p>\n<ol>\n<li>定义模块<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 通过 require 引入依赖</span><br><span class=\"line\">  var $ = require(&#x27;jquery&#x27;);</span><br><span class=\"line\">  var Spinning = require(&#x27;./spinning&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 通过 exports 对外提供接口</span><br><span class=\"line\">  exports.doSomething = ...</span><br><span class=\"line\"></span><br><span class=\"line\">  // 或者通过 module.exports 提供整个接口</span><br><span class=\"line\">  module.exports = ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>加载模块<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seajs.use(&quot;../static/hello/src/main&quot;)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>区别：</p>\n<ol>\n<li><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p>\n</li>\n<li><p>CMD 推崇依赖就近，AMD 推崇依赖前置。</p>\n</li>\n</ol>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"jquery对javascript事件的封装一览","date":"2015-10-16T06:22:21.000Z","description":"事件绑定，事件封装","_content":"\njavaScript 与HTML 之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式的模型，支持页面的行为（JavaScript 代码）与页面的外观（HTML 和CSS 代码）之间的松散耦合。\n\n<!-- more -->\n\n### 1.事件封装一览表\n\n<table> <tbody><tr> <td>描述</td> <td>jquery</td> <td>javascript</td> </tr> <tr> <td>鼠标点击某个对象</td> <td>click()</td> <td>onclick</td> </tr> <tr> <td>鼠标双击某个对象</td> <td>dblclick()</td> <td>ondblclick</td> </tr> <tr> <td>元素获得焦点</td> <td>focus()<br/>focusin()[可以在父元素上检测子元素获取焦点的情况]</td> <td>onfocus<br/>onfocusout</td> </tr> <tr> <td>元素失去焦点</td> <td>blur()<br/>focusout()[可以在父元素上检测子元素失去焦点的情况]</td> <td>onblur<br/>onfocusout</td> </tr> <tr> <td>用户改变域的内容</td> <td>change()</td> <td>onchange</td> </tr> <tr> <td>某个键盘的键被按下</td> <td>keydown()</td> <td>onkeydown</td> </tr> <tr> <td>某个键盘的键被按下或按住</td> <td>keypress()</td> <td>onkeypress</td> </tr> <tr> <td>某个键盘的键被松开 </td> <td>keyup()</td> <td>onkeyup</td> </tr> <tr> <td>某个页面或图像被完成加载</td> <td>load()</td> <td>onload</td> </tr> <tr> <td>用户退出页面</td> <td>unload()</td> <td>onunload</td> </tr> <tr> <td>某个鼠标按键被按下</td> <td>mousedown()</td> <td>onmousedown</td> </tr> <tr> <td>鼠标被移动</td> <td>mousemove()</td> <td>onmousemove</td> </tr> <tr> <td>鼠标从某元素移开</td> <td>mouseout()</td> <td>onmouseout</td> </tr> <tr> <td>鼠标被移到某元素之上</td> <td>mouseover()/mouseout【触发子元素有效】<br/> mouseenter()/mouseleave()</td> <td>onmouseover</td> </tr> <tr> <td>某个鼠标按键被松开</td> <td>mouseup()</td> <td>onmouseup</td> </tr> <tr> <td>窗口或框架被调整尺寸</td> <td>resize()</td> <td>onresize</td> </tr> <tr> <td>文本被选定</td> <td>select()</td> <td>onselect</td> </tr> <tr> <td>提交按钮被点击</td> <td>submit()</td> <td>onsubmit</td> </tr> <tr> <td>元素滚动条在滚动</td> <td>scroll()</td> <td>onscroll</td> </tr> <tr> <td>当加载文档或图像时发生某个错误</td> <td>error()</td> <td>onerror</td> </tr> <tr> <td>提交按钮被点击</td> <td>submit()</td> <td>onsubmit</td> </tr> </tbody></table>\n\n### 2.jquery源码(版本2.1.4)\n\tjQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t\t// Handle event binding  事件绑定\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name ); \n\t\t\t\t//如果不带参数，则返回this.on( name, null, data, fn )，否则返回this.trigger( name )\n\t\t};\n\t});\n\nsplit() 方法用于把一个字符串分割成字符串数组；\neach()方法遍历这个数组，为每个匹配元素规定运行的函数；\njQuery.fn 指jquery的命名空间，加上fn上的方法及属性；\non方法：在选择元素上绑定一个或多个事件的事件处理函数\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\t\tvar origFn, type;\n\n\t\t\t// Types can be a map of types/handlers  判断types参数\n\t\t\tif ( typeof types === \"object\" ) {\n\t\t\t\t// ( types-Object, selector, data )\n\t\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t\t// ( types-Object, data )\n\t\t\t\t\tdata = data || selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t\n\t\t\t//判断data参数\n\t\t\tif ( data == null && fn == null ) {  \n\t\t\t\t// ( types, fn )\n\t\t\t\tfn = selector;\n\t\t\t\tdata = selector = undefined;\n\t\t\t} else if ( fn == null ) {\n\t\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t\t// ( types, selector, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = undefined;\n\t\t\t\t} else {\n\t\t\t\t\t// ( types, data, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//判断fn参数\n\t\t\tif ( fn === false ) {  \n\t\t\t\tfn = returnFalse;\n\t\t\t} else if ( !fn ) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t//判断fn参数\n\t\t\tif ( one === 1 ) {\n\t\t\t\torigFn = fn;\n\t\t\t\tfn = function( event ) {\n\t\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\t\tjQuery().off( event );\n\t\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t\t};\n\t\t\t\t// Use same guid so caller can remove using origFn\n\t\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t\t});\n\t\t}\n\ntrigger方法：在每一个匹配的元素上触发某类事件。\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\n\n---\n<p style=\"text-align:right\">整理于2015-11-30 17:28:21</p>\n","source":"_posts/jquery对javascript事件的封装一览.md","raw":"title: jquery对javascript事件的封装一览\ndate: 2015-10-16 14:22:21\ntags: [web,javascript]\ndescription: 事件绑定，事件封装\n\n---\n\njavaScript 与HTML 之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式的模型，支持页面的行为（JavaScript 代码）与页面的外观（HTML 和CSS 代码）之间的松散耦合。\n\n<!-- more -->\n\n### 1.事件封装一览表\n\n<table> <tbody><tr> <td>描述</td> <td>jquery</td> <td>javascript</td> </tr> <tr> <td>鼠标点击某个对象</td> <td>click()</td> <td>onclick</td> </tr> <tr> <td>鼠标双击某个对象</td> <td>dblclick()</td> <td>ondblclick</td> </tr> <tr> <td>元素获得焦点</td> <td>focus()<br/>focusin()[可以在父元素上检测子元素获取焦点的情况]</td> <td>onfocus<br/>onfocusout</td> </tr> <tr> <td>元素失去焦点</td> <td>blur()<br/>focusout()[可以在父元素上检测子元素失去焦点的情况]</td> <td>onblur<br/>onfocusout</td> </tr> <tr> <td>用户改变域的内容</td> <td>change()</td> <td>onchange</td> </tr> <tr> <td>某个键盘的键被按下</td> <td>keydown()</td> <td>onkeydown</td> </tr> <tr> <td>某个键盘的键被按下或按住</td> <td>keypress()</td> <td>onkeypress</td> </tr> <tr> <td>某个键盘的键被松开 </td> <td>keyup()</td> <td>onkeyup</td> </tr> <tr> <td>某个页面或图像被完成加载</td> <td>load()</td> <td>onload</td> </tr> <tr> <td>用户退出页面</td> <td>unload()</td> <td>onunload</td> </tr> <tr> <td>某个鼠标按键被按下</td> <td>mousedown()</td> <td>onmousedown</td> </tr> <tr> <td>鼠标被移动</td> <td>mousemove()</td> <td>onmousemove</td> </tr> <tr> <td>鼠标从某元素移开</td> <td>mouseout()</td> <td>onmouseout</td> </tr> <tr> <td>鼠标被移到某元素之上</td> <td>mouseover()/mouseout【触发子元素有效】<br/> mouseenter()/mouseleave()</td> <td>onmouseover</td> </tr> <tr> <td>某个鼠标按键被松开</td> <td>mouseup()</td> <td>onmouseup</td> </tr> <tr> <td>窗口或框架被调整尺寸</td> <td>resize()</td> <td>onresize</td> </tr> <tr> <td>文本被选定</td> <td>select()</td> <td>onselect</td> </tr> <tr> <td>提交按钮被点击</td> <td>submit()</td> <td>onsubmit</td> </tr> <tr> <td>元素滚动条在滚动</td> <td>scroll()</td> <td>onscroll</td> </tr> <tr> <td>当加载文档或图像时发生某个错误</td> <td>error()</td> <td>onerror</td> </tr> <tr> <td>提交按钮被点击</td> <td>submit()</td> <td>onsubmit</td> </tr> </tbody></table>\n\n### 2.jquery源码(版本2.1.4)\n\tjQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t\t// Handle event binding  事件绑定\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name ); \n\t\t\t\t//如果不带参数，则返回this.on( name, null, data, fn )，否则返回this.trigger( name )\n\t\t};\n\t});\n\nsplit() 方法用于把一个字符串分割成字符串数组；\neach()方法遍历这个数组，为每个匹配元素规定运行的函数；\njQuery.fn 指jquery的命名空间，加上fn上的方法及属性；\non方法：在选择元素上绑定一个或多个事件的事件处理函数\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\t\tvar origFn, type;\n\n\t\t\t// Types can be a map of types/handlers  判断types参数\n\t\t\tif ( typeof types === \"object\" ) {\n\t\t\t\t// ( types-Object, selector, data )\n\t\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t\t// ( types-Object, data )\n\t\t\t\t\tdata = data || selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t\n\t\t\t//判断data参数\n\t\t\tif ( data == null && fn == null ) {  \n\t\t\t\t// ( types, fn )\n\t\t\t\tfn = selector;\n\t\t\t\tdata = selector = undefined;\n\t\t\t} else if ( fn == null ) {\n\t\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t\t// ( types, selector, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = undefined;\n\t\t\t\t} else {\n\t\t\t\t\t// ( types, data, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//判断fn参数\n\t\t\tif ( fn === false ) {  \n\t\t\t\tfn = returnFalse;\n\t\t\t} else if ( !fn ) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t//判断fn参数\n\t\t\tif ( one === 1 ) {\n\t\t\t\torigFn = fn;\n\t\t\t\tfn = function( event ) {\n\t\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\t\tjQuery().off( event );\n\t\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t\t};\n\t\t\t\t// Use same guid so caller can remove using origFn\n\t\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t\t});\n\t\t}\n\ntrigger方法：在每一个匹配的元素上触发某类事件。\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\n\n---\n<p style=\"text-align:right\">整理于2015-11-30 17:28:21</p>\n","slug":"jquery对javascript事件的封装一览","published":1,"updated":"2021-12-06T06:07:06.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolf0023y4v24943cclj","content":"<p>javaScript 与HTML 之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式的模型，支持页面的行为（JavaScript 代码）与页面的外观（HTML 和CSS 代码）之间的松散耦合。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"1-事件封装一览表\"><a href=\"#1-事件封装一览表\" class=\"headerlink\" title=\"1.事件封装一览表\"></a>1.事件封装一览表</h3><table> <tbody><tr> <td>描述</td> <td>jquery</td> <td>javascript</td> </tr> <tr> <td>鼠标点击某个对象</td> <td>click()</td> <td>onclick</td> </tr> <tr> <td>鼠标双击某个对象</td> <td>dblclick()</td> <td>ondblclick</td> </tr> <tr> <td>元素获得焦点</td> <td>focus()<br/>focusin()[可以在父元素上检测子元素获取焦点的情况]</td> <td>onfocus<br/>onfocusout</td> </tr> <tr> <td>元素失去焦点</td> <td>blur()<br/>focusout()[可以在父元素上检测子元素失去焦点的情况]</td> <td>onblur<br/>onfocusout</td> </tr> <tr> <td>用户改变域的内容</td> <td>change()</td> <td>onchange</td> </tr> <tr> <td>某个键盘的键被按下</td> <td>keydown()</td> <td>onkeydown</td> </tr> <tr> <td>某个键盘的键被按下或按住</td> <td>keypress()</td> <td>onkeypress</td> </tr> <tr> <td>某个键盘的键被松开 </td> <td>keyup()</td> <td>onkeyup</td> </tr> <tr> <td>某个页面或图像被完成加载</td> <td>load()</td> <td>onload</td> </tr> <tr> <td>用户退出页面</td> <td>unload()</td> <td>onunload</td> </tr> <tr> <td>某个鼠标按键被按下</td> <td>mousedown()</td> <td>onmousedown</td> </tr> <tr> <td>鼠标被移动</td> <td>mousemove()</td> <td>onmousemove</td> </tr> <tr> <td>鼠标从某元素移开</td> <td>mouseout()</td> <td>onmouseout</td> </tr> <tr> <td>鼠标被移到某元素之上</td> <td>mouseover()/mouseout【触发子元素有效】<br/> mouseenter()/mouseleave()</td> <td>onmouseover</td> </tr> <tr> <td>某个鼠标按键被松开</td> <td>mouseup()</td> <td>onmouseup</td> </tr> <tr> <td>窗口或框架被调整尺寸</td> <td>resize()</td> <td>onresize</td> </tr> <tr> <td>文本被选定</td> <td>select()</td> <td>onselect</td> </tr> <tr> <td>提交按钮被点击</td> <td>submit()</td> <td>onsubmit</td> </tr> <tr> <td>元素滚动条在滚动</td> <td>scroll()</td> <td>onscroll</td> </tr> <tr> <td>当加载文档或图像时发生某个错误</td> <td>error()</td> <td>onerror</td> </tr> <tr> <td>提交按钮被点击</td> <td>submit()</td> <td>onsubmit</td> </tr> </tbody></table>\n\n<h3 id=\"2-jquery源码-版本2-1-4\"><a href=\"#2-jquery源码-版本2-1-4\" class=\"headerlink\" title=\"2.jquery源码(版本2.1.4)\"></a>2.jquery源码(版本2.1.4)</h3><pre><code>jQuery.each( (&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; +\n    &quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +\n    &quot;change select submit keydown keypress keyup error contextmenu&quot;).split(&quot; &quot;), function( i, name ) &#123;\n\n    // Handle event binding  事件绑定\n    jQuery.fn[ name ] = function( data, fn ) &#123;\n        return arguments.length &gt; 0 ?\n            this.on( name, null, data, fn ) :\n            this.trigger( name ); \n            //如果不带参数，则返回this.on( name, null, data, fn )，否则返回this.trigger( name )\n    &#125;;\n&#125;);\n</code></pre>\n<p>split() 方法用于把一个字符串分割成字符串数组；<br>each()方法遍历这个数组，为每个匹配元素规定运行的函数；<br>jQuery.fn 指jquery的命名空间，加上fn上的方法及属性；<br>on方法：在选择元素上绑定一个或多个事件的事件处理函数</p>\n<pre><code>on: function( types, selector, data, fn, /*INTERNAL*/ one ) &#123;\n        var origFn, type;\n\n        // Types can be a map of types/handlers  判断types参数\n        if ( typeof types === &quot;object&quot; ) &#123;\n            // ( types-Object, selector, data )\n            if ( typeof selector !== &quot;string&quot; ) &#123;\n                // ( types-Object, data )\n                data = data || selector;\n                selector = undefined;\n            &#125;\n            for ( type in types ) &#123;\n                this.on( type, selector, data, types[ type ], one );\n            &#125;\n            return this;\n        &#125;\n        \n        //判断data参数\n        if ( data == null &amp;&amp; fn == null ) &#123;  \n            // ( types, fn )\n            fn = selector;\n            data = selector = undefined;\n        &#125; else if ( fn == null ) &#123;\n            if ( typeof selector === &quot;string&quot; ) &#123;\n                // ( types, selector, fn )\n                fn = data;\n                data = undefined;\n            &#125; else &#123;\n                // ( types, data, fn )\n                fn = data;\n                data = selector;\n                selector = undefined;\n            &#125;\n        &#125;\n\n        //判断fn参数\n        if ( fn === false ) &#123;  \n            fn = returnFalse;\n        &#125; else if ( !fn ) &#123;\n            return this;\n        &#125;\n\n        //判断fn参数\n        if ( one === 1 ) &#123;\n            origFn = fn;\n            fn = function( event ) &#123;\n                // Can use an empty set, since event contains the info\n                jQuery().off( event );\n                return origFn.apply( this, arguments );\n            &#125;;\n            // Use same guid so caller can remove using origFn\n            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n        &#125;\n        return this.each( function() &#123;\n            jQuery.event.add( this, types, fn, data, selector );\n        &#125;);\n    &#125;\n</code></pre>\n<p>trigger方法：在每一个匹配的元素上触发某类事件。</p>\n<pre><code>trigger: function( type, data ) &#123;\n    return this.each(function() &#123;\n        jQuery.event.trigger( type, data, this );\n    &#125;);\n&#125;,\n</code></pre>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-30 17:28:21</p>\n","site":{"data":{}},"excerpt":"<p>javaScript 与HTML 之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式的模型，支持页面的行为（JavaScript 代码）与页面的外观（HTML 和CSS 代码）之间的松散耦合。</p>","more":"<h3 id=\"1-事件封装一览表\"><a href=\"#1-事件封装一览表\" class=\"headerlink\" title=\"1.事件封装一览表\"></a>1.事件封装一览表</h3><table> <tbody><tr> <td>描述</td> <td>jquery</td> <td>javascript</td> </tr> <tr> <td>鼠标点击某个对象</td> <td>click()</td> <td>onclick</td> </tr> <tr> <td>鼠标双击某个对象</td> <td>dblclick()</td> <td>ondblclick</td> </tr> <tr> <td>元素获得焦点</td> <td>focus()<br/>focusin()[可以在父元素上检测子元素获取焦点的情况]</td> <td>onfocus<br/>onfocusout</td> </tr> <tr> <td>元素失去焦点</td> <td>blur()<br/>focusout()[可以在父元素上检测子元素失去焦点的情况]</td> <td>onblur<br/>onfocusout</td> </tr> <tr> <td>用户改变域的内容</td> <td>change()</td> <td>onchange</td> </tr> <tr> <td>某个键盘的键被按下</td> <td>keydown()</td> <td>onkeydown</td> </tr> <tr> <td>某个键盘的键被按下或按住</td> <td>keypress()</td> <td>onkeypress</td> </tr> <tr> <td>某个键盘的键被松开 </td> <td>keyup()</td> <td>onkeyup</td> </tr> <tr> <td>某个页面或图像被完成加载</td> <td>load()</td> <td>onload</td> </tr> <tr> <td>用户退出页面</td> <td>unload()</td> <td>onunload</td> </tr> <tr> <td>某个鼠标按键被按下</td> <td>mousedown()</td> <td>onmousedown</td> </tr> <tr> <td>鼠标被移动</td> <td>mousemove()</td> <td>onmousemove</td> </tr> <tr> <td>鼠标从某元素移开</td> <td>mouseout()</td> <td>onmouseout</td> </tr> <tr> <td>鼠标被移到某元素之上</td> <td>mouseover()/mouseout【触发子元素有效】<br/> mouseenter()/mouseleave()</td> <td>onmouseover</td> </tr> <tr> <td>某个鼠标按键被松开</td> <td>mouseup()</td> <td>onmouseup</td> </tr> <tr> <td>窗口或框架被调整尺寸</td> <td>resize()</td> <td>onresize</td> </tr> <tr> <td>文本被选定</td> <td>select()</td> <td>onselect</td> </tr> <tr> <td>提交按钮被点击</td> <td>submit()</td> <td>onsubmit</td> </tr> <tr> <td>元素滚动条在滚动</td> <td>scroll()</td> <td>onscroll</td> </tr> <tr> <td>当加载文档或图像时发生某个错误</td> <td>error()</td> <td>onerror</td> </tr> <tr> <td>提交按钮被点击</td> <td>submit()</td> <td>onsubmit</td> </tr> </tbody></table>\n\n<h3 id=\"2-jquery源码-版本2-1-4\"><a href=\"#2-jquery源码-版本2-1-4\" class=\"headerlink\" title=\"2.jquery源码(版本2.1.4)\"></a>2.jquery源码(版本2.1.4)</h3><pre><code>jQuery.each( (&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; +\n    &quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +\n    &quot;change select submit keydown keypress keyup error contextmenu&quot;).split(&quot; &quot;), function( i, name ) &#123;\n\n    // Handle event binding  事件绑定\n    jQuery.fn[ name ] = function( data, fn ) &#123;\n        return arguments.length &gt; 0 ?\n            this.on( name, null, data, fn ) :\n            this.trigger( name ); \n            //如果不带参数，则返回this.on( name, null, data, fn )，否则返回this.trigger( name )\n    &#125;;\n&#125;);\n</code></pre>\n<p>split() 方法用于把一个字符串分割成字符串数组；<br>each()方法遍历这个数组，为每个匹配元素规定运行的函数；<br>jQuery.fn 指jquery的命名空间，加上fn上的方法及属性；<br>on方法：在选择元素上绑定一个或多个事件的事件处理函数</p>\n<pre><code>on: function( types, selector, data, fn, /*INTERNAL*/ one ) &#123;\n        var origFn, type;\n\n        // Types can be a map of types/handlers  判断types参数\n        if ( typeof types === &quot;object&quot; ) &#123;\n            // ( types-Object, selector, data )\n            if ( typeof selector !== &quot;string&quot; ) &#123;\n                // ( types-Object, data )\n                data = data || selector;\n                selector = undefined;\n            &#125;\n            for ( type in types ) &#123;\n                this.on( type, selector, data, types[ type ], one );\n            &#125;\n            return this;\n        &#125;\n        \n        //判断data参数\n        if ( data == null &amp;&amp; fn == null ) &#123;  \n            // ( types, fn )\n            fn = selector;\n            data = selector = undefined;\n        &#125; else if ( fn == null ) &#123;\n            if ( typeof selector === &quot;string&quot; ) &#123;\n                // ( types, selector, fn )\n                fn = data;\n                data = undefined;\n            &#125; else &#123;\n                // ( types, data, fn )\n                fn = data;\n                data = selector;\n                selector = undefined;\n            &#125;\n        &#125;\n\n        //判断fn参数\n        if ( fn === false ) &#123;  \n            fn = returnFalse;\n        &#125; else if ( !fn ) &#123;\n            return this;\n        &#125;\n\n        //判断fn参数\n        if ( one === 1 ) &#123;\n            origFn = fn;\n            fn = function( event ) &#123;\n                // Can use an empty set, since event contains the info\n                jQuery().off( event );\n                return origFn.apply( this, arguments );\n            &#125;;\n            // Use same guid so caller can remove using origFn\n            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n        &#125;\n        return this.each( function() &#123;\n            jQuery.event.add( this, types, fn, data, selector );\n        &#125;);\n    &#125;\n</code></pre>\n<p>trigger方法：在每一个匹配的元素上触发某类事件。</p>\n<pre><code>trigger: function( type, data ) &#123;\n    return this.each(function() &#123;\n        jQuery.event.trigger( type, data, this );\n    &#125;);\n&#125;,\n</code></pre>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-30 17:28:21</p>"},{"title":"javascript作用域链学习笔记","date":"2016-03-14T06:54:41.000Z","description":"javascript作用域链","_content":"\n我的博客地址:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n## 作用域链\n1. ”JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.”　——权威指南\n\n2. 在JavaScript中，一切皆对象，包括函数。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。\n\n3. 在一个函数被定义的时候, 会将它定义时刻的scope chain链接到这个函数对象的[[scope]]属性.\n\n4. 在一个函数对象被调用的时候，会创建一个活动对象(也就是一个对象), 该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。\n\n5. 在每次调用一个函数的时候 ，就会进入一个函数内的作用域，当从函数返回以后，就返回调用前的作用域.\n\n<!-- more -->\n\n## 实例解析\n```javascript\nvar sayHello = function(l,s){\n    var word = \"hello world\";\n}\n\nsayHello();\n```\n\n+ 在执行sayHello定义语句的时候, 会创建一个这个函数对象的[[scope]]属性。\n\n+ 将这个[[scope]]属性, 链接到定义它的作用域链上。此时因为func定义在全局环境, 所以此时的[[scope]]只是指向全局活动对象window active object.\n\n+ 在调用sayHello的时候, 会创建一个活动对象(假设为fObj)，并创建arguments属性。然后会给这个对象添加俩个命名属性fObj.l, fObj.s; 对于每一个在这个函数中申明的局部变量和函数定义, 都作为该活动对象的同名命名属性。对于局部变量,变量的值会在真正执行的时候才计算, 此时只是简单的赋为undefined.\n\n+ 将调用参数赋值给形参，对于缺少的调用参数，赋值为undefined。\n\n+ 将这个活动对象做为scope chain的最前端, 并将func的[[scope]]属性所指向的,定义sayHello时候的顶级活动对象, 加入到scope chain.\n\n+ 在发生标识符解析的时候, 就会逆向查询当前scope chain列表的每一个活动对象的属性，如果找到同名的就返回。找不到，那就是这个标识符没有被定义。\n\n\n作用域链全过程解析：\n```javascript\nfunction factory() {\n     var name = 'laruence';\n     var intro = function(){\n          alert('I am ' + name);\n     }\n     return intro;\n}\n\nfunction app(para){\n     var name = para;\n     var func = factory();\n     func();\n}\n\napp('eve');\n```\n\n首先当调用app的时候, scope chain是由: {window活动对象(全局)}->{app的活动对象} 组成。此时的scope chain如下:（对于局部变量,变量的值会在真正执行的时候才计算, 此时只是简单的赋为undefined.\n）\n```\n[[scope chain]] = [\n{\n     para : 'eve',\n     name : undefined,\n     func : undefined,\n     arguments : []\n}, {\n     window call object\n}\n]\n```\n\n当调用进入factory的函数体的时候, 此时的factory的scope chain为:\n```\n[[scope chain]] = [\n{\n     name : undefined,\n     intor : undefined\n}, {\n     window call object\n}\n]\n```\n\n注意: 此时的作用域链中, 并不包含app的活动对象.(JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.)\n\n在定义intro函数的时候, intro函数的[[scope]]为:\n```\n[[scope chain]] = [\n{\n     name : 'laruence',\n     intor : undefined\n}, {\n     window call object\n}\n]\n```\n\n从factory函数返回以后,在app体内调用intor的时候, 发生了标识符解析, 而此时的sope chain是:\n```\n[[scope chain]] = [\n{\n     intro call object\n}, {\n     name : 'laruence',\n     intor : undefined\n}, {\n     window call object\n}\n]\n```\n所以, name标识符解析的结果(在上面的作用域链中一层层往上匹配)应该是factory活动对象中的name属性, 也就是’laruence’。\n\n\n标识符解析过程：\n该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。\n\n\n\n## 利用作用域链的代码优化\n1. 把全局变量存储到局部变量里再使用\n\n从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。例如下面的代码：\n\n```\nfunction changeColor(){\n    var doc=document;\n    doc.getElementById(\"btnChange\").onclick=function(){\n        doc.getElementById(\"targetCanvas\").style.backgroundColor=\"red\";\n    };\n}\n\n```\n\n\n\n2. 避免改变作用域链\n函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。\n\n```javascript\nfunction initUI(){\n    with(document){\n        var bd=body,\n            links=getElementsByTagName(\"a\"),\n            i=0,\n            len=links.length;\n        while(i < len){\n            update(links[i++]);\n        }\n        getElementById(\"btnInit\").onclick=function(){\n            doSomething();\n        };\n    }\n}\n```\n`with 语句的作用是将代码的作用域设置到一个特定的对象中`\n\n当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。\n\n参考文章:[Javascript作用域原理](http://www.laruence.com/2009/05/28/863.html)、[理解 JavaScript 作用域和作用域链](http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html)","source":"_posts/javascript作用域链学习笔记.md","raw":"title: javascript作用域链学习笔记\ndate: 2016-03-14 14:54:41\ntags: [javascript]\ndescription: javascript作用域链\n\n---\n\n我的博客地址:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n## 作用域链\n1. ”JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.”　——权威指南\n\n2. 在JavaScript中，一切皆对象，包括函数。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。\n\n3. 在一个函数被定义的时候, 会将它定义时刻的scope chain链接到这个函数对象的[[scope]]属性.\n\n4. 在一个函数对象被调用的时候，会创建一个活动对象(也就是一个对象), 该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。\n\n5. 在每次调用一个函数的时候 ，就会进入一个函数内的作用域，当从函数返回以后，就返回调用前的作用域.\n\n<!-- more -->\n\n## 实例解析\n```javascript\nvar sayHello = function(l,s){\n    var word = \"hello world\";\n}\n\nsayHello();\n```\n\n+ 在执行sayHello定义语句的时候, 会创建一个这个函数对象的[[scope]]属性。\n\n+ 将这个[[scope]]属性, 链接到定义它的作用域链上。此时因为func定义在全局环境, 所以此时的[[scope]]只是指向全局活动对象window active object.\n\n+ 在调用sayHello的时候, 会创建一个活动对象(假设为fObj)，并创建arguments属性。然后会给这个对象添加俩个命名属性fObj.l, fObj.s; 对于每一个在这个函数中申明的局部变量和函数定义, 都作为该活动对象的同名命名属性。对于局部变量,变量的值会在真正执行的时候才计算, 此时只是简单的赋为undefined.\n\n+ 将调用参数赋值给形参，对于缺少的调用参数，赋值为undefined。\n\n+ 将这个活动对象做为scope chain的最前端, 并将func的[[scope]]属性所指向的,定义sayHello时候的顶级活动对象, 加入到scope chain.\n\n+ 在发生标识符解析的时候, 就会逆向查询当前scope chain列表的每一个活动对象的属性，如果找到同名的就返回。找不到，那就是这个标识符没有被定义。\n\n\n作用域链全过程解析：\n```javascript\nfunction factory() {\n     var name = 'laruence';\n     var intro = function(){\n          alert('I am ' + name);\n     }\n     return intro;\n}\n\nfunction app(para){\n     var name = para;\n     var func = factory();\n     func();\n}\n\napp('eve');\n```\n\n首先当调用app的时候, scope chain是由: {window活动对象(全局)}->{app的活动对象} 组成。此时的scope chain如下:（对于局部变量,变量的值会在真正执行的时候才计算, 此时只是简单的赋为undefined.\n）\n```\n[[scope chain]] = [\n{\n     para : 'eve',\n     name : undefined,\n     func : undefined,\n     arguments : []\n}, {\n     window call object\n}\n]\n```\n\n当调用进入factory的函数体的时候, 此时的factory的scope chain为:\n```\n[[scope chain]] = [\n{\n     name : undefined,\n     intor : undefined\n}, {\n     window call object\n}\n]\n```\n\n注意: 此时的作用域链中, 并不包含app的活动对象.(JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.)\n\n在定义intro函数的时候, intro函数的[[scope]]为:\n```\n[[scope chain]] = [\n{\n     name : 'laruence',\n     intor : undefined\n}, {\n     window call object\n}\n]\n```\n\n从factory函数返回以后,在app体内调用intor的时候, 发生了标识符解析, 而此时的sope chain是:\n```\n[[scope chain]] = [\n{\n     intro call object\n}, {\n     name : 'laruence',\n     intor : undefined\n}, {\n     window call object\n}\n]\n```\n所以, name标识符解析的结果(在上面的作用域链中一层层往上匹配)应该是factory活动对象中的name属性, 也就是’laruence’。\n\n\n标识符解析过程：\n该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。\n\n\n\n## 利用作用域链的代码优化\n1. 把全局变量存储到局部变量里再使用\n\n从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。例如下面的代码：\n\n```\nfunction changeColor(){\n    var doc=document;\n    doc.getElementById(\"btnChange\").onclick=function(){\n        doc.getElementById(\"targetCanvas\").style.backgroundColor=\"red\";\n    };\n}\n\n```\n\n\n\n2. 避免改变作用域链\n函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。\n\n```javascript\nfunction initUI(){\n    with(document){\n        var bd=body,\n            links=getElementsByTagName(\"a\"),\n            i=0,\n            len=links.length;\n        while(i < len){\n            update(links[i++]);\n        }\n        getElementById(\"btnInit\").onclick=function(){\n            doSomething();\n        };\n    }\n}\n```\n`with 语句的作用是将代码的作用域设置到一个特定的对象中`\n\n当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。\n\n参考文章:[Javascript作用域原理](http://www.laruence.com/2009/05/28/863.html)、[理解 JavaScript 作用域和作用域链](http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html)","slug":"javascript作用域链学习笔记","published":1,"updated":"2021-12-06T06:07:06.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolg0025y4v2gmm65iaf","content":"<p>我的博客地址:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><ol>\n<li><p>”JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.”　——权威指南</p>\n</li>\n<li><p>在JavaScript中，一切皆对象，包括函数。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>\n</li>\n<li><p>在一个函数被定义的时候, 会将它定义时刻的scope chain链接到这个函数对象的[[scope]]属性.</p>\n</li>\n<li><p>在一个函数对象被调用的时候，会创建一个活动对象(也就是一个对象), 该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。</p>\n</li>\n<li><p>在每次调用一个函数的时候 ，就会进入一个函数内的作用域，当从函数返回以后，就返回调用前的作用域.</p>\n</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"实例解析\"><a href=\"#实例解析\" class=\"headerlink\" title=\"实例解析\"></a>实例解析</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">l,s</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> word = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sayHello();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>在执行sayHello定义语句的时候, 会创建一个这个函数对象的[[scope]]属性。</p>\n</li>\n<li><p>将这个[[scope]]属性, 链接到定义它的作用域链上。此时因为func定义在全局环境, 所以此时的[[scope]]只是指向全局活动对象window active object.</p>\n</li>\n<li><p>在调用sayHello的时候, 会创建一个活动对象(假设为fObj)，并创建arguments属性。然后会给这个对象添加俩个命名属性fObj.l, fObj.s; 对于每一个在这个函数中申明的局部变量和函数定义, 都作为该活动对象的同名命名属性。对于局部变量,变量的值会在真正执行的时候才计算, 此时只是简单的赋为undefined.</p>\n</li>\n<li><p>将调用参数赋值给形参，对于缺少的调用参数，赋值为undefined。</p>\n</li>\n<li><p>将这个活动对象做为scope chain的最前端, 并将func的[[scope]]属性所指向的,定义sayHello时候的顶级活动对象, 加入到scope chain.</p>\n</li>\n<li><p>在发生标识符解析的时候, 就会逆向查询当前scope chain列表的每一个活动对象的属性，如果找到同名的就返回。找不到，那就是这个标识符没有被定义。</p>\n</li>\n</ul>\n<p>作用域链全过程解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factory</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;laruence&#x27;</span>;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> intro = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          alert(<span class=\"string\">&#x27;I am &#x27;</span> + name);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> intro;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">app</span>(<span class=\"params\">para</span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> name = para;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> func = factory();</span><br><span class=\"line\">     func();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app(<span class=\"string\">&#x27;eve&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>首先当调用app的时候, scope chain是由: {window活动对象(全局)}-&gt;{app的活动对象} 组成。此时的scope chain如下:（对于局部变量,变量的值会在真正执行的时候才计算, 此时只是简单的赋为undefined.<br>）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[scope chain]] = [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     para : &#x27;eve&#x27;,</span><br><span class=\"line\">     name : undefined,</span><br><span class=\"line\">     func : undefined,</span><br><span class=\"line\">     arguments : []</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">     window call object</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>当调用进入factory的函数体的时候, 此时的factory的scope chain为:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[scope chain]] = [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     name : undefined,</span><br><span class=\"line\">     intor : undefined</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">     window call object</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>注意: 此时的作用域链中, 并不包含app的活动对象.(JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.)</p>\n<p>在定义intro函数的时候, intro函数的[[scope]]为:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[scope chain]] = [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     name : &#x27;laruence&#x27;,</span><br><span class=\"line\">     intor : undefined</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">     window call object</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>从factory函数返回以后,在app体内调用intor的时候, 发生了标识符解析, 而此时的sope chain是:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[scope chain]] = [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     intro call object</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">     name : &#x27;laruence&#x27;,</span><br><span class=\"line\">     intor : undefined</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">     window call object</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>所以, name标识符解析的结果(在上面的作用域链中一层层往上匹配)应该是factory活动对象中的name属性, 也就是’laruence’。</p>\n<p>标识符解析过程：<br>该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。</p>\n<h2 id=\"利用作用域链的代码优化\"><a href=\"#利用作用域链的代码优化\" class=\"headerlink\" title=\"利用作用域链的代码优化\"></a>利用作用域链的代码优化</h2><ol>\n<li>把全局变量存储到局部变量里再使用</li>\n</ol>\n<p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。例如下面的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function changeColor()&#123;</span><br><span class=\"line\">    var doc=document;</span><br><span class=\"line\">    doc.getElementById(&quot;btnChange&quot;).onclick=function()&#123;</span><br><span class=\"line\">        doc.getElementById(&quot;targetCanvas&quot;).style.backgroundColor=&quot;red&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"2\">\n<li>避免改变作用域链<br>函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initUI</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">with</span>(<span class=\"params\"><span class=\"built_in\">document</span></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bd=body,</span><br><span class=\"line\">            links=getElementsByTagName(<span class=\"string\">&quot;a&quot;</span>),</span><br><span class=\"line\">            i=<span class=\"number\">0</span>,</span><br><span class=\"line\">            len=links.length;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; len)&#123;</span><br><span class=\"line\">            update(links[i++]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        getElementById(<span class=\"string\">&quot;btnInit&quot;</span>).onclick=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            doSomething();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>with 语句的作用是将代码的作用域设置到一个特定的对象中</code></p>\n<p>当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。</p>\n<p>参考文章:<a href=\"http://www.laruence.com/2009/05/28/863.html\">Javascript作用域原理</a>、<a href=\"http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html\">理解 JavaScript 作用域和作用域链</a></p>\n","site":{"data":{}},"excerpt":"<p>我的博客地址:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><ol>\n<li><p>”JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.”　——权威指南</p>\n</li>\n<li><p>在JavaScript中，一切皆对象，包括函数。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>\n</li>\n<li><p>在一个函数被定义的时候, 会将它定义时刻的scope chain链接到这个函数对象的[[scope]]属性.</p>\n</li>\n<li><p>在一个函数对象被调用的时候，会创建一个活动对象(也就是一个对象), 该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。</p>\n</li>\n<li><p>在每次调用一个函数的时候 ，就会进入一个函数内的作用域，当从函数返回以后，就返回调用前的作用域.</p>\n</li>\n</ol>","more":"<h2 id=\"实例解析\"><a href=\"#实例解析\" class=\"headerlink\" title=\"实例解析\"></a>实例解析</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">l,s</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> word = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sayHello();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>在执行sayHello定义语句的时候, 会创建一个这个函数对象的[[scope]]属性。</p>\n</li>\n<li><p>将这个[[scope]]属性, 链接到定义它的作用域链上。此时因为func定义在全局环境, 所以此时的[[scope]]只是指向全局活动对象window active object.</p>\n</li>\n<li><p>在调用sayHello的时候, 会创建一个活动对象(假设为fObj)，并创建arguments属性。然后会给这个对象添加俩个命名属性fObj.l, fObj.s; 对于每一个在这个函数中申明的局部变量和函数定义, 都作为该活动对象的同名命名属性。对于局部变量,变量的值会在真正执行的时候才计算, 此时只是简单的赋为undefined.</p>\n</li>\n<li><p>将调用参数赋值给形参，对于缺少的调用参数，赋值为undefined。</p>\n</li>\n<li><p>将这个活动对象做为scope chain的最前端, 并将func的[[scope]]属性所指向的,定义sayHello时候的顶级活动对象, 加入到scope chain.</p>\n</li>\n<li><p>在发生标识符解析的时候, 就会逆向查询当前scope chain列表的每一个活动对象的属性，如果找到同名的就返回。找不到，那就是这个标识符没有被定义。</p>\n</li>\n</ul>\n<p>作用域链全过程解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factory</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;laruence&#x27;</span>;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> intro = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          alert(<span class=\"string\">&#x27;I am &#x27;</span> + name);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> intro;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">app</span>(<span class=\"params\">para</span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> name = para;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> func = factory();</span><br><span class=\"line\">     func();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app(<span class=\"string\">&#x27;eve&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>首先当调用app的时候, scope chain是由: {window活动对象(全局)}-&gt;{app的活动对象} 组成。此时的scope chain如下:（对于局部变量,变量的值会在真正执行的时候才计算, 此时只是简单的赋为undefined.<br>）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[scope chain]] = [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     para : &#x27;eve&#x27;,</span><br><span class=\"line\">     name : undefined,</span><br><span class=\"line\">     func : undefined,</span><br><span class=\"line\">     arguments : []</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">     window call object</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>当调用进入factory的函数体的时候, 此时的factory的scope chain为:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[scope chain]] = [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     name : undefined,</span><br><span class=\"line\">     intor : undefined</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">     window call object</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>注意: 此时的作用域链中, 并不包含app的活动对象.(JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.)</p>\n<p>在定义intro函数的时候, intro函数的[[scope]]为:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[scope chain]] = [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     name : &#x27;laruence&#x27;,</span><br><span class=\"line\">     intor : undefined</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">     window call object</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>从factory函数返回以后,在app体内调用intor的时候, 发生了标识符解析, 而此时的sope chain是:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[scope chain]] = [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     intro call object</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">     name : &#x27;laruence&#x27;,</span><br><span class=\"line\">     intor : undefined</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">     window call object</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>所以, name标识符解析的结果(在上面的作用域链中一层层往上匹配)应该是factory活动对象中的name属性, 也就是’laruence’。</p>\n<p>标识符解析过程：<br>该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。</p>\n<h2 id=\"利用作用域链的代码优化\"><a href=\"#利用作用域链的代码优化\" class=\"headerlink\" title=\"利用作用域链的代码优化\"></a>利用作用域链的代码优化</h2><ol>\n<li>把全局变量存储到局部变量里再使用</li>\n</ol>\n<p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。例如下面的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function changeColor()&#123;</span><br><span class=\"line\">    var doc=document;</span><br><span class=\"line\">    doc.getElementById(&quot;btnChange&quot;).onclick=function()&#123;</span><br><span class=\"line\">        doc.getElementById(&quot;targetCanvas&quot;).style.backgroundColor=&quot;red&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"2\">\n<li>避免改变作用域链<br>函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initUI</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">with</span>(<span class=\"params\"><span class=\"built_in\">document</span></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bd=body,</span><br><span class=\"line\">            links=getElementsByTagName(<span class=\"string\">&quot;a&quot;</span>),</span><br><span class=\"line\">            i=<span class=\"number\">0</span>,</span><br><span class=\"line\">            len=links.length;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; len)&#123;</span><br><span class=\"line\">            update(links[i++]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        getElementById(<span class=\"string\">&quot;btnInit&quot;</span>).onclick=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            doSomething();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>with 语句的作用是将代码的作用域设置到一个特定的对象中</code></p>\n<p>当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。</p>\n<p>参考文章:<a href=\"http://www.laruence.com/2009/05/28/863.html\">Javascript作用域原理</a>、<a href=\"http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html\">理解 JavaScript 作用域和作用域链</a></p>"},{"_content":"\n\n# javascript 基础\n\n## [内存](http://www.jianshu.com/p/996671d4dcc4)\n\n### 堆与栈\n\n1. 堆内存类似书架，无关顺序，按地址取。\n\n2. 栈内存类似羽毛球桶，先进后出。\n\n### javascript中的内存\n1. 严格意义上来说，javascript只有堆内存，基本类型值储存在变量对象中。而变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。\n\n### 数据类型\n1. 引用类型值： （对象），长度不固定，是按引用访问的。\n2. 基本类型值：（Undefined、Null、Boolean、Number、String），长度固定，按值访问。\n\n### 内存管理\n\n1. 分配内存  （定义变量时）\n2. 使用分配到的内存（数据处理等读、写操作）\n3. 不需要时将其释放、归还 （简单方法是将null赋值给变量）\n\n## 垃圾回收：\n1. 在局部作用域中，当函数执行完毕，回收局部变量的值。\n2. 在全局作用域中，当一个值不再有变量引用它时，会进行回收。\n\n### 深浅拷贝\n\n对象的简单赋值，只是浅拷贝，只是把引用拷贝给了新变量，并没有生成一个全新的对象值。\n\n\n## [执行上下文（Execution Context）](http://www.jianshu.com/p/a6d37c77e8db)\n\n一个执行上下文会形成一个作用域。一个JavaScript程序中，会有一个全局的执行上下文，并且遇到函数和eval都会生成一个新的执行上下文。\n\nJavaScript引擎以堆栈的方式来处理执行上下文，这个堆栈，我们称其为**函数调用栈(call stack)**。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。每个执行上下文中的代码执行完毕后，这个执行上下文就会从从栈中弹出。\n\n过程： \n1. 生成全局执行上下文，将其放入栈底\n2. 执行栈顶上下文中的代码（一开始是全局执行上下文），遇到函数或者eval从而生成新的执行上下文，放入栈顶，并执行其中代码。\n3. 当前执行上下文中的代码执行完毕，当前执行上下文从栈中弹出，继续步骤2，直至栈中只剩下全局上下文\n4. 全局上下文只有唯一的一个，在应用关闭时出栈\n\n### 执行上下文的生命周期\n+ 创建阶段\n    + 创建变量对象\n    + 建立作用域链\n    + 以及确定this的指向\n+ 代码执行阶段（此时变量对象成为活动对象）\n    + 变量赋值\n    + 函数引用\n    + 执行其他代码\n\n## [变量对象](http://www.jianshu.com/p/330b1505e41d)\n\n1. 变量对象的创建: （理解变量提升）\n    + 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。\n    + 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。\n    + 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。\n\n全局执行上下文的变量对象在浏览器中是window对象。\n\n## 作用域链\n\n作用域是引擎根据标识符名称进行变量查找的规则。（标识符，指的是变量名或者函数名）\n\n> 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。\n\n\n### 作用域与执行上下文\n\nJavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段**作用域**会确定。执行阶段由引擎完成，主要任务是执行可执行代码，**执行上下文**在这个阶段创建。\n\n作用域在编译阶段生成，执行上下文在执行阶段生成，作用域链是在执行上下文的创建阶段生成的。\n\n当前作用域与上层作用域不是包含关系。作用域链就是一个形似糖葫芦的单方向通道。\n\n\n## this\n\nthis的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的，指向当前执行上下文。\n\n如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。\n\n\ncall，apply指定this指向的对象。\n\n## 构造函数\n通过new操作符调用构造函数，会经历以下4个阶段。\n\n+ 创建一个新的对象；\n+ 将构造函数的this指向这个新对象；\n+ 为这个对象添加属性，方法等；\n+ 返回新对象。\n\n\n## 模块化\n\n一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。\n\n可以通过闭包来实现公有变量和公有方法。\n\n\n## 隐式转换\n\n当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString/vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。其中valueOf会比toString后执行\n","source":"_posts/js基础.md","raw":"\n\n# javascript 基础\n\n## [内存](http://www.jianshu.com/p/996671d4dcc4)\n\n### 堆与栈\n\n1. 堆内存类似书架，无关顺序，按地址取。\n\n2. 栈内存类似羽毛球桶，先进后出。\n\n### javascript中的内存\n1. 严格意义上来说，javascript只有堆内存，基本类型值储存在变量对象中。而变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。\n\n### 数据类型\n1. 引用类型值： （对象），长度不固定，是按引用访问的。\n2. 基本类型值：（Undefined、Null、Boolean、Number、String），长度固定，按值访问。\n\n### 内存管理\n\n1. 分配内存  （定义变量时）\n2. 使用分配到的内存（数据处理等读、写操作）\n3. 不需要时将其释放、归还 （简单方法是将null赋值给变量）\n\n## 垃圾回收：\n1. 在局部作用域中，当函数执行完毕，回收局部变量的值。\n2. 在全局作用域中，当一个值不再有变量引用它时，会进行回收。\n\n### 深浅拷贝\n\n对象的简单赋值，只是浅拷贝，只是把引用拷贝给了新变量，并没有生成一个全新的对象值。\n\n\n## [执行上下文（Execution Context）](http://www.jianshu.com/p/a6d37c77e8db)\n\n一个执行上下文会形成一个作用域。一个JavaScript程序中，会有一个全局的执行上下文，并且遇到函数和eval都会生成一个新的执行上下文。\n\nJavaScript引擎以堆栈的方式来处理执行上下文，这个堆栈，我们称其为**函数调用栈(call stack)**。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。每个执行上下文中的代码执行完毕后，这个执行上下文就会从从栈中弹出。\n\n过程： \n1. 生成全局执行上下文，将其放入栈底\n2. 执行栈顶上下文中的代码（一开始是全局执行上下文），遇到函数或者eval从而生成新的执行上下文，放入栈顶，并执行其中代码。\n3. 当前执行上下文中的代码执行完毕，当前执行上下文从栈中弹出，继续步骤2，直至栈中只剩下全局上下文\n4. 全局上下文只有唯一的一个，在应用关闭时出栈\n\n### 执行上下文的生命周期\n+ 创建阶段\n    + 创建变量对象\n    + 建立作用域链\n    + 以及确定this的指向\n+ 代码执行阶段（此时变量对象成为活动对象）\n    + 变量赋值\n    + 函数引用\n    + 执行其他代码\n\n## [变量对象](http://www.jianshu.com/p/330b1505e41d)\n\n1. 变量对象的创建: （理解变量提升）\n    + 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。\n    + 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。\n    + 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。\n\n全局执行上下文的变量对象在浏览器中是window对象。\n\n## 作用域链\n\n作用域是引擎根据标识符名称进行变量查找的规则。（标识符，指的是变量名或者函数名）\n\n> 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。\n\n\n### 作用域与执行上下文\n\nJavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段**作用域**会确定。执行阶段由引擎完成，主要任务是执行可执行代码，**执行上下文**在这个阶段创建。\n\n作用域在编译阶段生成，执行上下文在执行阶段生成，作用域链是在执行上下文的创建阶段生成的。\n\n当前作用域与上层作用域不是包含关系。作用域链就是一个形似糖葫芦的单方向通道。\n\n\n## this\n\nthis的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的，指向当前执行上下文。\n\n如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。\n\n\ncall，apply指定this指向的对象。\n\n## 构造函数\n通过new操作符调用构造函数，会经历以下4个阶段。\n\n+ 创建一个新的对象；\n+ 将构造函数的this指向这个新对象；\n+ 为这个对象添加属性，方法等；\n+ 返回新对象。\n\n\n## 模块化\n\n一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。\n\n可以通过闭包来实现公有变量和公有方法。\n\n\n## 隐式转换\n\n当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString/vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。其中valueOf会比toString后执行\n","slug":"js基础","published":1,"date":"2021-12-06T06:07:06.184Z","updated":"2021-12-06T06:07:06.184Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolh0028y4v274ab7cow","content":"<h1 id=\"javascript-基础\"><a href=\"#javascript-基础\" class=\"headerlink\" title=\"javascript 基础\"></a>javascript 基础</h1><h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a><a href=\"http://www.jianshu.com/p/996671d4dcc4\">内存</a></h2><h3 id=\"堆与栈\"><a href=\"#堆与栈\" class=\"headerlink\" title=\"堆与栈\"></a>堆与栈</h3><ol>\n<li><p>堆内存类似书架，无关顺序，按地址取。</p>\n</li>\n<li><p>栈内存类似羽毛球桶，先进后出。</p>\n</li>\n</ol>\n<h3 id=\"javascript中的内存\"><a href=\"#javascript中的内存\" class=\"headerlink\" title=\"javascript中的内存\"></a>javascript中的内存</h3><ol>\n<li>严格意义上来说，javascript只有堆内存，基本类型值储存在变量对象中。而变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。</li>\n</ol>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><ol>\n<li>引用类型值： （对象），长度不固定，是按引用访问的。</li>\n<li>基本类型值：（Undefined、Null、Boolean、Number、String），长度固定，按值访问。</li>\n</ol>\n<h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h3><ol>\n<li>分配内存  （定义变量时）</li>\n<li>使用分配到的内存（数据处理等读、写操作）</li>\n<li>不需要时将其释放、归还 （简单方法是将null赋值给变量）</li>\n</ol>\n<h2 id=\"垃圾回收：\"><a href=\"#垃圾回收：\" class=\"headerlink\" title=\"垃圾回收：\"></a>垃圾回收：</h2><ol>\n<li>在局部作用域中，当函数执行完毕，回收局部变量的值。</li>\n<li>在全局作用域中，当一个值不再有变量引用它时，会进行回收。</li>\n</ol>\n<h3 id=\"深浅拷贝\"><a href=\"#深浅拷贝\" class=\"headerlink\" title=\"深浅拷贝\"></a>深浅拷贝</h3><p>对象的简单赋值，只是浅拷贝，只是把引用拷贝给了新变量，并没有生成一个全新的对象值。</p>\n<h2 id=\"执行上下文（Execution-Context）\"><a href=\"#执行上下文（Execution-Context）\" class=\"headerlink\" title=\"执行上下文（Execution Context）\"></a><a href=\"http://www.jianshu.com/p/a6d37c77e8db\">执行上下文（Execution Context）</a></h2><p>一个执行上下文会形成一个作用域。一个JavaScript程序中，会有一个全局的执行上下文，并且遇到函数和eval都会生成一个新的执行上下文。</p>\n<p>JavaScript引擎以堆栈的方式来处理执行上下文，这个堆栈，我们称其为**函数调用栈(call stack)**。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。每个执行上下文中的代码执行完毕后，这个执行上下文就会从从栈中弹出。</p>\n<p>过程： </p>\n<ol>\n<li>生成全局执行上下文，将其放入栈底</li>\n<li>执行栈顶上下文中的代码（一开始是全局执行上下文），遇到函数或者eval从而生成新的执行上下文，放入栈顶，并执行其中代码。</li>\n<li>当前执行上下文中的代码执行完毕，当前执行上下文从栈中弹出，继续步骤2，直至栈中只剩下全局上下文</li>\n<li>全局上下文只有唯一的一个，在应用关闭时出栈</li>\n</ol>\n<h3 id=\"执行上下文的生命周期\"><a href=\"#执行上下文的生命周期\" class=\"headerlink\" title=\"执行上下文的生命周期\"></a>执行上下文的生命周期</h3><ul>\n<li>创建阶段<ul>\n<li>创建变量对象</li>\n<li>建立作用域链</li>\n<li>以及确定this的指向</li>\n</ul>\n</li>\n<li>代码执行阶段（此时变量对象成为活动对象）<ul>\n<li>变量赋值</li>\n<li>函数引用</li>\n<li>执行其他代码</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"变量对象\"><a href=\"#变量对象\" class=\"headerlink\" title=\"变量对象\"></a><a href=\"http://www.jianshu.com/p/330b1505e41d\">变量对象</a></h2><ol>\n<li>变量对象的创建: （理解变量提升）<ul>\n<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>\n<li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>\n<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。</li>\n</ul>\n</li>\n</ol>\n<p>全局执行上下文的变量对象在浏览器中是window对象。</p>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><p>作用域是引擎根据标识符名称进行变量查找的规则。（标识符，指的是变量名或者函数名）</p>\n<blockquote>\n<p>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>\n</blockquote>\n<h3 id=\"作用域与执行上下文\"><a href=\"#作用域与执行上下文\" class=\"headerlink\" title=\"作用域与执行上下文\"></a>作用域与执行上下文</h3><p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段<strong>作用域</strong>会确定。执行阶段由引擎完成，主要任务是执行可执行代码，<strong>执行上下文</strong>在这个阶段创建。</p>\n<p>作用域在编译阶段生成，执行上下文在执行阶段生成，作用域链是在执行上下文的创建阶段生成的。</p>\n<p>当前作用域与上层作用域不是包含关系。作用域链就是一个形似糖葫芦的单方向通道。</p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><p>this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的，指向当前执行上下文。</p>\n<p>如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p>\n<p>call，apply指定this指向的对象。</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>通过new操作符调用构造函数，会经历以下4个阶段。</p>\n<ul>\n<li>创建一个新的对象；</li>\n<li>将构造函数的this指向这个新对象；</li>\n<li>为这个对象添加属性，方法等；</li>\n<li>返回新对象。</li>\n</ul>\n<h2 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h2><p>一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。</p>\n<p>可以通过闭包来实现公有变量和公有方法。</p>\n<h2 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h2><p>当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString/vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。其中valueOf会比toString后执行</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"javascript-基础\"><a href=\"#javascript-基础\" class=\"headerlink\" title=\"javascript 基础\"></a>javascript 基础</h1><h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a><a href=\"http://www.jianshu.com/p/996671d4dcc4\">内存</a></h2><h3 id=\"堆与栈\"><a href=\"#堆与栈\" class=\"headerlink\" title=\"堆与栈\"></a>堆与栈</h3><ol>\n<li><p>堆内存类似书架，无关顺序，按地址取。</p>\n</li>\n<li><p>栈内存类似羽毛球桶，先进后出。</p>\n</li>\n</ol>\n<h3 id=\"javascript中的内存\"><a href=\"#javascript中的内存\" class=\"headerlink\" title=\"javascript中的内存\"></a>javascript中的内存</h3><ol>\n<li>严格意义上来说，javascript只有堆内存，基本类型值储存在变量对象中。而变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。</li>\n</ol>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><ol>\n<li>引用类型值： （对象），长度不固定，是按引用访问的。</li>\n<li>基本类型值：（Undefined、Null、Boolean、Number、String），长度固定，按值访问。</li>\n</ol>\n<h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h3><ol>\n<li>分配内存  （定义变量时）</li>\n<li>使用分配到的内存（数据处理等读、写操作）</li>\n<li>不需要时将其释放、归还 （简单方法是将null赋值给变量）</li>\n</ol>\n<h2 id=\"垃圾回收：\"><a href=\"#垃圾回收：\" class=\"headerlink\" title=\"垃圾回收：\"></a>垃圾回收：</h2><ol>\n<li>在局部作用域中，当函数执行完毕，回收局部变量的值。</li>\n<li>在全局作用域中，当一个值不再有变量引用它时，会进行回收。</li>\n</ol>\n<h3 id=\"深浅拷贝\"><a href=\"#深浅拷贝\" class=\"headerlink\" title=\"深浅拷贝\"></a>深浅拷贝</h3><p>对象的简单赋值，只是浅拷贝，只是把引用拷贝给了新变量，并没有生成一个全新的对象值。</p>\n<h2 id=\"执行上下文（Execution-Context）\"><a href=\"#执行上下文（Execution-Context）\" class=\"headerlink\" title=\"执行上下文（Execution Context）\"></a><a href=\"http://www.jianshu.com/p/a6d37c77e8db\">执行上下文（Execution Context）</a></h2><p>一个执行上下文会形成一个作用域。一个JavaScript程序中，会有一个全局的执行上下文，并且遇到函数和eval都会生成一个新的执行上下文。</p>\n<p>JavaScript引擎以堆栈的方式来处理执行上下文，这个堆栈，我们称其为**函数调用栈(call stack)**。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。每个执行上下文中的代码执行完毕后，这个执行上下文就会从从栈中弹出。</p>\n<p>过程： </p>\n<ol>\n<li>生成全局执行上下文，将其放入栈底</li>\n<li>执行栈顶上下文中的代码（一开始是全局执行上下文），遇到函数或者eval从而生成新的执行上下文，放入栈顶，并执行其中代码。</li>\n<li>当前执行上下文中的代码执行完毕，当前执行上下文从栈中弹出，继续步骤2，直至栈中只剩下全局上下文</li>\n<li>全局上下文只有唯一的一个，在应用关闭时出栈</li>\n</ol>\n<h3 id=\"执行上下文的生命周期\"><a href=\"#执行上下文的生命周期\" class=\"headerlink\" title=\"执行上下文的生命周期\"></a>执行上下文的生命周期</h3><ul>\n<li>创建阶段<ul>\n<li>创建变量对象</li>\n<li>建立作用域链</li>\n<li>以及确定this的指向</li>\n</ul>\n</li>\n<li>代码执行阶段（此时变量对象成为活动对象）<ul>\n<li>变量赋值</li>\n<li>函数引用</li>\n<li>执行其他代码</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"变量对象\"><a href=\"#变量对象\" class=\"headerlink\" title=\"变量对象\"></a><a href=\"http://www.jianshu.com/p/330b1505e41d\">变量对象</a></h2><ol>\n<li>变量对象的创建: （理解变量提升）<ul>\n<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>\n<li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>\n<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。</li>\n</ul>\n</li>\n</ol>\n<p>全局执行上下文的变量对象在浏览器中是window对象。</p>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><p>作用域是引擎根据标识符名称进行变量查找的规则。（标识符，指的是变量名或者函数名）</p>\n<blockquote>\n<p>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>\n</blockquote>\n<h3 id=\"作用域与执行上下文\"><a href=\"#作用域与执行上下文\" class=\"headerlink\" title=\"作用域与执行上下文\"></a>作用域与执行上下文</h3><p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段<strong>作用域</strong>会确定。执行阶段由引擎完成，主要任务是执行可执行代码，<strong>执行上下文</strong>在这个阶段创建。</p>\n<p>作用域在编译阶段生成，执行上下文在执行阶段生成，作用域链是在执行上下文的创建阶段生成的。</p>\n<p>当前作用域与上层作用域不是包含关系。作用域链就是一个形似糖葫芦的单方向通道。</p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><p>this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的，指向当前执行上下文。</p>\n<p>如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p>\n<p>call，apply指定this指向的对象。</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>通过new操作符调用构造函数，会经历以下4个阶段。</p>\n<ul>\n<li>创建一个新的对象；</li>\n<li>将构造函数的this指向这个新对象；</li>\n<li>为这个对象添加属性，方法等；</li>\n<li>返回新对象。</li>\n</ul>\n<h2 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h2><p>一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。</p>\n<p>可以通过闭包来实现公有变量和公有方法。</p>\n<h2 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h2><p>当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString/vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。其中valueOf会比toString后执行</p>\n"},{"title":"jquery和js控制元素的尺寸和位置","date":"2015-04-28T14:38:14.000Z","description":"jquery和js控制样式，位置，尺寸","_content":"\n### 1.偏移量\n_javascript_：\n\n* offsetLeft：元素的左外边框至offsetParent的左内边框之间的像素距离。\n* offsetTop：元素的上外边框至offsetParent的上内边框之间的像素距离。\n* 这里的offsetParent为距离当前元素最近的拥有定位的父元素：\n　　1.拥有定位指的是position为absolute或relative\n　　2.如果当前元素的父级元素并不拥有定位，offsetParent为body。\n\n<!-- more -->\n\n---\n\n_jquery_：\n\n* position()：\n　　*返回的对象包含两个整型属性：top 和 left；\n\n　　*可通过ele.position().top和ele.position().left单独获取和设置\n* offset():\n\n　　*获取匹配元素在当前视口的相对偏移。\n![](/images/201511/8.png)\n\n<i> 上图盗自《javascript高级程序设计》</i>\n\n### 2.尺寸值\n_javascript_：\n\n* offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。<b style=\"color:red\">只能获取，不能设置</b>。\n* offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。<b style=\"color:red\">只能获取，不能设</b>。\n* ele.style.width  获取元素content的宽度。不包括补白和边距、边框\n* ele.style.height  获取元素content的高度。不包括补白和边距、边框\n* clientWidth  元素内容区宽度加上左右内边距宽度\n* clientHeight  元素内容区高度加上上下内边距高\n\n---\n_jquery_：\n\n* outerHeight()      \n　　与javascript的offsetHeight功能一致\n* outerWidth()       \n　　与javascript的offsetWidth功能一致\n* width()\n　　与javascript的ele.style.width功能一致\n* height()           \n　　与javascript的ele.style.height功能一致\n* innerWidth()       \n　　与javascript的clientWidth功能一致\n* innerHeight()      \n　　与javascript的clientHeight功能一致\n![](/images/201511/9.png)\n\n<i>上图盗自《javascript高级程序设计》</i>\n\n### 2.滚动大小\n_javascript_\n\n* scrollHeight：在没有滚动条的情况下，元素内容的总高度。=scrollTop+可视区域高度\n* scrollWidth：在没有滚动条的情况下，元素内容的总宽度。=scrollLeft+可视区域宽度\n* scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。\n* scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。\n\n_jquery_：\n\n* scrollTop()  获取匹配元素相对滚动条顶部的偏移，同js\n* scrollLeft()  获取匹配元素相对滚动条左侧的偏移，同js\n![](/images/201511/10.png)\n<i>上图，你懂的</i>\n\n---\n<p style=\"text-align:right\">整理于2015-11-26 16:13:14</p>","source":"_posts/jquery和js获取及设置元素的尺寸和位置.md","raw":"title: jquery和js控制元素的尺寸和位置\ndate: 2015-04-28 22:38:14\ndescription: jquery和js控制样式，位置，尺寸\ntags: [web,javascript]\n---\n\n### 1.偏移量\n_javascript_：\n\n* offsetLeft：元素的左外边框至offsetParent的左内边框之间的像素距离。\n* offsetTop：元素的上外边框至offsetParent的上内边框之间的像素距离。\n* 这里的offsetParent为距离当前元素最近的拥有定位的父元素：\n　　1.拥有定位指的是position为absolute或relative\n　　2.如果当前元素的父级元素并不拥有定位，offsetParent为body。\n\n<!-- more -->\n\n---\n\n_jquery_：\n\n* position()：\n　　*返回的对象包含两个整型属性：top 和 left；\n\n　　*可通过ele.position().top和ele.position().left单独获取和设置\n* offset():\n\n　　*获取匹配元素在当前视口的相对偏移。\n![](/images/201511/8.png)\n\n<i> 上图盗自《javascript高级程序设计》</i>\n\n### 2.尺寸值\n_javascript_：\n\n* offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。<b style=\"color:red\">只能获取，不能设置</b>。\n* offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。<b style=\"color:red\">只能获取，不能设</b>。\n* ele.style.width  获取元素content的宽度。不包括补白和边距、边框\n* ele.style.height  获取元素content的高度。不包括补白和边距、边框\n* clientWidth  元素内容区宽度加上左右内边距宽度\n* clientHeight  元素内容区高度加上上下内边距高\n\n---\n_jquery_：\n\n* outerHeight()      \n　　与javascript的offsetHeight功能一致\n* outerWidth()       \n　　与javascript的offsetWidth功能一致\n* width()\n　　与javascript的ele.style.width功能一致\n* height()           \n　　与javascript的ele.style.height功能一致\n* innerWidth()       \n　　与javascript的clientWidth功能一致\n* innerHeight()      \n　　与javascript的clientHeight功能一致\n![](/images/201511/9.png)\n\n<i>上图盗自《javascript高级程序设计》</i>\n\n### 2.滚动大小\n_javascript_\n\n* scrollHeight：在没有滚动条的情况下，元素内容的总高度。=scrollTop+可视区域高度\n* scrollWidth：在没有滚动条的情况下，元素内容的总宽度。=scrollLeft+可视区域宽度\n* scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。\n* scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。\n\n_jquery_：\n\n* scrollTop()  获取匹配元素相对滚动条顶部的偏移，同js\n* scrollLeft()  获取匹配元素相对滚动条左侧的偏移，同js\n![](/images/201511/10.png)\n<i>上图，你懂的</i>\n\n---\n<p style=\"text-align:right\">整理于2015-11-26 16:13:14</p>","slug":"jquery和js获取及设置元素的尺寸和位置","published":1,"updated":"2021-12-06T06:07:06.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoli002ay4v2bnlceilm","content":"<h3 id=\"1-偏移量\"><a href=\"#1-偏移量\" class=\"headerlink\" title=\"1.偏移量\"></a>1.偏移量</h3><p>_javascript_：</p>\n<ul>\n<li>offsetLeft：元素的左外边框至offsetParent的左内边框之间的像素距离。</li>\n<li>offsetTop：元素的上外边框至offsetParent的上内边框之间的像素距离。</li>\n<li>这里的offsetParent为距离当前元素最近的拥有定位的父元素：<br>　　1.拥有定位指的是position为absolute或relative<br>　　2.如果当前元素的父级元素并不拥有定位，offsetParent为body。</li>\n</ul>\n<span id=\"more\"></span>\n\n<hr>\n<p>_jquery_：</p>\n<ul>\n<li>position()：<br>　　*返回的对象包含两个整型属性：top 和 left；</li>\n</ul>\n<p>　　*可通过ele.position().top和ele.position().left单独获取和设置</p>\n<ul>\n<li>offset():</li>\n</ul>\n<p>　　*获取匹配元素在当前视口的相对偏移。<br><img src=\"/images/201511/8.png\"></p>\n<p><i> 上图盗自《javascript高级程序设计》</i></p>\n<h3 id=\"2-尺寸值\"><a href=\"#2-尺寸值\" class=\"headerlink\" title=\"2.尺寸值\"></a>2.尺寸值</h3><p>_javascript_：</p>\n<ul>\n<li>offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。<b style=\"color:red\">只能获取，不能设置</b>。</li>\n<li>offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。<b style=\"color:red\">只能获取，不能设</b>。</li>\n<li>ele.style.width  获取元素content的宽度。不包括补白和边距、边框</li>\n<li>ele.style.height  获取元素content的高度。不包括补白和边距、边框</li>\n<li>clientWidth  元素内容区宽度加上左右内边距宽度</li>\n<li>clientHeight  元素内容区高度加上上下内边距高</li>\n</ul>\n<hr>\n<p>_jquery_：</p>\n<ul>\n<li>outerHeight()<br>　　与javascript的offsetHeight功能一致</li>\n<li>outerWidth()<br>　　与javascript的offsetWidth功能一致</li>\n<li>width()<br>　　与javascript的ele.style.width功能一致</li>\n<li>height()<br>　　与javascript的ele.style.height功能一致</li>\n<li>innerWidth()<br>　　与javascript的clientWidth功能一致</li>\n<li>innerHeight()<br>　　与javascript的clientHeight功能一致<br><img src=\"/images/201511/9.png\"></li>\n</ul>\n<p><i>上图盗自《javascript高级程序设计》</i></p>\n<h3 id=\"2-滚动大小\"><a href=\"#2-滚动大小\" class=\"headerlink\" title=\"2.滚动大小\"></a>2.滚动大小</h3><p><em>javascript</em></p>\n<ul>\n<li>scrollHeight：在没有滚动条的情况下，元素内容的总高度。=scrollTop+可视区域高度</li>\n<li>scrollWidth：在没有滚动条的情况下，元素内容的总宽度。=scrollLeft+可视区域宽度</li>\n<li>scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</li>\n<li>scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</li>\n</ul>\n<p>_jquery_：</p>\n<ul>\n<li>scrollTop()  获取匹配元素相对滚动条顶部的偏移，同js</li>\n<li>scrollLeft()  获取匹配元素相对滚动条左侧的偏移，同js<br><img src=\"/images/201511/10.png\"><br><i>上图，你懂的</i></li>\n</ul>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-26 16:13:14</p>","site":{"data":{}},"excerpt":"<h3 id=\"1-偏移量\"><a href=\"#1-偏移量\" class=\"headerlink\" title=\"1.偏移量\"></a>1.偏移量</h3><p>_javascript_：</p>\n<ul>\n<li>offsetLeft：元素的左外边框至offsetParent的左内边框之间的像素距离。</li>\n<li>offsetTop：元素的上外边框至offsetParent的上内边框之间的像素距离。</li>\n<li>这里的offsetParent为距离当前元素最近的拥有定位的父元素：<br>　　1.拥有定位指的是position为absolute或relative<br>　　2.如果当前元素的父级元素并不拥有定位，offsetParent为body。</li>\n</ul>","more":"<hr>\n<p>_jquery_：</p>\n<ul>\n<li>position()：<br>　　*返回的对象包含两个整型属性：top 和 left；</li>\n</ul>\n<p>　　*可通过ele.position().top和ele.position().left单独获取和设置</p>\n<ul>\n<li>offset():</li>\n</ul>\n<p>　　*获取匹配元素在当前视口的相对偏移。<br><img src=\"/images/201511/8.png\"></p>\n<p><i> 上图盗自《javascript高级程序设计》</i></p>\n<h3 id=\"2-尺寸值\"><a href=\"#2-尺寸值\" class=\"headerlink\" title=\"2.尺寸值\"></a>2.尺寸值</h3><p>_javascript_：</p>\n<ul>\n<li>offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。<b style=\"color:red\">只能获取，不能设置</b>。</li>\n<li>offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。<b style=\"color:red\">只能获取，不能设</b>。</li>\n<li>ele.style.width  获取元素content的宽度。不包括补白和边距、边框</li>\n<li>ele.style.height  获取元素content的高度。不包括补白和边距、边框</li>\n<li>clientWidth  元素内容区宽度加上左右内边距宽度</li>\n<li>clientHeight  元素内容区高度加上上下内边距高</li>\n</ul>\n<hr>\n<p>_jquery_：</p>\n<ul>\n<li>outerHeight()<br>　　与javascript的offsetHeight功能一致</li>\n<li>outerWidth()<br>　　与javascript的offsetWidth功能一致</li>\n<li>width()<br>　　与javascript的ele.style.width功能一致</li>\n<li>height()<br>　　与javascript的ele.style.height功能一致</li>\n<li>innerWidth()<br>　　与javascript的clientWidth功能一致</li>\n<li>innerHeight()<br>　　与javascript的clientHeight功能一致<br><img src=\"/images/201511/9.png\"></li>\n</ul>\n<p><i>上图盗自《javascript高级程序设计》</i></p>\n<h3 id=\"2-滚动大小\"><a href=\"#2-滚动大小\" class=\"headerlink\" title=\"2.滚动大小\"></a>2.滚动大小</h3><p><em>javascript</em></p>\n<ul>\n<li>scrollHeight：在没有滚动条的情况下，元素内容的总高度。=scrollTop+可视区域高度</li>\n<li>scrollWidth：在没有滚动条的情况下，元素内容的总宽度。=scrollLeft+可视区域宽度</li>\n<li>scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</li>\n<li>scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</li>\n</ul>\n<p>_jquery_：</p>\n<ul>\n<li>scrollTop()  获取匹配元素相对滚动条顶部的偏移，同js</li>\n<li>scrollLeft()  获取匹配元素相对滚动条左侧的偏移，同js<br><img src=\"/images/201511/10.png\"><br><i>上图，你懂的</i></li>\n</ul>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-26 16:13:14</p>"},{"_content":"\n# ES6深入理解\n\n## let & const\n在代码块`{}`内有效；\n不允许重复声明；\n不存在变量提升；\n存在暂时性死区；\n\n### let\n\n声明一个局部变量，不用多说。\n\n### const\n\n声明一个常量，但**const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。**\n\n对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。\n\n```js\nconst a = [];\na.push('Hello'); // 可执行\na.length = 0;    // 可执行\na = ['Dave'];    // 报错\n\nconst b = {}\nb.a = 2; // 可执行\nb = {a:2} // 报错\n```\n\n\n## 箭头函数\n\n1. 函数体内的this对象，它是固定的，就是定义时所在的对象，而不是使用时所在的对象。\n\n2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n\n3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n\n4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\n\n**this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。**\n\n\n内部实现\n```js\n// ES6\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\n// ES5\nfunction foo() {\n  var _this = this;\n\n  setTimeout(function () {\n    console.log('id:', _this.id);\n  }, 100);\n}\n```","source":"_posts/let&const.md","raw":"\n# ES6深入理解\n\n## let & const\n在代码块`{}`内有效；\n不允许重复声明；\n不存在变量提升；\n存在暂时性死区；\n\n### let\n\n声明一个局部变量，不用多说。\n\n### const\n\n声明一个常量，但**const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。**\n\n对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。\n\n```js\nconst a = [];\na.push('Hello'); // 可执行\na.length = 0;    // 可执行\na = ['Dave'];    // 报错\n\nconst b = {}\nb.a = 2; // 可执行\nb = {a:2} // 报错\n```\n\n\n## 箭头函数\n\n1. 函数体内的this对象，它是固定的，就是定义时所在的对象，而不是使用时所在的对象。\n\n2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n\n3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n\n4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\n\n**this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。**\n\n\n内部实现\n```js\n// ES6\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\n// ES5\nfunction foo() {\n  var _this = this;\n\n  setTimeout(function () {\n    console.log('id:', _this.id);\n  }, 100);\n}\n```","slug":"let&const","published":1,"date":"2021-12-06T05:35:02.561Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolj002cy4v221yxfo1n","content":"<h1 id=\"ES6深入理解\"><a href=\"#ES6深入理解\" class=\"headerlink\" title=\"ES6深入理解\"></a>ES6深入理解</h1><h2 id=\"let-amp-const\"><a href=\"#let-amp-const\" class=\"headerlink\" title=\"let &amp; const\"></a>let &amp; const</h2><p>在代码块<code>&#123;&#125;</code>内有效；<br>不允许重复声明；<br>不存在变量提升；<br>存在暂时性死区；</p>\n<h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><p>声明一个局部变量，不用多说。</p>\n<h3 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h3><p>声明一个常量，但<strong>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。</strong></p>\n<p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\">a.push(<span class=\"string\">&#x27;Hello&#x27;</span>); <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a.length = <span class=\"number\">0</span>;    <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a = [<span class=\"string\">&#x27;Dave&#x27;</span>];    <span class=\"comment\">// 报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;&#125;</span><br><span class=\"line\">b.a = <span class=\"number\">2</span>; <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">b = &#123;<span class=\"attr\">a</span>:<span class=\"number\">2</span>&#125; <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><ol>\n<li><p>函数体内的this对象，它是固定的，就是定义时所在的对象，而不是使用时所在的对象。</p>\n</li>\n<li><p>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>\n</li>\n<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>\n</li>\n<li><p>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</p>\n</li>\n</ol>\n<p><strong>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</strong></p>\n<p>内部实现</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;id:&#x27;</span>, <span class=\"built_in\">this</span>.id);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _this = <span class=\"built_in\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;id:&#x27;</span>, _this.id);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ES6深入理解\"><a href=\"#ES6深入理解\" class=\"headerlink\" title=\"ES6深入理解\"></a>ES6深入理解</h1><h2 id=\"let-amp-const\"><a href=\"#let-amp-const\" class=\"headerlink\" title=\"let &amp; const\"></a>let &amp; const</h2><p>在代码块<code>&#123;&#125;</code>内有效；<br>不允许重复声明；<br>不存在变量提升；<br>存在暂时性死区；</p>\n<h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><p>声明一个局部变量，不用多说。</p>\n<h3 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h3><p>声明一个常量，但<strong>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。</strong></p>\n<p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\">a.push(<span class=\"string\">&#x27;Hello&#x27;</span>); <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a.length = <span class=\"number\">0</span>;    <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a = [<span class=\"string\">&#x27;Dave&#x27;</span>];    <span class=\"comment\">// 报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;&#125;</span><br><span class=\"line\">b.a = <span class=\"number\">2</span>; <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">b = &#123;<span class=\"attr\">a</span>:<span class=\"number\">2</span>&#125; <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><ol>\n<li><p>函数体内的this对象，它是固定的，就是定义时所在的对象，而不是使用时所在的对象。</p>\n</li>\n<li><p>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>\n</li>\n<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>\n</li>\n<li><p>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</p>\n</li>\n</ol>\n<p><strong>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</strong></p>\n<p>内部实现</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;id:&#x27;</span>, <span class=\"built_in\">this</span>.id);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _this = <span class=\"built_in\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;id:&#x27;</span>, _this.id);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"lazyload.js详解","date":"2015-12-16T06:23:21.000Z","description":null,"_content":"\n## 简介\n\nlazyload.js用于长页面图片的延迟加载，视口外的图片会在窗口滚动到它的位置时再进行加载，这是与预加载相反的。\n\n## 优点：\n\n+ 它可以提高页面加载速度；\n+ 在某些情况清晰它也可以帮助减少服务器负载。\n\n<!-- more -->\n## 安装\n\nbower安装：\n``` bash\n$ bower install jquery.lazyload\n```\n\nnpm安装:\n``` bash\n$ npm install jquery-lazyload  \n```\n\n\n\n## 使用\nlazyload依赖与jquery。所以先引入jquery和lazyload\n\n\t<script src=\"jquery.js\"></script>\n\t<script src=\"jquery.lazyload.js\"></script>\n\n1.将图片路径写入data-original属性\n2.给lazyload的图片增加一个名为lazy的class\n3.选择所有要lazyload的图片（img.lazy），执行lazyload();\n\n\t<img class=\"lazy\" data-original=\"img/example.jpg\" style=\"margin-top:1000px\" height=\"200\">\n\t<script>\n\t\t$(function(){\n\t\t\t$(\"img.lazy\").lazyload();\n\t\t})\n\t</script>\n<p style=\"color:red\">注意：必须设置图片的高度或者宽度，否则插件可能无法正常工作</p>\n\n## 提前加载——Threshold\nlazyload默认是当滚动到该图片位置时，加载该图片。但是可以通过设置Threshold参数来实现滚到距离其xx px时就加载。\n\n\t\n\t\t$(function(){\n\t\t\t$(\"img.lazy\").lazyload({\n\t\t\t\tthreshold :20\n\t\t\t});\n\t\t})\n\t\n\n上面的例子设置了滚动到距离图片20px时，图片就开始再开始加载\n\n## 事件触发(可以是jquery事件，也可以是自定义事件)——Event\n\n当触发定义的事件时，图片才开始加载\n\n\t\n\t\t$(function(){\n\t\t\t$(\"img.lazy\").lazyload({\n\t\t\t\tevent : \"click\"\n\t\t\t});\n\t\t})\n\t\n上面的例子使图片点击后，才开始加载\n\n\n<p style=\"color:rgb(27, 128, 158)\">Tip:你可以使用这个来实现图片的延迟加载</p>\n\n\t$(function() {\n\t    $(\"img.lazy\").lazyload({\n\t        event : \"sporty\"\n\t    });\n\t});\n\n\t$(window).bind(\"load\", function() {\n\t    var timeout = setTimeout(function() {\n\t        $(\"img.lazy\").trigger(\"sporty\")\n\t    }, 5000);\n\t});\n\n上面的代码在页面加载完毕后五秒才开始加载图片\n\n\n## 设定效果——Effects\n\n插件默认的加载效果是 `show()` ,你可以使用任何你想要的效果。下面的代码使用了 `fadeIn()`\n\n\t$(\"img.lazy\").lazyload({\n\t    effect : \"fadeIn\"\n\t});\n\n## 滚动容器内的图片——container\n\n插件也可以使用在滚动容器内的图片上。下面的div拥有scrollerbar，内容的内容进行滚动，滚到图片位置时，图片开始加载\n\n\t<div style=\"height:600px;overflow:scroll\" id=\"container\">\n\t\t<img class=\"lazy\" data-original=\"img/example.jpg\"  alt=\"\" style=\"margin-top:1000px\" height=\"200\">\n\t</div>\n\t<script>\n\t\t$(function(){\n\t\t\t$(\"img.lazy\").lazyload({\n\t\t\t\tcontainer: $(\"#container\")\n\t\t\t});\n\t\t})\n\t</script>\n\n## 不顺序排列的图片——failurelimit\n+ 插件会执行一个寻找未加载图片的循坏，该循环会检查图片是否可见，默认情况下，当第一个视图外的图片被找到，循环就会停止 。\n+ 但是存在一种情况：页面布局图片的顺序和html图片代码的顺序不一致;它会导致本该加载的没有加载。这种情况下就可以将 failurelimit 设为 10 ，它令插件找到 10 个不在可见区域的图片是才停止搜索. 如果你有一个恶心的布局, 请把这个参数设高一点。\n\n代码：\n\n\t$(\"img.lazy\").lazyload({\n\t    failure_limit : 10\n\t});\n\n## 处理隐藏图片——skip_invisible \n\n为了提升性能，插件默认忽略隐藏的图片；如果想要加载隐藏图片.设置skip_invisible为false;\n<p style=\"color:red\">注意：Webkit浏览器将自动把没有宽度和高度的图像视为不可见</p> \n\n\t$(\"img.lazy\").lazyload({\n\t    skip_invisible : true\n\t});\n\n\n详情请查看[文档](http://www.appelsiini.net/projects/lazyload/)","source":"_posts/lazyload-js详解.md","raw":"title: lazyload.js详解\ndate: 2015-12-16 14:23:21\ntags: [插件]\ndescription:\n\n---\n\n## 简介\n\nlazyload.js用于长页面图片的延迟加载，视口外的图片会在窗口滚动到它的位置时再进行加载，这是与预加载相反的。\n\n## 优点：\n\n+ 它可以提高页面加载速度；\n+ 在某些情况清晰它也可以帮助减少服务器负载。\n\n<!-- more -->\n## 安装\n\nbower安装：\n``` bash\n$ bower install jquery.lazyload\n```\n\nnpm安装:\n``` bash\n$ npm install jquery-lazyload  \n```\n\n\n\n## 使用\nlazyload依赖与jquery。所以先引入jquery和lazyload\n\n\t<script src=\"jquery.js\"></script>\n\t<script src=\"jquery.lazyload.js\"></script>\n\n1.将图片路径写入data-original属性\n2.给lazyload的图片增加一个名为lazy的class\n3.选择所有要lazyload的图片（img.lazy），执行lazyload();\n\n\t<img class=\"lazy\" data-original=\"img/example.jpg\" style=\"margin-top:1000px\" height=\"200\">\n\t<script>\n\t\t$(function(){\n\t\t\t$(\"img.lazy\").lazyload();\n\t\t})\n\t</script>\n<p style=\"color:red\">注意：必须设置图片的高度或者宽度，否则插件可能无法正常工作</p>\n\n## 提前加载——Threshold\nlazyload默认是当滚动到该图片位置时，加载该图片。但是可以通过设置Threshold参数来实现滚到距离其xx px时就加载。\n\n\t\n\t\t$(function(){\n\t\t\t$(\"img.lazy\").lazyload({\n\t\t\t\tthreshold :20\n\t\t\t});\n\t\t})\n\t\n\n上面的例子设置了滚动到距离图片20px时，图片就开始再开始加载\n\n## 事件触发(可以是jquery事件，也可以是自定义事件)——Event\n\n当触发定义的事件时，图片才开始加载\n\n\t\n\t\t$(function(){\n\t\t\t$(\"img.lazy\").lazyload({\n\t\t\t\tevent : \"click\"\n\t\t\t});\n\t\t})\n\t\n上面的例子使图片点击后，才开始加载\n\n\n<p style=\"color:rgb(27, 128, 158)\">Tip:你可以使用这个来实现图片的延迟加载</p>\n\n\t$(function() {\n\t    $(\"img.lazy\").lazyload({\n\t        event : \"sporty\"\n\t    });\n\t});\n\n\t$(window).bind(\"load\", function() {\n\t    var timeout = setTimeout(function() {\n\t        $(\"img.lazy\").trigger(\"sporty\")\n\t    }, 5000);\n\t});\n\n上面的代码在页面加载完毕后五秒才开始加载图片\n\n\n## 设定效果——Effects\n\n插件默认的加载效果是 `show()` ,你可以使用任何你想要的效果。下面的代码使用了 `fadeIn()`\n\n\t$(\"img.lazy\").lazyload({\n\t    effect : \"fadeIn\"\n\t});\n\n## 滚动容器内的图片——container\n\n插件也可以使用在滚动容器内的图片上。下面的div拥有scrollerbar，内容的内容进行滚动，滚到图片位置时，图片开始加载\n\n\t<div style=\"height:600px;overflow:scroll\" id=\"container\">\n\t\t<img class=\"lazy\" data-original=\"img/example.jpg\"  alt=\"\" style=\"margin-top:1000px\" height=\"200\">\n\t</div>\n\t<script>\n\t\t$(function(){\n\t\t\t$(\"img.lazy\").lazyload({\n\t\t\t\tcontainer: $(\"#container\")\n\t\t\t});\n\t\t})\n\t</script>\n\n## 不顺序排列的图片——failurelimit\n+ 插件会执行一个寻找未加载图片的循坏，该循环会检查图片是否可见，默认情况下，当第一个视图外的图片被找到，循环就会停止 。\n+ 但是存在一种情况：页面布局图片的顺序和html图片代码的顺序不一致;它会导致本该加载的没有加载。这种情况下就可以将 failurelimit 设为 10 ，它令插件找到 10 个不在可见区域的图片是才停止搜索. 如果你有一个恶心的布局, 请把这个参数设高一点。\n\n代码：\n\n\t$(\"img.lazy\").lazyload({\n\t    failure_limit : 10\n\t});\n\n## 处理隐藏图片——skip_invisible \n\n为了提升性能，插件默认忽略隐藏的图片；如果想要加载隐藏图片.设置skip_invisible为false;\n<p style=\"color:red\">注意：Webkit浏览器将自动把没有宽度和高度的图像视为不可见</p> \n\n\t$(\"img.lazy\").lazyload({\n\t    skip_invisible : true\n\t});\n\n\n详情请查看[文档](http://www.appelsiini.net/projects/lazyload/)","slug":"lazyload-js详解","published":1,"updated":"2021-12-06T06:07:06.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolk002ey4v2eazt0ial","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>lazyload.js用于长页面图片的延迟加载，视口外的图片会在窗口滚动到它的位置时再进行加载，这是与预加载相反的。</p>\n<h2 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><ul>\n<li>它可以提高页面加载速度；</li>\n<li>在某些情况清晰它也可以帮助减少服务器负载。</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>bower安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ bower install jquery.lazyload</span><br></pre></td></tr></table></figure>\n\n<p>npm安装:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install jquery-lazyload  </span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>lazyload依赖与jquery。所以先引入jquery和lazyload</p>\n<pre><code>&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;jquery.lazyload.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>1.将图片路径写入data-original属性<br>2.给lazyload的图片增加一个名为lazy的class<br>3.选择所有要lazyload的图片（img.lazy），执行lazyload();</p>\n<pre><code>&lt;img class=&quot;lazy&quot; data-original=&quot;img/example.jpg&quot; style=&quot;margin-top:1000px&quot; height=&quot;200&quot;&gt;\n&lt;script&gt;\n    $(function()&#123;\n        $(&quot;img.lazy&quot;).lazyload();\n    &#125;)\n&lt;/script&gt;\n</code></pre>\n<p style=\"color:red\">注意：必须设置图片的高度或者宽度，否则插件可能无法正常工作</p>\n\n<h2 id=\"提前加载——Threshold\"><a href=\"#提前加载——Threshold\" class=\"headerlink\" title=\"提前加载——Threshold\"></a>提前加载——Threshold</h2><p>lazyload默认是当滚动到该图片位置时，加载该图片。但是可以通过设置Threshold参数来实现滚到距离其xx px时就加载。</p>\n<pre><code>    $(function()&#123;\n        $(&quot;img.lazy&quot;).lazyload(&#123;\n            threshold :20\n        &#125;);\n    &#125;)\n</code></pre>\n<p>上面的例子设置了滚动到距离图片20px时，图片就开始再开始加载</p>\n<h2 id=\"事件触发-可以是jquery事件，也可以是自定义事件-——Event\"><a href=\"#事件触发-可以是jquery事件，也可以是自定义事件-——Event\" class=\"headerlink\" title=\"事件触发(可以是jquery事件，也可以是自定义事件)——Event\"></a>事件触发(可以是jquery事件，也可以是自定义事件)——Event</h2><p>当触发定义的事件时，图片才开始加载</p>\n<pre><code>    $(function()&#123;\n        $(&quot;img.lazy&quot;).lazyload(&#123;\n            event : &quot;click&quot;\n        &#125;);\n    &#125;)\n</code></pre>\n<p>上面的例子使图片点击后，才开始加载</p>\n<p style=\"color:rgb(27, 128, 158)\">Tip:你可以使用这个来实现图片的延迟加载</p>\n\n<pre><code>$(function() &#123;\n    $(&quot;img.lazy&quot;).lazyload(&#123;\n        event : &quot;sporty&quot;\n    &#125;);\n&#125;);\n\n$(window).bind(&quot;load&quot;, function() &#123;\n    var timeout = setTimeout(function() &#123;\n        $(&quot;img.lazy&quot;).trigger(&quot;sporty&quot;)\n    &#125;, 5000);\n&#125;);\n</code></pre>\n<p>上面的代码在页面加载完毕后五秒才开始加载图片</p>\n<h2 id=\"设定效果——Effects\"><a href=\"#设定效果——Effects\" class=\"headerlink\" title=\"设定效果——Effects\"></a>设定效果——Effects</h2><p>插件默认的加载效果是 <code>show()</code> ,你可以使用任何你想要的效果。下面的代码使用了 <code>fadeIn()</code></p>\n<pre><code>$(&quot;img.lazy&quot;).lazyload(&#123;\n    effect : &quot;fadeIn&quot;\n&#125;);\n</code></pre>\n<h2 id=\"滚动容器内的图片——container\"><a href=\"#滚动容器内的图片——container\" class=\"headerlink\" title=\"滚动容器内的图片——container\"></a>滚动容器内的图片——container</h2><p>插件也可以使用在滚动容器内的图片上。下面的div拥有scrollerbar，内容的内容进行滚动，滚到图片位置时，图片开始加载</p>\n<pre><code>&lt;div style=&quot;height:600px;overflow:scroll&quot; id=&quot;container&quot;&gt;\n    &lt;img class=&quot;lazy&quot; data-original=&quot;img/example.jpg&quot;  alt=&quot;&quot; style=&quot;margin-top:1000px&quot; height=&quot;200&quot;&gt;\n&lt;/div&gt;\n&lt;script&gt;\n    $(function()&#123;\n        $(&quot;img.lazy&quot;).lazyload(&#123;\n            container: $(&quot;#container&quot;)\n        &#125;);\n    &#125;)\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"不顺序排列的图片——failurelimit\"><a href=\"#不顺序排列的图片——failurelimit\" class=\"headerlink\" title=\"不顺序排列的图片——failurelimit\"></a>不顺序排列的图片——failurelimit</h2><ul>\n<li>插件会执行一个寻找未加载图片的循坏，该循环会检查图片是否可见，默认情况下，当第一个视图外的图片被找到，循环就会停止 。</li>\n<li>但是存在一种情况：页面布局图片的顺序和html图片代码的顺序不一致;它会导致本该加载的没有加载。这种情况下就可以将 failurelimit 设为 10 ，它令插件找到 10 个不在可见区域的图片是才停止搜索. 如果你有一个恶心的布局, 请把这个参数设高一点。</li>\n</ul>\n<p>代码：</p>\n<pre><code>$(&quot;img.lazy&quot;).lazyload(&#123;\n    failure_limit : 10\n&#125;);\n</code></pre>\n<h2 id=\"处理隐藏图片——skip-invisible\"><a href=\"#处理隐藏图片——skip-invisible\" class=\"headerlink\" title=\"处理隐藏图片——skip_invisible\"></a>处理隐藏图片——skip_invisible</h2><p>为了提升性能，插件默认忽略隐藏的图片；如果想要加载隐藏图片.设置skip_invisible为false;</p>\n<p style=\"color:red\">注意：Webkit浏览器将自动把没有宽度和高度的图像视为不可见</p> \n\n<pre><code>$(&quot;img.lazy&quot;).lazyload(&#123;\n    skip_invisible : true\n&#125;);\n</code></pre>\n<p>详情请查看<a href=\"http://www.appelsiini.net/projects/lazyload/\">文档</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>lazyload.js用于长页面图片的延迟加载，视口外的图片会在窗口滚动到它的位置时再进行加载，这是与预加载相反的。</p>\n<h2 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><ul>\n<li>它可以提高页面加载速度；</li>\n<li>在某些情况清晰它也可以帮助减少服务器负载。</li>\n</ul>","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>bower安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ bower install jquery.lazyload</span><br></pre></td></tr></table></figure>\n\n<p>npm安装:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install jquery-lazyload  </span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>lazyload依赖与jquery。所以先引入jquery和lazyload</p>\n<pre><code>&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;jquery.lazyload.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>1.将图片路径写入data-original属性<br>2.给lazyload的图片增加一个名为lazy的class<br>3.选择所有要lazyload的图片（img.lazy），执行lazyload();</p>\n<pre><code>&lt;img class=&quot;lazy&quot; data-original=&quot;img/example.jpg&quot; style=&quot;margin-top:1000px&quot; height=&quot;200&quot;&gt;\n&lt;script&gt;\n    $(function()&#123;\n        $(&quot;img.lazy&quot;).lazyload();\n    &#125;)\n&lt;/script&gt;\n</code></pre>\n<p style=\"color:red\">注意：必须设置图片的高度或者宽度，否则插件可能无法正常工作</p>\n\n<h2 id=\"提前加载——Threshold\"><a href=\"#提前加载——Threshold\" class=\"headerlink\" title=\"提前加载——Threshold\"></a>提前加载——Threshold</h2><p>lazyload默认是当滚动到该图片位置时，加载该图片。但是可以通过设置Threshold参数来实现滚到距离其xx px时就加载。</p>\n<pre><code>    $(function()&#123;\n        $(&quot;img.lazy&quot;).lazyload(&#123;\n            threshold :20\n        &#125;);\n    &#125;)\n</code></pre>\n<p>上面的例子设置了滚动到距离图片20px时，图片就开始再开始加载</p>\n<h2 id=\"事件触发-可以是jquery事件，也可以是自定义事件-——Event\"><a href=\"#事件触发-可以是jquery事件，也可以是自定义事件-——Event\" class=\"headerlink\" title=\"事件触发(可以是jquery事件，也可以是自定义事件)——Event\"></a>事件触发(可以是jquery事件，也可以是自定义事件)——Event</h2><p>当触发定义的事件时，图片才开始加载</p>\n<pre><code>    $(function()&#123;\n        $(&quot;img.lazy&quot;).lazyload(&#123;\n            event : &quot;click&quot;\n        &#125;);\n    &#125;)\n</code></pre>\n<p>上面的例子使图片点击后，才开始加载</p>\n<p style=\"color:rgb(27, 128, 158)\">Tip:你可以使用这个来实现图片的延迟加载</p>\n\n<pre><code>$(function() &#123;\n    $(&quot;img.lazy&quot;).lazyload(&#123;\n        event : &quot;sporty&quot;\n    &#125;);\n&#125;);\n\n$(window).bind(&quot;load&quot;, function() &#123;\n    var timeout = setTimeout(function() &#123;\n        $(&quot;img.lazy&quot;).trigger(&quot;sporty&quot;)\n    &#125;, 5000);\n&#125;);\n</code></pre>\n<p>上面的代码在页面加载完毕后五秒才开始加载图片</p>\n<h2 id=\"设定效果——Effects\"><a href=\"#设定效果——Effects\" class=\"headerlink\" title=\"设定效果——Effects\"></a>设定效果——Effects</h2><p>插件默认的加载效果是 <code>show()</code> ,你可以使用任何你想要的效果。下面的代码使用了 <code>fadeIn()</code></p>\n<pre><code>$(&quot;img.lazy&quot;).lazyload(&#123;\n    effect : &quot;fadeIn&quot;\n&#125;);\n</code></pre>\n<h2 id=\"滚动容器内的图片——container\"><a href=\"#滚动容器内的图片——container\" class=\"headerlink\" title=\"滚动容器内的图片——container\"></a>滚动容器内的图片——container</h2><p>插件也可以使用在滚动容器内的图片上。下面的div拥有scrollerbar，内容的内容进行滚动，滚到图片位置时，图片开始加载</p>\n<pre><code>&lt;div style=&quot;height:600px;overflow:scroll&quot; id=&quot;container&quot;&gt;\n    &lt;img class=&quot;lazy&quot; data-original=&quot;img/example.jpg&quot;  alt=&quot;&quot; style=&quot;margin-top:1000px&quot; height=&quot;200&quot;&gt;\n&lt;/div&gt;\n&lt;script&gt;\n    $(function()&#123;\n        $(&quot;img.lazy&quot;).lazyload(&#123;\n            container: $(&quot;#container&quot;)\n        &#125;);\n    &#125;)\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"不顺序排列的图片——failurelimit\"><a href=\"#不顺序排列的图片——failurelimit\" class=\"headerlink\" title=\"不顺序排列的图片——failurelimit\"></a>不顺序排列的图片——failurelimit</h2><ul>\n<li>插件会执行一个寻找未加载图片的循坏，该循环会检查图片是否可见，默认情况下，当第一个视图外的图片被找到，循环就会停止 。</li>\n<li>但是存在一种情况：页面布局图片的顺序和html图片代码的顺序不一致;它会导致本该加载的没有加载。这种情况下就可以将 failurelimit 设为 10 ，它令插件找到 10 个不在可见区域的图片是才停止搜索. 如果你有一个恶心的布局, 请把这个参数设高一点。</li>\n</ul>\n<p>代码：</p>\n<pre><code>$(&quot;img.lazy&quot;).lazyload(&#123;\n    failure_limit : 10\n&#125;);\n</code></pre>\n<h2 id=\"处理隐藏图片——skip-invisible\"><a href=\"#处理隐藏图片——skip-invisible\" class=\"headerlink\" title=\"处理隐藏图片——skip_invisible\"></a>处理隐藏图片——skip_invisible</h2><p>为了提升性能，插件默认忽略隐藏的图片；如果想要加载隐藏图片.设置skip_invisible为false;</p>\n<p style=\"color:red\">注意：Webkit浏览器将自动把没有宽度和高度的图像视为不可见</p> \n\n<pre><code>$(&quot;img.lazy&quot;).lazyload(&#123;\n    skip_invisible : true\n&#125;);\n</code></pre>\n<p>详情请查看<a href=\"http://www.appelsiini.net/projects/lazyload/\">文档</a></p>"},{"_content":"# mysql环境搭建 #\n最近决定学习数据库，在比较了各个数据库之后，选择从mysql入手，主要原因：\n\n- 开源\n- 成熟，通用\n- 用户量多，社区完善\n- 入门简单\n\n## 下载安装 ##\nmysql的官网下载地址：[http://dev.mysql.com/downloads/mysql/](http://dev.mysql.com/downloads/mysql/ \"下载地址\")\n\nmysql官网有俩种版本可供下载，分别是客户端版本（Recommended Download，也是官网的推荐版本）和解压缩版本（Archive）。我这里选择的是解压缩版本，点击download进行下载，下载完毕后直接将压缩包解压到您想要安装mysql的目标路径即可。\n\n我下载的是5.7.13版本，解压后，得到一个`mysql-5.7.13-winx64`的文件夹，它包含如下文件：\n\n\t2016/07/18  14:34    <DIR>          .\n\t2016/07/18  14:34    <DIR>          ..\n\t2016/07/18  14:34    <DIR>          bin\n\t2016/05/25  13:50            17,987 COPYING\n\t2016/07/18  14:34    <DIR>          docs\n\t2016/07/18  14:33    <DIR>          include\n\t2016/07/18  14:34    <DIR>          lib\n\t2016/05/25  14:08             1,141 my-default.ini\n\t2016/05/25  13:50             2,478 README\n\t2016/07/18  14:34    <DIR>          share\n\t               3 个文件         21,606 字节\n\t               7 个目录 118,994,726,912 可用字节\n至此，下载安装完毕\n\n## 配置mysql ##\n1.配置my.ini\n\n我这里将mysql-5.7.13-winx64文件重命名为mysql（原文件名太长了），该文件下的my-default.ini是默认的配置文件，我们这里需要自己重新实现配置：将my-default.ini复制一份并重命名为my.ini，并将最将basedir、datadir等参数的文件目录替换成你自己mysql所在目录的路径。\n\t# For advice on how to change settings please see\n\t# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html\n\t# *** DO NOT EDIT THIS FILE. It's a template which will be copied to the\n\t# *** default location during install, and will be replaced if you\n\t# *** upgrade to a newer version of MySQL.\n\t\n\t[mysqld]\n\t\n\t# Remove leading # and set to the amount of RAM for the most important data\n\t# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.\n\t# innodb_buffer_pool_size = 128M\n\t\n\t# Remove leading # to turn on a very important data integrity option: logging\n\t# changes to the binary log between backups.\n\t# log_bin\n\t\n\t# These are commonly set, remove the # and set as required.\n\tbasedir = C:\\mysql\n\tdatadir = C:\\mysql\\data\n\t# port = .....\n\t# server_id = .....\n\t\n\t\n\t# Remove leading # to set options mainly useful for reporting servers.\n\t# The server defaults are faster for transactions and fast SELECTs.\n\t# Adjust sizes as needed, experiment to find the optimal values.\n\t# join_buffer_size = 128M\n\t# sort_buffer_size = 2M\n\t# read_rnd_buffer_size = 2M \n\t\n\tsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES \n我这里的mysql文件放在c盘下，所以只要把上面文件中“c:/mysql”的地方填入你自己的文件路径就ok了。\n\n2.配置环境变量\n\n将你的mysql bin文件夹的路径添加到PATH中，很简单，不多说了。\n\n\n## 运行mysql ##\n以管理员身份运行cmd（**一定要用管理员身份运行**），并进入到mysql的bin文件中\n\n\tmysqld --remove \n\tmysqld --install\n\tmysqld --initialize //会生成一个data文件夹\n\tnet start mysql //启动mysql服务\n\n依次执行这三个命令后，打开data文件夹，找到其下error文件类型的文件打开，该文件是本次mysql初始化的log日志，包括初始化密码。如果显示“root@localhost is created with an empty password !”，则为空。然后执行\n\n\tmysql -uroot -p\n输入用户名和密码，显示“ Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. ”，则表示连接成功。\n\n\n\n\n## 登录出错 ##\n如果登录的时候存在问题，显示“ Access denied for user 'root'@'localhost'”，可以尝试重新设置设置root密码:\n\n1. 修改/my.ini文件,在[mysqld]下添加 skip-grant-tables , 再启动mysql\n\n2. 然后用空密码方式使用root用户登录 MySQL；\n \n\t\tmysql -u root\n\n3. 修改root用户的密码；\n\n\t\tmysql> update mysql.user set password=PASSWORD（'新密码'） where User='root'\n\t\tmysql> flush privileges；\n\t\tmysql> quit\n\n4. 重新启动MySQL，就可以使用新密码登录了。","source":"_posts/mysql环境搭建.md","raw":"# mysql环境搭建 #\n最近决定学习数据库，在比较了各个数据库之后，选择从mysql入手，主要原因：\n\n- 开源\n- 成熟，通用\n- 用户量多，社区完善\n- 入门简单\n\n## 下载安装 ##\nmysql的官网下载地址：[http://dev.mysql.com/downloads/mysql/](http://dev.mysql.com/downloads/mysql/ \"下载地址\")\n\nmysql官网有俩种版本可供下载，分别是客户端版本（Recommended Download，也是官网的推荐版本）和解压缩版本（Archive）。我这里选择的是解压缩版本，点击download进行下载，下载完毕后直接将压缩包解压到您想要安装mysql的目标路径即可。\n\n我下载的是5.7.13版本，解压后，得到一个`mysql-5.7.13-winx64`的文件夹，它包含如下文件：\n\n\t2016/07/18  14:34    <DIR>          .\n\t2016/07/18  14:34    <DIR>          ..\n\t2016/07/18  14:34    <DIR>          bin\n\t2016/05/25  13:50            17,987 COPYING\n\t2016/07/18  14:34    <DIR>          docs\n\t2016/07/18  14:33    <DIR>          include\n\t2016/07/18  14:34    <DIR>          lib\n\t2016/05/25  14:08             1,141 my-default.ini\n\t2016/05/25  13:50             2,478 README\n\t2016/07/18  14:34    <DIR>          share\n\t               3 个文件         21,606 字节\n\t               7 个目录 118,994,726,912 可用字节\n至此，下载安装完毕\n\n## 配置mysql ##\n1.配置my.ini\n\n我这里将mysql-5.7.13-winx64文件重命名为mysql（原文件名太长了），该文件下的my-default.ini是默认的配置文件，我们这里需要自己重新实现配置：将my-default.ini复制一份并重命名为my.ini，并将最将basedir、datadir等参数的文件目录替换成你自己mysql所在目录的路径。\n\t# For advice on how to change settings please see\n\t# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html\n\t# *** DO NOT EDIT THIS FILE. It's a template which will be copied to the\n\t# *** default location during install, and will be replaced if you\n\t# *** upgrade to a newer version of MySQL.\n\t\n\t[mysqld]\n\t\n\t# Remove leading # and set to the amount of RAM for the most important data\n\t# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.\n\t# innodb_buffer_pool_size = 128M\n\t\n\t# Remove leading # to turn on a very important data integrity option: logging\n\t# changes to the binary log between backups.\n\t# log_bin\n\t\n\t# These are commonly set, remove the # and set as required.\n\tbasedir = C:\\mysql\n\tdatadir = C:\\mysql\\data\n\t# port = .....\n\t# server_id = .....\n\t\n\t\n\t# Remove leading # to set options mainly useful for reporting servers.\n\t# The server defaults are faster for transactions and fast SELECTs.\n\t# Adjust sizes as needed, experiment to find the optimal values.\n\t# join_buffer_size = 128M\n\t# sort_buffer_size = 2M\n\t# read_rnd_buffer_size = 2M \n\t\n\tsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES \n我这里的mysql文件放在c盘下，所以只要把上面文件中“c:/mysql”的地方填入你自己的文件路径就ok了。\n\n2.配置环境变量\n\n将你的mysql bin文件夹的路径添加到PATH中，很简单，不多说了。\n\n\n## 运行mysql ##\n以管理员身份运行cmd（**一定要用管理员身份运行**），并进入到mysql的bin文件中\n\n\tmysqld --remove \n\tmysqld --install\n\tmysqld --initialize //会生成一个data文件夹\n\tnet start mysql //启动mysql服务\n\n依次执行这三个命令后，打开data文件夹，找到其下error文件类型的文件打开，该文件是本次mysql初始化的log日志，包括初始化密码。如果显示“root@localhost is created with an empty password !”，则为空。然后执行\n\n\tmysql -uroot -p\n输入用户名和密码，显示“ Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. ”，则表示连接成功。\n\n\n\n\n## 登录出错 ##\n如果登录的时候存在问题，显示“ Access denied for user 'root'@'localhost'”，可以尝试重新设置设置root密码:\n\n1. 修改/my.ini文件,在[mysqld]下添加 skip-grant-tables , 再启动mysql\n\n2. 然后用空密码方式使用root用户登录 MySQL；\n \n\t\tmysql -u root\n\n3. 修改root用户的密码；\n\n\t\tmysql> update mysql.user set password=PASSWORD（'新密码'） where User='root'\n\t\tmysql> flush privileges；\n\t\tmysql> quit\n\n4. 重新启动MySQL，就可以使用新密码登录了。","slug":"mysql环境搭建","published":1,"date":"2021-12-06T06:07:06.193Z","updated":"2021-12-06T06:07:06.193Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoll002gy4v2dwre30oh","content":"<h1 id=\"mysql环境搭建\"><a href=\"#mysql环境搭建\" class=\"headerlink\" title=\"mysql环境搭建\"></a>mysql环境搭建</h1><p>最近决定学习数据库，在比较了各个数据库之后，选择从mysql入手，主要原因：</p>\n<ul>\n<li>开源</li>\n<li>成熟，通用</li>\n<li>用户量多，社区完善</li>\n<li>入门简单</li>\n</ul>\n<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><p>mysql的官网下载地址：<a href=\"http://dev.mysql.com/downloads/mysql/\" title=\"下载地址\">http://dev.mysql.com/downloads/mysql/</a></p>\n<p>mysql官网有俩种版本可供下载，分别是客户端版本（Recommended Download，也是官网的推荐版本）和解压缩版本（Archive）。我这里选择的是解压缩版本，点击download进行下载，下载完毕后直接将压缩包解压到您想要安装mysql的目标路径即可。</p>\n<p>我下载的是5.7.13版本，解压后，得到一个<code>mysql-5.7.13-winx64</code>的文件夹，它包含如下文件：</p>\n<pre><code>2016/07/18  14:34    &lt;DIR&gt;          .\n2016/07/18  14:34    &lt;DIR&gt;          ..\n2016/07/18  14:34    &lt;DIR&gt;          bin\n2016/05/25  13:50            17,987 COPYING\n2016/07/18  14:34    &lt;DIR&gt;          docs\n2016/07/18  14:33    &lt;DIR&gt;          include\n2016/07/18  14:34    &lt;DIR&gt;          lib\n2016/05/25  14:08             1,141 my-default.ini\n2016/05/25  13:50             2,478 README\n2016/07/18  14:34    &lt;DIR&gt;          share\n               3 个文件         21,606 字节\n               7 个目录 118,994,726,912 可用字节\n</code></pre>\n<p>至此，下载安装完毕</p>\n<h2 id=\"配置mysql\"><a href=\"#配置mysql\" class=\"headerlink\" title=\"配置mysql\"></a>配置mysql</h2><p>1.配置my.ini</p>\n<p>我这里将mysql-5.7.13-winx64文件重命名为mysql（原文件名太长了），该文件下的my-default.ini是默认的配置文件，我们这里需要自己重新实现配置：将my-default.ini复制一份并重命名为my.ini，并将最将basedir、datadir等参数的文件目录替换成你自己mysql所在目录的路径。<br>    # For advice on how to change settings please see<br>    # <a href=\"http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html\">http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</a><br>    # *** DO NOT EDIT THIS FILE. It’s a template which will be copied to the<br>    # *** default location during install, and will be replaced if you<br>    # *** upgrade to a newer version of MySQL.</p>\n<pre><code>[mysqld]\n\n# Remove leading # and set to the amount of RAM for the most important data\n# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.\n# innodb_buffer_pool_size = 128M\n\n# Remove leading # to turn on a very important data integrity option: logging\n# changes to the binary log between backups.\n# log_bin\n\n# These are commonly set, remove the # and set as required.\nbasedir = C:\\mysql\ndatadir = C:\\mysql\\data\n# port = .....\n# server_id = .....\n\n\n# Remove leading # to set options mainly useful for reporting servers.\n# The server defaults are faster for transactions and fast SELECTs.\n# Adjust sizes as needed, experiment to find the optimal values.\n# join_buffer_size = 128M\n# sort_buffer_size = 2M\n# read_rnd_buffer_size = 2M \n\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES \n</code></pre>\n<p>我这里的mysql文件放在c盘下，所以只要把上面文件中“c:/mysql”的地方填入你自己的文件路径就ok了。</p>\n<p>2.配置环境变量</p>\n<p>将你的mysql bin文件夹的路径添加到PATH中，很简单，不多说了。</p>\n<h2 id=\"运行mysql\"><a href=\"#运行mysql\" class=\"headerlink\" title=\"运行mysql\"></a>运行mysql</h2><p>以管理员身份运行cmd（<strong>一定要用管理员身份运行</strong>），并进入到mysql的bin文件中</p>\n<pre><code>mysqld --remove \nmysqld --install\nmysqld --initialize //会生成一个data文件夹\nnet start mysql //启动mysql服务\n</code></pre>\n<p>依次执行这三个命令后，打开data文件夹，找到其下error文件类型的文件打开，该文件是本次mysql初始化的log日志，包括初始化密码。如果显示“root@localhost is created with an empty password !”，则为空。然后执行</p>\n<pre><code>mysql -uroot -p\n</code></pre>\n<p>输入用户名和密码，显示“ Type ‘help;’ or ‘\\h’ for help. Type ‘\\c’ to clear the current input statement. ”，则表示连接成功。</p>\n<h2 id=\"登录出错\"><a href=\"#登录出错\" class=\"headerlink\" title=\"登录出错\"></a>登录出错</h2><p>如果登录的时候存在问题，显示“ Access denied for user ‘root‘@’localhost’”，可以尝试重新设置设置root密码:</p>\n<ol>\n<li><p>修改/my.ini文件,在[mysqld]下添加 skip-grant-tables , 再启动mysql</p>\n</li>\n<li><p>然后用空密码方式使用root用户登录 MySQL；</p>\n<pre><code> mysql -u root\n</code></pre>\n</li>\n<li><p>修改root用户的密码；</p>\n<pre><code> mysql&gt; update mysql.user set password=PASSWORD（&#39;新密码&#39;） where User=&#39;root&#39;\n mysql&gt; flush privileges；\n mysql&gt; quit\n</code></pre>\n</li>\n<li><p>重新启动MySQL，就可以使用新密码登录了。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"mysql环境搭建\"><a href=\"#mysql环境搭建\" class=\"headerlink\" title=\"mysql环境搭建\"></a>mysql环境搭建</h1><p>最近决定学习数据库，在比较了各个数据库之后，选择从mysql入手，主要原因：</p>\n<ul>\n<li>开源</li>\n<li>成熟，通用</li>\n<li>用户量多，社区完善</li>\n<li>入门简单</li>\n</ul>\n<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><p>mysql的官网下载地址：<a href=\"http://dev.mysql.com/downloads/mysql/\" title=\"下载地址\">http://dev.mysql.com/downloads/mysql/</a></p>\n<p>mysql官网有俩种版本可供下载，分别是客户端版本（Recommended Download，也是官网的推荐版本）和解压缩版本（Archive）。我这里选择的是解压缩版本，点击download进行下载，下载完毕后直接将压缩包解压到您想要安装mysql的目标路径即可。</p>\n<p>我下载的是5.7.13版本，解压后，得到一个<code>mysql-5.7.13-winx64</code>的文件夹，它包含如下文件：</p>\n<pre><code>2016/07/18  14:34    &lt;DIR&gt;          .\n2016/07/18  14:34    &lt;DIR&gt;          ..\n2016/07/18  14:34    &lt;DIR&gt;          bin\n2016/05/25  13:50            17,987 COPYING\n2016/07/18  14:34    &lt;DIR&gt;          docs\n2016/07/18  14:33    &lt;DIR&gt;          include\n2016/07/18  14:34    &lt;DIR&gt;          lib\n2016/05/25  14:08             1,141 my-default.ini\n2016/05/25  13:50             2,478 README\n2016/07/18  14:34    &lt;DIR&gt;          share\n               3 个文件         21,606 字节\n               7 个目录 118,994,726,912 可用字节\n</code></pre>\n<p>至此，下载安装完毕</p>\n<h2 id=\"配置mysql\"><a href=\"#配置mysql\" class=\"headerlink\" title=\"配置mysql\"></a>配置mysql</h2><p>1.配置my.ini</p>\n<p>我这里将mysql-5.7.13-winx64文件重命名为mysql（原文件名太长了），该文件下的my-default.ini是默认的配置文件，我们这里需要自己重新实现配置：将my-default.ini复制一份并重命名为my.ini，并将最将basedir、datadir等参数的文件目录替换成你自己mysql所在目录的路径。<br>    # For advice on how to change settings please see<br>    # <a href=\"http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html\">http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</a><br>    # *** DO NOT EDIT THIS FILE. It’s a template which will be copied to the<br>    # *** default location during install, and will be replaced if you<br>    # *** upgrade to a newer version of MySQL.</p>\n<pre><code>[mysqld]\n\n# Remove leading # and set to the amount of RAM for the most important data\n# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.\n# innodb_buffer_pool_size = 128M\n\n# Remove leading # to turn on a very important data integrity option: logging\n# changes to the binary log between backups.\n# log_bin\n\n# These are commonly set, remove the # and set as required.\nbasedir = C:\\mysql\ndatadir = C:\\mysql\\data\n# port = .....\n# server_id = .....\n\n\n# Remove leading # to set options mainly useful for reporting servers.\n# The server defaults are faster for transactions and fast SELECTs.\n# Adjust sizes as needed, experiment to find the optimal values.\n# join_buffer_size = 128M\n# sort_buffer_size = 2M\n# read_rnd_buffer_size = 2M \n\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES \n</code></pre>\n<p>我这里的mysql文件放在c盘下，所以只要把上面文件中“c:/mysql”的地方填入你自己的文件路径就ok了。</p>\n<p>2.配置环境变量</p>\n<p>将你的mysql bin文件夹的路径添加到PATH中，很简单，不多说了。</p>\n<h2 id=\"运行mysql\"><a href=\"#运行mysql\" class=\"headerlink\" title=\"运行mysql\"></a>运行mysql</h2><p>以管理员身份运行cmd（<strong>一定要用管理员身份运行</strong>），并进入到mysql的bin文件中</p>\n<pre><code>mysqld --remove \nmysqld --install\nmysqld --initialize //会生成一个data文件夹\nnet start mysql //启动mysql服务\n</code></pre>\n<p>依次执行这三个命令后，打开data文件夹，找到其下error文件类型的文件打开，该文件是本次mysql初始化的log日志，包括初始化密码。如果显示“root@localhost is created with an empty password !”，则为空。然后执行</p>\n<pre><code>mysql -uroot -p\n</code></pre>\n<p>输入用户名和密码，显示“ Type ‘help;’ or ‘\\h’ for help. Type ‘\\c’ to clear the current input statement. ”，则表示连接成功。</p>\n<h2 id=\"登录出错\"><a href=\"#登录出错\" class=\"headerlink\" title=\"登录出错\"></a>登录出错</h2><p>如果登录的时候存在问题，显示“ Access denied for user ‘root‘@’localhost’”，可以尝试重新设置设置root密码:</p>\n<ol>\n<li><p>修改/my.ini文件,在[mysqld]下添加 skip-grant-tables , 再启动mysql</p>\n</li>\n<li><p>然后用空密码方式使用root用户登录 MySQL；</p>\n<pre><code> mysql -u root\n</code></pre>\n</li>\n<li><p>修改root用户的密码；</p>\n<pre><code> mysql&gt; update mysql.user set password=PASSWORD（&#39;新密码&#39;） where User=&#39;root&#39;\n mysql&gt; flush privileges；\n mysql&gt; quit\n</code></pre>\n</li>\n<li><p>重新启动MySQL，就可以使用新密码登录了。</p>\n</li>\n</ol>\n"},{"_content":"","source":"_posts/promise.md","raw":"","slug":"promise","published":1,"date":"2021-12-06T05:35:02.571Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolm002iy4v20yj24htp","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"# jsonp 演示实例 —— 基于node\n\n## 序\n\n1. **同源策略**是浏览器处于安全考虑，为通信设置了“相同的域、相同的端口、相同的协议”这一限制。这让我们的ajax请求存在跨域无权限访问的问题。\n\n2. 同时我们发现script标签引入脚本的行为并不受同源策略的限制，但是script引入的文件会被立即执行，如果其内容不符合js语法，则会报错；\n\n## 操作原理\n\n针对以上情况，诞生了jsonp：\n\n1. 利用script标签的src属性来请求接口，并向接口传递一个回调函数（克服了同源问题）\n\n2. 接口将数据以`回调函数参数`的形式同回调函数一同传回;此时传回则是这样形式的一个字符串：`回调函数名(数据)`，这样就符合js语法了（克服了script标签引入内容非js报错的问题）\n\n\n\n## 实例操作\n\n纸上得来总觉浅，绝知此事要躬行。jsonp的原理我早就倒背入流了，但是看着觉得明白，但总觉得少了点什么没抓住。所以，实际操刀试试吧。[点击下载源码](https://github.com/bigdots/some-code)\n\n下载代码后，进入some-code/jsonp-demo文件夹,该文件夹的目录为：\n\napp.js\t \n\npackage.json\n\nviews\n\n1. 命令行进入当前目录，安装包依赖：\n\n\t```\n\tnpm install\n\t```\n\n2. 安装完毕后，运行程序：\n\t\n\t```\n\tnode app.js\n\t```\n\n\t如果看到命令行输出“app is listening”则表示运行成功\n\n3. 修改host\n\n\t因为需要模拟跨域，所以在host文件中创建俩个不同的域名，在host文件中添加以下内容：\n\n\t```\n\t127.0.0.1  www.a.com www.b.com\n\t```\n\t自此结束，在浏览器中输入http://www.a.com:3000/，如果访问成功则表示大功告成，页面中应该出现俩个按钮。\n\t\n这个时候，我们打开浏览器的控制台，分别点击页面中的俩个按钮，就可以看到测试结果啦。\n\n##代码分析\n\n\n1. 入口文件：app.js\n\n\t- 设定模版引擎\n\t\n\t\t```\n\t\tapp.set('views', path.join(__dirname, 'views'));\n\t\tvar swig = new swig.Swig();\n\t\tapp.engine('html', swig.renderFile);\n\t\tapp.set('view engine', 'html');\n\t\t```\n\t- 设置路由和接口\n\t\n\t\t访问www.a.com时，渲染view/index.html页面\n\t\t\n\t\t```\n\t\tapp.get(\"/\",function(req,res){\n    \t\tres.render('index', {});\n\t\t})\n\t\t```\n\t\t请求www.b.com/index.json时，返回数据,这里服务器收到jsonp的回调函数名，并把它与数据拼接在一起返回给客户端\n\t\t\n\t\t```\n\t\t//模拟数据\n\t\tvar data = {\"brand\":23}\n\t\tapp.get(\"/index.json\",function(req,res){\n\t\t//解析请求路径\n    \tvar param = urlLib.parse(req.url,true);\n    \tvar returnValue = param.query.callback+ '(' + \t\t\tJSON.stringify(data) +')';\n    \t\tres.send(returnValue)\n\t\t})\n\t\t```\n\t- 启动服务\n\n\t\t```\n\t\tapp.listen(3000,function(){\n\t      console.log(\"app is listening\")\n\t\t})\n\t\t```\n\n\n2. 页面：view/index.html\n\n\t页面中有俩个按钮：`jsonp_button` 和 `ajax_button`,点击以后分别进行jsonp请求和ajax请求。\n\t\n\t- 绑定点击事件\n\t\n\t\t```\n\t\tjsonp_button.onclick = function(){\n\t        var url = \"http://www.b.com:3000/index.json?callback=jsonp\";\n\t        //向页面中添加script标签，进行jsonp请求\n\t        creatScript(url)\n\t    }\n\t\n\t    ajax_button.onclick = function(){\n\t    //ajax请求\n\t        var xhr = getXhr();\n\t        xhr.open(\"get\",\"http://www.b.com:3000/index.json\");\n\t        xhr.send();\n\t        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){\n\t              console.log(xhr.responseText);\n\t          } else {\n\t              console.log(\"Request was unsuccessful: \" + xhr.status);\n\t        }\n\t    }\n\t    function getXhr(){\n            var xhr;\n            if(window.XMLHttpRequest){      \n                xhr = new XMLHttpRequest()\n            }else{\n                xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); \n            }\n            return xhr;\n        }\n\t```\n\n\t- 动态创建script标签\n\t\n\t\t```\n\t\tfunction creatScript(url){\n            var scriptTag = document.createElement('script');\n            scriptTag.setAttribute('src', url);\n            document.getElementsByTagName('head')[0].appendChild(scriptTag);\n        }\n        ```\n\t- jsonp回调函数\n\t\n\t\t```\n\t\tfunction jsonp(data) {\n  \t\t\t  //获取数据\n            console.log(data);\n        }\n\t\t```\n\n由上面可以得出：jsonp中所有请求数据的后续操作应写在jsonp的回调函数中，它类似于ajax 的 success操作。\n\n最后一句话概括jsonp：jsonp就是原本应该发送json数据给客户端的服务器，不再发送json，改为发送一段调用回调函数的js代码，而原本应该返回的数据则是该函数的参数。\n\n\n","source":"_posts/nodejs 演示jsonp.md","raw":"# jsonp 演示实例 —— 基于node\n\n## 序\n\n1. **同源策略**是浏览器处于安全考虑，为通信设置了“相同的域、相同的端口、相同的协议”这一限制。这让我们的ajax请求存在跨域无权限访问的问题。\n\n2. 同时我们发现script标签引入脚本的行为并不受同源策略的限制，但是script引入的文件会被立即执行，如果其内容不符合js语法，则会报错；\n\n## 操作原理\n\n针对以上情况，诞生了jsonp：\n\n1. 利用script标签的src属性来请求接口，并向接口传递一个回调函数（克服了同源问题）\n\n2. 接口将数据以`回调函数参数`的形式同回调函数一同传回;此时传回则是这样形式的一个字符串：`回调函数名(数据)`，这样就符合js语法了（克服了script标签引入内容非js报错的问题）\n\n\n\n## 实例操作\n\n纸上得来总觉浅，绝知此事要躬行。jsonp的原理我早就倒背入流了，但是看着觉得明白，但总觉得少了点什么没抓住。所以，实际操刀试试吧。[点击下载源码](https://github.com/bigdots/some-code)\n\n下载代码后，进入some-code/jsonp-demo文件夹,该文件夹的目录为：\n\napp.js\t \n\npackage.json\n\nviews\n\n1. 命令行进入当前目录，安装包依赖：\n\n\t```\n\tnpm install\n\t```\n\n2. 安装完毕后，运行程序：\n\t\n\t```\n\tnode app.js\n\t```\n\n\t如果看到命令行输出“app is listening”则表示运行成功\n\n3. 修改host\n\n\t因为需要模拟跨域，所以在host文件中创建俩个不同的域名，在host文件中添加以下内容：\n\n\t```\n\t127.0.0.1  www.a.com www.b.com\n\t```\n\t自此结束，在浏览器中输入http://www.a.com:3000/，如果访问成功则表示大功告成，页面中应该出现俩个按钮。\n\t\n这个时候，我们打开浏览器的控制台，分别点击页面中的俩个按钮，就可以看到测试结果啦。\n\n##代码分析\n\n\n1. 入口文件：app.js\n\n\t- 设定模版引擎\n\t\n\t\t```\n\t\tapp.set('views', path.join(__dirname, 'views'));\n\t\tvar swig = new swig.Swig();\n\t\tapp.engine('html', swig.renderFile);\n\t\tapp.set('view engine', 'html');\n\t\t```\n\t- 设置路由和接口\n\t\n\t\t访问www.a.com时，渲染view/index.html页面\n\t\t\n\t\t```\n\t\tapp.get(\"/\",function(req,res){\n    \t\tres.render('index', {});\n\t\t})\n\t\t```\n\t\t请求www.b.com/index.json时，返回数据,这里服务器收到jsonp的回调函数名，并把它与数据拼接在一起返回给客户端\n\t\t\n\t\t```\n\t\t//模拟数据\n\t\tvar data = {\"brand\":23}\n\t\tapp.get(\"/index.json\",function(req,res){\n\t\t//解析请求路径\n    \tvar param = urlLib.parse(req.url,true);\n    \tvar returnValue = param.query.callback+ '(' + \t\t\tJSON.stringify(data) +')';\n    \t\tres.send(returnValue)\n\t\t})\n\t\t```\n\t- 启动服务\n\n\t\t```\n\t\tapp.listen(3000,function(){\n\t      console.log(\"app is listening\")\n\t\t})\n\t\t```\n\n\n2. 页面：view/index.html\n\n\t页面中有俩个按钮：`jsonp_button` 和 `ajax_button`,点击以后分别进行jsonp请求和ajax请求。\n\t\n\t- 绑定点击事件\n\t\n\t\t```\n\t\tjsonp_button.onclick = function(){\n\t        var url = \"http://www.b.com:3000/index.json?callback=jsonp\";\n\t        //向页面中添加script标签，进行jsonp请求\n\t        creatScript(url)\n\t    }\n\t\n\t    ajax_button.onclick = function(){\n\t    //ajax请求\n\t        var xhr = getXhr();\n\t        xhr.open(\"get\",\"http://www.b.com:3000/index.json\");\n\t        xhr.send();\n\t        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){\n\t              console.log(xhr.responseText);\n\t          } else {\n\t              console.log(\"Request was unsuccessful: \" + xhr.status);\n\t        }\n\t    }\n\t    function getXhr(){\n            var xhr;\n            if(window.XMLHttpRequest){      \n                xhr = new XMLHttpRequest()\n            }else{\n                xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); \n            }\n            return xhr;\n        }\n\t```\n\n\t- 动态创建script标签\n\t\n\t\t```\n\t\tfunction creatScript(url){\n            var scriptTag = document.createElement('script');\n            scriptTag.setAttribute('src', url);\n            document.getElementsByTagName('head')[0].appendChild(scriptTag);\n        }\n        ```\n\t- jsonp回调函数\n\t\n\t\t```\n\t\tfunction jsonp(data) {\n  \t\t\t  //获取数据\n            console.log(data);\n        }\n\t\t```\n\n由上面可以得出：jsonp中所有请求数据的后续操作应写在jsonp的回调函数中，它类似于ajax 的 success操作。\n\n最后一句话概括jsonp：jsonp就是原本应该发送json数据给客户端的服务器，不再发送json，改为发送一段调用回调函数的js代码，而原本应该返回的数据则是该函数的参数。\n\n\n","slug":"nodejs 演示jsonp","published":1,"date":"2021-12-06T06:07:06.196Z","updated":"2021-12-06T06:07:06.196Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolm002ky4v2gjyudbac","content":"<h1 id=\"jsonp-演示实例-——-基于node\"><a href=\"#jsonp-演示实例-——-基于node\" class=\"headerlink\" title=\"jsonp 演示实例 —— 基于node\"></a>jsonp 演示实例 —— 基于node</h1><h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><ol>\n<li><p><strong>同源策略</strong>是浏览器处于安全考虑，为通信设置了“相同的域、相同的端口、相同的协议”这一限制。这让我们的ajax请求存在跨域无权限访问的问题。</p>\n</li>\n<li><p>同时我们发现script标签引入脚本的行为并不受同源策略的限制，但是script引入的文件会被立即执行，如果其内容不符合js语法，则会报错；</p>\n</li>\n</ol>\n<h2 id=\"操作原理\"><a href=\"#操作原理\" class=\"headerlink\" title=\"操作原理\"></a>操作原理</h2><p>针对以上情况，诞生了jsonp：</p>\n<ol>\n<li><p>利用script标签的src属性来请求接口，并向接口传递一个回调函数（克服了同源问题）</p>\n</li>\n<li><p>接口将数据以<code>回调函数参数</code>的形式同回调函数一同传回;此时传回则是这样形式的一个字符串：<code>回调函数名(数据)</code>，这样就符合js语法了（克服了script标签引入内容非js报错的问题）</p>\n</li>\n</ol>\n<h2 id=\"实例操作\"><a href=\"#实例操作\" class=\"headerlink\" title=\"实例操作\"></a>实例操作</h2><p>纸上得来总觉浅，绝知此事要躬行。jsonp的原理我早就倒背入流了，但是看着觉得明白，但总觉得少了点什么没抓住。所以，实际操刀试试吧。<a href=\"https://github.com/bigdots/some-code\">点击下载源码</a></p>\n<p>下载代码后，进入some-code/jsonp-demo文件夹,该文件夹的目录为：</p>\n<p>app.js     </p>\n<p>package.json</p>\n<p>views</p>\n<ol>\n<li><p>命令行进入当前目录，安装包依赖：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></li>\n<li><p>安装完毕后，运行程序：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node app.js</span><br></pre></td></tr></table></figure>\n\n<p> 如果看到命令行输出“app is listening”则表示运行成功</p>\n</li>\n<li><p>修改host</p>\n<p> 因为需要模拟跨域，所以在host文件中创建俩个不同的域名，在host文件中添加以下内容：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1  www.a.com www.b.com</span><br></pre></td></tr></table></figure>\n<p> 自此结束，在浏览器中输入<a href=\"http://www.a.com:3000/%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AE%BF%E9%97%AE%E6%88%90%E5%8A%9F%E5%88%99%E8%A1%A8%E7%A4%BA%E5%A4%A7%E5%8A%9F%E5%91%8A%E6%88%90%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%BA%94%E8%AF%A5%E5%87%BA%E7%8E%B0%E4%BF%A9%E4%B8%AA%E6%8C%89%E9%92%AE%E3%80%82\">http://www.a.com:3000/，如果访问成功则表示大功告成，页面中应该出现俩个按钮。</a></p>\n</li>\n</ol>\n<p>这个时候，我们打开浏览器的控制台，分别点击页面中的俩个按钮，就可以看到测试结果啦。</p>\n<p>##代码分析</p>\n<ol>\n<li><p>入口文件：app.js</p>\n<ul>\n<li><p>设定模版引擎</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));</span><br><span class=\"line\">var swig = new swig.Swig();</span><br><span class=\"line\">app.engine(&#x27;html&#x27;, swig.renderFile);</span><br><span class=\"line\">app.set(&#x27;view engine&#x27;, &#x27;html&#x27;);</span><br></pre></td></tr></table></figure></li>\n<li><p>设置路由和接口</p>\n<p>  访问<a href=\"http://www.a.com时,渲染view/index.html%E9%A1%B5%E9%9D%A2\">www.a.com时，渲染view/index.html页面</a></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&quot;/&quot;,function(req,res)&#123;</span><br><span class=\"line\">  \t\tres.render(&#x27;index&#x27;, &#123;&#125;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>  请求<a href=\"http://www.b.com/index.json%E6%97%B6%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE,%E8%BF%99%E9%87%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%B6%E5%88%B0jsonp%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%90%8D%EF%BC%8C%E5%B9%B6%E6%8A%8A%E5%AE%83%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8B%BC%E6%8E%A5%E5%9C%A8%E4%B8%80%E8%B5%B7%E8%BF%94%E5%9B%9E%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF\">www.b.com/index.json时，返回数据,这里服务器收到jsonp的回调函数名，并把它与数据拼接在一起返回给客户端</a></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//模拟数据</span><br><span class=\"line\">var data = &#123;&quot;brand&quot;:23&#125;</span><br><span class=\"line\">app.get(&quot;/index.json&quot;,function(req,res)&#123;</span><br><span class=\"line\">//解析请求路径</span><br><span class=\"line\">  \tvar param = urlLib.parse(req.url,true);</span><br><span class=\"line\">  \tvar returnValue = param.query.callback+ &#x27;(&#x27; + \t\t\tJSON.stringify(data) +&#x27;)&#x27;;</span><br><span class=\"line\">  \t\tres.send(returnValue)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>启动服务</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.listen(3000,function()&#123;</span><br><span class=\"line\">     console.log(&quot;app is listening&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>页面：view/index.html</p>\n<p> 页面中有俩个按钮：<code>jsonp_button</code> 和 <code>ajax_button</code>,点击以后分别进行jsonp请求和ajax请求。</p>\n<ul>\n<li><p>绑定点击事件</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsonp_button.onclick = function()&#123;</span><br><span class=\"line\">       var url = &quot;http://www.b.com:3000/index.json?callback=jsonp&quot;;</span><br><span class=\"line\">       //向页面中添加script标签，进行jsonp请求</span><br><span class=\"line\">       creatScript(url)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">   ajax_button.onclick = function()&#123;</span><br><span class=\"line\">   //ajax请求</span><br><span class=\"line\">       var xhr = getXhr();</span><br><span class=\"line\">       xhr.open(&quot;get&quot;,&quot;http://www.b.com:3000/index.json&quot;);</span><br><span class=\"line\">       xhr.send();</span><br><span class=\"line\">       if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class=\"line\">             console.log(xhr.responseText);</span><br><span class=\"line\">         &#125; else &#123;</span><br><span class=\"line\">             console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   function getXhr()&#123;</span><br><span class=\"line\">          var xhr;</span><br><span class=\"line\">          if(window.XMLHttpRequest)&#123;      </span><br><span class=\"line\">              xhr = new XMLHttpRequest()</span><br><span class=\"line\">          &#125;else&#123;</span><br><span class=\"line\">              xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); </span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          return xhr;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>动态创建script标签</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function creatScript(url)&#123;</span><br><span class=\"line\">          var scriptTag = document.createElement(&#x27;script&#x27;);</span><br><span class=\"line\">          scriptTag.setAttribute(&#x27;src&#x27;, url);</span><br><span class=\"line\">          document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(scriptTag);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>jsonp回调函数</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jsonp(data) &#123;</span><br><span class=\"line\">\t\t\t  //获取数据</span><br><span class=\"line\">          console.log(data);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p>由上面可以得出：jsonp中所有请求数据的后续操作应写在jsonp的回调函数中，它类似于ajax 的 success操作。</p>\n<p>最后一句话概括jsonp：jsonp就是原本应该发送json数据给客户端的服务器，不再发送json，改为发送一段调用回调函数的js代码，而原本应该返回的数据则是该函数的参数。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jsonp-演示实例-——-基于node\"><a href=\"#jsonp-演示实例-——-基于node\" class=\"headerlink\" title=\"jsonp 演示实例 —— 基于node\"></a>jsonp 演示实例 —— 基于node</h1><h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><ol>\n<li><p><strong>同源策略</strong>是浏览器处于安全考虑，为通信设置了“相同的域、相同的端口、相同的协议”这一限制。这让我们的ajax请求存在跨域无权限访问的问题。</p>\n</li>\n<li><p>同时我们发现script标签引入脚本的行为并不受同源策略的限制，但是script引入的文件会被立即执行，如果其内容不符合js语法，则会报错；</p>\n</li>\n</ol>\n<h2 id=\"操作原理\"><a href=\"#操作原理\" class=\"headerlink\" title=\"操作原理\"></a>操作原理</h2><p>针对以上情况，诞生了jsonp：</p>\n<ol>\n<li><p>利用script标签的src属性来请求接口，并向接口传递一个回调函数（克服了同源问题）</p>\n</li>\n<li><p>接口将数据以<code>回调函数参数</code>的形式同回调函数一同传回;此时传回则是这样形式的一个字符串：<code>回调函数名(数据)</code>，这样就符合js语法了（克服了script标签引入内容非js报错的问题）</p>\n</li>\n</ol>\n<h2 id=\"实例操作\"><a href=\"#实例操作\" class=\"headerlink\" title=\"实例操作\"></a>实例操作</h2><p>纸上得来总觉浅，绝知此事要躬行。jsonp的原理我早就倒背入流了，但是看着觉得明白，但总觉得少了点什么没抓住。所以，实际操刀试试吧。<a href=\"https://github.com/bigdots/some-code\">点击下载源码</a></p>\n<p>下载代码后，进入some-code/jsonp-demo文件夹,该文件夹的目录为：</p>\n<p>app.js     </p>\n<p>package.json</p>\n<p>views</p>\n<ol>\n<li><p>命令行进入当前目录，安装包依赖：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></li>\n<li><p>安装完毕后，运行程序：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node app.js</span><br></pre></td></tr></table></figure>\n\n<p> 如果看到命令行输出“app is listening”则表示运行成功</p>\n</li>\n<li><p>修改host</p>\n<p> 因为需要模拟跨域，所以在host文件中创建俩个不同的域名，在host文件中添加以下内容：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1  www.a.com www.b.com</span><br></pre></td></tr></table></figure>\n<p> 自此结束，在浏览器中输入<a href=\"http://www.a.com:3000/%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AE%BF%E9%97%AE%E6%88%90%E5%8A%9F%E5%88%99%E8%A1%A8%E7%A4%BA%E5%A4%A7%E5%8A%9F%E5%91%8A%E6%88%90%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%BA%94%E8%AF%A5%E5%87%BA%E7%8E%B0%E4%BF%A9%E4%B8%AA%E6%8C%89%E9%92%AE%E3%80%82\">http://www.a.com:3000/，如果访问成功则表示大功告成，页面中应该出现俩个按钮。</a></p>\n</li>\n</ol>\n<p>这个时候，我们打开浏览器的控制台，分别点击页面中的俩个按钮，就可以看到测试结果啦。</p>\n<p>##代码分析</p>\n<ol>\n<li><p>入口文件：app.js</p>\n<ul>\n<li><p>设定模版引擎</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));</span><br><span class=\"line\">var swig = new swig.Swig();</span><br><span class=\"line\">app.engine(&#x27;html&#x27;, swig.renderFile);</span><br><span class=\"line\">app.set(&#x27;view engine&#x27;, &#x27;html&#x27;);</span><br></pre></td></tr></table></figure></li>\n<li><p>设置路由和接口</p>\n<p>  访问<a href=\"http://www.a.com时,渲染view/index.html%E9%A1%B5%E9%9D%A2\">www.a.com时，渲染view/index.html页面</a></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&quot;/&quot;,function(req,res)&#123;</span><br><span class=\"line\">  \t\tres.render(&#x27;index&#x27;, &#123;&#125;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>  请求<a href=\"http://www.b.com/index.json%E6%97%B6%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE,%E8%BF%99%E9%87%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%B6%E5%88%B0jsonp%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%90%8D%EF%BC%8C%E5%B9%B6%E6%8A%8A%E5%AE%83%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8B%BC%E6%8E%A5%E5%9C%A8%E4%B8%80%E8%B5%B7%E8%BF%94%E5%9B%9E%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF\">www.b.com/index.json时，返回数据,这里服务器收到jsonp的回调函数名，并把它与数据拼接在一起返回给客户端</a></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//模拟数据</span><br><span class=\"line\">var data = &#123;&quot;brand&quot;:23&#125;</span><br><span class=\"line\">app.get(&quot;/index.json&quot;,function(req,res)&#123;</span><br><span class=\"line\">//解析请求路径</span><br><span class=\"line\">  \tvar param = urlLib.parse(req.url,true);</span><br><span class=\"line\">  \tvar returnValue = param.query.callback+ &#x27;(&#x27; + \t\t\tJSON.stringify(data) +&#x27;)&#x27;;</span><br><span class=\"line\">  \t\tres.send(returnValue)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>启动服务</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.listen(3000,function()&#123;</span><br><span class=\"line\">     console.log(&quot;app is listening&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>页面：view/index.html</p>\n<p> 页面中有俩个按钮：<code>jsonp_button</code> 和 <code>ajax_button</code>,点击以后分别进行jsonp请求和ajax请求。</p>\n<ul>\n<li><p>绑定点击事件</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsonp_button.onclick = function()&#123;</span><br><span class=\"line\">       var url = &quot;http://www.b.com:3000/index.json?callback=jsonp&quot;;</span><br><span class=\"line\">       //向页面中添加script标签，进行jsonp请求</span><br><span class=\"line\">       creatScript(url)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">   ajax_button.onclick = function()&#123;</span><br><span class=\"line\">   //ajax请求</span><br><span class=\"line\">       var xhr = getXhr();</span><br><span class=\"line\">       xhr.open(&quot;get&quot;,&quot;http://www.b.com:3000/index.json&quot;);</span><br><span class=\"line\">       xhr.send();</span><br><span class=\"line\">       if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class=\"line\">             console.log(xhr.responseText);</span><br><span class=\"line\">         &#125; else &#123;</span><br><span class=\"line\">             console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   function getXhr()&#123;</span><br><span class=\"line\">          var xhr;</span><br><span class=\"line\">          if(window.XMLHttpRequest)&#123;      </span><br><span class=\"line\">              xhr = new XMLHttpRequest()</span><br><span class=\"line\">          &#125;else&#123;</span><br><span class=\"line\">              xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); </span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          return xhr;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>动态创建script标签</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function creatScript(url)&#123;</span><br><span class=\"line\">          var scriptTag = document.createElement(&#x27;script&#x27;);</span><br><span class=\"line\">          scriptTag.setAttribute(&#x27;src&#x27;, url);</span><br><span class=\"line\">          document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(scriptTag);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>jsonp回调函数</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jsonp(data) &#123;</span><br><span class=\"line\">\t\t\t  //获取数据</span><br><span class=\"line\">          console.log(data);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p>由上面可以得出：jsonp中所有请求数据的后续操作应写在jsonp的回调函数中，它类似于ajax 的 success操作。</p>\n<p>最后一句话概括jsonp：jsonp就是原本应该发送json数据给客户端的服务器，不再发送json，改为发送一段调用回调函数的js代码，而原本应该返回的数据则是该函数的参数。</p>\n"},{"_content":"# npm package.json文件解读\n\n每个Nodejs项目的根目录下面，一般都会有一个package.json文件。该文件可以由`npm init`生成，定义了项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。\n\npackage.json文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。\n\n## 基本字段\n\n1. name\n\n\t项目名称（npm包名）。必需字段\n\t\n2. version\n\n\t项目版本。必需字段。\n\t版本号的格式为\"1.0.0\",分别代表“主版本号.次版本号.修订号”。它的递增规则如下： \n\t- 主版本号：当你做了不兼容的API 修改；\n\t- 次版本号：当你做了向下兼容的功能性新增；\n\t- 修订号：当你做了向下兼容的问题修正。\n\t\n\t在实际使用中，一般可以看到各种形式的版本号：\n\t\n\t```\n\t*: 任意版本\n\t1.1.0: 指定版本\n\t~1.1.0: 1.1.0 <= 版本 < 1.2.0\n\t^1.1.0: 1.1.0 <= 版本 < 2.0.0\n\tlatest：安装最新版本。\n\t```\n\t\n\t- `*`表示任意版本；\n\t- `~ `前缀表示，安装大于指定的这个版本，并且匹配到 x.y.z 中 z 最新的版本；\n\t- `^ `前缀在 ^0.y.z 时的表现和 ~0.y.z 是一样的，然而 ^1.y.z 的时候，就会匹配到 y 和 z 都是最新的版本；\n\t- 特殊的是，当版本号为 ^0.0.z 或者 ~0.0.z 的时候，考虑到 0.0.z 是一个不稳定版本， 所以它们都相当于 =0.0.z。\n\t\n3. author && contributors\n\n\t项目作者以及贡献者。author是字符串形式的作者名，contributors是一个项目贡献者数组。\n\t\n4. description && keywords\n\n\t项目描述和项目关键字。帮助人们在使用npm search时找到这个包。\n\t\n5. license\n\t\n\t许可证。\n\t\n\n## 功能性字段\n\n1. scripts\n\n\t定义脚本命令。它的每一个属性，对应一段脚本。并且可以在命令行下使用npm run命令执行这段脚本。\n\t\n\tnpm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。\n\t\n\t比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。\n\t\n\t更多可参考阮老师的 [npm scripts 使用指南](http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html)\n\t\n2. dependencies  &&  devDependencies\n\n\t`npm install`在安装node模块时，有两种命令参数可以把它们的信息写入package.json文件： `–save`以及`–save-dev`。`–save`会把依赖包名称添加到package.json文件`dependencies`键下，`–save-dev`则添加到package.json文件`devDependencies`键下。\n\n\t`dependencies`字段指定了项目生产环境中需要的依赖，即正常运行该包时所依赖的模块，`devDependencies`指定项目开发所需要的依赖项，像一些进行单元测试之类的包，比如grunt-contrib-uglify，我们用它混淆js文件，它们不会被部署到生产环境。\n\t\n\t它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。\n\t\n3. bin\n\n\t用来指定各个内部命令对应的可执行文件的位置。\n\t\n\t例如：\n\t\n\t```\n\t\"bin\": {\n  \t\t\"someTool\": \"./bin/someTool.js\"\n\t}\n\t```\n\t\n\t上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js\n\t\n4. main\n\n\t指定包的入口程序文件。这个字段的默认值是模块根目录下面的index.js。\n\t\n5. config\n\n\t用于向环境变量输出值。\n\t\n\t比如：\n\t\n\t```\n\t{\n\t\t// ...\n\t\t\"config\" : { \"port\" : \"8080\" },\n\t}\n\t```\n\t\n\t然后通过`process.env.npm_package_config_port`读取该值。\n\n\n## 其他字段\n\n1. engines\n\n\t指定node的工作版本\n\t\n2. man\n\n\t指定当前模块的man文档的位置。\n\t\n3. preferGlobal\n\n\t布尔类型值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告。\n\t\n\t...\n\n\t","source":"_posts/npm package.json文件解读.md","raw":"# npm package.json文件解读\n\n每个Nodejs项目的根目录下面，一般都会有一个package.json文件。该文件可以由`npm init`生成，定义了项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。\n\npackage.json文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。\n\n## 基本字段\n\n1. name\n\n\t项目名称（npm包名）。必需字段\n\t\n2. version\n\n\t项目版本。必需字段。\n\t版本号的格式为\"1.0.0\",分别代表“主版本号.次版本号.修订号”。它的递增规则如下： \n\t- 主版本号：当你做了不兼容的API 修改；\n\t- 次版本号：当你做了向下兼容的功能性新增；\n\t- 修订号：当你做了向下兼容的问题修正。\n\t\n\t在实际使用中，一般可以看到各种形式的版本号：\n\t\n\t```\n\t*: 任意版本\n\t1.1.0: 指定版本\n\t~1.1.0: 1.1.0 <= 版本 < 1.2.0\n\t^1.1.0: 1.1.0 <= 版本 < 2.0.0\n\tlatest：安装最新版本。\n\t```\n\t\n\t- `*`表示任意版本；\n\t- `~ `前缀表示，安装大于指定的这个版本，并且匹配到 x.y.z 中 z 最新的版本；\n\t- `^ `前缀在 ^0.y.z 时的表现和 ~0.y.z 是一样的，然而 ^1.y.z 的时候，就会匹配到 y 和 z 都是最新的版本；\n\t- 特殊的是，当版本号为 ^0.0.z 或者 ~0.0.z 的时候，考虑到 0.0.z 是一个不稳定版本， 所以它们都相当于 =0.0.z。\n\t\n3. author && contributors\n\n\t项目作者以及贡献者。author是字符串形式的作者名，contributors是一个项目贡献者数组。\n\t\n4. description && keywords\n\n\t项目描述和项目关键字。帮助人们在使用npm search时找到这个包。\n\t\n5. license\n\t\n\t许可证。\n\t\n\n## 功能性字段\n\n1. scripts\n\n\t定义脚本命令。它的每一个属性，对应一段脚本。并且可以在命令行下使用npm run命令执行这段脚本。\n\t\n\tnpm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。\n\t\n\t比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。\n\t\n\t更多可参考阮老师的 [npm scripts 使用指南](http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html)\n\t\n2. dependencies  &&  devDependencies\n\n\t`npm install`在安装node模块时，有两种命令参数可以把它们的信息写入package.json文件： `–save`以及`–save-dev`。`–save`会把依赖包名称添加到package.json文件`dependencies`键下，`–save-dev`则添加到package.json文件`devDependencies`键下。\n\n\t`dependencies`字段指定了项目生产环境中需要的依赖，即正常运行该包时所依赖的模块，`devDependencies`指定项目开发所需要的依赖项，像一些进行单元测试之类的包，比如grunt-contrib-uglify，我们用它混淆js文件，它们不会被部署到生产环境。\n\t\n\t它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。\n\t\n3. bin\n\n\t用来指定各个内部命令对应的可执行文件的位置。\n\t\n\t例如：\n\t\n\t```\n\t\"bin\": {\n  \t\t\"someTool\": \"./bin/someTool.js\"\n\t}\n\t```\n\t\n\t上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js\n\t\n4. main\n\n\t指定包的入口程序文件。这个字段的默认值是模块根目录下面的index.js。\n\t\n5. config\n\n\t用于向环境变量输出值。\n\t\n\t比如：\n\t\n\t```\n\t{\n\t\t// ...\n\t\t\"config\" : { \"port\" : \"8080\" },\n\t}\n\t```\n\t\n\t然后通过`process.env.npm_package_config_port`读取该值。\n\n\n## 其他字段\n\n1. engines\n\n\t指定node的工作版本\n\t\n2. man\n\n\t指定当前模块的man文档的位置。\n\t\n3. preferGlobal\n\n\t布尔类型值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告。\n\t\n\t...\n\n\t","slug":"npm package.json文件解读","published":1,"date":"2021-12-06T06:07:06.196Z","updated":"2021-12-06T06:07:06.196Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoln002my4v2ewfh6pzq","content":"<h1 id=\"npm-package-json文件解读\"><a href=\"#npm-package-json文件解读\" class=\"headerlink\" title=\"npm package.json文件解读\"></a>npm package.json文件解读</h1><p>每个Nodejs项目的根目录下面，一般都会有一个package.json文件。该文件可以由<code>npm init</code>生成，定义了项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。</p>\n<p>package.json文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。</p>\n<h2 id=\"基本字段\"><a href=\"#基本字段\" class=\"headerlink\" title=\"基本字段\"></a>基本字段</h2><ol>\n<li><p>name</p>\n<p> 项目名称（npm包名）。必需字段</p>\n</li>\n<li><p>version</p>\n<p> 项目版本。必需字段。<br> 版本号的格式为”1.0.0”,分别代表“主版本号.次版本号.修订号”。它的递增规则如下： </p>\n<ul>\n<li>主版本号：当你做了不兼容的API 修改；</li>\n<li>次版本号：当你做了向下兼容的功能性新增；</li>\n<li>修订号：当你做了向下兼容的问题修正。</li>\n</ul>\n<p> 在实际使用中，一般可以看到各种形式的版本号：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*: 任意版本</span><br><span class=\"line\">1.1.0: 指定版本</span><br><span class=\"line\">~1.1.0: 1.1.0 &lt;= 版本 &lt; 1.2.0</span><br><span class=\"line\">^1.1.0: 1.1.0 &lt;= 版本 &lt; 2.0.0</span><br><span class=\"line\">latest：安装最新版本。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>*</code>表示任意版本；</li>\n<li><code>~ </code>前缀表示，安装大于指定的这个版本，并且匹配到 x.y.z 中 z 最新的版本；</li>\n<li><code>^ </code>前缀在 ^0.y.z 时的表现和 ~0.y.z 是一样的，然而 ^1.y.z 的时候，就会匹配到 y 和 z 都是最新的版本；</li>\n<li>特殊的是，当版本号为 ^0.0.z 或者 ~0.0.z 的时候，考虑到 0.0.z 是一个不稳定版本， 所以它们都相当于 =0.0.z。</li>\n</ul>\n</li>\n<li><p>author &amp;&amp; contributors</p>\n<p> 项目作者以及贡献者。author是字符串形式的作者名，contributors是一个项目贡献者数组。</p>\n</li>\n<li><p>description &amp;&amp; keywords</p>\n<p> 项目描述和项目关键字。帮助人们在使用npm search时找到这个包。</p>\n</li>\n<li><p>license</p>\n<p> 许可证。</p>\n</li>\n</ol>\n<h2 id=\"功能性字段\"><a href=\"#功能性字段\" class=\"headerlink\" title=\"功能性字段\"></a>功能性字段</h2><ol>\n<li><p>scripts</p>\n<p> 定义脚本命令。它的每一个属性，对应一段脚本。并且可以在命令行下使用npm run命令执行这段脚本。</p>\n<p> npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。</p>\n<p> 比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。</p>\n<p> 更多可参考阮老师的 <a href=\"http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html\">npm scripts 使用指南</a></p>\n</li>\n<li><p>dependencies  &amp;&amp;  devDependencies</p>\n<p> <code>npm install</code>在安装node模块时，有两种命令参数可以把它们的信息写入package.json文件： <code>–save</code>以及<code>–save-dev</code>。<code>–save</code>会把依赖包名称添加到package.json文件<code>dependencies</code>键下，<code>–save-dev</code>则添加到package.json文件<code>devDependencies</code>键下。</p>\n<p> <code>dependencies</code>字段指定了项目生产环境中需要的依赖，即正常运行该包时所依赖的模块，<code>devDependencies</code>指定项目开发所需要的依赖项，像一些进行单元测试之类的包，比如grunt-contrib-uglify，我们用它混淆js文件，它们不会被部署到生产环境。</p>\n<p> 它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。</p>\n</li>\n<li><p>bin</p>\n<p> 用来指定各个内部命令对应的可执行文件的位置。</p>\n<p> 例如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;bin&quot;: &#123;</span><br><span class=\"line\"> \t\t&quot;someTool&quot;: &quot;./bin/someTool.js&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js</p>\n</li>\n<li><p>main</p>\n<p> 指定包的入口程序文件。这个字段的默认值是模块根目录下面的index.js。</p>\n</li>\n<li><p>config</p>\n<p> 用于向环境变量输出值。</p>\n<p> 比如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t// ...</span><br><span class=\"line\">\t&quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 然后通过<code>process.env.npm_package_config_port</code>读取该值。</p>\n</li>\n</ol>\n<h2 id=\"其他字段\"><a href=\"#其他字段\" class=\"headerlink\" title=\"其他字段\"></a>其他字段</h2><ol>\n<li><p>engines</p>\n<p> 指定node的工作版本</p>\n</li>\n<li><p>man</p>\n<p> 指定当前模块的man文档的位置。</p>\n</li>\n<li><p>preferGlobal</p>\n<p> 布尔类型值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告。</p>\n<p> …</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"npm-package-json文件解读\"><a href=\"#npm-package-json文件解读\" class=\"headerlink\" title=\"npm package.json文件解读\"></a>npm package.json文件解读</h1><p>每个Nodejs项目的根目录下面，一般都会有一个package.json文件。该文件可以由<code>npm init</code>生成，定义了项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。</p>\n<p>package.json文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。</p>\n<h2 id=\"基本字段\"><a href=\"#基本字段\" class=\"headerlink\" title=\"基本字段\"></a>基本字段</h2><ol>\n<li><p>name</p>\n<p> 项目名称（npm包名）。必需字段</p>\n</li>\n<li><p>version</p>\n<p> 项目版本。必需字段。<br> 版本号的格式为”1.0.0”,分别代表“主版本号.次版本号.修订号”。它的递增规则如下： </p>\n<ul>\n<li>主版本号：当你做了不兼容的API 修改；</li>\n<li>次版本号：当你做了向下兼容的功能性新增；</li>\n<li>修订号：当你做了向下兼容的问题修正。</li>\n</ul>\n<p> 在实际使用中，一般可以看到各种形式的版本号：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*: 任意版本</span><br><span class=\"line\">1.1.0: 指定版本</span><br><span class=\"line\">~1.1.0: 1.1.0 &lt;= 版本 &lt; 1.2.0</span><br><span class=\"line\">^1.1.0: 1.1.0 &lt;= 版本 &lt; 2.0.0</span><br><span class=\"line\">latest：安装最新版本。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>*</code>表示任意版本；</li>\n<li><code>~ </code>前缀表示，安装大于指定的这个版本，并且匹配到 x.y.z 中 z 最新的版本；</li>\n<li><code>^ </code>前缀在 ^0.y.z 时的表现和 ~0.y.z 是一样的，然而 ^1.y.z 的时候，就会匹配到 y 和 z 都是最新的版本；</li>\n<li>特殊的是，当版本号为 ^0.0.z 或者 ~0.0.z 的时候，考虑到 0.0.z 是一个不稳定版本， 所以它们都相当于 =0.0.z。</li>\n</ul>\n</li>\n<li><p>author &amp;&amp; contributors</p>\n<p> 项目作者以及贡献者。author是字符串形式的作者名，contributors是一个项目贡献者数组。</p>\n</li>\n<li><p>description &amp;&amp; keywords</p>\n<p> 项目描述和项目关键字。帮助人们在使用npm search时找到这个包。</p>\n</li>\n<li><p>license</p>\n<p> 许可证。</p>\n</li>\n</ol>\n<h2 id=\"功能性字段\"><a href=\"#功能性字段\" class=\"headerlink\" title=\"功能性字段\"></a>功能性字段</h2><ol>\n<li><p>scripts</p>\n<p> 定义脚本命令。它的每一个属性，对应一段脚本。并且可以在命令行下使用npm run命令执行这段脚本。</p>\n<p> npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。</p>\n<p> 比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。</p>\n<p> 更多可参考阮老师的 <a href=\"http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html\">npm scripts 使用指南</a></p>\n</li>\n<li><p>dependencies  &amp;&amp;  devDependencies</p>\n<p> <code>npm install</code>在安装node模块时，有两种命令参数可以把它们的信息写入package.json文件： <code>–save</code>以及<code>–save-dev</code>。<code>–save</code>会把依赖包名称添加到package.json文件<code>dependencies</code>键下，<code>–save-dev</code>则添加到package.json文件<code>devDependencies</code>键下。</p>\n<p> <code>dependencies</code>字段指定了项目生产环境中需要的依赖，即正常运行该包时所依赖的模块，<code>devDependencies</code>指定项目开发所需要的依赖项，像一些进行单元测试之类的包，比如grunt-contrib-uglify，我们用它混淆js文件，它们不会被部署到生产环境。</p>\n<p> 它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。</p>\n</li>\n<li><p>bin</p>\n<p> 用来指定各个内部命令对应的可执行文件的位置。</p>\n<p> 例如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;bin&quot;: &#123;</span><br><span class=\"line\"> \t\t&quot;someTool&quot;: &quot;./bin/someTool.js&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js</p>\n</li>\n<li><p>main</p>\n<p> 指定包的入口程序文件。这个字段的默认值是模块根目录下面的index.js。</p>\n</li>\n<li><p>config</p>\n<p> 用于向环境变量输出值。</p>\n<p> 比如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t// ...</span><br><span class=\"line\">\t&quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 然后通过<code>process.env.npm_package_config_port</code>读取该值。</p>\n</li>\n</ol>\n<h2 id=\"其他字段\"><a href=\"#其他字段\" class=\"headerlink\" title=\"其他字段\"></a>其他字段</h2><ol>\n<li><p>engines</p>\n<p> 指定node的工作版本</p>\n</li>\n<li><p>man</p>\n<p> 指定当前模块的man文档的位置。</p>\n</li>\n<li><p>preferGlobal</p>\n<p> 布尔类型值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告。</p>\n<p> …</p>\n</li>\n</ol>\n"},{"_content":"# redux中间价与副作用的理解\n\n\n## redux副作用\n\nreducer是纯函数，一定要保持纯净。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。\n\n所以在需要执行异步等操作的时候，就会带来redux的副作用。为了解决这一问题，redux提出了中间件。\n\n\n为什么直接在View发出异步操作，然后在dispatch一个action？\n\nView：与 State 一一对应，可以看作 State 的视觉层，并不合适承担其他功能。\n\n## 中间件\n\n为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？\n\n（1）Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。\n\n（2）View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。\n\n（3）Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。","source":"_posts/redux中间价与副作用的理解.md","raw":"# redux中间价与副作用的理解\n\n\n## redux副作用\n\nreducer是纯函数，一定要保持纯净。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。\n\n所以在需要执行异步等操作的时候，就会带来redux的副作用。为了解决这一问题，redux提出了中间件。\n\n\n为什么直接在View发出异步操作，然后在dispatch一个action？\n\nView：与 State 一一对应，可以看作 State 的视觉层，并不合适承担其他功能。\n\n## 中间件\n\n为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？\n\n（1）Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。\n\n（2）View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。\n\n（3）Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。","slug":"redux中间价与副作用的理解","published":1,"date":"2021-12-06T06:07:06.206Z","updated":"2021-12-06T06:07:06.206Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolo002oy4v26z04a6yc","content":"<h1 id=\"redux中间价与副作用的理解\"><a href=\"#redux中间价与副作用的理解\" class=\"headerlink\" title=\"redux中间价与副作用的理解\"></a>redux中间价与副作用的理解</h1><h2 id=\"redux副作用\"><a href=\"#redux副作用\" class=\"headerlink\" title=\"redux副作用\"></a>redux副作用</h2><p>reducer是纯函数，一定要保持纯净。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</p>\n<p>所以在需要执行异步等操作的时候，就会带来redux的副作用。为了解决这一问题，redux提出了中间件。</p>\n<p>为什么直接在View发出异步操作，然后在dispatch一个action？</p>\n<p>View：与 State 一一对应，可以看作 State 的视觉层，并不合适承担其他功能。</p>\n<h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><p>为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？</p>\n<p>（1）Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</p>\n<p>（2）View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。</p>\n<p>（3）Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"redux中间价与副作用的理解\"><a href=\"#redux中间价与副作用的理解\" class=\"headerlink\" title=\"redux中间价与副作用的理解\"></a>redux中间价与副作用的理解</h1><h2 id=\"redux副作用\"><a href=\"#redux副作用\" class=\"headerlink\" title=\"redux副作用\"></a>redux副作用</h2><p>reducer是纯函数，一定要保持纯净。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</p>\n<p>所以在需要执行异步等操作的时候，就会带来redux的副作用。为了解决这一问题，redux提出了中间件。</p>\n<p>为什么直接在View发出异步操作，然后在dispatch一个action？</p>\n<p>View：与 State 一一对应，可以看作 State 的视觉层，并不合适承担其他功能。</p>\n<h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><p>为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？</p>\n<p>（1）Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</p>\n<p>（2）View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。</p>\n<p>（3）Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</p>\n"},{"title":"seajs快速了解","date":"2015-12-17T07:04:34.000Z","description":"SeaJS","_content":"\n&nbsp;&nbsp;&nbsp;&nbsp;SeaJS是一个遵循CommonJS规范的JavaScript模块加载框架，可以实现JavaScript的模块化开发及加载机制。与jQuery等JavaScript框架不同，SeaJS不会扩展封装语言特性，而只是实现JavaScript的模块化及按模块加载。SeaJS的主要目的是令JavaScript开发模块化并可以轻松愉悦进行加载，将前端工程师从繁重的JavaScript文件及对象依赖处理中解放出来，可以专注于代码本身的逻辑。SeaJS可以与jQuery这类框架完美集成。使用SeaJS可以提高JavaScript代码的可读性和清晰度，解决目前JavaScript编程中普遍存在的依赖关系混乱和代码纠缠等问题，方便代码的编写和维护。\nSeaJS的作者是前淘宝UED,现支付宝前端工程师玉伯。\n\n<!-- more -->\n\n## 特点\nSeaJS 追求简单、自然的代码书写和组织方式，具有以下核心特性：\n\n+ 简单友好的模块定义规范：SeaJS 遵循CMD规范，可以像Node.js一般书写模块代码。\n+ 自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。\n\n\n## 使用\nSeaJS是为了实现JavaScript的模块化的，所以在 SeaJS 中，所有 JavaScript 文件都应该用模块的形式来书写，并且一个文件只包含一个模块。它的操作也是围绕着模块来进行。\n\n1.定义模块——**defined**\n\n\tdefine(id, dependencies,function(require, exports, module) {\n\n\t  // 模块代码\n\n\t});\n\n+ id:当前模块的唯一标识。该参数可选。如果没有指定，默认为模块所在文件的访问路径。如果指定的话， 必须是顶级或绝对标识（不能是相对标识）。\n+ dependencies:当前模块所依赖的模块，是一个由模块标识组成的数组。该参数可选。\n+ fn:模块的工厂函数。模块初始化时，会调用且仅调用一次该工厂函数。\n\t+ require:用来获取指定模块的接口\n``` javascript\n\tdefine(function(require) {\n\n\t  // 获取模块 a 的接口\n\t  var a = require('./a');\n\n\t  // 调用模块 a 的方法\n\t  a.doSomething();\n\t});\n```\n\t+ require.async:用来在模块内部异步加载一个或多个模块。\n\n\t``` javascript\n\t\tdefine(function(require) {\n\n\t\t  // 异步加载多个模块，在加载完成时，执行回调\n\t\t  require.async(['./c', './d'], function(c, d) {\n\t\t    c.doSomething();\n\t\t    d.doSomething();\n\t\t  });\n\n\t\t});\n\t```\n\n2.配置——**seajs.config**\n\n```javascript\nseajs.config({\n\n  // 设置路径，方便跨目录调用\n  paths: {\n    'arale': 'https://a.alipayobjects.com/arale',\n    'jquery': 'https://a.alipayobjects.com/jquery'\n  },\n\n  // 设置别名，方便调用\n  alias: {\n    'class': 'arale/class/1.0.0/class',\n    'jquery': 'jquery/jquery/1.10.1/jquery'\n  }\n\n});\n```\n\n3.加载模块——**seajs.use**\n\n``` javascript\n/ 加载一个模块\nseajs.use('./a');\n\n// 加载一个模块，在加载完成时，执行回调\nseajs.use('./a', function(a) {\n  a.doSomething();\n});\n\n// 加载多个模块，在加载完成时，执行回调\nseajs.use(['./a', './b'], function(a, b) {\n  a.doSomething();\n  b.doSomething();\n});\n```","source":"_posts/seajs快速了解.md","raw":"title: seajs快速了解\ndate: 2015-12-17 15:04:34\ntags: [web]\ndescription: SeaJS\n\n---\n\n&nbsp;&nbsp;&nbsp;&nbsp;SeaJS是一个遵循CommonJS规范的JavaScript模块加载框架，可以实现JavaScript的模块化开发及加载机制。与jQuery等JavaScript框架不同，SeaJS不会扩展封装语言特性，而只是实现JavaScript的模块化及按模块加载。SeaJS的主要目的是令JavaScript开发模块化并可以轻松愉悦进行加载，将前端工程师从繁重的JavaScript文件及对象依赖处理中解放出来，可以专注于代码本身的逻辑。SeaJS可以与jQuery这类框架完美集成。使用SeaJS可以提高JavaScript代码的可读性和清晰度，解决目前JavaScript编程中普遍存在的依赖关系混乱和代码纠缠等问题，方便代码的编写和维护。\nSeaJS的作者是前淘宝UED,现支付宝前端工程师玉伯。\n\n<!-- more -->\n\n## 特点\nSeaJS 追求简单、自然的代码书写和组织方式，具有以下核心特性：\n\n+ 简单友好的模块定义规范：SeaJS 遵循CMD规范，可以像Node.js一般书写模块代码。\n+ 自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。\n\n\n## 使用\nSeaJS是为了实现JavaScript的模块化的，所以在 SeaJS 中，所有 JavaScript 文件都应该用模块的形式来书写，并且一个文件只包含一个模块。它的操作也是围绕着模块来进行。\n\n1.定义模块——**defined**\n\n\tdefine(id, dependencies,function(require, exports, module) {\n\n\t  // 模块代码\n\n\t});\n\n+ id:当前模块的唯一标识。该参数可选。如果没有指定，默认为模块所在文件的访问路径。如果指定的话， 必须是顶级或绝对标识（不能是相对标识）。\n+ dependencies:当前模块所依赖的模块，是一个由模块标识组成的数组。该参数可选。\n+ fn:模块的工厂函数。模块初始化时，会调用且仅调用一次该工厂函数。\n\t+ require:用来获取指定模块的接口\n``` javascript\n\tdefine(function(require) {\n\n\t  // 获取模块 a 的接口\n\t  var a = require('./a');\n\n\t  // 调用模块 a 的方法\n\t  a.doSomething();\n\t});\n```\n\t+ require.async:用来在模块内部异步加载一个或多个模块。\n\n\t``` javascript\n\t\tdefine(function(require) {\n\n\t\t  // 异步加载多个模块，在加载完成时，执行回调\n\t\t  require.async(['./c', './d'], function(c, d) {\n\t\t    c.doSomething();\n\t\t    d.doSomething();\n\t\t  });\n\n\t\t});\n\t```\n\n2.配置——**seajs.config**\n\n```javascript\nseajs.config({\n\n  // 设置路径，方便跨目录调用\n  paths: {\n    'arale': 'https://a.alipayobjects.com/arale',\n    'jquery': 'https://a.alipayobjects.com/jquery'\n  },\n\n  // 设置别名，方便调用\n  alias: {\n    'class': 'arale/class/1.0.0/class',\n    'jquery': 'jquery/jquery/1.10.1/jquery'\n  }\n\n});\n```\n\n3.加载模块——**seajs.use**\n\n``` javascript\n/ 加载一个模块\nseajs.use('./a');\n\n// 加载一个模块，在加载完成时，执行回调\nseajs.use('./a', function(a) {\n  a.doSomething();\n});\n\n// 加载多个模块，在加载完成时，执行回调\nseajs.use(['./a', './b'], function(a, b) {\n  a.doSomething();\n  b.doSomething();\n});\n```","slug":"seajs快速了解","published":1,"updated":"2021-12-06T06:07:06.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolp002qy4v299e8ef0m","content":"<p>&nbsp;&nbsp;&nbsp;&nbsp;SeaJS是一个遵循CommonJS规范的JavaScript模块加载框架，可以实现JavaScript的模块化开发及加载机制。与jQuery等JavaScript框架不同，SeaJS不会扩展封装语言特性，而只是实现JavaScript的模块化及按模块加载。SeaJS的主要目的是令JavaScript开发模块化并可以轻松愉悦进行加载，将前端工程师从繁重的JavaScript文件及对象依赖处理中解放出来，可以专注于代码本身的逻辑。SeaJS可以与jQuery这类框架完美集成。使用SeaJS可以提高JavaScript代码的可读性和清晰度，解决目前JavaScript编程中普遍存在的依赖关系混乱和代码纠缠等问题，方便代码的编写和维护。<br>SeaJS的作者是前淘宝UED,现支付宝前端工程师玉伯。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>SeaJS 追求简单、自然的代码书写和组织方式，具有以下核心特性：</p>\n<ul>\n<li>简单友好的模块定义规范：SeaJS 遵循CMD规范，可以像Node.js一般书写模块代码。</li>\n<li>自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>SeaJS是为了实现JavaScript的模块化的，所以在 SeaJS 中，所有 JavaScript 文件都应该用模块的形式来书写，并且一个文件只包含一个模块。它的操作也是围绕着模块来进行。</p>\n<p>1.定义模块——<strong>defined</strong></p>\n<pre><code>define(id, dependencies,function(require, exports, module) &#123;\n\n  // 模块代码\n\n&#125;);\n</code></pre>\n<ul>\n<li><p>id:当前模块的唯一标识。该参数可选。如果没有指定，默认为模块所在文件的访问路径。如果指定的话， 必须是顶级或绝对标识（不能是相对标识）。</p>\n</li>\n<li><p>dependencies:当前模块所依赖的模块，是一个由模块标识组成的数组。该参数可选。</p>\n</li>\n<li><p>fn:模块的工厂函数。模块初始化时，会调用且仅调用一次该工厂函数。</p>\n<ul>\n<li>require:用来获取指定模块的接口<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"built_in\">require</span></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 获取模块 a 的接口</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./a&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 调用模块 a 的方法</span></span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>require.async:用来在模块内部异步加载一个或多个模块。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"built_in\">require</span></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 异步加载多个模块，在加载完成时，执行回调</span></span><br><span class=\"line\">  <span class=\"built_in\">require</span>.async([<span class=\"string\">&#x27;./c&#x27;</span>, <span class=\"string\">&#x27;./d&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c, d</span>) </span>&#123;</span><br><span class=\"line\">    c.doSomething();</span><br><span class=\"line\">    d.doSomething();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>2.配置——<strong>seajs.config</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seajs.config(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置路径，方便跨目录调用</span></span><br><span class=\"line\">  <span class=\"attr\">paths</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;arale&#x27;</span>: <span class=\"string\">&#x27;https://a.alipayobjects.com/arale&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;jquery&#x27;</span>: <span class=\"string\">&#x27;https://a.alipayobjects.com/jquery&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置别名，方便调用</span></span><br><span class=\"line\">  <span class=\"attr\">alias</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;class&#x27;</span>: <span class=\"string\">&#x27;arale/class/1.0.0/class&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;jquery&#x27;</span>: <span class=\"string\">&#x27;jquery/jquery/1.10.1/jquery&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>3.加载模块——<strong>seajs.use</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/ 加载一个模块</span><br><span class=\"line\">seajs.use(<span class=\"string\">&#x27;./a&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载一个模块，在加载完成时，执行回调</span></span><br><span class=\"line\">seajs.use(<span class=\"string\">&#x27;./a&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载多个模块，在加载完成时，执行回调</span></span><br><span class=\"line\">seajs.use([<span class=\"string\">&#x27;./a&#x27;</span>, <span class=\"string\">&#x27;./b&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;&nbsp;&nbsp;SeaJS是一个遵循CommonJS规范的JavaScript模块加载框架，可以实现JavaScript的模块化开发及加载机制。与jQuery等JavaScript框架不同，SeaJS不会扩展封装语言特性，而只是实现JavaScript的模块化及按模块加载。SeaJS的主要目的是令JavaScript开发模块化并可以轻松愉悦进行加载，将前端工程师从繁重的JavaScript文件及对象依赖处理中解放出来，可以专注于代码本身的逻辑。SeaJS可以与jQuery这类框架完美集成。使用SeaJS可以提高JavaScript代码的可读性和清晰度，解决目前JavaScript编程中普遍存在的依赖关系混乱和代码纠缠等问题，方便代码的编写和维护。<br>SeaJS的作者是前淘宝UED,现支付宝前端工程师玉伯。</p>","more":"<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>SeaJS 追求简单、自然的代码书写和组织方式，具有以下核心特性：</p>\n<ul>\n<li>简单友好的模块定义规范：SeaJS 遵循CMD规范，可以像Node.js一般书写模块代码。</li>\n<li>自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>SeaJS是为了实现JavaScript的模块化的，所以在 SeaJS 中，所有 JavaScript 文件都应该用模块的形式来书写，并且一个文件只包含一个模块。它的操作也是围绕着模块来进行。</p>\n<p>1.定义模块——<strong>defined</strong></p>\n<pre><code>define(id, dependencies,function(require, exports, module) &#123;\n\n  // 模块代码\n\n&#125;);\n</code></pre>\n<ul>\n<li><p>id:当前模块的唯一标识。该参数可选。如果没有指定，默认为模块所在文件的访问路径。如果指定的话， 必须是顶级或绝对标识（不能是相对标识）。</p>\n</li>\n<li><p>dependencies:当前模块所依赖的模块，是一个由模块标识组成的数组。该参数可选。</p>\n</li>\n<li><p>fn:模块的工厂函数。模块初始化时，会调用且仅调用一次该工厂函数。</p>\n<ul>\n<li>require:用来获取指定模块的接口<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"built_in\">require</span></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 获取模块 a 的接口</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./a&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 调用模块 a 的方法</span></span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>require.async:用来在模块内部异步加载一个或多个模块。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"built_in\">require</span></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 异步加载多个模块，在加载完成时，执行回调</span></span><br><span class=\"line\">  <span class=\"built_in\">require</span>.async([<span class=\"string\">&#x27;./c&#x27;</span>, <span class=\"string\">&#x27;./d&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c, d</span>) </span>&#123;</span><br><span class=\"line\">    c.doSomething();</span><br><span class=\"line\">    d.doSomething();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>2.配置——<strong>seajs.config</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seajs.config(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置路径，方便跨目录调用</span></span><br><span class=\"line\">  <span class=\"attr\">paths</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;arale&#x27;</span>: <span class=\"string\">&#x27;https://a.alipayobjects.com/arale&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;jquery&#x27;</span>: <span class=\"string\">&#x27;https://a.alipayobjects.com/jquery&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置别名，方便调用</span></span><br><span class=\"line\">  <span class=\"attr\">alias</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;class&#x27;</span>: <span class=\"string\">&#x27;arale/class/1.0.0/class&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;jquery&#x27;</span>: <span class=\"string\">&#x27;jquery/jquery/1.10.1/jquery&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>3.加载模块——<strong>seajs.use</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/ 加载一个模块</span><br><span class=\"line\">seajs.use(<span class=\"string\">&#x27;./a&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载一个模块，在加载完成时，执行回调</span></span><br><span class=\"line\">seajs.use(<span class=\"string\">&#x27;./a&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载多个模块，在加载完成时，执行回调</span></span><br><span class=\"line\">seajs.use([<span class=\"string\">&#x27;./a&#x27;</span>, <span class=\"string\">&#x27;./b&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"_content":"# redux 初识\n\n## 前言\n\n> Redux 试图让 state 的变化变得可预测\n\nreact／react-native 将组件的更新交给了状态机（state），想要更新页面活着页面的某个组件就必须得通过改变state的方式。页面越复杂，组件越多，所需要的state就越多，并且随着页面的交互，state也需要不断得变化，而管理这些不断变化的 state 就变的非常困难。终有一刻，不计其数的 state 会让你觉得 state 的变化已然不受控制。\n\n\n> \"如果你不知道是否需要 Redux，那就是不需要它。\"\n\nRedux主要作用是让应用的 state 可以集中管理，从而达到清晰管理每个 state，所以当你的应用很简单时，完全不需要使用redux，它会增加你的工作量。\n\n## 三大原则\n\nRedux 主要是通过限制 state 更新发生的时间和方式来实现 state 的管理。而这些限制条件则反应在三大原则中：\n\n### 单一数据源\n\n整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。\n\n\n### State 只读\n\n**惟一改变 state 的方法就是触发 action。**\n\n确保视图和网络请求都不能直接修改 state，它们可以表达想要修改的意图（actio），然后通过这个触发意图（action）来修改 state。\n\n### 使用纯函数来执行修改\n\n**为了描述 action 如何改变 state tree ，你需要编写 reducers。**\n\nReducer 是纯函数，它接收先前的 state 和 action，并返回新的 state。\n\n\n## Action、Reducer 和 Store\n\n### Action\n\naction是一个普通对象，用于指明用户的操作行为，它是把数据从应用传到 store 的有效载荷，是 store 数据的唯一来源。通常将新数据（state）传入action发送给store。\n\n```\nconst EAT_APPLE = 'EAT_APPLE'\n\n{\n  type: EAT_APPLE,\n  text: 'eat an apple'\n}\n```\n这里定义了一个action对象，它有`type`和`text`俩个键，其中`type`是必需的，用于描述当前action；`text`是自定义的，作为承载数据的载体。\n\n **Action 创建函数**\n \n `Action创建函数`就是生成 action 的方法，，调用这个函数会创建action，通常只返回一个简单的action对象。它的作用主要是为了减少重复大量地创建action。\n\n ```\n function eat(text) {\n  return {\n    type: EAT_APPLE,\n    text\n  }\n }\n ```\n\n### Reducer\n\nreducer根据action操作来做出不同的数据响应，指明应用如何更新 state。它是一个纯函数，只做数据处理。\n\n```\n(previousState, action) => newState\n```\n\n它接收俩个参数：action和state，并return一个新的state。\n\n纯函数(同样的输入，必定得到同样的输出)：\n\n+ 修改传入参数；\n+ 执行有副作用的操作，如 API 请求和路由跳转；\n+ 调用非纯函数，如 Date.now() 或 Math.random()。\n\n\n```\n //使用ES6参数默认值语法初始化state\nfunction toEat(state = {behavior: \"\"}, action) {\n  if (typeof state === 'EAT_APPLE') {\n    return Object.assign({}, state,{\n    \tbehavior: action.text\n    }}\n  }\n  \n  return state；\n}\n```\n\n**注意：**\n\n+ 不要修改 state，Object.assign() 新建了一个副本\n+ 在无匹配action的情况下返回旧的 state\n\n由于redux单一数据源，所以整个应用只有一个单一的 store，所以当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。\n\nRedux 提供了一个combineReducers方法，用于 Reducer 的合并：\n\n```\ncombineReducers({reducer,...})\n\n```\n\n### Store\n\n Redux 应用只有一个单一的 store。\n \n store有以下方法：\n   \n - createStore(reducer,[preloadedState])  \n\n \t根据传入的reducer创建一个store。这个函数的第二个参数是可选的，用于设置 state 初始状态。\n \t\n - store.getState()\n\n \t获取当前state的值。\n \t\n - store.dispatch(action)\n\t\n\t向store派遣一个action。即向store传值。\n \t\n - store.subscribe(listener)\n\t\n\t注册监听器，监听store，一旦store变化，会触发listener。该函数会返回一个函数用于注销该监听器。\n\n\n### 工作流程\n\n 一个清晰明了的流程图能帮我们更好的理解：\n ![](https://raw.githubusercontent.com/bigdots/blog/master/images/201601/redux.png)\n\n从上图可以看出redux处理的是一个单向数据流：\n\n+ 用户行为或者程序调用 store.dispatch(action)，向store派遣action；\n\n+ store在接收到action后，会自动呼起reducer来处理action，并且会传入俩个参数（当前 State 和收到的 Action），这里reducer可以依据数据处理逻辑拆分成多个,但是数据源store只能是一个；\n\n+ combineReducers函数会将多个多个子 reducer 输出合并成一个单一的 state 树\n\n+ 生成新的UI\n\n\n## 总结\n1. 并不总是需要redux，如果你的应用没那么复杂，就没必要用它；\n2. redux通过限制数据更新发生的时间和方式来达到管理state的目的；\n3. redux三大原则：单一store、reducer纯函数、state只读\n4. 在 createStore 和 reducer 函数中都可以初始化state。\n5. redux通过dispatch、subscribe、getState实现数据的发送、监听、获取，从而实现单向数据流的流动\n\n\n","source":"_posts/redux初识.md","raw":"# redux 初识\n\n## 前言\n\n> Redux 试图让 state 的变化变得可预测\n\nreact／react-native 将组件的更新交给了状态机（state），想要更新页面活着页面的某个组件就必须得通过改变state的方式。页面越复杂，组件越多，所需要的state就越多，并且随着页面的交互，state也需要不断得变化，而管理这些不断变化的 state 就变的非常困难。终有一刻，不计其数的 state 会让你觉得 state 的变化已然不受控制。\n\n\n> \"如果你不知道是否需要 Redux，那就是不需要它。\"\n\nRedux主要作用是让应用的 state 可以集中管理，从而达到清晰管理每个 state，所以当你的应用很简单时，完全不需要使用redux，它会增加你的工作量。\n\n## 三大原则\n\nRedux 主要是通过限制 state 更新发生的时间和方式来实现 state 的管理。而这些限制条件则反应在三大原则中：\n\n### 单一数据源\n\n整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。\n\n\n### State 只读\n\n**惟一改变 state 的方法就是触发 action。**\n\n确保视图和网络请求都不能直接修改 state，它们可以表达想要修改的意图（actio），然后通过这个触发意图（action）来修改 state。\n\n### 使用纯函数来执行修改\n\n**为了描述 action 如何改变 state tree ，你需要编写 reducers。**\n\nReducer 是纯函数，它接收先前的 state 和 action，并返回新的 state。\n\n\n## Action、Reducer 和 Store\n\n### Action\n\naction是一个普通对象，用于指明用户的操作行为，它是把数据从应用传到 store 的有效载荷，是 store 数据的唯一来源。通常将新数据（state）传入action发送给store。\n\n```\nconst EAT_APPLE = 'EAT_APPLE'\n\n{\n  type: EAT_APPLE,\n  text: 'eat an apple'\n}\n```\n这里定义了一个action对象，它有`type`和`text`俩个键，其中`type`是必需的，用于描述当前action；`text`是自定义的，作为承载数据的载体。\n\n **Action 创建函数**\n \n `Action创建函数`就是生成 action 的方法，，调用这个函数会创建action，通常只返回一个简单的action对象。它的作用主要是为了减少重复大量地创建action。\n\n ```\n function eat(text) {\n  return {\n    type: EAT_APPLE,\n    text\n  }\n }\n ```\n\n### Reducer\n\nreducer根据action操作来做出不同的数据响应，指明应用如何更新 state。它是一个纯函数，只做数据处理。\n\n```\n(previousState, action) => newState\n```\n\n它接收俩个参数：action和state，并return一个新的state。\n\n纯函数(同样的输入，必定得到同样的输出)：\n\n+ 修改传入参数；\n+ 执行有副作用的操作，如 API 请求和路由跳转；\n+ 调用非纯函数，如 Date.now() 或 Math.random()。\n\n\n```\n //使用ES6参数默认值语法初始化state\nfunction toEat(state = {behavior: \"\"}, action) {\n  if (typeof state === 'EAT_APPLE') {\n    return Object.assign({}, state,{\n    \tbehavior: action.text\n    }}\n  }\n  \n  return state；\n}\n```\n\n**注意：**\n\n+ 不要修改 state，Object.assign() 新建了一个副本\n+ 在无匹配action的情况下返回旧的 state\n\n由于redux单一数据源，所以整个应用只有一个单一的 store，所以当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。\n\nRedux 提供了一个combineReducers方法，用于 Reducer 的合并：\n\n```\ncombineReducers({reducer,...})\n\n```\n\n### Store\n\n Redux 应用只有一个单一的 store。\n \n store有以下方法：\n   \n - createStore(reducer,[preloadedState])  \n\n \t根据传入的reducer创建一个store。这个函数的第二个参数是可选的，用于设置 state 初始状态。\n \t\n - store.getState()\n\n \t获取当前state的值。\n \t\n - store.dispatch(action)\n\t\n\t向store派遣一个action。即向store传值。\n \t\n - store.subscribe(listener)\n\t\n\t注册监听器，监听store，一旦store变化，会触发listener。该函数会返回一个函数用于注销该监听器。\n\n\n### 工作流程\n\n 一个清晰明了的流程图能帮我们更好的理解：\n ![](https://raw.githubusercontent.com/bigdots/blog/master/images/201601/redux.png)\n\n从上图可以看出redux处理的是一个单向数据流：\n\n+ 用户行为或者程序调用 store.dispatch(action)，向store派遣action；\n\n+ store在接收到action后，会自动呼起reducer来处理action，并且会传入俩个参数（当前 State 和收到的 Action），这里reducer可以依据数据处理逻辑拆分成多个,但是数据源store只能是一个；\n\n+ combineReducers函数会将多个多个子 reducer 输出合并成一个单一的 state 树\n\n+ 生成新的UI\n\n\n## 总结\n1. 并不总是需要redux，如果你的应用没那么复杂，就没必要用它；\n2. redux通过限制数据更新发生的时间和方式来达到管理state的目的；\n3. redux三大原则：单一store、reducer纯函数、state只读\n4. 在 createStore 和 reducer 函数中都可以初始化state。\n5. redux通过dispatch、subscribe、getState实现数据的发送、监听、获取，从而实现单向数据流的流动\n\n\n","slug":"redux初识","published":1,"date":"2021-12-06T06:07:06.206Z","updated":"2021-12-06T06:07:06.206Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolp002ry4v2dyt7gdw1","content":"<h1 id=\"redux-初识\"><a href=\"#redux-初识\" class=\"headerlink\" title=\"redux 初识\"></a>redux 初识</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>Redux 试图让 state 的变化变得可预测</p>\n</blockquote>\n<p>react／react-native 将组件的更新交给了状态机（state），想要更新页面活着页面的某个组件就必须得通过改变state的方式。页面越复杂，组件越多，所需要的state就越多，并且随着页面的交互，state也需要不断得变化，而管理这些不断变化的 state 就变的非常困难。终有一刻，不计其数的 state 会让你觉得 state 的变化已然不受控制。</p>\n<blockquote>\n<p>“如果你不知道是否需要 Redux，那就是不需要它。”</p>\n</blockquote>\n<p>Redux主要作用是让应用的 state 可以集中管理，从而达到清晰管理每个 state，所以当你的应用很简单时，完全不需要使用redux，它会增加你的工作量。</p>\n<h2 id=\"三大原则\"><a href=\"#三大原则\" class=\"headerlink\" title=\"三大原则\"></a>三大原则</h2><p>Redux 主要是通过限制 state 更新发生的时间和方式来实现 state 的管理。而这些限制条件则反应在三大原则中：</p>\n<h3 id=\"单一数据源\"><a href=\"#单一数据源\" class=\"headerlink\" title=\"单一数据源\"></a>单一数据源</h3><p>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</p>\n<h3 id=\"State-只读\"><a href=\"#State-只读\" class=\"headerlink\" title=\"State 只读\"></a>State 只读</h3><p><strong>惟一改变 state 的方法就是触发 action。</strong></p>\n<p>确保视图和网络请求都不能直接修改 state，它们可以表达想要修改的意图（actio），然后通过这个触发意图（action）来修改 state。</p>\n<h3 id=\"使用纯函数来执行修改\"><a href=\"#使用纯函数来执行修改\" class=\"headerlink\" title=\"使用纯函数来执行修改\"></a>使用纯函数来执行修改</h3><p><strong>为了描述 action 如何改变 state tree ，你需要编写 reducers。</strong></p>\n<p>Reducer 是纯函数，它接收先前的 state 和 action，并返回新的 state。</p>\n<h2 id=\"Action、Reducer-和-Store\"><a href=\"#Action、Reducer-和-Store\" class=\"headerlink\" title=\"Action、Reducer 和 Store\"></a>Action、Reducer 和 Store</h2><h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><p>action是一个普通对象，用于指明用户的操作行为，它是把数据从应用传到 store 的有效载荷，是 store 数据的唯一来源。通常将新数据（state）传入action发送给store。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const EAT_APPLE = &#x27;EAT_APPLE&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  type: EAT_APPLE,</span><br><span class=\"line\">  text: &#x27;eat an apple&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里定义了一个action对象，它有<code>type</code>和<code>text</code>俩个键，其中<code>type</code>是必需的，用于描述当前action；<code>text</code>是自定义的，作为承载数据的载体。</p>\n<p> <strong>Action 创建函数</strong></p>\n<p> <code>Action创建函数</code>就是生成 action 的方法，，调用这个函数会创建action，通常只返回一个简单的action对象。它的作用主要是为了减少重复大量地创建action。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function eat(text) &#123;</span><br><span class=\"line\"> return &#123;</span><br><span class=\"line\">   type: EAT_APPLE,</span><br><span class=\"line\">   text</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h3><p>reducer根据action操作来做出不同的数据响应，指明应用如何更新 state。它是一个纯函数，只做数据处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(previousState, action) =&gt; newState</span><br></pre></td></tr></table></figure>\n\n<p>它接收俩个参数：action和state，并return一个新的state。</p>\n<p>纯函数(同样的输入，必定得到同样的输出)：</p>\n<ul>\n<li>修改传入参数；</li>\n<li>执行有副作用的操作，如 API 请求和路由跳转；</li>\n<li>调用非纯函数，如 Date.now() 或 Math.random()。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> //使用ES6参数默认值语法初始化state</span><br><span class=\"line\">function toEat(state = &#123;behavior: &quot;&quot;&#125;, action) &#123;</span><br><span class=\"line\">  if (typeof state === &#x27;EAT_APPLE&#x27;) &#123;</span><br><span class=\"line\">    return Object.assign(&#123;&#125;, state,&#123;</span><br><span class=\"line\">    \tbehavior: action.text</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  return state；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>不要修改 state，Object.assign() 新建了一个副本</li>\n<li>在无匹配action的情况下返回旧的 state</li>\n</ul>\n<p>由于redux单一数据源，所以整个应用只有一个单一的 store，所以当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。</p>\n<p>Redux 提供了一个combineReducers方法，用于 Reducer 的合并：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">combineReducers(&#123;reducer,...&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h3><p> Redux 应用只有一个单一的 store。</p>\n<p> store有以下方法：</p>\n<ul>\n<li><p>createStore(reducer,[preloadedState])  </p>\n<p>  根据传入的reducer创建一个store。这个函数的第二个参数是可选的，用于设置 state 初始状态。</p>\n</li>\n<li><p>store.getState()</p>\n<p>  获取当前state的值。</p>\n</li>\n<li><p>store.dispatch(action)</p>\n<p> 向store派遣一个action。即向store传值。</p>\n</li>\n<li><p>store.subscribe(listener)</p>\n<p> 注册监听器，监听store，一旦store变化，会触发listener。该函数会返回一个函数用于注销该监听器。</p>\n</li>\n</ul>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><p> 一个清晰明了的流程图能帮我们更好的理解：<br> <img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201601/redux.png\"></p>\n<p>从上图可以看出redux处理的是一个单向数据流：</p>\n<ul>\n<li><p>用户行为或者程序调用 store.dispatch(action)，向store派遣action；</p>\n</li>\n<li><p>store在接收到action后，会自动呼起reducer来处理action，并且会传入俩个参数（当前 State 和收到的 Action），这里reducer可以依据数据处理逻辑拆分成多个,但是数据源store只能是一个；</p>\n</li>\n<li><p>combineReducers函数会将多个多个子 reducer 输出合并成一个单一的 state 树</p>\n</li>\n<li><p>生成新的UI</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>并不总是需要redux，如果你的应用没那么复杂，就没必要用它；</li>\n<li>redux通过限制数据更新发生的时间和方式来达到管理state的目的；</li>\n<li>redux三大原则：单一store、reducer纯函数、state只读</li>\n<li>在 createStore 和 reducer 函数中都可以初始化state。</li>\n<li>redux通过dispatch、subscribe、getState实现数据的发送、监听、获取，从而实现单向数据流的流动</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"redux-初识\"><a href=\"#redux-初识\" class=\"headerlink\" title=\"redux 初识\"></a>redux 初识</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>Redux 试图让 state 的变化变得可预测</p>\n</blockquote>\n<p>react／react-native 将组件的更新交给了状态机（state），想要更新页面活着页面的某个组件就必须得通过改变state的方式。页面越复杂，组件越多，所需要的state就越多，并且随着页面的交互，state也需要不断得变化，而管理这些不断变化的 state 就变的非常困难。终有一刻，不计其数的 state 会让你觉得 state 的变化已然不受控制。</p>\n<blockquote>\n<p>“如果你不知道是否需要 Redux，那就是不需要它。”</p>\n</blockquote>\n<p>Redux主要作用是让应用的 state 可以集中管理，从而达到清晰管理每个 state，所以当你的应用很简单时，完全不需要使用redux，它会增加你的工作量。</p>\n<h2 id=\"三大原则\"><a href=\"#三大原则\" class=\"headerlink\" title=\"三大原则\"></a>三大原则</h2><p>Redux 主要是通过限制 state 更新发生的时间和方式来实现 state 的管理。而这些限制条件则反应在三大原则中：</p>\n<h3 id=\"单一数据源\"><a href=\"#单一数据源\" class=\"headerlink\" title=\"单一数据源\"></a>单一数据源</h3><p>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</p>\n<h3 id=\"State-只读\"><a href=\"#State-只读\" class=\"headerlink\" title=\"State 只读\"></a>State 只读</h3><p><strong>惟一改变 state 的方法就是触发 action。</strong></p>\n<p>确保视图和网络请求都不能直接修改 state，它们可以表达想要修改的意图（actio），然后通过这个触发意图（action）来修改 state。</p>\n<h3 id=\"使用纯函数来执行修改\"><a href=\"#使用纯函数来执行修改\" class=\"headerlink\" title=\"使用纯函数来执行修改\"></a>使用纯函数来执行修改</h3><p><strong>为了描述 action 如何改变 state tree ，你需要编写 reducers。</strong></p>\n<p>Reducer 是纯函数，它接收先前的 state 和 action，并返回新的 state。</p>\n<h2 id=\"Action、Reducer-和-Store\"><a href=\"#Action、Reducer-和-Store\" class=\"headerlink\" title=\"Action、Reducer 和 Store\"></a>Action、Reducer 和 Store</h2><h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><p>action是一个普通对象，用于指明用户的操作行为，它是把数据从应用传到 store 的有效载荷，是 store 数据的唯一来源。通常将新数据（state）传入action发送给store。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const EAT_APPLE = &#x27;EAT_APPLE&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  type: EAT_APPLE,</span><br><span class=\"line\">  text: &#x27;eat an apple&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里定义了一个action对象，它有<code>type</code>和<code>text</code>俩个键，其中<code>type</code>是必需的，用于描述当前action；<code>text</code>是自定义的，作为承载数据的载体。</p>\n<p> <strong>Action 创建函数</strong></p>\n<p> <code>Action创建函数</code>就是生成 action 的方法，，调用这个函数会创建action，通常只返回一个简单的action对象。它的作用主要是为了减少重复大量地创建action。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function eat(text) &#123;</span><br><span class=\"line\"> return &#123;</span><br><span class=\"line\">   type: EAT_APPLE,</span><br><span class=\"line\">   text</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h3><p>reducer根据action操作来做出不同的数据响应，指明应用如何更新 state。它是一个纯函数，只做数据处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(previousState, action) =&gt; newState</span><br></pre></td></tr></table></figure>\n\n<p>它接收俩个参数：action和state，并return一个新的state。</p>\n<p>纯函数(同样的输入，必定得到同样的输出)：</p>\n<ul>\n<li>修改传入参数；</li>\n<li>执行有副作用的操作，如 API 请求和路由跳转；</li>\n<li>调用非纯函数，如 Date.now() 或 Math.random()。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> //使用ES6参数默认值语法初始化state</span><br><span class=\"line\">function toEat(state = &#123;behavior: &quot;&quot;&#125;, action) &#123;</span><br><span class=\"line\">  if (typeof state === &#x27;EAT_APPLE&#x27;) &#123;</span><br><span class=\"line\">    return Object.assign(&#123;&#125;, state,&#123;</span><br><span class=\"line\">    \tbehavior: action.text</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  return state；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>不要修改 state，Object.assign() 新建了一个副本</li>\n<li>在无匹配action的情况下返回旧的 state</li>\n</ul>\n<p>由于redux单一数据源，所以整个应用只有一个单一的 store，所以当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。</p>\n<p>Redux 提供了一个combineReducers方法，用于 Reducer 的合并：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">combineReducers(&#123;reducer,...&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h3><p> Redux 应用只有一个单一的 store。</p>\n<p> store有以下方法：</p>\n<ul>\n<li><p>createStore(reducer,[preloadedState])  </p>\n<p>  根据传入的reducer创建一个store。这个函数的第二个参数是可选的，用于设置 state 初始状态。</p>\n</li>\n<li><p>store.getState()</p>\n<p>  获取当前state的值。</p>\n</li>\n<li><p>store.dispatch(action)</p>\n<p> 向store派遣一个action。即向store传值。</p>\n</li>\n<li><p>store.subscribe(listener)</p>\n<p> 注册监听器，监听store，一旦store变化，会触发listener。该函数会返回一个函数用于注销该监听器。</p>\n</li>\n</ul>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><p> 一个清晰明了的流程图能帮我们更好的理解：<br> <img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201601/redux.png\"></p>\n<p>从上图可以看出redux处理的是一个单向数据流：</p>\n<ul>\n<li><p>用户行为或者程序调用 store.dispatch(action)，向store派遣action；</p>\n</li>\n<li><p>store在接收到action后，会自动呼起reducer来处理action，并且会传入俩个参数（当前 State 和收到的 Action），这里reducer可以依据数据处理逻辑拆分成多个,但是数据源store只能是一个；</p>\n</li>\n<li><p>combineReducers函数会将多个多个子 reducer 输出合并成一个单一的 state 树</p>\n</li>\n<li><p>生成新的UI</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>并不总是需要redux，如果你的应用没那么复杂，就没必要用它；</li>\n<li>redux通过限制数据更新发生的时间和方式来达到管理state的目的；</li>\n<li>redux三大原则：单一store、reducer纯函数、state只读</li>\n<li>在 createStore 和 reducer 函数中都可以初始化state。</li>\n<li>redux通过dispatch、subscribe、getState实现数据的发送、监听、获取，从而实现单向数据流的流动</li>\n</ol>\n"},{"title":"rem在响应式布局中的应用","date":"2016-03-30T02:33:44.000Z","description":"rem在响应式布局中的应用","_content":"\n## rem/em/px/pt的基友关系\n**px**\n像素相对长度单位,相对于显示器屏幕分辨率而言\n\n<!-- more -->\n\n**em**\n相对长度单位,根据其父元素来设置字体大小\n\n**pt**\npoint，是印刷行业常用单位，等于1/72英寸\n\n**rem**\nCSS3新增的一个相对单位,是根据网页的跟元素（html）来设置字体大小\n\n\n## rem应用于适配\nrem的特性同样适用于width和height，我们可以根据根元素的font-size值来改变元素的宽高值，由此我们应该可以联想到我们可以根据屏幕大小动态地给html设定不同的值，从而达到我们css样式中的适配效果。\n\n## rem的适配规则\n\n**1.选择基准**\n虽然我们所写出的页面要在不同的屏幕大小设备上运行，但是我们写页面的时候，必须要选择其中一种屏幕大小作为初始的基准，而这个基准的选择应该根据我们所拿到的视觉稿来决定，\n\n**2.rem数值计算**\n正常情况下rem的值默认为16px，这样在整个页面的css计算过程中太过繁琐。比如，现在有个30px宽度的元素，就得写成30/16rem。对于整个页面来说工作量还是挺大的。所以这里提供了俩种方法\n\n+ 可以将html的font-size设置成100px\n这样设置，在写单位时直接将数值除以100在加上rem的单位就可以了。如果设计稿的字体是16px；我们就可以写成1.6rem。\n    + **这里为什么不用10？**\n    因为google等浏览器对最小字体有限制，即最小为12px，所以设置10px会有问题。\n\n+ 使用sass\n```sass\n$rem : 16x;\n@function px_rem($px){\n    @return ($px/$rem) + rem;\n}\n```\n\n**3.动态设置html的font-size**\n随着屏幕大小的改变，html的font-size的值应该是`基准rem*改变后的屏幕宽度 / 基准屏幕宽度`\n\n\n+ 利用css的media query来设置（这种是一个宽度区间内是一个rem）\n```\n@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2){\n      $rem : 16x;\n}\n```\n+ 利用javascript来动态设置（这种方法每一个宽度点都会有一个新的rem）\n```js\ndocument.getElementsByTagName('html')[0].style.fontSize = 基准rem*window.innerWidth / 基准屏幕宽度 + 'px';\n```\n\n## 考虑dpr\n一般我们获取到的视觉稿大部分尺寸是双倍大小的，我们一般会自觉的将标注/2，但是当我们配合rem使用时，完全可以按照视觉稿上的尺寸来设置。\n\n+ 设计给的稿子双倍的原因是iphone等高清屏手机的存在，高清屏的像素比(device pixel ratio)dpr比较大，所以显示的像素较为清晰。\n\n+ 一般手机的dpr是1，iphone4，iphone5这种高清屏是2，iphone6s plus这种高清屏是3，可以通过js的window.devicePixelRatio获取到当前设备的dpr，所以iphone6给的视觉稿大小是（*2）750×1334了。\n\n+ 拿到了dpr之后，我们就可以在viewport meta头里，取消让浏览器自动缩放页面，而自己去设置viewport的content\n```js\nmeta.setAttribute('content', 'initial-scale=' + 1/dpr + ', maximum-scale=' + 1/dpr + ', minimum-scale=' + 1/dpr + ', user-scalable=no');\n```\n这样我们就直接可以使用视觉稿上的尺寸了。\n\n[点击查看示例>>](http://bigdots.github.io/blogSource/example/rem.html)\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/rem在响应式布局中的应用.md","raw":"title: rem在响应式布局中的应用\ntags: [web]\ndate: 2016-03-30 10:33:44\ndescription: rem在响应式布局中的应用\n---\n\n## rem/em/px/pt的基友关系\n**px**\n像素相对长度单位,相对于显示器屏幕分辨率而言\n\n<!-- more -->\n\n**em**\n相对长度单位,根据其父元素来设置字体大小\n\n**pt**\npoint，是印刷行业常用单位，等于1/72英寸\n\n**rem**\nCSS3新增的一个相对单位,是根据网页的跟元素（html）来设置字体大小\n\n\n## rem应用于适配\nrem的特性同样适用于width和height，我们可以根据根元素的font-size值来改变元素的宽高值，由此我们应该可以联想到我们可以根据屏幕大小动态地给html设定不同的值，从而达到我们css样式中的适配效果。\n\n## rem的适配规则\n\n**1.选择基准**\n虽然我们所写出的页面要在不同的屏幕大小设备上运行，但是我们写页面的时候，必须要选择其中一种屏幕大小作为初始的基准，而这个基准的选择应该根据我们所拿到的视觉稿来决定，\n\n**2.rem数值计算**\n正常情况下rem的值默认为16px，这样在整个页面的css计算过程中太过繁琐。比如，现在有个30px宽度的元素，就得写成30/16rem。对于整个页面来说工作量还是挺大的。所以这里提供了俩种方法\n\n+ 可以将html的font-size设置成100px\n这样设置，在写单位时直接将数值除以100在加上rem的单位就可以了。如果设计稿的字体是16px；我们就可以写成1.6rem。\n    + **这里为什么不用10？**\n    因为google等浏览器对最小字体有限制，即最小为12px，所以设置10px会有问题。\n\n+ 使用sass\n```sass\n$rem : 16x;\n@function px_rem($px){\n    @return ($px/$rem) + rem;\n}\n```\n\n**3.动态设置html的font-size**\n随着屏幕大小的改变，html的font-size的值应该是`基准rem*改变后的屏幕宽度 / 基准屏幕宽度`\n\n\n+ 利用css的media query来设置（这种是一个宽度区间内是一个rem）\n```\n@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2){\n      $rem : 16x;\n}\n```\n+ 利用javascript来动态设置（这种方法每一个宽度点都会有一个新的rem）\n```js\ndocument.getElementsByTagName('html')[0].style.fontSize = 基准rem*window.innerWidth / 基准屏幕宽度 + 'px';\n```\n\n## 考虑dpr\n一般我们获取到的视觉稿大部分尺寸是双倍大小的，我们一般会自觉的将标注/2，但是当我们配合rem使用时，完全可以按照视觉稿上的尺寸来设置。\n\n+ 设计给的稿子双倍的原因是iphone等高清屏手机的存在，高清屏的像素比(device pixel ratio)dpr比较大，所以显示的像素较为清晰。\n\n+ 一般手机的dpr是1，iphone4，iphone5这种高清屏是2，iphone6s plus这种高清屏是3，可以通过js的window.devicePixelRatio获取到当前设备的dpr，所以iphone6给的视觉稿大小是（*2）750×1334了。\n\n+ 拿到了dpr之后，我们就可以在viewport meta头里，取消让浏览器自动缩放页面，而自己去设置viewport的content\n```js\nmeta.setAttribute('content', 'initial-scale=' + 1/dpr + ', maximum-scale=' + 1/dpr + ', minimum-scale=' + 1/dpr + ', user-scalable=no');\n```\n这样我们就直接可以使用视觉稿上的尺寸了。\n\n[点击查看示例>>](http://bigdots.github.io/blogSource/example/rem.html)\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"rem在响应式布局中的应用","published":1,"updated":"2021-12-06T06:07:06.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolq002ty4v257pbgbkw","content":"<h2 id=\"rem-em-px-pt的基友关系\"><a href=\"#rem-em-px-pt的基友关系\" class=\"headerlink\" title=\"rem/em/px/pt的基友关系\"></a>rem/em/px/pt的基友关系</h2><p><strong>px</strong><br>像素相对长度单位,相对于显示器屏幕分辨率而言</p>\n<span id=\"more\"></span>\n\n<p><strong>em</strong><br>相对长度单位,根据其父元素来设置字体大小</p>\n<p><strong>pt</strong><br>point，是印刷行业常用单位，等于1/72英寸</p>\n<p><strong>rem</strong><br>CSS3新增的一个相对单位,是根据网页的跟元素（html）来设置字体大小</p>\n<h2 id=\"rem应用于适配\"><a href=\"#rem应用于适配\" class=\"headerlink\" title=\"rem应用于适配\"></a>rem应用于适配</h2><p>rem的特性同样适用于width和height，我们可以根据根元素的font-size值来改变元素的宽高值，由此我们应该可以联想到我们可以根据屏幕大小动态地给html设定不同的值，从而达到我们css样式中的适配效果。</p>\n<h2 id=\"rem的适配规则\"><a href=\"#rem的适配规则\" class=\"headerlink\" title=\"rem的适配规则\"></a>rem的适配规则</h2><p><strong>1.选择基准</strong><br>虽然我们所写出的页面要在不同的屏幕大小设备上运行，但是我们写页面的时候，必须要选择其中一种屏幕大小作为初始的基准，而这个基准的选择应该根据我们所拿到的视觉稿来决定，</p>\n<p><strong>2.rem数值计算</strong><br>正常情况下rem的值默认为16px，这样在整个页面的css计算过程中太过繁琐。比如，现在有个30px宽度的元素，就得写成30/16rem。对于整个页面来说工作量还是挺大的。所以这里提供了俩种方法</p>\n<ul>\n<li><p>可以将html的font-size设置成100px<br>这样设置，在写单位时直接将数值除以100在加上rem的单位就可以了。如果设计稿的字体是16px；我们就可以写成1.6rem。</p>\n<ul>\n<li><strong>这里为什么不用10？</strong><br>因为google等浏览器对最小字体有限制，即最小为12px，所以设置10px会有问题。</li>\n</ul>\n</li>\n<li><p>使用sass</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$rem : 16x;</span><br><span class=\"line\">@function px_rem($px)&#123;</span><br><span class=\"line\">    @return ($px/$rem) + rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>3.动态设置html的font-size</strong><br>随着屏幕大小的改变，html的font-size的值应该是<code>基准rem*改变后的屏幕宽度 / 基准屏幕宽度</code></p>\n<ul>\n<li>利用css的media query来设置（这种是一个宽度区间内是一个rem）<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2)&#123;</span><br><span class=\"line\">      $rem : 16x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>利用javascript来动态设置（这种方法每一个宽度点都会有一个新的rem）<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&#x27;html&#x27;</span>)[<span class=\"number\">0</span>].style.fontSize = 基准rem*<span class=\"built_in\">window</span>.innerWidth / 基准屏幕宽度 + <span class=\"string\">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"考虑dpr\"><a href=\"#考虑dpr\" class=\"headerlink\" title=\"考虑dpr\"></a>考虑dpr</h2><p>一般我们获取到的视觉稿大部分尺寸是双倍大小的，我们一般会自觉的将标注/2，但是当我们配合rem使用时，完全可以按照视觉稿上的尺寸来设置。</p>\n<ul>\n<li><p>设计给的稿子双倍的原因是iphone等高清屏手机的存在，高清屏的像素比(device pixel ratio)dpr比较大，所以显示的像素较为清晰。</p>\n</li>\n<li><p>一般手机的dpr是1，iphone4，iphone5这种高清屏是2，iphone6s plus这种高清屏是3，可以通过js的window.devicePixelRatio获取到当前设备的dpr，所以iphone6给的视觉稿大小是（*2）750×1334了。</p>\n</li>\n<li><p>拿到了dpr之后，我们就可以在viewport meta头里，取消让浏览器自动缩放页面，而自己去设置viewport的content</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meta.setAttribute(<span class=\"string\">&#x27;content&#x27;</span>, <span class=\"string\">&#x27;initial-scale=&#x27;</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">&#x27;, maximum-scale=&#x27;</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">&#x27;, minimum-scale=&#x27;</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">&#x27;, user-scalable=no&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>这样我们就直接可以使用视觉稿上的尺寸了。</p>\n</li>\n</ul>\n<p><a href=\"http://bigdots.github.io/blogSource/example/rem.html\">点击查看示例&gt;&gt;</a></p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"rem-em-px-pt的基友关系\"><a href=\"#rem-em-px-pt的基友关系\" class=\"headerlink\" title=\"rem/em/px/pt的基友关系\"></a>rem/em/px/pt的基友关系</h2><p><strong>px</strong><br>像素相对长度单位,相对于显示器屏幕分辨率而言</p>","more":"<p><strong>em</strong><br>相对长度单位,根据其父元素来设置字体大小</p>\n<p><strong>pt</strong><br>point，是印刷行业常用单位，等于1/72英寸</p>\n<p><strong>rem</strong><br>CSS3新增的一个相对单位,是根据网页的跟元素（html）来设置字体大小</p>\n<h2 id=\"rem应用于适配\"><a href=\"#rem应用于适配\" class=\"headerlink\" title=\"rem应用于适配\"></a>rem应用于适配</h2><p>rem的特性同样适用于width和height，我们可以根据根元素的font-size值来改变元素的宽高值，由此我们应该可以联想到我们可以根据屏幕大小动态地给html设定不同的值，从而达到我们css样式中的适配效果。</p>\n<h2 id=\"rem的适配规则\"><a href=\"#rem的适配规则\" class=\"headerlink\" title=\"rem的适配规则\"></a>rem的适配规则</h2><p><strong>1.选择基准</strong><br>虽然我们所写出的页面要在不同的屏幕大小设备上运行，但是我们写页面的时候，必须要选择其中一种屏幕大小作为初始的基准，而这个基准的选择应该根据我们所拿到的视觉稿来决定，</p>\n<p><strong>2.rem数值计算</strong><br>正常情况下rem的值默认为16px，这样在整个页面的css计算过程中太过繁琐。比如，现在有个30px宽度的元素，就得写成30/16rem。对于整个页面来说工作量还是挺大的。所以这里提供了俩种方法</p>\n<ul>\n<li><p>可以将html的font-size设置成100px<br>这样设置，在写单位时直接将数值除以100在加上rem的单位就可以了。如果设计稿的字体是16px；我们就可以写成1.6rem。</p>\n<ul>\n<li><strong>这里为什么不用10？</strong><br>因为google等浏览器对最小字体有限制，即最小为12px，所以设置10px会有问题。</li>\n</ul>\n</li>\n<li><p>使用sass</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$rem : 16x;</span><br><span class=\"line\">@function px_rem($px)&#123;</span><br><span class=\"line\">    @return ($px/$rem) + rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>3.动态设置html的font-size</strong><br>随着屏幕大小的改变，html的font-size的值应该是<code>基准rem*改变后的屏幕宽度 / 基准屏幕宽度</code></p>\n<ul>\n<li>利用css的media query来设置（这种是一个宽度区间内是一个rem）<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2)&#123;</span><br><span class=\"line\">      $rem : 16x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>利用javascript来动态设置（这种方法每一个宽度点都会有一个新的rem）<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&#x27;html&#x27;</span>)[<span class=\"number\">0</span>].style.fontSize = 基准rem*<span class=\"built_in\">window</span>.innerWidth / 基准屏幕宽度 + <span class=\"string\">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"考虑dpr\"><a href=\"#考虑dpr\" class=\"headerlink\" title=\"考虑dpr\"></a>考虑dpr</h2><p>一般我们获取到的视觉稿大部分尺寸是双倍大小的，我们一般会自觉的将标注/2，但是当我们配合rem使用时，完全可以按照视觉稿上的尺寸来设置。</p>\n<ul>\n<li><p>设计给的稿子双倍的原因是iphone等高清屏手机的存在，高清屏的像素比(device pixel ratio)dpr比较大，所以显示的像素较为清晰。</p>\n</li>\n<li><p>一般手机的dpr是1，iphone4，iphone5这种高清屏是2，iphone6s plus这种高清屏是3，可以通过js的window.devicePixelRatio获取到当前设备的dpr，所以iphone6给的视觉稿大小是（*2）750×1334了。</p>\n</li>\n<li><p>拿到了dpr之后，我们就可以在viewport meta头里，取消让浏览器自动缩放页面，而自己去设置viewport的content</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meta.setAttribute(<span class=\"string\">&#x27;content&#x27;</span>, <span class=\"string\">&#x27;initial-scale=&#x27;</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">&#x27;, maximum-scale=&#x27;</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">&#x27;, minimum-scale=&#x27;</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">&#x27;, user-scalable=no&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>这样我们就直接可以使用视觉稿上的尺寸了。</p>\n</li>\n</ul>\n<p><a href=\"http://bigdots.github.io/blogSource/example/rem.html\">点击查看示例&gt;&gt;</a></p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"_content":"# return、break和continue\n\n## return\n\n结束函数\n\n## break\n\n退出整个循环，**终止**循环\n\n## continue\n\n退出本次循环，**中止**循环","source":"_posts/return、break和continue.md","raw":"# return、break和continue\n\n## return\n\n结束函数\n\n## break\n\n退出整个循环，**终止**循环\n\n## continue\n\n退出本次循环，**中止**循环","slug":"return、break和continue","published":1,"date":"2021-12-06T06:07:06.221Z","updated":"2021-12-06T06:07:06.221Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolr002uy4v23lf66jcc","content":"<h1 id=\"return、break和continue\"><a href=\"#return、break和continue\" class=\"headerlink\" title=\"return、break和continue\"></a>return、break和continue</h1><h2 id=\"return\"><a href=\"#return\" class=\"headerlink\" title=\"return\"></a>return</h2><p>结束函数</p>\n<h2 id=\"break\"><a href=\"#break\" class=\"headerlink\" title=\"break\"></a>break</h2><p>退出整个循环，<strong>终止</strong>循环</p>\n<h2 id=\"continue\"><a href=\"#continue\" class=\"headerlink\" title=\"continue\"></a>continue</h2><p>退出本次循环，<strong>中止</strong>循环</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"return、break和continue\"><a href=\"#return、break和continue\" class=\"headerlink\" title=\"return、break和continue\"></a>return、break和continue</h1><h2 id=\"return\"><a href=\"#return\" class=\"headerlink\" title=\"return\"></a>return</h2><p>结束函数</p>\n<h2 id=\"break\"><a href=\"#break\" class=\"headerlink\" title=\"break\"></a>break</h2><p>退出整个循环，<strong>终止</strong>循环</p>\n<h2 id=\"continue\"><a href=\"#continue\" class=\"headerlink\" title=\"continue\"></a>continue</h2><p>退出本次循环，<strong>中止</strong>循环</p>\n"},{"title":"sublimetext Emmet插件的使用","date":"2015-05-06T14:53:00.000Z","description":null,"_content":"\n### 1. 省略div，插件会默认元素为div\n\n.container\n\n\t<div class=\"container\"></div>\n\n### 2. 含糊标签名称,不需要指定。比如li，Emmet会自动帮助你生成 \n ul>.lis\n\n\t<ul>\n\t<li class=\"lis\"></li>\n\t</ul>\n\n<!-- more -->\n\n### 3.链式缩写 \n\n① > :添加创建子元素\ndiv>span \n\n\t<div><span></span></div>\n\n② + :添加创建同层级元素\n\ndiv+span\n\n\t<div></div>\n\t<span></span>\n③ ^ :添加一个父层级元素（需要的话你可以向上多层）\n\n p>a^p \n\n\t<p><a href=\"\"></a></p>\n\t<p></p>\n \n\n\n### 4.分组功能；\n (.one>h1)+(.two>h1) \n\n\n\t<div class=\"one\">\n\t<h1></h1>\n\t</div>\n\t<div class=\"two\">\n\t<h1></h1>\n\t</div>\n\n### 5.插入文本{}和属性[]；\n\nh1{heading}\n\n\t<h1>heading</h1>\n\t a[href='#'] \n\n\t<a href=\"#\"></a>\n### 6.添加多个class；\n\n .one.two.three\n\n\t<div class=\"one two three\"></div>\n### 7.添加多个元素\n ul>li*5 \n\n\n\t<ul>\n\t<li></li>\n\t<li></li>\n\t<li></li>\n\t<li></li>\n\t<li></li>\n\t</ul>\n\n### 8.自动列表计数\n\n 按顺序生成HTML元素，使用 ``$``符号可以帮助生成一系列数字，支持class，id，属性，内容等等。\n(生成n位的数字，使用n个``$``符号)\nul>li.list``$``{number``$``}*5\n\n\n\t<ul>\n\t<li class=\"list1\">number 1</li>\n\t<li class=\"list2\">number 2</li>\n\t<li class=\"list3\">number 3</li>\n\t<li class=\"list4\">number 4</li>\n\t<li class=\"list5\">number 5</li>\n\t</ul>\n\nul>li$.number``$$``*5 \n\n\n\t<ul>\n\t<li1 class=\"number01\"></li1>\n\t<li2 class=\"number02\"></li2>\n\t<li3 class=\"number03\"></li3>\n\t<li4 class=\"number04\"></li4>\n\t<li5 class=\"number05\"></li5>\n\t</ul>\n\n---\n<p style=\"text-align:right\">整理于2015-11-30 16:31:18</p>","source":"_posts/sublimetext-Emmet插件的使用.md","raw":"title: sublimetext Emmet插件的使用\ndate: 2015-05-06 22:53:0\ntags: [web,工具]\ndescription:\n\n---\n\n### 1. 省略div，插件会默认元素为div\n\n.container\n\n\t<div class=\"container\"></div>\n\n### 2. 含糊标签名称,不需要指定。比如li，Emmet会自动帮助你生成 \n ul>.lis\n\n\t<ul>\n\t<li class=\"lis\"></li>\n\t</ul>\n\n<!-- more -->\n\n### 3.链式缩写 \n\n① > :添加创建子元素\ndiv>span \n\n\t<div><span></span></div>\n\n② + :添加创建同层级元素\n\ndiv+span\n\n\t<div></div>\n\t<span></span>\n③ ^ :添加一个父层级元素（需要的话你可以向上多层）\n\n p>a^p \n\n\t<p><a href=\"\"></a></p>\n\t<p></p>\n \n\n\n### 4.分组功能；\n (.one>h1)+(.two>h1) \n\n\n\t<div class=\"one\">\n\t<h1></h1>\n\t</div>\n\t<div class=\"two\">\n\t<h1></h1>\n\t</div>\n\n### 5.插入文本{}和属性[]；\n\nh1{heading}\n\n\t<h1>heading</h1>\n\t a[href='#'] \n\n\t<a href=\"#\"></a>\n### 6.添加多个class；\n\n .one.two.three\n\n\t<div class=\"one two three\"></div>\n### 7.添加多个元素\n ul>li*5 \n\n\n\t<ul>\n\t<li></li>\n\t<li></li>\n\t<li></li>\n\t<li></li>\n\t<li></li>\n\t</ul>\n\n### 8.自动列表计数\n\n 按顺序生成HTML元素，使用 ``$``符号可以帮助生成一系列数字，支持class，id，属性，内容等等。\n(生成n位的数字，使用n个``$``符号)\nul>li.list``$``{number``$``}*5\n\n\n\t<ul>\n\t<li class=\"list1\">number 1</li>\n\t<li class=\"list2\">number 2</li>\n\t<li class=\"list3\">number 3</li>\n\t<li class=\"list4\">number 4</li>\n\t<li class=\"list5\">number 5</li>\n\t</ul>\n\nul>li$.number``$$``*5 \n\n\n\t<ul>\n\t<li1 class=\"number01\"></li1>\n\t<li2 class=\"number02\"></li2>\n\t<li3 class=\"number03\"></li3>\n\t<li4 class=\"number04\"></li4>\n\t<li5 class=\"number05\"></li5>\n\t</ul>\n\n---\n<p style=\"text-align:right\">整理于2015-11-30 16:31:18</p>","slug":"sublimetext-Emmet插件的使用","published":1,"updated":"2021-12-06T06:07:06.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwols002wy4v2g6yq1b5j","content":"<h3 id=\"1-省略div，插件会默认元素为div\"><a href=\"#1-省略div，插件会默认元素为div\" class=\"headerlink\" title=\"1. 省略div，插件会默认元素为div\"></a>1. 省略div，插件会默认元素为div</h3><p>.container</p>\n<pre><code>&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id=\"2-含糊标签名称-不需要指定。比如li，Emmet会自动帮助你生成\"><a href=\"#2-含糊标签名称-不需要指定。比如li，Emmet会自动帮助你生成\" class=\"headerlink\" title=\"2. 含糊标签名称,不需要指定。比如li，Emmet会自动帮助你生成\"></a>2. 含糊标签名称,不需要指定。比如li，Emmet会自动帮助你生成</h3><p> ul&gt;.lis</p>\n<pre><code>&lt;ul&gt;\n&lt;li class=&quot;lis&quot;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<span id=\"more\"></span>\n\n<h3 id=\"3-链式缩写\"><a href=\"#3-链式缩写\" class=\"headerlink\" title=\"3.链式缩写\"></a>3.链式缩写</h3><p>① &gt; :添加创建子元素<br>div&gt;span </p>\n<pre><code>&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;\n</code></pre>\n<p>② + :添加创建同层级元素</p>\n<p>div+span</p>\n<pre><code>&lt;div&gt;&lt;/div&gt;\n&lt;span&gt;&lt;/span&gt;\n</code></pre>\n<p>③ ^ :添加一个父层级元素（需要的话你可以向上多层）</p>\n<p> p&gt;a^p </p>\n<pre><code>&lt;p&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;\n</code></pre>\n<h3 id=\"4-分组功能；\"><a href=\"#4-分组功能；\" class=\"headerlink\" title=\"4.分组功能；\"></a>4.分组功能；</h3><p> (.one&gt;h1)+(.two&gt;h1) </p>\n<pre><code>&lt;div class=&quot;one&quot;&gt;\n&lt;h1&gt;&lt;/h1&gt;\n&lt;/div&gt;\n&lt;div class=&quot;two&quot;&gt;\n&lt;h1&gt;&lt;/h1&gt;\n&lt;/div&gt;\n</code></pre>\n<h3 id=\"5-插入文本-和属性-；\"><a href=\"#5-插入文本-和属性-；\" class=\"headerlink\" title=\"5.插入文本{}和属性[]；\"></a>5.插入文本{}和属性[]；</h3><p>h1{heading}</p>\n<pre><code>&lt;h1&gt;heading&lt;/h1&gt;\n a[href=&#39;#&#39;] \n\n&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;\n</code></pre>\n<h3 id=\"6-添加多个class；\"><a href=\"#6-添加多个class；\" class=\"headerlink\" title=\"6.添加多个class；\"></a>6.添加多个class；</h3><p> .one.two.three</p>\n<pre><code>&lt;div class=&quot;one two three&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id=\"7-添加多个元素\"><a href=\"#7-添加多个元素\" class=\"headerlink\" title=\"7.添加多个元素\"></a>7.添加多个元素</h3><p> ul&gt;li*5 </p>\n<pre><code>&lt;ul&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h3 id=\"8-自动列表计数\"><a href=\"#8-自动列表计数\" class=\"headerlink\" title=\"8.自动列表计数\"></a>8.自动列表计数</h3><p> 按顺序生成HTML元素，使用 <code>$</code>符号可以帮助生成一系列数字，支持class，id，属性，内容等等。<br>(生成n位的数字，使用n个<code>$</code>符号)<br>ul&gt;li.list<code>$</code>{number<code>$</code>}*5</p>\n<pre><code>&lt;ul&gt;\n&lt;li class=&quot;list1&quot;&gt;number 1&lt;/li&gt;\n&lt;li class=&quot;list2&quot;&gt;number 2&lt;/li&gt;\n&lt;li class=&quot;list3&quot;&gt;number 3&lt;/li&gt;\n&lt;li class=&quot;list4&quot;&gt;number 4&lt;/li&gt;\n&lt;li class=&quot;list5&quot;&gt;number 5&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>ul&gt;li$.number<code>$$</code>*5 </p>\n<pre><code>&lt;ul&gt;\n&lt;li1 class=&quot;number01&quot;&gt;&lt;/li1&gt;\n&lt;li2 class=&quot;number02&quot;&gt;&lt;/li2&gt;\n&lt;li3 class=&quot;number03&quot;&gt;&lt;/li3&gt;\n&lt;li4 class=&quot;number04&quot;&gt;&lt;/li4&gt;\n&lt;li5 class=&quot;number05&quot;&gt;&lt;/li5&gt;\n&lt;/ul&gt;\n</code></pre>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-30 16:31:18</p>","site":{"data":{}},"excerpt":"<h3 id=\"1-省略div，插件会默认元素为div\"><a href=\"#1-省略div，插件会默认元素为div\" class=\"headerlink\" title=\"1. 省略div，插件会默认元素为div\"></a>1. 省略div，插件会默认元素为div</h3><p>.container</p>\n<pre><code>&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id=\"2-含糊标签名称-不需要指定。比如li，Emmet会自动帮助你生成\"><a href=\"#2-含糊标签名称-不需要指定。比如li，Emmet会自动帮助你生成\" class=\"headerlink\" title=\"2. 含糊标签名称,不需要指定。比如li，Emmet会自动帮助你生成\"></a>2. 含糊标签名称,不需要指定。比如li，Emmet会自动帮助你生成</h3><p> ul&gt;.lis</p>\n<pre><code>&lt;ul&gt;\n&lt;li class=&quot;lis&quot;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>","more":"<h3 id=\"3-链式缩写\"><a href=\"#3-链式缩写\" class=\"headerlink\" title=\"3.链式缩写\"></a>3.链式缩写</h3><p>① &gt; :添加创建子元素<br>div&gt;span </p>\n<pre><code>&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;\n</code></pre>\n<p>② + :添加创建同层级元素</p>\n<p>div+span</p>\n<pre><code>&lt;div&gt;&lt;/div&gt;\n&lt;span&gt;&lt;/span&gt;\n</code></pre>\n<p>③ ^ :添加一个父层级元素（需要的话你可以向上多层）</p>\n<p> p&gt;a^p </p>\n<pre><code>&lt;p&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;\n</code></pre>\n<h3 id=\"4-分组功能；\"><a href=\"#4-分组功能；\" class=\"headerlink\" title=\"4.分组功能；\"></a>4.分组功能；</h3><p> (.one&gt;h1)+(.two&gt;h1) </p>\n<pre><code>&lt;div class=&quot;one&quot;&gt;\n&lt;h1&gt;&lt;/h1&gt;\n&lt;/div&gt;\n&lt;div class=&quot;two&quot;&gt;\n&lt;h1&gt;&lt;/h1&gt;\n&lt;/div&gt;\n</code></pre>\n<h3 id=\"5-插入文本-和属性-；\"><a href=\"#5-插入文本-和属性-；\" class=\"headerlink\" title=\"5.插入文本{}和属性[]；\"></a>5.插入文本{}和属性[]；</h3><p>h1{heading}</p>\n<pre><code>&lt;h1&gt;heading&lt;/h1&gt;\n a[href=&#39;#&#39;] \n\n&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;\n</code></pre>\n<h3 id=\"6-添加多个class；\"><a href=\"#6-添加多个class；\" class=\"headerlink\" title=\"6.添加多个class；\"></a>6.添加多个class；</h3><p> .one.two.three</p>\n<pre><code>&lt;div class=&quot;one two three&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id=\"7-添加多个元素\"><a href=\"#7-添加多个元素\" class=\"headerlink\" title=\"7.添加多个元素\"></a>7.添加多个元素</h3><p> ul&gt;li*5 </p>\n<pre><code>&lt;ul&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h3 id=\"8-自动列表计数\"><a href=\"#8-自动列表计数\" class=\"headerlink\" title=\"8.自动列表计数\"></a>8.自动列表计数</h3><p> 按顺序生成HTML元素，使用 <code>$</code>符号可以帮助生成一系列数字，支持class，id，属性，内容等等。<br>(生成n位的数字，使用n个<code>$</code>符号)<br>ul&gt;li.list<code>$</code>{number<code>$</code>}*5</p>\n<pre><code>&lt;ul&gt;\n&lt;li class=&quot;list1&quot;&gt;number 1&lt;/li&gt;\n&lt;li class=&quot;list2&quot;&gt;number 2&lt;/li&gt;\n&lt;li class=&quot;list3&quot;&gt;number 3&lt;/li&gt;\n&lt;li class=&quot;list4&quot;&gt;number 4&lt;/li&gt;\n&lt;li class=&quot;list5&quot;&gt;number 5&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>ul&gt;li$.number<code>$$</code>*5 </p>\n<pre><code>&lt;ul&gt;\n&lt;li1 class=&quot;number01&quot;&gt;&lt;/li1&gt;\n&lt;li2 class=&quot;number02&quot;&gt;&lt;/li2&gt;\n&lt;li3 class=&quot;number03&quot;&gt;&lt;/li3&gt;\n&lt;li4 class=&quot;number04&quot;&gt;&lt;/li4&gt;\n&lt;li5 class=&quot;number05&quot;&gt;&lt;/li5&gt;\n&lt;/ul&gt;\n</code></pre>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-30 16:31:18</p>"},{"title":"sublimeText插件推荐","date":"2016-01-11T08:59:55.000Z","description":"sublimeText，插件，sublimeText插件，前端工具","_content":"\n工欲善其事必先利其器。sublimeText是前端开发工程师的一把利器，它的优点包含：\n\n1. 随时保留文件的修改\n2. Goto Anything，智能搜索;\n3. 简单全面的插件体系;\n4. 代码地图;\n5. 快速启动\n6. ...\n\n<!-- more -->\n其中它的插件体系绝对称得上是其精髓中的精髓。它的插件数量让你鞭长莫及的同时，也为sublimeText带来了更加强大的功能。安装几款优秀的插件可以改善我们的工作流程，提高我们的开发效率。这里推荐一些我所使用的插件，希望能帮助到有需要的人。\n\n\n### Emmet\nEmmet的前身是大名鼎鼎的Zen coding,它使用仿CSS选择器的语法来生成代码,大大提高了HTML/CSS代码编写的速度。\n使用方法可以阅读[sublimetext-Emmet插件的使用](http://bigdots.github.io/2015/05/06/sublimetext-Emmet插件的使用/)\n\n### jquery\n提供jquery的语法提示。\n![](/images/201601/jquery.gif)\n\n### Bracket Highlight\n代码匹配，可以匹配标记，符号等。可匹配[], (), {}, “”, ”, <tag></tag>，高亮标记，便于查看起始和结束标记。\n![](/images/201601/highlight.gif)\n\n### Trailing space\n自动检测多余空格并高亮。\n![](/images/201601/spac.gif)\n\n### DocBlocker\n生成优美的注释。输入/*、/**然后回车即可使用\n![](/images/201601/docblocker.gif)\n\n### AutoFileName\n自动完成文件名的输入。输入”/”即可看到相对于本项目文件夹的其他文件。\n![](/images/201601/autofilename.gif)\n\n### JsLint\n检测js的不良代码和错误。\n\n### Autoprefixer\nCSS3 私有前缀自动补全。\n![](/images/201601/prefixer.gif)\n\n### JsFormat\n一个JS代码格式化插件。这个插件能帮我们把原始代码进行格式的整理，包括换行和缩进等等，是代码一目了然，更快读懂。\n![](/images/201601/jsFormat.gif)\n\n### Alignment\n等号对齐插件。\n![](/images/201601/align.gif)\n\n### colorPicker\n调出调色板；需要输入颜色时，可直接选取颜色。\n\n\n### 管理使用使用插件\nPreference -> package settings -> 插件名 -> key bindings-Uefault(这里面是其默认的快捷键)\nPreference -> package settings -> 插件名 -> key bindings-User(这里面可自定义其快捷键)","source":"_posts/sublimeText插件推荐.md","raw":"title: sublimeText插件推荐\ndate: 2016-01-11 16:59:55\ntags: [工具]\ndescription: sublimeText，插件，sublimeText插件，前端工具\n\n---\n\n工欲善其事必先利其器。sublimeText是前端开发工程师的一把利器，它的优点包含：\n\n1. 随时保留文件的修改\n2. Goto Anything，智能搜索;\n3. 简单全面的插件体系;\n4. 代码地图;\n5. 快速启动\n6. ...\n\n<!-- more -->\n其中它的插件体系绝对称得上是其精髓中的精髓。它的插件数量让你鞭长莫及的同时，也为sublimeText带来了更加强大的功能。安装几款优秀的插件可以改善我们的工作流程，提高我们的开发效率。这里推荐一些我所使用的插件，希望能帮助到有需要的人。\n\n\n### Emmet\nEmmet的前身是大名鼎鼎的Zen coding,它使用仿CSS选择器的语法来生成代码,大大提高了HTML/CSS代码编写的速度。\n使用方法可以阅读[sublimetext-Emmet插件的使用](http://bigdots.github.io/2015/05/06/sublimetext-Emmet插件的使用/)\n\n### jquery\n提供jquery的语法提示。\n![](/images/201601/jquery.gif)\n\n### Bracket Highlight\n代码匹配，可以匹配标记，符号等。可匹配[], (), {}, “”, ”, <tag></tag>，高亮标记，便于查看起始和结束标记。\n![](/images/201601/highlight.gif)\n\n### Trailing space\n自动检测多余空格并高亮。\n![](/images/201601/spac.gif)\n\n### DocBlocker\n生成优美的注释。输入/*、/**然后回车即可使用\n![](/images/201601/docblocker.gif)\n\n### AutoFileName\n自动完成文件名的输入。输入”/”即可看到相对于本项目文件夹的其他文件。\n![](/images/201601/autofilename.gif)\n\n### JsLint\n检测js的不良代码和错误。\n\n### Autoprefixer\nCSS3 私有前缀自动补全。\n![](/images/201601/prefixer.gif)\n\n### JsFormat\n一个JS代码格式化插件。这个插件能帮我们把原始代码进行格式的整理，包括换行和缩进等等，是代码一目了然，更快读懂。\n![](/images/201601/jsFormat.gif)\n\n### Alignment\n等号对齐插件。\n![](/images/201601/align.gif)\n\n### colorPicker\n调出调色板；需要输入颜色时，可直接选取颜色。\n\n\n### 管理使用使用插件\nPreference -> package settings -> 插件名 -> key bindings-Uefault(这里面是其默认的快捷键)\nPreference -> package settings -> 插件名 -> key bindings-User(这里面可自定义其快捷键)","slug":"sublimeText插件推荐","published":1,"updated":"2021-12-06T06:07:06.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwols002xy4v24ijx3lj9","content":"<p>工欲善其事必先利其器。sublimeText是前端开发工程师的一把利器，它的优点包含：</p>\n<ol>\n<li>随时保留文件的修改</li>\n<li>Goto Anything，智能搜索;</li>\n<li>简单全面的插件体系;</li>\n<li>代码地图;</li>\n<li>快速启动</li>\n<li>…</li>\n</ol>\n<span id=\"more\"></span>\n<p>其中它的插件体系绝对称得上是其精髓中的精髓。它的插件数量让你鞭长莫及的同时，也为sublimeText带来了更加强大的功能。安装几款优秀的插件可以改善我们的工作流程，提高我们的开发效率。这里推荐一些我所使用的插件，希望能帮助到有需要的人。</p>\n<h3 id=\"Emmet\"><a href=\"#Emmet\" class=\"headerlink\" title=\"Emmet\"></a>Emmet</h3><p>Emmet的前身是大名鼎鼎的Zen coding,它使用仿CSS选择器的语法来生成代码,大大提高了HTML/CSS代码编写的速度。<br>使用方法可以阅读<a href=\"http://bigdots.github.io/2015/05/06/sublimetext-Emmet%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/\">sublimetext-Emmet插件的使用</a></p>\n<h3 id=\"jquery\"><a href=\"#jquery\" class=\"headerlink\" title=\"jquery\"></a>jquery</h3><p>提供jquery的语法提示。<br><img src=\"/images/201601/jquery.gif\"></p>\n<h3 id=\"Bracket-Highlight\"><a href=\"#Bracket-Highlight\" class=\"headerlink\" title=\"Bracket Highlight\"></a>Bracket Highlight</h3><p>代码匹配，可以匹配标记，符号等。可匹配[], (), {}, “”, ”, <tag></tag>，高亮标记，便于查看起始和结束标记。<br><img src=\"/images/201601/highlight.gif\"></p>\n<h3 id=\"Trailing-space\"><a href=\"#Trailing-space\" class=\"headerlink\" title=\"Trailing space\"></a>Trailing space</h3><p>自动检测多余空格并高亮。<br><img src=\"/images/201601/spac.gif\"></p>\n<h3 id=\"DocBlocker\"><a href=\"#DocBlocker\" class=\"headerlink\" title=\"DocBlocker\"></a>DocBlocker</h3><p>生成优美的注释。输入/*、/**然后回车即可使用<br><img src=\"/images/201601/docblocker.gif\"></p>\n<h3 id=\"AutoFileName\"><a href=\"#AutoFileName\" class=\"headerlink\" title=\"AutoFileName\"></a>AutoFileName</h3><p>自动完成文件名的输入。输入”/”即可看到相对于本项目文件夹的其他文件。<br><img src=\"/images/201601/autofilename.gif\"></p>\n<h3 id=\"JsLint\"><a href=\"#JsLint\" class=\"headerlink\" title=\"JsLint\"></a>JsLint</h3><p>检测js的不良代码和错误。</p>\n<h3 id=\"Autoprefixer\"><a href=\"#Autoprefixer\" class=\"headerlink\" title=\"Autoprefixer\"></a>Autoprefixer</h3><p>CSS3 私有前缀自动补全。<br><img src=\"/images/201601/prefixer.gif\"></p>\n<h3 id=\"JsFormat\"><a href=\"#JsFormat\" class=\"headerlink\" title=\"JsFormat\"></a>JsFormat</h3><p>一个JS代码格式化插件。这个插件能帮我们把原始代码进行格式的整理，包括换行和缩进等等，是代码一目了然，更快读懂。<br><img src=\"/images/201601/jsFormat.gif\"></p>\n<h3 id=\"Alignment\"><a href=\"#Alignment\" class=\"headerlink\" title=\"Alignment\"></a>Alignment</h3><p>等号对齐插件。<br><img src=\"/images/201601/align.gif\"></p>\n<h3 id=\"colorPicker\"><a href=\"#colorPicker\" class=\"headerlink\" title=\"colorPicker\"></a>colorPicker</h3><p>调出调色板；需要输入颜色时，可直接选取颜色。</p>\n<h3 id=\"管理使用使用插件\"><a href=\"#管理使用使用插件\" class=\"headerlink\" title=\"管理使用使用插件\"></a>管理使用使用插件</h3><p>Preference -&gt; package settings -&gt; 插件名 -&gt; key bindings-Uefault(这里面是其默认的快捷键)<br>Preference -&gt; package settings -&gt; 插件名 -&gt; key bindings-User(这里面可自定义其快捷键)</p>\n","site":{"data":{}},"excerpt":"<p>工欲善其事必先利其器。sublimeText是前端开发工程师的一把利器，它的优点包含：</p>\n<ol>\n<li>随时保留文件的修改</li>\n<li>Goto Anything，智能搜索;</li>\n<li>简单全面的插件体系;</li>\n<li>代码地图;</li>\n<li>快速启动</li>\n<li>…</li>\n</ol>","more":"<p>其中它的插件体系绝对称得上是其精髓中的精髓。它的插件数量让你鞭长莫及的同时，也为sublimeText带来了更加强大的功能。安装几款优秀的插件可以改善我们的工作流程，提高我们的开发效率。这里推荐一些我所使用的插件，希望能帮助到有需要的人。</p>\n<h3 id=\"Emmet\"><a href=\"#Emmet\" class=\"headerlink\" title=\"Emmet\"></a>Emmet</h3><p>Emmet的前身是大名鼎鼎的Zen coding,它使用仿CSS选择器的语法来生成代码,大大提高了HTML/CSS代码编写的速度。<br>使用方法可以阅读<a href=\"http://bigdots.github.io/2015/05/06/sublimetext-Emmet%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/\">sublimetext-Emmet插件的使用</a></p>\n<h3 id=\"jquery\"><a href=\"#jquery\" class=\"headerlink\" title=\"jquery\"></a>jquery</h3><p>提供jquery的语法提示。<br><img src=\"/images/201601/jquery.gif\"></p>\n<h3 id=\"Bracket-Highlight\"><a href=\"#Bracket-Highlight\" class=\"headerlink\" title=\"Bracket Highlight\"></a>Bracket Highlight</h3><p>代码匹配，可以匹配标记，符号等。可匹配[], (), {}, “”, ”, <tag></tag>，高亮标记，便于查看起始和结束标记。<br><img src=\"/images/201601/highlight.gif\"></p>\n<h3 id=\"Trailing-space\"><a href=\"#Trailing-space\" class=\"headerlink\" title=\"Trailing space\"></a>Trailing space</h3><p>自动检测多余空格并高亮。<br><img src=\"/images/201601/spac.gif\"></p>\n<h3 id=\"DocBlocker\"><a href=\"#DocBlocker\" class=\"headerlink\" title=\"DocBlocker\"></a>DocBlocker</h3><p>生成优美的注释。输入/*、/**然后回车即可使用<br><img src=\"/images/201601/docblocker.gif\"></p>\n<h3 id=\"AutoFileName\"><a href=\"#AutoFileName\" class=\"headerlink\" title=\"AutoFileName\"></a>AutoFileName</h3><p>自动完成文件名的输入。输入”/”即可看到相对于本项目文件夹的其他文件。<br><img src=\"/images/201601/autofilename.gif\"></p>\n<h3 id=\"JsLint\"><a href=\"#JsLint\" class=\"headerlink\" title=\"JsLint\"></a>JsLint</h3><p>检测js的不良代码和错误。</p>\n<h3 id=\"Autoprefixer\"><a href=\"#Autoprefixer\" class=\"headerlink\" title=\"Autoprefixer\"></a>Autoprefixer</h3><p>CSS3 私有前缀自动补全。<br><img src=\"/images/201601/prefixer.gif\"></p>\n<h3 id=\"JsFormat\"><a href=\"#JsFormat\" class=\"headerlink\" title=\"JsFormat\"></a>JsFormat</h3><p>一个JS代码格式化插件。这个插件能帮我们把原始代码进行格式的整理，包括换行和缩进等等，是代码一目了然，更快读懂。<br><img src=\"/images/201601/jsFormat.gif\"></p>\n<h3 id=\"Alignment\"><a href=\"#Alignment\" class=\"headerlink\" title=\"Alignment\"></a>Alignment</h3><p>等号对齐插件。<br><img src=\"/images/201601/align.gif\"></p>\n<h3 id=\"colorPicker\"><a href=\"#colorPicker\" class=\"headerlink\" title=\"colorPicker\"></a>colorPicker</h3><p>调出调色板；需要输入颜色时，可直接选取颜色。</p>\n<h3 id=\"管理使用使用插件\"><a href=\"#管理使用使用插件\" class=\"headerlink\" title=\"管理使用使用插件\"></a>管理使用使用插件</h3><p>Preference -&gt; package settings -&gt; 插件名 -&gt; key bindings-Uefault(这里面是其默认的快捷键)<br>Preference -&gt; package settings -&gt; 插件名 -&gt; key bindings-User(这里面可自定义其快捷键)</p>"},{"_content":"# YDKJS:this 与对象原型(一)\n\n<!-- TOC -->\n\n- [YDKJS:this 与对象原型(一)](#ydkjsthis-与对象原型一)\n    - [this 还是 that](#this-还是-that)\n        - [为什么要使用 this](#为什么要使用-this)\n        - [困惑](#困惑)\n        - [什么是 this](#什么是-this)\n    - [this 豁然开朗](#this-豁然开朗)\n        - [调用点](#调用点)\n        - [this 绑定规则](#this-绑定规则)\n        - [一切皆有顺序](#一切皆有顺序)\n        - [判定 this](#判定-this)\n\n<!-- /TOC -->\n\n## this 还是 that\n\n> this 是在每个函数作用域中自动定义的特殊标识符关键字。\n\n### 为什么要使用 this\n\n1. 目标：\n\n    允许函数对多个环境对象进行复用，而不是针对不同的环境重复定义。\n\n2. 实现：\n\n    * 明确地将环境对象传递给函数。\n\n    * 通过 this 机制自动引用恰当的执行环境\n\n3. 比较：\n\n    this 机制提供了更优雅的方式来隐含地传递一个对象引用。实现了更加干净的 API 设计和更容易的复用。\n\n### 困惑\n\n开发者在对 this 的理解上往往存在俩种误解：\n\n1. this 是函数自身的引用\n\n    第一种常见的错误倾向是认为 this 指向函数自己。\n\n    ```js\n    function foo() {\n        this.count++;\n    }\n\n    foo.count = 0;\n\n    for (var i = 1; i <= 5; i++) {\n        console.log(i); // 1,2,3,4,5\n        foo();\n    }\n\n    console.log(foo.count); //0\n    ```\n\n    上面 foo 被执行了五次，但是 foo.count 的值依然为 0，这说明 this 根本就不指向那个函数对象。\n\n2. this 是函数词法作用域的引用\n\n    第二种常见的对 this 指向的误解是认为它指向当前的函数作用域。这是一种严重的误导，this 不会以任何方式指向函数的词法作用域。\n\n    ```js\n    var a = 3;\n    function foo() {\n        var a = 2;\n        console.log(this.a);\n    }\n\n    foo(); // 3\n    ```\n\n    如果 this 指向的是函数的词法作用域，那么执行 foo 的结果应该输出 2，但是显而易见，输出的并不是 3，这说明**this 和词法作用域之间没有桥**，不能使用 this 在词法作用域中查找东西。\n\n### 什么是 this\n\n**this 实际上是在函数被调用时建立的一个绑定，它指向什么完全是由函数的调用点(call-site)来决定的。**\n\nthis 不是编写时绑定而是运行时绑定，它依赖于函数调用的上下文条件。this 的绑定和函数声明的位置无关，反而和函数被调用的方式有关。\n\n当一个函数被调用时，会创建一个执行环境（活动记录），它包括函数是从何处(call-stack)被调用的，函数是如何被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的 this 引用。\n\n## this 豁然开朗\n\nthis 完全是一个根据**调用点**而为每次函数调用建立的绑定。\n\n### 调用点\n\n> 调用点就是函数在代码中被调用的位置。\n\n要弄明白 this 指向，我们必须先寻找到调用点。\n\n调用栈和调用点：\n\n```js\nfunction foo() {\n    // 调用栈： baz -> bar -> foo\n    console.log(\"foo\");\n}\n\nfunction bar() {\n    // 调用栈： baz -> bar\n    console.log(\"bar\");\n    foo(); // foo的调用点\n}\n\nfunction baz() {\n    // 调用栈： baz\n    console.log(\"baz\");\n    bar(); // bar的调用点\n}\n\nbaz(); // baz的调用点\n```\n\n**调用点是影响 this 绑定的唯一因素。**\n\n### this 绑定规则\n\n1. 默认绑定\n\n    **独立函数**调用时，适用于这种规则。\n\n    ```js\n    var a = 2;\n    function foo() {\n        console.log(this.a);\n    }\n    foo(); // 2\n    ```\n\n    上述代码，this 指向了全局对象，这是为什么？\n\n    这是因为对于默认绑定来说：如果没有在严格模式下运行，**全局对象是唯一合法的**。\n\n```js\nvar a = 2;\nfunction foo() {\n    \"use strict\";\n    console.log(this.a);\n}\nfoo(); // TypeError: this is undefined\n```\n\n严格模式下，必须指明函数的调用者。\n\n2. 隐含绑定\n\n    适用于调用者拥有一个环境对象（也称拥有者对象或容器对象）的情况。\n\n    ```js\n    function foo() {\n        console.log(this.a);\n    }\n\n    var obj = {\n        a: 2,\n        foo: foo\n    };\n\n    obj.foo(); // 2\n    ```\n\n    在这里，函数 foo 作为属性被添加到对象 obj 上，可以说这个函数被 obj 所“拥有”或“包含”。在函数 foo 调用的位置上，它被冠以一个指向 obj 的对象引用。\n\n    隐含绑定的规则：当一个函数引用一个环境对象时，这个对象应当被用于函数调用的 this 绑定。\n\n    **隐含丢失**\n\n    ```js\n    function foo() {\n        console.log(this.a);\n    }\n\n    var obj = {\n        a: 2,\n        foo: foo\n    };\n\n    var bar = obj.foo;\n\n    var a = \"global\";\n\n    bar(); // global\n    ```\n\n    尽管 bar 似乎是 obj.foo 的引用，但实际上它只是一个 foo 的 引用而已。另外从调用点看来，是独立函数调用，因此默认绑定规则起了作用。\n\n3. 明确绑定\n\n    1. `call` 和 `apply` 提供了一种直接指明函数 this 的方法。\n\n        ```js\n        function foo() {\n            console.log(this.a);\n        }\n\n        var obj = {\n            a: 2\n        };\n\n        foo.call(obj); //2\n        foo.apply(obj); //2\n        ```\n\n        这里使用了`call` 和 `apply`强制函数的 this 指向 obj 。\n\n        如果第参数传递的是简单原始类型，那么这个原始类型会被包装在它的对象类型中。\n\n        `call` 和 `apply` 在绑定 this 的角度上没有任何区别。它们只是在参数的传递上有所区别。\n\n    2. 硬绑定\n\n        明确绑定仍存在一个问题：它还是无法解决隐含丢失。而硬绑定正是为了解决这一问题。\n\n        **ES5 提供了 bind 这一工具用于硬绑定。**\n\n        ```js\n        function foo() {\n            console.log(this.a);\n        }\n\n        var obj = {\n            a: 2\n        };\n\n        var bar = foo.bind(obj);\n\n        bar(); // 2\n        ```\n\n        bind 返回一个硬编码的新函数，它使用你指定的 this 环境来调用原本的函数。\n\n        **硬绑定其实是 明确绑定 的变种。**\n\n        ```js\n        // 简单的bind函数\n        function bind(fn, obj) {\n            return function() {\n                return fn.apply(obj);\n            };\n        }\n        ```\n\n4. new 绑定\n\n在 JS 中，构造器仅仅是一个函数，它们被前置的 new 操作符调用。它们不依附于类，也不初始化类。\n\n当函数作为 new 表达式的一部分被调用时，它才是一个构造器：初始化这个新创建的对象。\n\n**所以实际上，不存在“构造函数”这样的东西，而只有函数的构造期调用。**\n\n当 new 表达式调用时：\n\n1. 创建一个全新的对象；\n2. 将这个对象接入原型链\n3. 将这个对象设置为函数调用的 this 绑定\n4. 返回这个对象（需要排除函数返回一个它自己的对象的情况）\n\n```js\nfunction foo(a) {\n    this.a = a;\n}\nvar bar = new foo(2);\nconsole.log(bar.a);\n```\n\n我们通过 new 来调用 foo，从而创建了一个新的对象，并将这个新对象作为 foo 调用的 this。这种方式实现了 new 绑定。\n\n### 一切皆有顺序\n\nnew 绑定 > 明确绑定 > 隐含绑定 > 默认绑定\n\n### 判定 this\n\n通过上面的顺序，我们可以轻易地判定 this 的指向了：\n\n* 如果使用了 new ，那么 this 就是新构建的对象；\n* 如果使用了 apply／call 和 bind，this 就是明确制定的对象；\n* 如果函数存在调用者，也就是环境对象，那么 this 就是那个环境对象；\n* 否则，使用默认规则。严格模式下为 undefinde,否则则是全局对象。\n","source":"_posts/this与对象原型(一).md","raw":"# YDKJS:this 与对象原型(一)\n\n<!-- TOC -->\n\n- [YDKJS:this 与对象原型(一)](#ydkjsthis-与对象原型一)\n    - [this 还是 that](#this-还是-that)\n        - [为什么要使用 this](#为什么要使用-this)\n        - [困惑](#困惑)\n        - [什么是 this](#什么是-this)\n    - [this 豁然开朗](#this-豁然开朗)\n        - [调用点](#调用点)\n        - [this 绑定规则](#this-绑定规则)\n        - [一切皆有顺序](#一切皆有顺序)\n        - [判定 this](#判定-this)\n\n<!-- /TOC -->\n\n## this 还是 that\n\n> this 是在每个函数作用域中自动定义的特殊标识符关键字。\n\n### 为什么要使用 this\n\n1. 目标：\n\n    允许函数对多个环境对象进行复用，而不是针对不同的环境重复定义。\n\n2. 实现：\n\n    * 明确地将环境对象传递给函数。\n\n    * 通过 this 机制自动引用恰当的执行环境\n\n3. 比较：\n\n    this 机制提供了更优雅的方式来隐含地传递一个对象引用。实现了更加干净的 API 设计和更容易的复用。\n\n### 困惑\n\n开发者在对 this 的理解上往往存在俩种误解：\n\n1. this 是函数自身的引用\n\n    第一种常见的错误倾向是认为 this 指向函数自己。\n\n    ```js\n    function foo() {\n        this.count++;\n    }\n\n    foo.count = 0;\n\n    for (var i = 1; i <= 5; i++) {\n        console.log(i); // 1,2,3,4,5\n        foo();\n    }\n\n    console.log(foo.count); //0\n    ```\n\n    上面 foo 被执行了五次，但是 foo.count 的值依然为 0，这说明 this 根本就不指向那个函数对象。\n\n2. this 是函数词法作用域的引用\n\n    第二种常见的对 this 指向的误解是认为它指向当前的函数作用域。这是一种严重的误导，this 不会以任何方式指向函数的词法作用域。\n\n    ```js\n    var a = 3;\n    function foo() {\n        var a = 2;\n        console.log(this.a);\n    }\n\n    foo(); // 3\n    ```\n\n    如果 this 指向的是函数的词法作用域，那么执行 foo 的结果应该输出 2，但是显而易见，输出的并不是 3，这说明**this 和词法作用域之间没有桥**，不能使用 this 在词法作用域中查找东西。\n\n### 什么是 this\n\n**this 实际上是在函数被调用时建立的一个绑定，它指向什么完全是由函数的调用点(call-site)来决定的。**\n\nthis 不是编写时绑定而是运行时绑定，它依赖于函数调用的上下文条件。this 的绑定和函数声明的位置无关，反而和函数被调用的方式有关。\n\n当一个函数被调用时，会创建一个执行环境（活动记录），它包括函数是从何处(call-stack)被调用的，函数是如何被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的 this 引用。\n\n## this 豁然开朗\n\nthis 完全是一个根据**调用点**而为每次函数调用建立的绑定。\n\n### 调用点\n\n> 调用点就是函数在代码中被调用的位置。\n\n要弄明白 this 指向，我们必须先寻找到调用点。\n\n调用栈和调用点：\n\n```js\nfunction foo() {\n    // 调用栈： baz -> bar -> foo\n    console.log(\"foo\");\n}\n\nfunction bar() {\n    // 调用栈： baz -> bar\n    console.log(\"bar\");\n    foo(); // foo的调用点\n}\n\nfunction baz() {\n    // 调用栈： baz\n    console.log(\"baz\");\n    bar(); // bar的调用点\n}\n\nbaz(); // baz的调用点\n```\n\n**调用点是影响 this 绑定的唯一因素。**\n\n### this 绑定规则\n\n1. 默认绑定\n\n    **独立函数**调用时，适用于这种规则。\n\n    ```js\n    var a = 2;\n    function foo() {\n        console.log(this.a);\n    }\n    foo(); // 2\n    ```\n\n    上述代码，this 指向了全局对象，这是为什么？\n\n    这是因为对于默认绑定来说：如果没有在严格模式下运行，**全局对象是唯一合法的**。\n\n```js\nvar a = 2;\nfunction foo() {\n    \"use strict\";\n    console.log(this.a);\n}\nfoo(); // TypeError: this is undefined\n```\n\n严格模式下，必须指明函数的调用者。\n\n2. 隐含绑定\n\n    适用于调用者拥有一个环境对象（也称拥有者对象或容器对象）的情况。\n\n    ```js\n    function foo() {\n        console.log(this.a);\n    }\n\n    var obj = {\n        a: 2,\n        foo: foo\n    };\n\n    obj.foo(); // 2\n    ```\n\n    在这里，函数 foo 作为属性被添加到对象 obj 上，可以说这个函数被 obj 所“拥有”或“包含”。在函数 foo 调用的位置上，它被冠以一个指向 obj 的对象引用。\n\n    隐含绑定的规则：当一个函数引用一个环境对象时，这个对象应当被用于函数调用的 this 绑定。\n\n    **隐含丢失**\n\n    ```js\n    function foo() {\n        console.log(this.a);\n    }\n\n    var obj = {\n        a: 2,\n        foo: foo\n    };\n\n    var bar = obj.foo;\n\n    var a = \"global\";\n\n    bar(); // global\n    ```\n\n    尽管 bar 似乎是 obj.foo 的引用，但实际上它只是一个 foo 的 引用而已。另外从调用点看来，是独立函数调用，因此默认绑定规则起了作用。\n\n3. 明确绑定\n\n    1. `call` 和 `apply` 提供了一种直接指明函数 this 的方法。\n\n        ```js\n        function foo() {\n            console.log(this.a);\n        }\n\n        var obj = {\n            a: 2\n        };\n\n        foo.call(obj); //2\n        foo.apply(obj); //2\n        ```\n\n        这里使用了`call` 和 `apply`强制函数的 this 指向 obj 。\n\n        如果第参数传递的是简单原始类型，那么这个原始类型会被包装在它的对象类型中。\n\n        `call` 和 `apply` 在绑定 this 的角度上没有任何区别。它们只是在参数的传递上有所区别。\n\n    2. 硬绑定\n\n        明确绑定仍存在一个问题：它还是无法解决隐含丢失。而硬绑定正是为了解决这一问题。\n\n        **ES5 提供了 bind 这一工具用于硬绑定。**\n\n        ```js\n        function foo() {\n            console.log(this.a);\n        }\n\n        var obj = {\n            a: 2\n        };\n\n        var bar = foo.bind(obj);\n\n        bar(); // 2\n        ```\n\n        bind 返回一个硬编码的新函数，它使用你指定的 this 环境来调用原本的函数。\n\n        **硬绑定其实是 明确绑定 的变种。**\n\n        ```js\n        // 简单的bind函数\n        function bind(fn, obj) {\n            return function() {\n                return fn.apply(obj);\n            };\n        }\n        ```\n\n4. new 绑定\n\n在 JS 中，构造器仅仅是一个函数，它们被前置的 new 操作符调用。它们不依附于类，也不初始化类。\n\n当函数作为 new 表达式的一部分被调用时，它才是一个构造器：初始化这个新创建的对象。\n\n**所以实际上，不存在“构造函数”这样的东西，而只有函数的构造期调用。**\n\n当 new 表达式调用时：\n\n1. 创建一个全新的对象；\n2. 将这个对象接入原型链\n3. 将这个对象设置为函数调用的 this 绑定\n4. 返回这个对象（需要排除函数返回一个它自己的对象的情况）\n\n```js\nfunction foo(a) {\n    this.a = a;\n}\nvar bar = new foo(2);\nconsole.log(bar.a);\n```\n\n我们通过 new 来调用 foo，从而创建了一个新的对象，并将这个新对象作为 foo 调用的 this。这种方式实现了 new 绑定。\n\n### 一切皆有顺序\n\nnew 绑定 > 明确绑定 > 隐含绑定 > 默认绑定\n\n### 判定 this\n\n通过上面的顺序，我们可以轻易地判定 this 的指向了：\n\n* 如果使用了 new ，那么 this 就是新构建的对象；\n* 如果使用了 apply／call 和 bind，this 就是明确制定的对象；\n* 如果函数存在调用者，也就是环境对象，那么 this 就是那个环境对象；\n* 否则，使用默认规则。严格模式下为 undefinde,否则则是全局对象。\n","slug":"this与对象原型(一)","published":1,"date":"2021-12-06T06:07:05.854Z","updated":"2021-12-06T06:07:05.854Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolt002zy4v202qj8t6i","content":"<h1 id=\"YDKJS-this-与对象原型-一\"><a href=\"#YDKJS-this-与对象原型-一\" class=\"headerlink\" title=\"YDKJS:this 与对象原型(一)\"></a>YDKJS:this 与对象原型(一)</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#ydkjsthis-%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E4%B8%80\">YDKJS:this 与对象原型(一)</a><ul>\n<li><a href=\"#this-%E8%BF%98%E6%98%AF-that\">this 还是 that</a><ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-this\">为什么要使用 this</a></li>\n<li><a href=\"#%E5%9B%B0%E6%83%91\">困惑</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-this\">什么是 this</a></li>\n</ul>\n</li>\n<li><a href=\"#this-%E8%B1%81%E7%84%B6%E5%BC%80%E6%9C%97\">this 豁然开朗</a><ul>\n<li><a href=\"#%E8%B0%83%E7%94%A8%E7%82%B9\">调用点</a></li>\n<li><a href=\"#this-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99\">this 绑定规则</a></li>\n<li><a href=\"#%E4%B8%80%E5%88%87%E7%9A%86%E6%9C%89%E9%A1%BA%E5%BA%8F\">一切皆有顺序</a></li>\n<li><a href=\"#%E5%88%A4%E5%AE%9A-this\">判定 this</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<h2 id=\"this-还是-that\"><a href=\"#this-还是-that\" class=\"headerlink\" title=\"this 还是 that\"></a>this 还是 that</h2><blockquote>\n<p>this 是在每个函数作用域中自动定义的特殊标识符关键字。</p>\n</blockquote>\n<h3 id=\"为什么要使用-this\"><a href=\"#为什么要使用-this\" class=\"headerlink\" title=\"为什么要使用 this\"></a>为什么要使用 this</h3><ol>\n<li><p>目标：</p>\n<p> 允许函数对多个环境对象进行复用，而不是针对不同的环境重复定义。</p>\n</li>\n<li><p>实现：</p>\n<ul>\n<li><p>明确地将环境对象传递给函数。</p>\n</li>\n<li><p>通过 this 机制自动引用恰当的执行环境</p>\n</li>\n</ul>\n</li>\n<li><p>比较：</p>\n<p> this 机制提供了更优雅的方式来隐含地传递一个对象引用。实现了更加干净的 API 设计和更容易的复用。</p>\n</li>\n</ol>\n<h3 id=\"困惑\"><a href=\"#困惑\" class=\"headerlink\" title=\"困惑\"></a>困惑</h3><p>开发者在对 this 的理解上往往存在俩种误解：</p>\n<ol>\n<li><p>this 是函数自身的引用</p>\n<p> 第一种常见的错误倾向是认为 this 指向函数自己。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 1,2,3,4,5</span></span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.count); <span class=\"comment\">//0</span></span><br></pre></td></tr></table></figure>\n\n<p> 上面 foo 被执行了五次，但是 foo.count 的值依然为 0，这说明 this 根本就不指向那个函数对象。</p>\n</li>\n<li><p>this 是函数词法作用域的引用</p>\n<p> 第二种常见的对 this 指向的误解是认为它指向当前的函数作用域。这是一种严重的误导，this 不会以任何方式指向函数的词法作用域。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p> 如果 this 指向的是函数的词法作用域，那么执行 foo 的结果应该输出 2，但是显而易见，输出的并不是 3，这说明<strong>this 和词法作用域之间没有桥</strong>，不能使用 this 在词法作用域中查找东西。</p>\n</li>\n</ol>\n<h3 id=\"什么是-this\"><a href=\"#什么是-this\" class=\"headerlink\" title=\"什么是 this\"></a>什么是 this</h3><p><strong>this 实际上是在函数被调用时建立的一个绑定，它指向什么完全是由函数的调用点(call-site)来决定的。</strong></p>\n<p>this 不是编写时绑定而是运行时绑定，它依赖于函数调用的上下文条件。this 的绑定和函数声明的位置无关，反而和函数被调用的方式有关。</p>\n<p>当一个函数被调用时，会创建一个执行环境（活动记录），它包括函数是从何处(call-stack)被调用的，函数是如何被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的 this 引用。</p>\n<h2 id=\"this-豁然开朗\"><a href=\"#this-豁然开朗\" class=\"headerlink\" title=\"this 豁然开朗\"></a>this 豁然开朗</h2><p>this 完全是一个根据<strong>调用点</strong>而为每次函数调用建立的绑定。</p>\n<h3 id=\"调用点\"><a href=\"#调用点\" class=\"headerlink\" title=\"调用点\"></a>调用点</h3><blockquote>\n<p>调用点就是函数在代码中被调用的位置。</p>\n</blockquote>\n<p>要弄明白 this 指向，我们必须先寻找到调用点。</p>\n<p>调用栈和调用点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用栈： baz -&gt; bar -&gt; foo</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用栈： baz -&gt; bar</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\">    foo(); <span class=\"comment\">// foo的调用点</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用栈： baz</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;baz&quot;</span>);</span><br><span class=\"line\">    bar(); <span class=\"comment\">// bar的调用点</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">baz(); <span class=\"comment\">// baz的调用点</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>调用点是影响 this 绑定的唯一因素。</strong></p>\n<h3 id=\"this-绑定规则\"><a href=\"#this-绑定规则\" class=\"headerlink\" title=\"this 绑定规则\"></a>this 绑定规则</h3><ol>\n<li><p>默认绑定</p>\n<p> <strong>独立函数</strong>调用时，适用于这种规则。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p> 上述代码，this 指向了全局对象，这是为什么？</p>\n<p> 这是因为对于默认绑定来说：如果没有在严格模式下运行，<strong>全局对象是唯一合法的</strong>。</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    &quot;use strict&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(); <span class=\"comment\">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>严格模式下，必须指明函数的调用者。</p>\n<ol start=\"2\">\n<li><p>隐含绑定</p>\n<p> 适用于调用者拥有一个环境对象（也称拥有者对象或容器对象）的情况。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p> 在这里，函数 foo 作为属性被添加到对象 obj 上，可以说这个函数被 obj 所“拥有”或“包含”。在函数 foo 调用的位置上，它被冠以一个指向 obj 的对象引用。</p>\n<p> 隐含绑定的规则：当一个函数引用一个环境对象时，这个对象应当被用于函数调用的 this 绑定。</p>\n<p> <strong>隐含丢失</strong></p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;global&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// global</span></span><br></pre></td></tr></table></figure>\n\n<p> 尽管 bar 似乎是 obj.foo 的引用，但实际上它只是一个 foo 的 引用而已。另外从调用点看来，是独立函数调用，因此默认绑定规则起了作用。</p>\n</li>\n<li><p>明确绑定</p>\n<ol>\n<li><p><code>call</code> 和 <code>apply</code> 提供了一种直接指明函数 this 的方法。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call(obj); <span class=\"comment\">//2</span></span><br><span class=\"line\">foo.apply(obj); <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n\n<p> 这里使用了<code>call</code> 和 <code>apply</code>强制函数的 this 指向 obj 。</p>\n<p> 如果第参数传递的是简单原始类型，那么这个原始类型会被包装在它的对象类型中。</p>\n<p> <code>call</code> 和 <code>apply</code> 在绑定 this 的角度上没有任何区别。它们只是在参数的传递上有所区别。</p>\n</li>\n<li><p>硬绑定</p>\n<p> 明确绑定仍存在一个问题：它还是无法解决隐含丢失。而硬绑定正是为了解决这一问题。</p>\n<p> <strong>ES5 提供了 bind 这一工具用于硬绑定。</strong></p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p> bind 返回一个硬编码的新函数，它使用你指定的 this 环境来调用原本的函数。</p>\n<p> <strong>硬绑定其实是 明确绑定 的变种。</strong></p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单的bind函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn.apply(obj);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>new 绑定</p>\n</li>\n</ol>\n<p>在 JS 中，构造器仅仅是一个函数，它们被前置的 new 操作符调用。它们不依附于类，也不初始化类。</p>\n<p>当函数作为 new 表达式的一部分被调用时，它才是一个构造器：初始化这个新创建的对象。</p>\n<p><strong>所以实际上，不存在“构造函数”这样的东西，而只有函数的构造期调用。</strong></p>\n<p>当 new 表达式调用时：</p>\n<ol>\n<li>创建一个全新的对象；</li>\n<li>将这个对象接入原型链</li>\n<li>将这个对象设置为函数调用的 this 绑定</li>\n<li>返回这个对象（需要排除函数返回一个它自己的对象的情况）</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar.a);</span><br></pre></td></tr></table></figure>\n\n<p>我们通过 new 来调用 foo，从而创建了一个新的对象，并将这个新对象作为 foo 调用的 this。这种方式实现了 new 绑定。</p>\n<h3 id=\"一切皆有顺序\"><a href=\"#一切皆有顺序\" class=\"headerlink\" title=\"一切皆有顺序\"></a>一切皆有顺序</h3><p>new 绑定 &gt; 明确绑定 &gt; 隐含绑定 &gt; 默认绑定</p>\n<h3 id=\"判定-this\"><a href=\"#判定-this\" class=\"headerlink\" title=\"判定 this\"></a>判定 this</h3><p>通过上面的顺序，我们可以轻易地判定 this 的指向了：</p>\n<ul>\n<li>如果使用了 new ，那么 this 就是新构建的对象；</li>\n<li>如果使用了 apply／call 和 bind，this 就是明确制定的对象；</li>\n<li>如果函数存在调用者，也就是环境对象，那么 this 就是那个环境对象；</li>\n<li>否则，使用默认规则。严格模式下为 undefinde,否则则是全局对象。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"YDKJS-this-与对象原型-一\"><a href=\"#YDKJS-this-与对象原型-一\" class=\"headerlink\" title=\"YDKJS:this 与对象原型(一)\"></a>YDKJS:this 与对象原型(一)</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#ydkjsthis-%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E4%B8%80\">YDKJS:this 与对象原型(一)</a><ul>\n<li><a href=\"#this-%E8%BF%98%E6%98%AF-that\">this 还是 that</a><ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-this\">为什么要使用 this</a></li>\n<li><a href=\"#%E5%9B%B0%E6%83%91\">困惑</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-this\">什么是 this</a></li>\n</ul>\n</li>\n<li><a href=\"#this-%E8%B1%81%E7%84%B6%E5%BC%80%E6%9C%97\">this 豁然开朗</a><ul>\n<li><a href=\"#%E8%B0%83%E7%94%A8%E7%82%B9\">调用点</a></li>\n<li><a href=\"#this-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99\">this 绑定规则</a></li>\n<li><a href=\"#%E4%B8%80%E5%88%87%E7%9A%86%E6%9C%89%E9%A1%BA%E5%BA%8F\">一切皆有顺序</a></li>\n<li><a href=\"#%E5%88%A4%E5%AE%9A-this\">判定 this</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<h2 id=\"this-还是-that\"><a href=\"#this-还是-that\" class=\"headerlink\" title=\"this 还是 that\"></a>this 还是 that</h2><blockquote>\n<p>this 是在每个函数作用域中自动定义的特殊标识符关键字。</p>\n</blockquote>\n<h3 id=\"为什么要使用-this\"><a href=\"#为什么要使用-this\" class=\"headerlink\" title=\"为什么要使用 this\"></a>为什么要使用 this</h3><ol>\n<li><p>目标：</p>\n<p> 允许函数对多个环境对象进行复用，而不是针对不同的环境重复定义。</p>\n</li>\n<li><p>实现：</p>\n<ul>\n<li><p>明确地将环境对象传递给函数。</p>\n</li>\n<li><p>通过 this 机制自动引用恰当的执行环境</p>\n</li>\n</ul>\n</li>\n<li><p>比较：</p>\n<p> this 机制提供了更优雅的方式来隐含地传递一个对象引用。实现了更加干净的 API 设计和更容易的复用。</p>\n</li>\n</ol>\n<h3 id=\"困惑\"><a href=\"#困惑\" class=\"headerlink\" title=\"困惑\"></a>困惑</h3><p>开发者在对 this 的理解上往往存在俩种误解：</p>\n<ol>\n<li><p>this 是函数自身的引用</p>\n<p> 第一种常见的错误倾向是认为 this 指向函数自己。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 1,2,3,4,5</span></span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.count); <span class=\"comment\">//0</span></span><br></pre></td></tr></table></figure>\n\n<p> 上面 foo 被执行了五次，但是 foo.count 的值依然为 0，这说明 this 根本就不指向那个函数对象。</p>\n</li>\n<li><p>this 是函数词法作用域的引用</p>\n<p> 第二种常见的对 this 指向的误解是认为它指向当前的函数作用域。这是一种严重的误导，this 不会以任何方式指向函数的词法作用域。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p> 如果 this 指向的是函数的词法作用域，那么执行 foo 的结果应该输出 2，但是显而易见，输出的并不是 3，这说明<strong>this 和词法作用域之间没有桥</strong>，不能使用 this 在词法作用域中查找东西。</p>\n</li>\n</ol>\n<h3 id=\"什么是-this\"><a href=\"#什么是-this\" class=\"headerlink\" title=\"什么是 this\"></a>什么是 this</h3><p><strong>this 实际上是在函数被调用时建立的一个绑定，它指向什么完全是由函数的调用点(call-site)来决定的。</strong></p>\n<p>this 不是编写时绑定而是运行时绑定，它依赖于函数调用的上下文条件。this 的绑定和函数声明的位置无关，反而和函数被调用的方式有关。</p>\n<p>当一个函数被调用时，会创建一个执行环境（活动记录），它包括函数是从何处(call-stack)被调用的，函数是如何被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的 this 引用。</p>\n<h2 id=\"this-豁然开朗\"><a href=\"#this-豁然开朗\" class=\"headerlink\" title=\"this 豁然开朗\"></a>this 豁然开朗</h2><p>this 完全是一个根据<strong>调用点</strong>而为每次函数调用建立的绑定。</p>\n<h3 id=\"调用点\"><a href=\"#调用点\" class=\"headerlink\" title=\"调用点\"></a>调用点</h3><blockquote>\n<p>调用点就是函数在代码中被调用的位置。</p>\n</blockquote>\n<p>要弄明白 this 指向，我们必须先寻找到调用点。</p>\n<p>调用栈和调用点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用栈： baz -&gt; bar -&gt; foo</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用栈： baz -&gt; bar</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\">    foo(); <span class=\"comment\">// foo的调用点</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用栈： baz</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;baz&quot;</span>);</span><br><span class=\"line\">    bar(); <span class=\"comment\">// bar的调用点</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">baz(); <span class=\"comment\">// baz的调用点</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>调用点是影响 this 绑定的唯一因素。</strong></p>\n<h3 id=\"this-绑定规则\"><a href=\"#this-绑定规则\" class=\"headerlink\" title=\"this 绑定规则\"></a>this 绑定规则</h3><ol>\n<li><p>默认绑定</p>\n<p> <strong>独立函数</strong>调用时，适用于这种规则。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p> 上述代码，this 指向了全局对象，这是为什么？</p>\n<p> 这是因为对于默认绑定来说：如果没有在严格模式下运行，<strong>全局对象是唯一合法的</strong>。</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    &quot;use strict&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(); <span class=\"comment\">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>严格模式下，必须指明函数的调用者。</p>\n<ol start=\"2\">\n<li><p>隐含绑定</p>\n<p> 适用于调用者拥有一个环境对象（也称拥有者对象或容器对象）的情况。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p> 在这里，函数 foo 作为属性被添加到对象 obj 上，可以说这个函数被 obj 所“拥有”或“包含”。在函数 foo 调用的位置上，它被冠以一个指向 obj 的对象引用。</p>\n<p> 隐含绑定的规则：当一个函数引用一个环境对象时，这个对象应当被用于函数调用的 this 绑定。</p>\n<p> <strong>隐含丢失</strong></p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;global&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// global</span></span><br></pre></td></tr></table></figure>\n\n<p> 尽管 bar 似乎是 obj.foo 的引用，但实际上它只是一个 foo 的 引用而已。另外从调用点看来，是独立函数调用，因此默认绑定规则起了作用。</p>\n</li>\n<li><p>明确绑定</p>\n<ol>\n<li><p><code>call</code> 和 <code>apply</code> 提供了一种直接指明函数 this 的方法。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call(obj); <span class=\"comment\">//2</span></span><br><span class=\"line\">foo.apply(obj); <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n\n<p> 这里使用了<code>call</code> 和 <code>apply</code>强制函数的 this 指向 obj 。</p>\n<p> 如果第参数传递的是简单原始类型，那么这个原始类型会被包装在它的对象类型中。</p>\n<p> <code>call</code> 和 <code>apply</code> 在绑定 this 的角度上没有任何区别。它们只是在参数的传递上有所区别。</p>\n</li>\n<li><p>硬绑定</p>\n<p> 明确绑定仍存在一个问题：它还是无法解决隐含丢失。而硬绑定正是为了解决这一问题。</p>\n<p> <strong>ES5 提供了 bind 这一工具用于硬绑定。</strong></p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p> bind 返回一个硬编码的新函数，它使用你指定的 this 环境来调用原本的函数。</p>\n<p> <strong>硬绑定其实是 明确绑定 的变种。</strong></p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单的bind函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn.apply(obj);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>new 绑定</p>\n</li>\n</ol>\n<p>在 JS 中，构造器仅仅是一个函数，它们被前置的 new 操作符调用。它们不依附于类，也不初始化类。</p>\n<p>当函数作为 new 表达式的一部分被调用时，它才是一个构造器：初始化这个新创建的对象。</p>\n<p><strong>所以实际上，不存在“构造函数”这样的东西，而只有函数的构造期调用。</strong></p>\n<p>当 new 表达式调用时：</p>\n<ol>\n<li>创建一个全新的对象；</li>\n<li>将这个对象接入原型链</li>\n<li>将这个对象设置为函数调用的 this 绑定</li>\n<li>返回这个对象（需要排除函数返回一个它自己的对象的情况）</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar.a);</span><br></pre></td></tr></table></figure>\n\n<p>我们通过 new 来调用 foo，从而创建了一个新的对象，并将这个新对象作为 foo 调用的 this。这种方式实现了 new 绑定。</p>\n<h3 id=\"一切皆有顺序\"><a href=\"#一切皆有顺序\" class=\"headerlink\" title=\"一切皆有顺序\"></a>一切皆有顺序</h3><p>new 绑定 &gt; 明确绑定 &gt; 隐含绑定 &gt; 默认绑定</p>\n<h3 id=\"判定-this\"><a href=\"#判定-this\" class=\"headerlink\" title=\"判定 this\"></a>判定 this</h3><p>通过上面的顺序，我们可以轻易地判定 this 的指向了：</p>\n<ul>\n<li>如果使用了 new ，那么 this 就是新构建的对象；</li>\n<li>如果使用了 apply／call 和 bind，this 就是明确制定的对象；</li>\n<li>如果函数存在调用者，也就是环境对象，那么 this 就是那个环境对象；</li>\n<li>否则，使用默认规则。严格模式下为 undefinde,否则则是全局对象。</li>\n</ul>\n"},{"_content":"# YDKJS:this 与对象原型(二)\n\n<!-- TOC -->\n\n- [YDKJS:this 与对象原型(二)](#ydkjsthis-与对象原型二)\n    - [语法](#语法)\n    - [类型](#类型)\n    - [内容](#内容)\n        - [计算型属性名](#计算型属性名)\n        - [属性(Property) vs 方法(Method)](#属性property-vs-方法method)\n        - [数组](#数组)\n        - [复制对象](#复制对象)\n        - [属性描述符](#属性描述符)\n        - [不变性](#不变性)\n        - [[[Get]]](#get)\n        - [[[Put]]](#put)\n        - [Getter 和 Setter](#getter-和-setter)\n        - [存在性](#存在性)\n    - [遍历](#遍历)\n\n<!-- /TOC -->\n\n什么是对象？this 为什么需要指向对象？\n\n## 语法\n\n对象主要来源于俩种形式：\n\n1. 字面量形式\n\n    ```js\n    var myObj = {};\n    ```\n\n2. 构造形式\n\n    ```js\n    var myObj = new Object();\n    ```\n\n## 类型\n\nJavscript 中的一切皆对象的理解是存在错误的。\n\n简单基本类型自身不是 object。typeof null 返回 object 是语言中的一个 bug，实际上 null 是它自己的基本类型。\n\n**内建对象**\n\n* String\n* Number\n* Boolean\n* Object\n* Function\n* Array\n* Date\n* RegExp\n* Error\n\n内建对象仅仅只是函数，每一个都可以被用作构造器。new 一个内建对象的结果是一个新构建的相应**子类型的对象**。\n\n```js\nvar strObj = new String(\"I am a string\");\nObject.prototype.toString.call(strObj); // [object String]\n```\n\n`Object.prototype.toString`方法可以考察自类型的内部。\n\n**内建对象与基本类型的关系？**\n\n基本类型不是一个对象，它是一个不可变的基本字面值。为了对它进行操作都需要一个相应的对象。\n\n在 js 中，必要的时候会将基本类型值转化为相应的对象类型，比如：\n\n```js\nvar str = \"I am a string\";\nconsole.log(str.length); // 13\n```\n\n这里调用`str.length`，js 会先将 str 转化成 `new String('I am a string')`，再进行属性读取。\n\n**特殊： null 和 undefined 没有基本包装类型。Date 没有字面量值。**\n\n**注意：仅在必要时使用构建形式，推荐使用字面形式**\n\n## 内容\n\n对象的内容是由属性构成的，属性就是储存在特定位置上（任意类型）的值。\n\n引擎会根据自己的实现来存储属性值，而且通常都不是把它们存储在对象内部。储存在对象内部的是这些对象的名称，它们像指针一样指向值存储的地方。\n\n**访问方式：**\n\n* 属性（property）访问\n\n    使用 `.` 操作符。后面接一个`标识符`。\n\n* 键（key）访问\n\n    使用 `[]` 操作符。可以接受任何兼容`UTF-8/unicode`的字符串。可以使用动态键（表达式）。\n\n属性名总是字符串。使用字符串以外的值，它会首先被转化为字符串。\n\n```js\nvar myObj = {};\nmyObj[true] = \"foo\";\nmyObj[3] = \"bar\";\nmyObj[myObj] = \"baz\";\n\nmyObj[\"true\"]; // foo\nmyObj[\"3\"]; // bar\nmyObj[\"[object Object]\"]; //baz\n```\n\n### 计算型属性名\n\n`[]`提供了使用表达式作为键名的方法。但这种方式并不支持使用字面量语法。\n\nES6 加入了计算型属性名，可以在字面量声明时通过`[]`指定表达式属性。\n\n```js\nvar prefix = \"foo\";\n\nvar myObj = {\n    [prefix + \"bar\"]: \"hello\"\n};\nmyObj[\"foobar\"]; // hello\n```\n\n### 属性(Property) vs 方法(Method)\n\n人们喜欢将属性进行区分，把属于对象（类）的函数称为方法。但从技术上讲，函数不会属于对象 ，因为 this 是在运行时动态绑定的，说明它与对象的关系至多是间接的。\n\n```js\nfunction foo() {\n    console.log(\"foo\");\n}\n\nvar someFoo = foo;\n\nvar myObj = {\n    someFoo: foo\n};\n\nfoo; // ƒ foo(){...}\nsomeFoo; // ƒ foo(){...}\nmyObj.someFoo; // ƒ foo(){...}\n```\n\n`myObj.someFoo` 和 `someFoo` 都是对 foo 函数的分离引用，它们并不意味着很特别或者被某个对象所拥有。\n\n### 数组\n\n跟对象采用键来存储值一样，数组采用数字索引（数字小标）来存储值。\n\n数组的索引都是非负整数。\n\n如果在数组上添加一个似数字属性，那么它会称为一个数组索引。\n\n```js\nvar foo = [\"foo\", 123];\nfoo[\"3\"] = \"bar\";\nfoo[3]; // bar\n```\n\n### 复制对象\n\n浅拷贝 和 深拷贝。\n\n使用 JSON 安全对象来进行神拷贝。\n\n### 属性描述符\n\n自 ES5 开始，js 添加了属性描述符来考察或者描述属性。\n\n```js\nvar obj = {\n    a: 2\n};\nObject.getOwnPropertyDescriptor(obj, \"a\");\n\n// {value: 2, writable: true, enumerable: true, configurable: true}\n```\n\n属性描述符：\n\n* writable\n\n    可写性。设置为 false 则不可写。\n\n* enumerable\n\n    可枚举性。它控制对象属性能否被枚举，比如 for...in 循环。\n\n    ```js\n    var myObject = {};\n    Object.defineProperty(\n        myObject,\n        \"a\",\n        // 让 a 像普通属性一样可以枚举\n        { enumerable: true, value: 2 }\n    );\n    Object.defineProperty(\n        myObject,\n        \"b\",\n        // 让 b 不可枚举\n        { enumerable: false, value: 3 }\n    );\n\n    for (var k in myObject) {\n        console.log(k, myObject[k]);\n    }\n    // a 2\n    ```\n\n    可以看到，myObject.b 不会出现在 for..in 循环中。\n\n    其他检验属性是否可枚举的方法：\n\n    1. `propertyIsEnumerable(..)` 会检查给定的属性名是否直接存在于对象中(而不是在原型链 上)并且满足 `enumerable:true`。\n\n        ```js\n        myObject.propertyIsEnumerable(\"a\"); //true\n        myObject.propertyIsEnumerable(\"b\"); // false\n        ```\n\n    2. `Object.keys(..)` 会返回一个数组，包含所有可枚举属性，`Object.getOwnPropertyNames(..)` 会返回一个数组，包含所有属性，无论它们是否可枚举。\n\n        ```js\n        Object.keys(myObject); // [\"a\"]\n        Object.getOwnPropertyNames(myObject); //  [\"a\", \"b\"]\n        ```\n\n- configurable\n\n    可配置性。将它设为 false：\n\n    * defineProperty 也不可再使用，会报错。（说明是单向操作，不可撤销）\n    * delete 操作失效\n\n我们可以使用`Object.defineProperty`来添加和修改属性。\n\n### 不变性\n\n如何实现属性/对象的不可变性？\n\n1. 对象常量\n\n    通过 `writable: false` 和 `configurable: false`可以实现常量的创建。不可改变，重定义或者删除。\n\n2. 防止扩展\n\n    通过 `Object.preventExtensions()` 方法可以防止一个对象添加新属性。\n\n    ```js\n    var obj = { a: 1 };\n    Object.preventExtensions(obj);\n    obj.b = 2;\n    obj.b; //undefined\n    ```\n\n3. 封印\n\n    `Object.seal()`创建一个封印的对象。它既防扩展又不可配置。相等于同事调用`Object.preventExtensions()`和设置`configurable: false`。\n\n4. 冻结\n\n    `Object.freeze()`创建一个冻结对象。它相当于`Object.seal()` + `writable: false`。这事目前最高级别的不可变性。\n\n### [[Get]]\n\n属性访问实际上执行了一个 `[[Get]]` 操作。它会首先检查对象，查找是否有名称相同的属性：\n\n1. 存在，返回相应的值。\n2. 不存在，返回 `undefined`。（这个查找会遍历原型链）\n\n```js\nvar myObject = {\n    a: 2\n};\nmyObject.a; // 2\nmyObject.b; // undefined\n```\n\n\n### [[Put]]\n\n相应于 `[[Get]]` 操作，js 有个相应的 `[[Put]]` 操作。\n\n[[Put]] 操作的实际行为取决于许多因素，包括对象中是否已经存在这个属性(这是最重要的因素)。\n\n如果已经存在这个属性：\n\n1. 属性是否是访问描述符(参见 Getter 和 Setter)?如果是并且存在 setter 就调用 setter。\n2. 属性的数据描述符中 writable 是否是 false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。\n3. 如果都不是，将该值设置为属性的值。\n\n如果不存在，更复杂，详见[原型]()\n\n### Getter 和 Setter\n\n对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。\n\n在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。\n\ngetter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏函数，会在设置属性值时调用。\n\n当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述符”\n\nJavaScript 会忽略访问描述符的 value 和 writable 特性，取而代之的是关心 set 和 get(还有 configurable 和 enumerable)特性。\n\n```js\nvar myObject = {\n    // 给 a 定义一个 getter\n    get a() {\n        return 2;\n    }\n};\n\nObject.defineProperty(\n    myObject, // 目标对象 \"b\", // 属性名\n    \"b\",\n    {\n        // 给 b 设置一个 getter\n        get: function() {\n            return this.a * 2;\n        },\n        // 确保 b 会出现在对象的属性列表中\n        enumerable: true\n    }\n);\n\nmyObject.a; // 2\nmyObject.b; // 4\n```\n\n`get a() { .. }`和`defineProperty(..)`都会在对象中创建一个不包含值的属性, 对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值。\n\n通常来说 getter 和 setter 是成对出现的(只定义一个的话 通常会产生意料之外的行为):\n\n```js\nvar myObject = {\n    // 给 a 定义一个 getter\n    get a() {\n        return this._a_;\n    },\n    // 给 a 定义一个 setter\n    set a(val) {\n        this._a_ = val * 2;\n    }\n};\nmyObject.a = 2;\nmyObject.a; // 4\n```\n\n### 存在性\n\n```js\nvar myObject = {\n    a: undefined\n};\nmyObject.a; //undefined\nmyObject.b; //undefined\n```\n\n一个属性值有可能 是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分 这两种情况呢?\n\n1. in\n   in 操作符会检查**属性名**在对象及其 [[Prototype]] 原型链中是否存在\n\n    ```js\n    \"a\" in myObject; //true\n    \"b\" in myObject; //false\n    ```\n\n2. hasOwnProperty\n   只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。\n\n    ```js\n    myObject.hasOwnProperty(\"a\"); //true\n    myObject.hasOwnProperty(\"b\"); //false\n    ```\n\n## 遍历\n\n1. for..in\n2. for 循环\n3. forEach(..)、every(..) 和 some(..)\n4. for..of\n","source":"_posts/this与对象原型(二).md","raw":"# YDKJS:this 与对象原型(二)\n\n<!-- TOC -->\n\n- [YDKJS:this 与对象原型(二)](#ydkjsthis-与对象原型二)\n    - [语法](#语法)\n    - [类型](#类型)\n    - [内容](#内容)\n        - [计算型属性名](#计算型属性名)\n        - [属性(Property) vs 方法(Method)](#属性property-vs-方法method)\n        - [数组](#数组)\n        - [复制对象](#复制对象)\n        - [属性描述符](#属性描述符)\n        - [不变性](#不变性)\n        - [[[Get]]](#get)\n        - [[[Put]]](#put)\n        - [Getter 和 Setter](#getter-和-setter)\n        - [存在性](#存在性)\n    - [遍历](#遍历)\n\n<!-- /TOC -->\n\n什么是对象？this 为什么需要指向对象？\n\n## 语法\n\n对象主要来源于俩种形式：\n\n1. 字面量形式\n\n    ```js\n    var myObj = {};\n    ```\n\n2. 构造形式\n\n    ```js\n    var myObj = new Object();\n    ```\n\n## 类型\n\nJavscript 中的一切皆对象的理解是存在错误的。\n\n简单基本类型自身不是 object。typeof null 返回 object 是语言中的一个 bug，实际上 null 是它自己的基本类型。\n\n**内建对象**\n\n* String\n* Number\n* Boolean\n* Object\n* Function\n* Array\n* Date\n* RegExp\n* Error\n\n内建对象仅仅只是函数，每一个都可以被用作构造器。new 一个内建对象的结果是一个新构建的相应**子类型的对象**。\n\n```js\nvar strObj = new String(\"I am a string\");\nObject.prototype.toString.call(strObj); // [object String]\n```\n\n`Object.prototype.toString`方法可以考察自类型的内部。\n\n**内建对象与基本类型的关系？**\n\n基本类型不是一个对象，它是一个不可变的基本字面值。为了对它进行操作都需要一个相应的对象。\n\n在 js 中，必要的时候会将基本类型值转化为相应的对象类型，比如：\n\n```js\nvar str = \"I am a string\";\nconsole.log(str.length); // 13\n```\n\n这里调用`str.length`，js 会先将 str 转化成 `new String('I am a string')`，再进行属性读取。\n\n**特殊： null 和 undefined 没有基本包装类型。Date 没有字面量值。**\n\n**注意：仅在必要时使用构建形式，推荐使用字面形式**\n\n## 内容\n\n对象的内容是由属性构成的，属性就是储存在特定位置上（任意类型）的值。\n\n引擎会根据自己的实现来存储属性值，而且通常都不是把它们存储在对象内部。储存在对象内部的是这些对象的名称，它们像指针一样指向值存储的地方。\n\n**访问方式：**\n\n* 属性（property）访问\n\n    使用 `.` 操作符。后面接一个`标识符`。\n\n* 键（key）访问\n\n    使用 `[]` 操作符。可以接受任何兼容`UTF-8/unicode`的字符串。可以使用动态键（表达式）。\n\n属性名总是字符串。使用字符串以外的值，它会首先被转化为字符串。\n\n```js\nvar myObj = {};\nmyObj[true] = \"foo\";\nmyObj[3] = \"bar\";\nmyObj[myObj] = \"baz\";\n\nmyObj[\"true\"]; // foo\nmyObj[\"3\"]; // bar\nmyObj[\"[object Object]\"]; //baz\n```\n\n### 计算型属性名\n\n`[]`提供了使用表达式作为键名的方法。但这种方式并不支持使用字面量语法。\n\nES6 加入了计算型属性名，可以在字面量声明时通过`[]`指定表达式属性。\n\n```js\nvar prefix = \"foo\";\n\nvar myObj = {\n    [prefix + \"bar\"]: \"hello\"\n};\nmyObj[\"foobar\"]; // hello\n```\n\n### 属性(Property) vs 方法(Method)\n\n人们喜欢将属性进行区分，把属于对象（类）的函数称为方法。但从技术上讲，函数不会属于对象 ，因为 this 是在运行时动态绑定的，说明它与对象的关系至多是间接的。\n\n```js\nfunction foo() {\n    console.log(\"foo\");\n}\n\nvar someFoo = foo;\n\nvar myObj = {\n    someFoo: foo\n};\n\nfoo; // ƒ foo(){...}\nsomeFoo; // ƒ foo(){...}\nmyObj.someFoo; // ƒ foo(){...}\n```\n\n`myObj.someFoo` 和 `someFoo` 都是对 foo 函数的分离引用，它们并不意味着很特别或者被某个对象所拥有。\n\n### 数组\n\n跟对象采用键来存储值一样，数组采用数字索引（数字小标）来存储值。\n\n数组的索引都是非负整数。\n\n如果在数组上添加一个似数字属性，那么它会称为一个数组索引。\n\n```js\nvar foo = [\"foo\", 123];\nfoo[\"3\"] = \"bar\";\nfoo[3]; // bar\n```\n\n### 复制对象\n\n浅拷贝 和 深拷贝。\n\n使用 JSON 安全对象来进行神拷贝。\n\n### 属性描述符\n\n自 ES5 开始，js 添加了属性描述符来考察或者描述属性。\n\n```js\nvar obj = {\n    a: 2\n};\nObject.getOwnPropertyDescriptor(obj, \"a\");\n\n// {value: 2, writable: true, enumerable: true, configurable: true}\n```\n\n属性描述符：\n\n* writable\n\n    可写性。设置为 false 则不可写。\n\n* enumerable\n\n    可枚举性。它控制对象属性能否被枚举，比如 for...in 循环。\n\n    ```js\n    var myObject = {};\n    Object.defineProperty(\n        myObject,\n        \"a\",\n        // 让 a 像普通属性一样可以枚举\n        { enumerable: true, value: 2 }\n    );\n    Object.defineProperty(\n        myObject,\n        \"b\",\n        // 让 b 不可枚举\n        { enumerable: false, value: 3 }\n    );\n\n    for (var k in myObject) {\n        console.log(k, myObject[k]);\n    }\n    // a 2\n    ```\n\n    可以看到，myObject.b 不会出现在 for..in 循环中。\n\n    其他检验属性是否可枚举的方法：\n\n    1. `propertyIsEnumerable(..)` 会检查给定的属性名是否直接存在于对象中(而不是在原型链 上)并且满足 `enumerable:true`。\n\n        ```js\n        myObject.propertyIsEnumerable(\"a\"); //true\n        myObject.propertyIsEnumerable(\"b\"); // false\n        ```\n\n    2. `Object.keys(..)` 会返回一个数组，包含所有可枚举属性，`Object.getOwnPropertyNames(..)` 会返回一个数组，包含所有属性，无论它们是否可枚举。\n\n        ```js\n        Object.keys(myObject); // [\"a\"]\n        Object.getOwnPropertyNames(myObject); //  [\"a\", \"b\"]\n        ```\n\n- configurable\n\n    可配置性。将它设为 false：\n\n    * defineProperty 也不可再使用，会报错。（说明是单向操作，不可撤销）\n    * delete 操作失效\n\n我们可以使用`Object.defineProperty`来添加和修改属性。\n\n### 不变性\n\n如何实现属性/对象的不可变性？\n\n1. 对象常量\n\n    通过 `writable: false` 和 `configurable: false`可以实现常量的创建。不可改变，重定义或者删除。\n\n2. 防止扩展\n\n    通过 `Object.preventExtensions()` 方法可以防止一个对象添加新属性。\n\n    ```js\n    var obj = { a: 1 };\n    Object.preventExtensions(obj);\n    obj.b = 2;\n    obj.b; //undefined\n    ```\n\n3. 封印\n\n    `Object.seal()`创建一个封印的对象。它既防扩展又不可配置。相等于同事调用`Object.preventExtensions()`和设置`configurable: false`。\n\n4. 冻结\n\n    `Object.freeze()`创建一个冻结对象。它相当于`Object.seal()` + `writable: false`。这事目前最高级别的不可变性。\n\n### [[Get]]\n\n属性访问实际上执行了一个 `[[Get]]` 操作。它会首先检查对象，查找是否有名称相同的属性：\n\n1. 存在，返回相应的值。\n2. 不存在，返回 `undefined`。（这个查找会遍历原型链）\n\n```js\nvar myObject = {\n    a: 2\n};\nmyObject.a; // 2\nmyObject.b; // undefined\n```\n\n\n### [[Put]]\n\n相应于 `[[Get]]` 操作，js 有个相应的 `[[Put]]` 操作。\n\n[[Put]] 操作的实际行为取决于许多因素，包括对象中是否已经存在这个属性(这是最重要的因素)。\n\n如果已经存在这个属性：\n\n1. 属性是否是访问描述符(参见 Getter 和 Setter)?如果是并且存在 setter 就调用 setter。\n2. 属性的数据描述符中 writable 是否是 false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。\n3. 如果都不是，将该值设置为属性的值。\n\n如果不存在，更复杂，详见[原型]()\n\n### Getter 和 Setter\n\n对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。\n\n在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。\n\ngetter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏函数，会在设置属性值时调用。\n\n当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述符”\n\nJavaScript 会忽略访问描述符的 value 和 writable 特性，取而代之的是关心 set 和 get(还有 configurable 和 enumerable)特性。\n\n```js\nvar myObject = {\n    // 给 a 定义一个 getter\n    get a() {\n        return 2;\n    }\n};\n\nObject.defineProperty(\n    myObject, // 目标对象 \"b\", // 属性名\n    \"b\",\n    {\n        // 给 b 设置一个 getter\n        get: function() {\n            return this.a * 2;\n        },\n        // 确保 b 会出现在对象的属性列表中\n        enumerable: true\n    }\n);\n\nmyObject.a; // 2\nmyObject.b; // 4\n```\n\n`get a() { .. }`和`defineProperty(..)`都会在对象中创建一个不包含值的属性, 对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值。\n\n通常来说 getter 和 setter 是成对出现的(只定义一个的话 通常会产生意料之外的行为):\n\n```js\nvar myObject = {\n    // 给 a 定义一个 getter\n    get a() {\n        return this._a_;\n    },\n    // 给 a 定义一个 setter\n    set a(val) {\n        this._a_ = val * 2;\n    }\n};\nmyObject.a = 2;\nmyObject.a; // 4\n```\n\n### 存在性\n\n```js\nvar myObject = {\n    a: undefined\n};\nmyObject.a; //undefined\nmyObject.b; //undefined\n```\n\n一个属性值有可能 是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分 这两种情况呢?\n\n1. in\n   in 操作符会检查**属性名**在对象及其 [[Prototype]] 原型链中是否存在\n\n    ```js\n    \"a\" in myObject; //true\n    \"b\" in myObject; //false\n    ```\n\n2. hasOwnProperty\n   只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。\n\n    ```js\n    myObject.hasOwnProperty(\"a\"); //true\n    myObject.hasOwnProperty(\"b\"); //false\n    ```\n\n## 遍历\n\n1. for..in\n2. for 循环\n3. forEach(..)、every(..) 和 some(..)\n4. for..of\n","slug":"this与对象原型(二)","published":1,"date":"2021-12-06T06:07:05.867Z","updated":"2021-12-06T06:07:05.867Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolu0030y4v21rxcastp","content":"<h1 id=\"YDKJS-this-与对象原型-二\"><a href=\"#YDKJS-this-与对象原型-二\" class=\"headerlink\" title=\"YDKJS:this 与对象原型(二)\"></a>YDKJS:this 与对象原型(二)</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#ydkjsthis-%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E4%BA%8C\">YDKJS:this 与对象原型(二)</a><ul>\n<li><a href=\"#%E8%AF%AD%E6%B3%95\">语法</a></li>\n<li><a href=\"#%E7%B1%BB%E5%9E%8B\">类型</a></li>\n<li><a href=\"#%E5%86%85%E5%AE%B9\">内容</a><ul>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E5%9E%8B%E5%B1%9E%E6%80%A7%E5%90%8D\">计算型属性名</a></li>\n<li><a href=\"#%E5%B1%9E%E6%80%A7property-vs-%E6%96%B9%E6%B3%95method\">属性(Property) vs 方法(Method)</a></li>\n<li><a href=\"#%E6%95%B0%E7%BB%84\">数组</a></li>\n<li><a href=\"#%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1\">复制对象</a></li>\n<li><a href=\"#%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6\">属性描述符</a></li>\n<li><a href=\"#%E4%B8%8D%E5%8F%98%E6%80%A7\">不变性</a></li>\n<li>[[[Get]]](#get)</li>\n<li>[[[Put]]](#put)</li>\n<li><a href=\"#getter-%E5%92%8C-setter\">Getter 和 Setter</a></li>\n<li><a href=\"#%E5%AD%98%E5%9C%A8%E6%80%A7\">存在性</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%81%8D%E5%8E%86\">遍历</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<p>什么是对象？this 为什么需要指向对象？</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>对象主要来源于俩种形式：</p>\n<ol>\n<li><p>字面量形式</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p>构造形式</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p>Javscript 中的一切皆对象的理解是存在错误的。</p>\n<p>简单基本类型自身不是 object。typeof null 返回 object 是语言中的一个 bug，实际上 null 是它自己的基本类型。</p>\n<p><strong>内建对象</strong></p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Object</li>\n<li>Function</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n</ul>\n<p>内建对象仅仅只是函数，每一个都可以被用作构造器。new 一个内建对象的结果是一个新构建的相应<strong>子类型的对象</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> strObj = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;I am a string&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(strObj); <span class=\"comment\">// [object String]</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Object.prototype.toString</code>方法可以考察自类型的内部。</p>\n<p><strong>内建对象与基本类型的关系？</strong></p>\n<p>基本类型不是一个对象，它是一个不可变的基本字面值。为了对它进行操作都需要一个相应的对象。</p>\n<p>在 js 中，必要的时候会将基本类型值转化为相应的对象类型，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;I am a string&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.length); <span class=\"comment\">// 13</span></span><br></pre></td></tr></table></figure>\n\n<p>这里调用<code>str.length</code>，js 会先将 str 转化成 <code>new String(&#39;I am a string&#39;)</code>，再进行属性读取。</p>\n<p><strong>特殊： null 和 undefined 没有基本包装类型。Date 没有字面量值。</strong></p>\n<p><strong>注意：仅在必要时使用构建形式，推荐使用字面形式</strong></p>\n<h2 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h2><p>对象的内容是由属性构成的，属性就是储存在特定位置上（任意类型）的值。</p>\n<p>引擎会根据自己的实现来存储属性值，而且通常都不是把它们存储在对象内部。储存在对象内部的是这些对象的名称，它们像指针一样指向值存储的地方。</p>\n<p><strong>访问方式：</strong></p>\n<ul>\n<li><p>属性（property）访问</p>\n<p>  使用 <code>.</code> 操作符。后面接一个<code>标识符</code>。</p>\n</li>\n<li><p>键（key）访问</p>\n<p>  使用 <code>[]</code> 操作符。可以接受任何兼容<code>UTF-8/unicode</code>的字符串。可以使用动态键（表达式）。</p>\n</li>\n</ul>\n<p>属性名总是字符串。使用字符串以外的值，它会首先被转化为字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;&#125;;</span><br><span class=\"line\">myObj[<span class=\"literal\">true</span>] = <span class=\"string\">&quot;foo&quot;</span>;</span><br><span class=\"line\">myObj[<span class=\"number\">3</span>] = <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\">myObj[myObj] = <span class=\"string\">&quot;baz&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myObj[<span class=\"string\">&quot;true&quot;</span>]; <span class=\"comment\">// foo</span></span><br><span class=\"line\">myObj[<span class=\"string\">&quot;3&quot;</span>]; <span class=\"comment\">// bar</span></span><br><span class=\"line\">myObj[<span class=\"string\">&quot;[object Object]&quot;</span>]; <span class=\"comment\">//baz</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"计算型属性名\"><a href=\"#计算型属性名\" class=\"headerlink\" title=\"计算型属性名\"></a>计算型属性名</h3><p><code>[]</code>提供了使用表达式作为键名的方法。但这种方式并不支持使用字面量语法。</p>\n<p>ES6 加入了计算型属性名，可以在字面量声明时通过<code>[]</code>指定表达式属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> prefix = <span class=\"string\">&quot;foo&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">    [prefix + <span class=\"string\">&quot;bar&quot;</span>]: <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObj[<span class=\"string\">&quot;foobar&quot;</span>]; <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性-Property-vs-方法-Method\"><a href=\"#属性-Property-vs-方法-Method\" class=\"headerlink\" title=\"属性(Property) vs 方法(Method)\"></a>属性(Property) vs 方法(Method)</h3><p>人们喜欢将属性进行区分，把属于对象（类）的函数称为方法。但从技术上讲，函数不会属于对象 ，因为 this 是在运行时动态绑定的，说明它与对象的关系至多是间接的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> someFoo = foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">someFoo</span>: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo; <span class=\"comment\">// ƒ foo()&#123;...&#125;</span></span><br><span class=\"line\">someFoo; <span class=\"comment\">// ƒ foo()&#123;...&#125;</span></span><br><span class=\"line\">myObj.someFoo; <span class=\"comment\">// ƒ foo()&#123;...&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>myObj.someFoo</code> 和 <code>someFoo</code> 都是对 foo 函数的分离引用，它们并不意味着很特别或者被某个对象所拥有。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>跟对象采用键来存储值一样，数组采用数字索引（数字小标）来存储值。</p>\n<p>数组的索引都是非负整数。</p>\n<p>如果在数组上添加一个似数字属性，那么它会称为一个数组索引。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = [<span class=\"string\">&quot;foo&quot;</span>, <span class=\"number\">123</span>];</span><br><span class=\"line\">foo[<span class=\"string\">&quot;3&quot;</span>] = <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\">foo[<span class=\"number\">3</span>]; <span class=\"comment\">// bar</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"复制对象\"><a href=\"#复制对象\" class=\"headerlink\" title=\"复制对象\"></a>复制对象</h3><p>浅拷贝 和 深拷贝。</p>\n<p>使用 JSON 安全对象来进行神拷贝。</p>\n<h3 id=\"属性描述符\"><a href=\"#属性描述符\" class=\"headerlink\" title=\"属性描述符\"></a>属性描述符</h3><p>自 ES5 开始，js 添加了属性描述符来考察或者描述属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性描述符：</p>\n<ul>\n<li><p>writable</p>\n<p>  可写性。设置为 false 则不可写。</p>\n</li>\n<li><p>enumerable</p>\n<p>  可枚举性。它控制对象属性能否被枚举，比如 for…in 循环。</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(</span><br><span class=\"line\">    myObject,</span><br><span class=\"line\">    <span class=\"string\">&quot;a&quot;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 让 a 像普通属性一样可以枚举</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(</span><br><span class=\"line\">    myObject,</span><br><span class=\"line\">    <span class=\"string\">&quot;b&quot;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 让 b 不可枚举</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span>, <span class=\"attr\">value</span>: <span class=\"number\">3</span> &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> myObject) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(k, myObject[k]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// a 2</span></span><br></pre></td></tr></table></figure>\n\n<p>  可以看到，myObject.b 不会出现在 for..in 循环中。</p>\n<p>  其他检验属性是否可枚举的方法：</p>\n<ol>\n<li><p><code>propertyIsEnumerable(..)</code> 会检查给定的属性名是否直接存在于对象中(而不是在原型链 上)并且满足 <code>enumerable:true</code>。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObject.propertyIsEnumerable(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\">myObject.propertyIsEnumerable(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>Object.keys(..)</code> 会返回一个数组，包含所有可枚举属性，<code>Object.getOwnPropertyNames(..)</code> 会返回一个数组，包含所有属性，无论它们是否可枚举。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(myObject); <span class=\"comment\">// [&quot;a&quot;]</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(myObject); <span class=\"comment\">//  [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>configurable</p>\n<p>  可配置性。将它设为 false：</p>\n<ul>\n<li>defineProperty 也不可再使用，会报错。（说明是单向操作，不可撤销）</li>\n<li>delete 操作失效</li>\n</ul>\n</li>\n</ul>\n<p>我们可以使用<code>Object.defineProperty</code>来添加和修改属性。</p>\n<h3 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h3><p>如何实现属性/对象的不可变性？</p>\n<ol>\n<li><p>对象常量</p>\n<p> 通过 <code>writable: false</code> 和 <code>configurable: false</code>可以实现常量的创建。不可改变，重定义或者删除。</p>\n</li>\n<li><p>防止扩展</p>\n<p> 通过 <code>Object.preventExtensions()</code> 方法可以防止一个对象添加新属性。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions(obj);</span><br><span class=\"line\">obj.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">obj.b; <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure></li>\n<li><p>封印</p>\n<p> <code>Object.seal()</code>创建一个封印的对象。它既防扩展又不可配置。相等于同事调用<code>Object.preventExtensions()</code>和设置<code>configurable: false</code>。</p>\n</li>\n<li><p>冻结</p>\n<p> <code>Object.freeze()</code>创建一个冻结对象。它相当于<code>Object.seal()</code> + <code>writable: false</code>。这事目前最高级别的不可变性。</p>\n</li>\n</ol>\n<h3 id=\"Get\"><a href=\"#Get\" class=\"headerlink\" title=\"[[Get]]\"></a>[[Get]]</h3><p>属性访问实际上执行了一个 <code>[[Get]]</code> 操作。它会首先检查对象，查找是否有名称相同的属性：</p>\n<ol>\n<li>存在，返回相应的值。</li>\n<li>不存在，返回 <code>undefined</code>。（这个查找会遍历原型链）</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.b; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Put\"><a href=\"#Put\" class=\"headerlink\" title=\"[[Put]]\"></a>[[Put]]</h3><p>相应于 <code>[[Get]]</code> 操作，js 有个相应的 <code>[[Put]]</code> 操作。</p>\n<p>[[Put]] 操作的实际行为取决于许多因素，包括对象中是否已经存在这个属性(这是最重要的因素)。</p>\n<p>如果已经存在这个属性：</p>\n<ol>\n<li>属性是否是访问描述符(参见 Getter 和 Setter)?如果是并且存在 setter 就调用 setter。</li>\n<li>属性的数据描述符中 writable 是否是 false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。</li>\n<li>如果都不是，将该值设置为属性的值。</li>\n</ol>\n<p>如果不存在，更复杂，详见<a href=\"\">原型</a></p>\n<h3 id=\"Getter-和-Setter\"><a href=\"#Getter-和-Setter\" class=\"headerlink\" title=\"Getter 和 Setter\"></a>Getter 和 Setter</h3><p>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。</p>\n<p>在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。</p>\n<p>getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏函数，会在设置属性值时调用。</p>\n<p>当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述符”</p>\n<p>JavaScript 会忽略访问描述符的 value 和 writable 特性，取而代之的是关心 set 和 get(还有 configurable 和 enumerable)特性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 给 a 定义一个 getter</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title\">a</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(</span><br><span class=\"line\">    myObject, <span class=\"comment\">// 目标对象 &quot;b&quot;, // 属性名</span></span><br><span class=\"line\">    <span class=\"string\">&quot;b&quot;</span>,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 给 b 设置一个 getter</span></span><br><span class=\"line\">        <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.a * <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">// 确保 b 会出现在对象的属性列表中</span></span><br><span class=\"line\">        <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.b; <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<p><code>get a() &#123; .. &#125;</code>和<code>defineProperty(..)</code>都会在对象中创建一个不包含值的属性, 对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值。</p>\n<p>通常来说 getter 和 setter 是成对出现的(只定义一个的话 通常会产生意料之外的行为):</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 给 a 定义一个 getter</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title\">a</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._a_;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 给 a 定义一个 setter</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title\">a</span>(<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._a_ = val * <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.a = <span class=\"number\">2</span>;</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存在性\"><a href=\"#存在性\" class=\"headerlink\" title=\"存在性\"></a>存在性</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.a; <span class=\"comment\">//undefined</span></span><br><span class=\"line\">myObject.b; <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>一个属性值有可能 是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分 这两种情况呢?</p>\n<ol>\n<li><p>in<br>in 操作符会检查<strong>属性名</strong>在对象及其 [[Prototype]] 原型链中是否存在</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;a&quot;</span> <span class=\"keyword\">in</span> myObject; <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"string\">&quot;b&quot;</span> <span class=\"keyword\">in</span> myObject; <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></li>\n<li><p>hasOwnProperty<br>只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObject.hasOwnProperty(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\">myObject.hasOwnProperty(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><ol>\n<li>for..in</li>\n<li>for 循环</li>\n<li>forEach(..)、every(..) 和 some(..)</li>\n<li>for..of</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"YDKJS-this-与对象原型-二\"><a href=\"#YDKJS-this-与对象原型-二\" class=\"headerlink\" title=\"YDKJS:this 与对象原型(二)\"></a>YDKJS:this 与对象原型(二)</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#ydkjsthis-%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E4%BA%8C\">YDKJS:this 与对象原型(二)</a><ul>\n<li><a href=\"#%E8%AF%AD%E6%B3%95\">语法</a></li>\n<li><a href=\"#%E7%B1%BB%E5%9E%8B\">类型</a></li>\n<li><a href=\"#%E5%86%85%E5%AE%B9\">内容</a><ul>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E5%9E%8B%E5%B1%9E%E6%80%A7%E5%90%8D\">计算型属性名</a></li>\n<li><a href=\"#%E5%B1%9E%E6%80%A7property-vs-%E6%96%B9%E6%B3%95method\">属性(Property) vs 方法(Method)</a></li>\n<li><a href=\"#%E6%95%B0%E7%BB%84\">数组</a></li>\n<li><a href=\"#%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1\">复制对象</a></li>\n<li><a href=\"#%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6\">属性描述符</a></li>\n<li><a href=\"#%E4%B8%8D%E5%8F%98%E6%80%A7\">不变性</a></li>\n<li>[[[Get]]](#get)</li>\n<li>[[[Put]]](#put)</li>\n<li><a href=\"#getter-%E5%92%8C-setter\">Getter 和 Setter</a></li>\n<li><a href=\"#%E5%AD%98%E5%9C%A8%E6%80%A7\">存在性</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%81%8D%E5%8E%86\">遍历</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<p>什么是对象？this 为什么需要指向对象？</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>对象主要来源于俩种形式：</p>\n<ol>\n<li><p>字面量形式</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p>构造形式</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p>Javscript 中的一切皆对象的理解是存在错误的。</p>\n<p>简单基本类型自身不是 object。typeof null 返回 object 是语言中的一个 bug，实际上 null 是它自己的基本类型。</p>\n<p><strong>内建对象</strong></p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Object</li>\n<li>Function</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n</ul>\n<p>内建对象仅仅只是函数，每一个都可以被用作构造器。new 一个内建对象的结果是一个新构建的相应<strong>子类型的对象</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> strObj = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;I am a string&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(strObj); <span class=\"comment\">// [object String]</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Object.prototype.toString</code>方法可以考察自类型的内部。</p>\n<p><strong>内建对象与基本类型的关系？</strong></p>\n<p>基本类型不是一个对象，它是一个不可变的基本字面值。为了对它进行操作都需要一个相应的对象。</p>\n<p>在 js 中，必要的时候会将基本类型值转化为相应的对象类型，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;I am a string&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.length); <span class=\"comment\">// 13</span></span><br></pre></td></tr></table></figure>\n\n<p>这里调用<code>str.length</code>，js 会先将 str 转化成 <code>new String(&#39;I am a string&#39;)</code>，再进行属性读取。</p>\n<p><strong>特殊： null 和 undefined 没有基本包装类型。Date 没有字面量值。</strong></p>\n<p><strong>注意：仅在必要时使用构建形式，推荐使用字面形式</strong></p>\n<h2 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h2><p>对象的内容是由属性构成的，属性就是储存在特定位置上（任意类型）的值。</p>\n<p>引擎会根据自己的实现来存储属性值，而且通常都不是把它们存储在对象内部。储存在对象内部的是这些对象的名称，它们像指针一样指向值存储的地方。</p>\n<p><strong>访问方式：</strong></p>\n<ul>\n<li><p>属性（property）访问</p>\n<p>  使用 <code>.</code> 操作符。后面接一个<code>标识符</code>。</p>\n</li>\n<li><p>键（key）访问</p>\n<p>  使用 <code>[]</code> 操作符。可以接受任何兼容<code>UTF-8/unicode</code>的字符串。可以使用动态键（表达式）。</p>\n</li>\n</ul>\n<p>属性名总是字符串。使用字符串以外的值，它会首先被转化为字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;&#125;;</span><br><span class=\"line\">myObj[<span class=\"literal\">true</span>] = <span class=\"string\">&quot;foo&quot;</span>;</span><br><span class=\"line\">myObj[<span class=\"number\">3</span>] = <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\">myObj[myObj] = <span class=\"string\">&quot;baz&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myObj[<span class=\"string\">&quot;true&quot;</span>]; <span class=\"comment\">// foo</span></span><br><span class=\"line\">myObj[<span class=\"string\">&quot;3&quot;</span>]; <span class=\"comment\">// bar</span></span><br><span class=\"line\">myObj[<span class=\"string\">&quot;[object Object]&quot;</span>]; <span class=\"comment\">//baz</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"计算型属性名\"><a href=\"#计算型属性名\" class=\"headerlink\" title=\"计算型属性名\"></a>计算型属性名</h3><p><code>[]</code>提供了使用表达式作为键名的方法。但这种方式并不支持使用字面量语法。</p>\n<p>ES6 加入了计算型属性名，可以在字面量声明时通过<code>[]</code>指定表达式属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> prefix = <span class=\"string\">&quot;foo&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">    [prefix + <span class=\"string\">&quot;bar&quot;</span>]: <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObj[<span class=\"string\">&quot;foobar&quot;</span>]; <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性-Property-vs-方法-Method\"><a href=\"#属性-Property-vs-方法-Method\" class=\"headerlink\" title=\"属性(Property) vs 方法(Method)\"></a>属性(Property) vs 方法(Method)</h3><p>人们喜欢将属性进行区分，把属于对象（类）的函数称为方法。但从技术上讲，函数不会属于对象 ，因为 this 是在运行时动态绑定的，说明它与对象的关系至多是间接的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> someFoo = foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">someFoo</span>: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo; <span class=\"comment\">// ƒ foo()&#123;...&#125;</span></span><br><span class=\"line\">someFoo; <span class=\"comment\">// ƒ foo()&#123;...&#125;</span></span><br><span class=\"line\">myObj.someFoo; <span class=\"comment\">// ƒ foo()&#123;...&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>myObj.someFoo</code> 和 <code>someFoo</code> 都是对 foo 函数的分离引用，它们并不意味着很特别或者被某个对象所拥有。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>跟对象采用键来存储值一样，数组采用数字索引（数字小标）来存储值。</p>\n<p>数组的索引都是非负整数。</p>\n<p>如果在数组上添加一个似数字属性，那么它会称为一个数组索引。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = [<span class=\"string\">&quot;foo&quot;</span>, <span class=\"number\">123</span>];</span><br><span class=\"line\">foo[<span class=\"string\">&quot;3&quot;</span>] = <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\">foo[<span class=\"number\">3</span>]; <span class=\"comment\">// bar</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"复制对象\"><a href=\"#复制对象\" class=\"headerlink\" title=\"复制对象\"></a>复制对象</h3><p>浅拷贝 和 深拷贝。</p>\n<p>使用 JSON 安全对象来进行神拷贝。</p>\n<h3 id=\"属性描述符\"><a href=\"#属性描述符\" class=\"headerlink\" title=\"属性描述符\"></a>属性描述符</h3><p>自 ES5 开始，js 添加了属性描述符来考察或者描述属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性描述符：</p>\n<ul>\n<li><p>writable</p>\n<p>  可写性。设置为 false 则不可写。</p>\n</li>\n<li><p>enumerable</p>\n<p>  可枚举性。它控制对象属性能否被枚举，比如 for…in 循环。</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(</span><br><span class=\"line\">    myObject,</span><br><span class=\"line\">    <span class=\"string\">&quot;a&quot;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 让 a 像普通属性一样可以枚举</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(</span><br><span class=\"line\">    myObject,</span><br><span class=\"line\">    <span class=\"string\">&quot;b&quot;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 让 b 不可枚举</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span>, <span class=\"attr\">value</span>: <span class=\"number\">3</span> &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> myObject) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(k, myObject[k]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// a 2</span></span><br></pre></td></tr></table></figure>\n\n<p>  可以看到，myObject.b 不会出现在 for..in 循环中。</p>\n<p>  其他检验属性是否可枚举的方法：</p>\n<ol>\n<li><p><code>propertyIsEnumerable(..)</code> 会检查给定的属性名是否直接存在于对象中(而不是在原型链 上)并且满足 <code>enumerable:true</code>。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObject.propertyIsEnumerable(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\">myObject.propertyIsEnumerable(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>Object.keys(..)</code> 会返回一个数组，包含所有可枚举属性，<code>Object.getOwnPropertyNames(..)</code> 会返回一个数组，包含所有属性，无论它们是否可枚举。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(myObject); <span class=\"comment\">// [&quot;a&quot;]</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(myObject); <span class=\"comment\">//  [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>configurable</p>\n<p>  可配置性。将它设为 false：</p>\n<ul>\n<li>defineProperty 也不可再使用，会报错。（说明是单向操作，不可撤销）</li>\n<li>delete 操作失效</li>\n</ul>\n</li>\n</ul>\n<p>我们可以使用<code>Object.defineProperty</code>来添加和修改属性。</p>\n<h3 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h3><p>如何实现属性/对象的不可变性？</p>\n<ol>\n<li><p>对象常量</p>\n<p> 通过 <code>writable: false</code> 和 <code>configurable: false</code>可以实现常量的创建。不可改变，重定义或者删除。</p>\n</li>\n<li><p>防止扩展</p>\n<p> 通过 <code>Object.preventExtensions()</code> 方法可以防止一个对象添加新属性。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions(obj);</span><br><span class=\"line\">obj.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">obj.b; <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure></li>\n<li><p>封印</p>\n<p> <code>Object.seal()</code>创建一个封印的对象。它既防扩展又不可配置。相等于同事调用<code>Object.preventExtensions()</code>和设置<code>configurable: false</code>。</p>\n</li>\n<li><p>冻结</p>\n<p> <code>Object.freeze()</code>创建一个冻结对象。它相当于<code>Object.seal()</code> + <code>writable: false</code>。这事目前最高级别的不可变性。</p>\n</li>\n</ol>\n<h3 id=\"Get\"><a href=\"#Get\" class=\"headerlink\" title=\"[[Get]]\"></a>[[Get]]</h3><p>属性访问实际上执行了一个 <code>[[Get]]</code> 操作。它会首先检查对象，查找是否有名称相同的属性：</p>\n<ol>\n<li>存在，返回相应的值。</li>\n<li>不存在，返回 <code>undefined</code>。（这个查找会遍历原型链）</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.b; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Put\"><a href=\"#Put\" class=\"headerlink\" title=\"[[Put]]\"></a>[[Put]]</h3><p>相应于 <code>[[Get]]</code> 操作，js 有个相应的 <code>[[Put]]</code> 操作。</p>\n<p>[[Put]] 操作的实际行为取决于许多因素，包括对象中是否已经存在这个属性(这是最重要的因素)。</p>\n<p>如果已经存在这个属性：</p>\n<ol>\n<li>属性是否是访问描述符(参见 Getter 和 Setter)?如果是并且存在 setter 就调用 setter。</li>\n<li>属性的数据描述符中 writable 是否是 false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。</li>\n<li>如果都不是，将该值设置为属性的值。</li>\n</ol>\n<p>如果不存在，更复杂，详见<a href=\"\">原型</a></p>\n<h3 id=\"Getter-和-Setter\"><a href=\"#Getter-和-Setter\" class=\"headerlink\" title=\"Getter 和 Setter\"></a>Getter 和 Setter</h3><p>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。</p>\n<p>在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。</p>\n<p>getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏函数，会在设置属性值时调用。</p>\n<p>当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述符”</p>\n<p>JavaScript 会忽略访问描述符的 value 和 writable 特性，取而代之的是关心 set 和 get(还有 configurable 和 enumerable)特性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 给 a 定义一个 getter</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title\">a</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(</span><br><span class=\"line\">    myObject, <span class=\"comment\">// 目标对象 &quot;b&quot;, // 属性名</span></span><br><span class=\"line\">    <span class=\"string\">&quot;b&quot;</span>,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 给 b 设置一个 getter</span></span><br><span class=\"line\">        <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.a * <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">// 确保 b 会出现在对象的属性列表中</span></span><br><span class=\"line\">        <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.b; <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<p><code>get a() &#123; .. &#125;</code>和<code>defineProperty(..)</code>都会在对象中创建一个不包含值的属性, 对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值。</p>\n<p>通常来说 getter 和 setter 是成对出现的(只定义一个的话 通常会产生意料之外的行为):</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 给 a 定义一个 getter</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title\">a</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._a_;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 给 a 定义一个 setter</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title\">a</span>(<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._a_ = val * <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.a = <span class=\"number\">2</span>;</span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存在性\"><a href=\"#存在性\" class=\"headerlink\" title=\"存在性\"></a>存在性</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.a; <span class=\"comment\">//undefined</span></span><br><span class=\"line\">myObject.b; <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>一个属性值有可能 是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分 这两种情况呢?</p>\n<ol>\n<li><p>in<br>in 操作符会检查<strong>属性名</strong>在对象及其 [[Prototype]] 原型链中是否存在</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;a&quot;</span> <span class=\"keyword\">in</span> myObject; <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"string\">&quot;b&quot;</span> <span class=\"keyword\">in</span> myObject; <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></li>\n<li><p>hasOwnProperty<br>只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObject.hasOwnProperty(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\">myObject.hasOwnProperty(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><ol>\n<li>for..in</li>\n<li>for 循环</li>\n<li>forEach(..)、every(..) 和 some(..)</li>\n<li>for..of</li>\n</ol>\n"},{"_content":"# YDKJS:this 与对象原型(三)\n\n<!-- TOC -->\n\n- [YDKJS:this 与对象原型(三)](#ydkjsthis-与对象原型三)\n    - [类和面向对象](#类和面向对象)\n        - [类的设计模式](#类的设计模式)\n        - [类理论](#类理论)\n        - [类机制](#类机制)\n            - [建造](#建造)\n            - [构造函数](#构造函数)\n        - [类继承](#类继承)\n            - [多态](#多态)\n            - [多重继承](#多重继承)\n    - [javascript 中的类](#javascript-中的类)\n        - [混入](#混入)\n            - [显式混入](#显式混入)\n            - [隐式混入](#隐式混入)\n        - [寄生](#寄生)\n\n<!-- /TOC -->\n\n## 类和面向对象\n\n类是一种设计模式：实例化(instantiation)、继承(inheritance)和（相对）多态(polymorphism)。\n\n### 类的设计模式\n\n**类是非常常用的一种设计模式**。\n\n### 类理论\n\n类／继承描述了代码的一种组织结构形式。\n\n面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为打包(或者说封装)起来。\n\n举例来说，一个单词是一个字符串，它就是数据，但它往往还需要很多行为（截断、拼接等）。 如果采用面向对象的方式，将这种数据和行为封装在一起，就设计成了`String`类。\n\n### 类机制\n\n#### 建造\n\n“类”和“实例”的概念来源于房屋建造。一个类就是一张蓝图，按照这个蓝图所建造的具体建筑物就是实例。\n\n> 类意味着**复制**。\n\n#### 构造函数\n\n构造函数的特点：\n\n* 是一个类方法\n* 通常与类同名\n* 大多需要 `new` 来调用\n\n### 类继承\n\n可以先定义一个类，然后定义一个继承前者的类，后者通常被称为“子类”，前者通常被称为“父类”。\n\n“子类”和“父类”二者之间没有直接的联系。定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。\n\n```\n// 语法自编\nclass Vehicle {\n    engines = 1\n    ignition() {\n        output( \"Turning on my engine.\" );\n    }\n    drive() {\n        ignition();\n        output( \"Steering and moving forward!\" )\n    }\n}\nclass Car inherits Vehicle { wheels = 4\n    drive() {\n        inherited:drive()\n        output( \"Rolling on all \", wheels, \" wheels!\" )\n    }\n}\nclass SpeedBoat inherits Vehicle { engines = 2\n    ignition() {\n        output( \"Turning on my \", engines, \" engines.\" )\n    }\n    pilot() {\n        inherited:drive()\n        output( \"Speeding through the water with ease!\" )\n    }\n}\n```\n\n#### 多态\n\n> 子类的方法中引用继承来的原始方法，这个技术被称为多态或者虚拟多态。\n\n多态是一个非常广泛的话题，它包含多个方面：\n\n* 任何方法都可以引用继承层次中高层的方法(无论高层的方法名和当前方法名是否相同)。\n* 在继承链的不同层次中一个方法名可以被多次定义，当调用方法时 会自动选择合适的定义。\n\n#### 多重继承\n\n有些语言允许你继承多个“父类”，多重继承意味着所有父类的定义都会被复制到子类中。\n\nJavaScript 要本身并不提供“多重继承”功能。但开发者们尝试了各种各样的办法来实现多重继承。\n\n## javascript 中的类\n\n> JavaScript 中实际上并没有有类\n\n但由于类是一种设计模式，所以我们可以用一些方法近似实现类的功能。 为了满足对于类设计模式的最普遍需求，JavaScript 提供了一些近似类的语法。\n\n### 混入\n\n混入：javascript 中类的实现。\n\n> 在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为。\n\nJavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来。\n\n#### 显式混入\n\nJavaScript 不会自动实现类的复制行为，所以我们需要手动实现复制功能。\n\n```js\nfunction mixin(sourceObj, targetObj) {\n    for (var key in sourceObj) {\n        // 只会在不存在的情况下复制\n        if (!(key in targetObj)) {\n            targetObj[key] = sourceObj[key];\n        }\n    }\n    return targetObj;\n}\nvar Vehicle = {\n    engines: 1,\n    ignition: function() {\n        console.log(\"点火\");\n    },\n    drive: function() {\n        this.ignition();\n        console.log(\"行驶\");\n    }\n};\nvar Car = mixin(Vehicle, {\n    wheels: 4,\n    drive: function() {\n        Vehicle.drive.call(this);\n        console.log(\"Rolling on all \" + this.wheels + \" wheels!\");\n    }\n});\n```\n\n这里我们处理的已经不再是类了，因为在 JavaScript 中不存在 类，Vehicle 和 Car 都是对象，供我们分别进行复制和粘贴。\n\n复制操作完成后，Car 就和 Vehicle 分离了，向 Car 中添加属性不会影响 Vehicle，反之 亦然。\n\n缺点：\n\n1. 显式混入实际上无法完全模拟类的复制行为，，因为对象(函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。\n2. 并不能带来太多的好处，无非就是少几条定义语句，\n\n#### 隐式混入\n\n```js\nvar Something = {\n    cool: function() {\n        this.greeting = \"Hello World\";\n        this.count = this.count ? this.count + 1 : 1;\n    }\n};\n\nSomething.cool();\nSomething.greeting; // \"Hello World\"\nSomething.count; // 1\nvar Another = {\n    cool: function() {\n        // 隐式把 Something 混入 Another\n        Something.cool.call(this);\n    }\n};\nAnother.cool();\nAnother.greeting; // \"Hello World\"\nAnother.count; // 1(count 不是共享状态)\n```\n\n但是`Something.cool.call( this )`仍然无法变成相对(而且更灵活的)引用，所以使用时千万要小心。通常来说，尽量避免使用这样的结构，以保证代码的整洁和可维护性。\n\n### 寄生\n\n显式混入模式的一种变体被称为“寄生继承”，它既是显式的又是隐式的\n\n```js\n//“传统的 JavaScript 类”Vehicle\nfunction Vehicle() {\n    this.engines = 1;\n}\n\nVehicle.prototype.ignition = function() {\n    console.log(\"点火\");\n};\nVehicle.prototype.drive = function() {\n    this.ignition();\n    console.log(\"前进\");\n};\n\n//“寄生类”Car\nfunction Car() {\n    // 首先，car 是一个 Vehicle\n    var car = new Vehicle();\n    // 接着我们对 car 进行定制\n    car.wheels = 4;\n    // 保存到 Vehicle::drive() 的特殊引用\n    var vehDrive = car.drive;\n    // 重写 Vehicle::drive()\n\n    car.drive = function() {\n        vehDrive.call(this);\n        console.log(this.wheels + \"个轮子在跑\");\n    };\n    return car;\n}\nvar myCar = new Car();\nmyCar.drive();\n```\n","source":"_posts/this与对象原型(三).md","raw":"# YDKJS:this 与对象原型(三)\n\n<!-- TOC -->\n\n- [YDKJS:this 与对象原型(三)](#ydkjsthis-与对象原型三)\n    - [类和面向对象](#类和面向对象)\n        - [类的设计模式](#类的设计模式)\n        - [类理论](#类理论)\n        - [类机制](#类机制)\n            - [建造](#建造)\n            - [构造函数](#构造函数)\n        - [类继承](#类继承)\n            - [多态](#多态)\n            - [多重继承](#多重继承)\n    - [javascript 中的类](#javascript-中的类)\n        - [混入](#混入)\n            - [显式混入](#显式混入)\n            - [隐式混入](#隐式混入)\n        - [寄生](#寄生)\n\n<!-- /TOC -->\n\n## 类和面向对象\n\n类是一种设计模式：实例化(instantiation)、继承(inheritance)和（相对）多态(polymorphism)。\n\n### 类的设计模式\n\n**类是非常常用的一种设计模式**。\n\n### 类理论\n\n类／继承描述了代码的一种组织结构形式。\n\n面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为打包(或者说封装)起来。\n\n举例来说，一个单词是一个字符串，它就是数据，但它往往还需要很多行为（截断、拼接等）。 如果采用面向对象的方式，将这种数据和行为封装在一起，就设计成了`String`类。\n\n### 类机制\n\n#### 建造\n\n“类”和“实例”的概念来源于房屋建造。一个类就是一张蓝图，按照这个蓝图所建造的具体建筑物就是实例。\n\n> 类意味着**复制**。\n\n#### 构造函数\n\n构造函数的特点：\n\n* 是一个类方法\n* 通常与类同名\n* 大多需要 `new` 来调用\n\n### 类继承\n\n可以先定义一个类，然后定义一个继承前者的类，后者通常被称为“子类”，前者通常被称为“父类”。\n\n“子类”和“父类”二者之间没有直接的联系。定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。\n\n```\n// 语法自编\nclass Vehicle {\n    engines = 1\n    ignition() {\n        output( \"Turning on my engine.\" );\n    }\n    drive() {\n        ignition();\n        output( \"Steering and moving forward!\" )\n    }\n}\nclass Car inherits Vehicle { wheels = 4\n    drive() {\n        inherited:drive()\n        output( \"Rolling on all \", wheels, \" wheels!\" )\n    }\n}\nclass SpeedBoat inherits Vehicle { engines = 2\n    ignition() {\n        output( \"Turning on my \", engines, \" engines.\" )\n    }\n    pilot() {\n        inherited:drive()\n        output( \"Speeding through the water with ease!\" )\n    }\n}\n```\n\n#### 多态\n\n> 子类的方法中引用继承来的原始方法，这个技术被称为多态或者虚拟多态。\n\n多态是一个非常广泛的话题，它包含多个方面：\n\n* 任何方法都可以引用继承层次中高层的方法(无论高层的方法名和当前方法名是否相同)。\n* 在继承链的不同层次中一个方法名可以被多次定义，当调用方法时 会自动选择合适的定义。\n\n#### 多重继承\n\n有些语言允许你继承多个“父类”，多重继承意味着所有父类的定义都会被复制到子类中。\n\nJavaScript 要本身并不提供“多重继承”功能。但开发者们尝试了各种各样的办法来实现多重继承。\n\n## javascript 中的类\n\n> JavaScript 中实际上并没有有类\n\n但由于类是一种设计模式，所以我们可以用一些方法近似实现类的功能。 为了满足对于类设计模式的最普遍需求，JavaScript 提供了一些近似类的语法。\n\n### 混入\n\n混入：javascript 中类的实现。\n\n> 在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为。\n\nJavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来。\n\n#### 显式混入\n\nJavaScript 不会自动实现类的复制行为，所以我们需要手动实现复制功能。\n\n```js\nfunction mixin(sourceObj, targetObj) {\n    for (var key in sourceObj) {\n        // 只会在不存在的情况下复制\n        if (!(key in targetObj)) {\n            targetObj[key] = sourceObj[key];\n        }\n    }\n    return targetObj;\n}\nvar Vehicle = {\n    engines: 1,\n    ignition: function() {\n        console.log(\"点火\");\n    },\n    drive: function() {\n        this.ignition();\n        console.log(\"行驶\");\n    }\n};\nvar Car = mixin(Vehicle, {\n    wheels: 4,\n    drive: function() {\n        Vehicle.drive.call(this);\n        console.log(\"Rolling on all \" + this.wheels + \" wheels!\");\n    }\n});\n```\n\n这里我们处理的已经不再是类了，因为在 JavaScript 中不存在 类，Vehicle 和 Car 都是对象，供我们分别进行复制和粘贴。\n\n复制操作完成后，Car 就和 Vehicle 分离了，向 Car 中添加属性不会影响 Vehicle，反之 亦然。\n\n缺点：\n\n1. 显式混入实际上无法完全模拟类的复制行为，，因为对象(函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。\n2. 并不能带来太多的好处，无非就是少几条定义语句，\n\n#### 隐式混入\n\n```js\nvar Something = {\n    cool: function() {\n        this.greeting = \"Hello World\";\n        this.count = this.count ? this.count + 1 : 1;\n    }\n};\n\nSomething.cool();\nSomething.greeting; // \"Hello World\"\nSomething.count; // 1\nvar Another = {\n    cool: function() {\n        // 隐式把 Something 混入 Another\n        Something.cool.call(this);\n    }\n};\nAnother.cool();\nAnother.greeting; // \"Hello World\"\nAnother.count; // 1(count 不是共享状态)\n```\n\n但是`Something.cool.call( this )`仍然无法变成相对(而且更灵活的)引用，所以使用时千万要小心。通常来说，尽量避免使用这样的结构，以保证代码的整洁和可维护性。\n\n### 寄生\n\n显式混入模式的一种变体被称为“寄生继承”，它既是显式的又是隐式的\n\n```js\n//“传统的 JavaScript 类”Vehicle\nfunction Vehicle() {\n    this.engines = 1;\n}\n\nVehicle.prototype.ignition = function() {\n    console.log(\"点火\");\n};\nVehicle.prototype.drive = function() {\n    this.ignition();\n    console.log(\"前进\");\n};\n\n//“寄生类”Car\nfunction Car() {\n    // 首先，car 是一个 Vehicle\n    var car = new Vehicle();\n    // 接着我们对 car 进行定制\n    car.wheels = 4;\n    // 保存到 Vehicle::drive() 的特殊引用\n    var vehDrive = car.drive;\n    // 重写 Vehicle::drive()\n\n    car.drive = function() {\n        vehDrive.call(this);\n        console.log(this.wheels + \"个轮子在跑\");\n    };\n    return car;\n}\nvar myCar = new Car();\nmyCar.drive();\n```\n","slug":"this与对象原型(三)","published":1,"date":"2021-12-06T06:07:05.854Z","updated":"2021-12-06T06:07:05.864Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolv0031y4v2ftnbeucz","content":"<h1 id=\"YDKJS-this-与对象原型-三\"><a href=\"#YDKJS-this-与对象原型-三\" class=\"headerlink\" title=\"YDKJS:this 与对象原型(三)\"></a>YDKJS:this 与对象原型(三)</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#ydkjsthis-%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E4%B8%89\">YDKJS:this 与对象原型(三)</a><ul>\n<li><a href=\"#%E7%B1%BB%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\">类和面向对象</a><ul>\n<li><a href=\"#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\">类的设计模式</a></li>\n<li><a href=\"#%E7%B1%BB%E7%90%86%E8%AE%BA\">类理论</a></li>\n<li><a href=\"#%E7%B1%BB%E6%9C%BA%E5%88%B6\">类机制</a><ul>\n<li><a href=\"#%E5%BB%BA%E9%80%A0\">建造</a></li>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">构造函数</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%B1%BB%E7%BB%A7%E6%89%BF\">类继承</a><ul>\n<li><a href=\"#%E5%A4%9A%E6%80%81\">多态</a></li>\n<li><a href=\"#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF\">多重继承</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#javascript-%E4%B8%AD%E7%9A%84%E7%B1%BB\">javascript 中的类</a><ul>\n<li><a href=\"#%E6%B7%B7%E5%85%A5\">混入</a><ul>\n<li><a href=\"#%E6%98%BE%E5%BC%8F%E6%B7%B7%E5%85%A5\">显式混入</a></li>\n<li><a href=\"#%E9%9A%90%E5%BC%8F%E6%B7%B7%E5%85%A5\">隐式混入</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%AF%84%E7%94%9F\">寄生</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<h2 id=\"类和面向对象\"><a href=\"#类和面向对象\" class=\"headerlink\" title=\"类和面向对象\"></a>类和面向对象</h2><p>类是一种设计模式：实例化(instantiation)、继承(inheritance)和（相对）多态(polymorphism)。</p>\n<h3 id=\"类的设计模式\"><a href=\"#类的设计模式\" class=\"headerlink\" title=\"类的设计模式\"></a>类的设计模式</h3><p><strong>类是非常常用的一种设计模式</strong>。</p>\n<h3 id=\"类理论\"><a href=\"#类理论\" class=\"headerlink\" title=\"类理论\"></a>类理论</h3><p>类／继承描述了代码的一种组织结构形式。</p>\n<p>面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为打包(或者说封装)起来。</p>\n<p>举例来说，一个单词是一个字符串，它就是数据，但它往往还需要很多行为（截断、拼接等）。 如果采用面向对象的方式，将这种数据和行为封装在一起，就设计成了<code>String</code>类。</p>\n<h3 id=\"类机制\"><a href=\"#类机制\" class=\"headerlink\" title=\"类机制\"></a>类机制</h3><h4 id=\"建造\"><a href=\"#建造\" class=\"headerlink\" title=\"建造\"></a>建造</h4><p>“类”和“实例”的概念来源于房屋建造。一个类就是一张蓝图，按照这个蓝图所建造的具体建筑物就是实例。</p>\n<blockquote>\n<p>类意味着<strong>复制</strong>。</p>\n</blockquote>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>构造函数的特点：</p>\n<ul>\n<li>是一个类方法</li>\n<li>通常与类同名</li>\n<li>大多需要 <code>new</code> 来调用</li>\n</ul>\n<h3 id=\"类继承\"><a href=\"#类继承\" class=\"headerlink\" title=\"类继承\"></a>类继承</h3><p>可以先定义一个类，然后定义一个继承前者的类，后者通常被称为“子类”，前者通常被称为“父类”。</p>\n<p>“子类”和“父类”二者之间没有直接的联系。定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 语法自编</span><br><span class=\"line\">class Vehicle &#123;</span><br><span class=\"line\">    engines = 1</span><br><span class=\"line\">    ignition() &#123;</span><br><span class=\"line\">        output( &quot;Turning on my engine.&quot; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    drive() &#123;</span><br><span class=\"line\">        ignition();</span><br><span class=\"line\">        output( &quot;Steering and moving forward!&quot; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Car inherits Vehicle &#123; wheels = 4</span><br><span class=\"line\">    drive() &#123;</span><br><span class=\"line\">        inherited:drive()</span><br><span class=\"line\">        output( &quot;Rolling on all &quot;, wheels, &quot; wheels!&quot; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class SpeedBoat inherits Vehicle &#123; engines = 2</span><br><span class=\"line\">    ignition() &#123;</span><br><span class=\"line\">        output( &quot;Turning on my &quot;, engines, &quot; engines.&quot; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pilot() &#123;</span><br><span class=\"line\">        inherited:drive()</span><br><span class=\"line\">        output( &quot;Speeding through the water with ease!&quot; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><blockquote>\n<p>子类的方法中引用继承来的原始方法，这个技术被称为多态或者虚拟多态。</p>\n</blockquote>\n<p>多态是一个非常广泛的话题，它包含多个方面：</p>\n<ul>\n<li>任何方法都可以引用继承层次中高层的方法(无论高层的方法名和当前方法名是否相同)。</li>\n<li>在继承链的不同层次中一个方法名可以被多次定义，当调用方法时 会自动选择合适的定义。</li>\n</ul>\n<h4 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h4><p>有些语言允许你继承多个“父类”，多重继承意味着所有父类的定义都会被复制到子类中。</p>\n<p>JavaScript 要本身并不提供“多重继承”功能。但开发者们尝试了各种各样的办法来实现多重继承。</p>\n<h2 id=\"javascript-中的类\"><a href=\"#javascript-中的类\" class=\"headerlink\" title=\"javascript 中的类\"></a>javascript 中的类</h2><blockquote>\n<p>JavaScript 中实际上并没有有类</p>\n</blockquote>\n<p>但由于类是一种设计模式，所以我们可以用一些方法近似实现类的功能。 为了满足对于类设计模式的最普遍需求，JavaScript 提供了一些近似类的语法。</p>\n<h3 id=\"混入\"><a href=\"#混入\" class=\"headerlink\" title=\"混入\"></a>混入</h3><p>混入：javascript 中类的实现。</p>\n<blockquote>\n<p>在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为。</p>\n</blockquote>\n<p>JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来。</p>\n<h4 id=\"显式混入\"><a href=\"#显式混入\" class=\"headerlink\" title=\"显式混入\"></a>显式混入</h4><p>JavaScript 不会自动实现类的复制行为，所以我们需要手动实现复制功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mixin</span>(<span class=\"params\">sourceObj, targetObj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> sourceObj) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 只会在不存在的情况下复制</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(key <span class=\"keyword\">in</span> targetObj)) &#123;</span><br><span class=\"line\">            targetObj[key] = sourceObj[key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> targetObj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Vehicle = &#123;</span><br><span class=\"line\">    <span class=\"attr\">engines</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">ignition</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;点火&quot;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">drive</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.ignition();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;行驶&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Car = mixin(Vehicle, &#123;</span><br><span class=\"line\">    <span class=\"attr\">wheels</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"attr\">drive</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Vehicle.drive.call(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Rolling on all &quot;</span> + <span class=\"built_in\">this</span>.wheels + <span class=\"string\">&quot; wheels!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们处理的已经不再是类了，因为在 JavaScript 中不存在 类，Vehicle 和 Car 都是对象，供我们分别进行复制和粘贴。</p>\n<p>复制操作完成后，Car 就和 Vehicle 分离了，向 Car 中添加属性不会影响 Vehicle，反之 亦然。</p>\n<p>缺点：</p>\n<ol>\n<li>显式混入实际上无法完全模拟类的复制行为，，因为对象(函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。</li>\n<li>并不能带来太多的好处，无非就是少几条定义语句，</li>\n</ol>\n<h4 id=\"隐式混入\"><a href=\"#隐式混入\" class=\"headerlink\" title=\"隐式混入\"></a>隐式混入</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Something = &#123;</span><br><span class=\"line\">    <span class=\"attr\">cool</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.greeting = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.count = <span class=\"built_in\">this</span>.count ? <span class=\"built_in\">this</span>.count + <span class=\"number\">1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Something.cool();</span><br><span class=\"line\">Something.greeting; <span class=\"comment\">// &quot;Hello World&quot;</span></span><br><span class=\"line\">Something.count; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Another = &#123;</span><br><span class=\"line\">    <span class=\"attr\">cool</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 隐式把 Something 混入 Another</span></span><br><span class=\"line\">        Something.cool.call(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Another.cool();</span><br><span class=\"line\">Another.greeting; <span class=\"comment\">// &quot;Hello World&quot;</span></span><br><span class=\"line\">Another.count; <span class=\"comment\">// 1(count 不是共享状态)</span></span><br></pre></td></tr></table></figure>\n\n<p>但是<code>Something.cool.call( this )</code>仍然无法变成相对(而且更灵活的)引用，所以使用时千万要小心。通常来说，尽量避免使用这样的结构，以保证代码的整洁和可维护性。</p>\n<h3 id=\"寄生\"><a href=\"#寄生\" class=\"headerlink\" title=\"寄生\"></a>寄生</h3><p>显式混入模式的一种变体被称为“寄生继承”，它既是显式的又是隐式的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//“传统的 JavaScript 类”Vehicle</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Vehicle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.engines = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vehicle.prototype.ignition = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;点火&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Vehicle.prototype.drive = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.ignition();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;前进&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//“寄生类”Car</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先，car 是一个 Vehicle</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> car = <span class=\"keyword\">new</span> Vehicle();</span><br><span class=\"line\">    <span class=\"comment\">// 接着我们对 car 进行定制</span></span><br><span class=\"line\">    car.wheels = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 保存到 Vehicle::drive() 的特殊引用</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> vehDrive = car.drive;</span><br><span class=\"line\">    <span class=\"comment\">// 重写 Vehicle::drive()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    car.drive = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        vehDrive.call(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.wheels + <span class=\"string\">&quot;个轮子在跑&quot;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> car;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myCar = <span class=\"keyword\">new</span> Car();</span><br><span class=\"line\">myCar.drive();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"YDKJS-this-与对象原型-三\"><a href=\"#YDKJS-this-与对象原型-三\" class=\"headerlink\" title=\"YDKJS:this 与对象原型(三)\"></a>YDKJS:this 与对象原型(三)</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#ydkjsthis-%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E4%B8%89\">YDKJS:this 与对象原型(三)</a><ul>\n<li><a href=\"#%E7%B1%BB%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\">类和面向对象</a><ul>\n<li><a href=\"#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\">类的设计模式</a></li>\n<li><a href=\"#%E7%B1%BB%E7%90%86%E8%AE%BA\">类理论</a></li>\n<li><a href=\"#%E7%B1%BB%E6%9C%BA%E5%88%B6\">类机制</a><ul>\n<li><a href=\"#%E5%BB%BA%E9%80%A0\">建造</a></li>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">构造函数</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%B1%BB%E7%BB%A7%E6%89%BF\">类继承</a><ul>\n<li><a href=\"#%E5%A4%9A%E6%80%81\">多态</a></li>\n<li><a href=\"#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF\">多重继承</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#javascript-%E4%B8%AD%E7%9A%84%E7%B1%BB\">javascript 中的类</a><ul>\n<li><a href=\"#%E6%B7%B7%E5%85%A5\">混入</a><ul>\n<li><a href=\"#%E6%98%BE%E5%BC%8F%E6%B7%B7%E5%85%A5\">显式混入</a></li>\n<li><a href=\"#%E9%9A%90%E5%BC%8F%E6%B7%B7%E5%85%A5\">隐式混入</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%AF%84%E7%94%9F\">寄生</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<h2 id=\"类和面向对象\"><a href=\"#类和面向对象\" class=\"headerlink\" title=\"类和面向对象\"></a>类和面向对象</h2><p>类是一种设计模式：实例化(instantiation)、继承(inheritance)和（相对）多态(polymorphism)。</p>\n<h3 id=\"类的设计模式\"><a href=\"#类的设计模式\" class=\"headerlink\" title=\"类的设计模式\"></a>类的设计模式</h3><p><strong>类是非常常用的一种设计模式</strong>。</p>\n<h3 id=\"类理论\"><a href=\"#类理论\" class=\"headerlink\" title=\"类理论\"></a>类理论</h3><p>类／继承描述了代码的一种组织结构形式。</p>\n<p>面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为打包(或者说封装)起来。</p>\n<p>举例来说，一个单词是一个字符串，它就是数据，但它往往还需要很多行为（截断、拼接等）。 如果采用面向对象的方式，将这种数据和行为封装在一起，就设计成了<code>String</code>类。</p>\n<h3 id=\"类机制\"><a href=\"#类机制\" class=\"headerlink\" title=\"类机制\"></a>类机制</h3><h4 id=\"建造\"><a href=\"#建造\" class=\"headerlink\" title=\"建造\"></a>建造</h4><p>“类”和“实例”的概念来源于房屋建造。一个类就是一张蓝图，按照这个蓝图所建造的具体建筑物就是实例。</p>\n<blockquote>\n<p>类意味着<strong>复制</strong>。</p>\n</blockquote>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>构造函数的特点：</p>\n<ul>\n<li>是一个类方法</li>\n<li>通常与类同名</li>\n<li>大多需要 <code>new</code> 来调用</li>\n</ul>\n<h3 id=\"类继承\"><a href=\"#类继承\" class=\"headerlink\" title=\"类继承\"></a>类继承</h3><p>可以先定义一个类，然后定义一个继承前者的类，后者通常被称为“子类”，前者通常被称为“父类”。</p>\n<p>“子类”和“父类”二者之间没有直接的联系。定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 语法自编</span><br><span class=\"line\">class Vehicle &#123;</span><br><span class=\"line\">    engines = 1</span><br><span class=\"line\">    ignition() &#123;</span><br><span class=\"line\">        output( &quot;Turning on my engine.&quot; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    drive() &#123;</span><br><span class=\"line\">        ignition();</span><br><span class=\"line\">        output( &quot;Steering and moving forward!&quot; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Car inherits Vehicle &#123; wheels = 4</span><br><span class=\"line\">    drive() &#123;</span><br><span class=\"line\">        inherited:drive()</span><br><span class=\"line\">        output( &quot;Rolling on all &quot;, wheels, &quot; wheels!&quot; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class SpeedBoat inherits Vehicle &#123; engines = 2</span><br><span class=\"line\">    ignition() &#123;</span><br><span class=\"line\">        output( &quot;Turning on my &quot;, engines, &quot; engines.&quot; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pilot() &#123;</span><br><span class=\"line\">        inherited:drive()</span><br><span class=\"line\">        output( &quot;Speeding through the water with ease!&quot; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><blockquote>\n<p>子类的方法中引用继承来的原始方法，这个技术被称为多态或者虚拟多态。</p>\n</blockquote>\n<p>多态是一个非常广泛的话题，它包含多个方面：</p>\n<ul>\n<li>任何方法都可以引用继承层次中高层的方法(无论高层的方法名和当前方法名是否相同)。</li>\n<li>在继承链的不同层次中一个方法名可以被多次定义，当调用方法时 会自动选择合适的定义。</li>\n</ul>\n<h4 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h4><p>有些语言允许你继承多个“父类”，多重继承意味着所有父类的定义都会被复制到子类中。</p>\n<p>JavaScript 要本身并不提供“多重继承”功能。但开发者们尝试了各种各样的办法来实现多重继承。</p>\n<h2 id=\"javascript-中的类\"><a href=\"#javascript-中的类\" class=\"headerlink\" title=\"javascript 中的类\"></a>javascript 中的类</h2><blockquote>\n<p>JavaScript 中实际上并没有有类</p>\n</blockquote>\n<p>但由于类是一种设计模式，所以我们可以用一些方法近似实现类的功能。 为了满足对于类设计模式的最普遍需求，JavaScript 提供了一些近似类的语法。</p>\n<h3 id=\"混入\"><a href=\"#混入\" class=\"headerlink\" title=\"混入\"></a>混入</h3><p>混入：javascript 中类的实现。</p>\n<blockquote>\n<p>在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为。</p>\n</blockquote>\n<p>JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来。</p>\n<h4 id=\"显式混入\"><a href=\"#显式混入\" class=\"headerlink\" title=\"显式混入\"></a>显式混入</h4><p>JavaScript 不会自动实现类的复制行为，所以我们需要手动实现复制功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mixin</span>(<span class=\"params\">sourceObj, targetObj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> sourceObj) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 只会在不存在的情况下复制</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(key <span class=\"keyword\">in</span> targetObj)) &#123;</span><br><span class=\"line\">            targetObj[key] = sourceObj[key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> targetObj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Vehicle = &#123;</span><br><span class=\"line\">    <span class=\"attr\">engines</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">ignition</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;点火&quot;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">drive</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.ignition();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;行驶&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Car = mixin(Vehicle, &#123;</span><br><span class=\"line\">    <span class=\"attr\">wheels</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"attr\">drive</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Vehicle.drive.call(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Rolling on all &quot;</span> + <span class=\"built_in\">this</span>.wheels + <span class=\"string\">&quot; wheels!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们处理的已经不再是类了，因为在 JavaScript 中不存在 类，Vehicle 和 Car 都是对象，供我们分别进行复制和粘贴。</p>\n<p>复制操作完成后，Car 就和 Vehicle 分离了，向 Car 中添加属性不会影响 Vehicle，反之 亦然。</p>\n<p>缺点：</p>\n<ol>\n<li>显式混入实际上无法完全模拟类的复制行为，，因为对象(函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。</li>\n<li>并不能带来太多的好处，无非就是少几条定义语句，</li>\n</ol>\n<h4 id=\"隐式混入\"><a href=\"#隐式混入\" class=\"headerlink\" title=\"隐式混入\"></a>隐式混入</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Something = &#123;</span><br><span class=\"line\">    <span class=\"attr\">cool</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.greeting = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.count = <span class=\"built_in\">this</span>.count ? <span class=\"built_in\">this</span>.count + <span class=\"number\">1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Something.cool();</span><br><span class=\"line\">Something.greeting; <span class=\"comment\">// &quot;Hello World&quot;</span></span><br><span class=\"line\">Something.count; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Another = &#123;</span><br><span class=\"line\">    <span class=\"attr\">cool</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 隐式把 Something 混入 Another</span></span><br><span class=\"line\">        Something.cool.call(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Another.cool();</span><br><span class=\"line\">Another.greeting; <span class=\"comment\">// &quot;Hello World&quot;</span></span><br><span class=\"line\">Another.count; <span class=\"comment\">// 1(count 不是共享状态)</span></span><br></pre></td></tr></table></figure>\n\n<p>但是<code>Something.cool.call( this )</code>仍然无法变成相对(而且更灵活的)引用，所以使用时千万要小心。通常来说，尽量避免使用这样的结构，以保证代码的整洁和可维护性。</p>\n<h3 id=\"寄生\"><a href=\"#寄生\" class=\"headerlink\" title=\"寄生\"></a>寄生</h3><p>显式混入模式的一种变体被称为“寄生继承”，它既是显式的又是隐式的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//“传统的 JavaScript 类”Vehicle</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Vehicle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.engines = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vehicle.prototype.ignition = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;点火&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Vehicle.prototype.drive = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.ignition();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;前进&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//“寄生类”Car</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先，car 是一个 Vehicle</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> car = <span class=\"keyword\">new</span> Vehicle();</span><br><span class=\"line\">    <span class=\"comment\">// 接着我们对 car 进行定制</span></span><br><span class=\"line\">    car.wheels = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 保存到 Vehicle::drive() 的特殊引用</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> vehDrive = car.drive;</span><br><span class=\"line\">    <span class=\"comment\">// 重写 Vehicle::drive()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    car.drive = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        vehDrive.call(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.wheels + <span class=\"string\">&quot;个轮子在跑&quot;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> car;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myCar = <span class=\"keyword\">new</span> Car();</span><br><span class=\"line\">myCar.drive();</span><br></pre></td></tr></table></figure>\n"},{"_content":"# YDKJS:this 与对象原型(四)\n\n\n## 原型\n\n\n### [[Prototype]]\n\n[[Prototype]] 是 JavaScript 对象中的内置属性。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。\n\n1. 作用：\n保持对另一个对象的引用。\n[[Get]] 操作当被检查对象本身不具有有某个属性时就会使用对象的 [[Prototype]] 链查找。\n\n2. 尽头\n[[Prototype]] 链的“尽头” 是Object.prototype 对象。\n\n\n### 类\n\n在 JavaScript 中，我们并不会将一个对象(“类”)复制到另一个对象(“实例”)，只是将它们关联起来，称为原型继承。","source":"_posts/this与对象原型(四).md","raw":"# YDKJS:this 与对象原型(四)\n\n\n## 原型\n\n\n### [[Prototype]]\n\n[[Prototype]] 是 JavaScript 对象中的内置属性。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。\n\n1. 作用：\n保持对另一个对象的引用。\n[[Get]] 操作当被检查对象本身不具有有某个属性时就会使用对象的 [[Prototype]] 链查找。\n\n2. 尽头\n[[Prototype]] 链的“尽头” 是Object.prototype 对象。\n\n\n### 类\n\n在 JavaScript 中，我们并不会将一个对象(“类”)复制到另一个对象(“实例”)，只是将它们关联起来，称为原型继承。","slug":"this与对象原型(四)","published":1,"date":"2021-12-06T06:07:05.867Z","updated":"2021-12-06T06:07:05.867Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolx0034y4v23gi8hlps","content":"<h1 id=\"YDKJS-this-与对象原型-四\"><a href=\"#YDKJS-this-与对象原型-四\" class=\"headerlink\" title=\"YDKJS:this 与对象原型(四)\"></a>YDKJS:this 与对象原型(四)</h1><h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"Prototype\"><a href=\"#Prototype\" class=\"headerlink\" title=\"[[Prototype]]\"></a>[[Prototype]]</h3><p>[[Prototype]] 是 JavaScript 对象中的内置属性。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。</p>\n<ol>\n<li><p>作用：<br>保持对另一个对象的引用。<br>[[Get]] 操作当被检查对象本身不具有有某个属性时就会使用对象的 [[Prototype]] 链查找。</p>\n</li>\n<li><p>尽头<br>[[Prototype]] 链的“尽头” 是Object.prototype 对象。</p>\n</li>\n</ol>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p>在 JavaScript 中，我们并不会将一个对象(“类”)复制到另一个对象(“实例”)，只是将它们关联起来，称为原型继承。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"YDKJS-this-与对象原型-四\"><a href=\"#YDKJS-this-与对象原型-四\" class=\"headerlink\" title=\"YDKJS:this 与对象原型(四)\"></a>YDKJS:this 与对象原型(四)</h1><h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"Prototype\"><a href=\"#Prototype\" class=\"headerlink\" title=\"[[Prototype]]\"></a>[[Prototype]]</h3><p>[[Prototype]] 是 JavaScript 对象中的内置属性。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。</p>\n<ol>\n<li><p>作用：<br>保持对另一个对象的引用。<br>[[Get]] 操作当被检查对象本身不具有有某个属性时就会使用对象的 [[Prototype]] 链查找。</p>\n</li>\n<li><p>尽头<br>[[Prototype]] 链的“尽头” 是Object.prototype 对象。</p>\n</li>\n</ol>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p>在 JavaScript 中，我们并不会将一个对象(“类”)复制到另一个对象(“实例”)，只是将它们关联起来，称为原型继承。</p>\n"},{"_content":"# touch触摸事件\n\n## 事件对象\n事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有事件发生时才会产生，并且只能是事件处理函数内部访问，在所有事件处理函数运行结束后，事件对象就被销毁！\n\n+ W3C DOM把事件对象作为事件处理函数的第一个参数传入进去\n+ IE将事件对象作为window对象的一个属性（相当于全局变量）\n\n<!-- more -->\n\n## originalEvent对象\n在一次偶然的使用中，我发现当使用on()函数并且传入第二个选择器参数时,e.touches[0]的访问为undefined，打印e发现，它的事件对象不是原生的事件对象。经查阅发现它是jquery事件对象。\n```javascript\n$(window).on(\"touchstart\",\"body\",function(e){\n\tconsole.log(e)\n})\n```\n![](https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touchclass1.png)\n\n上面例子中event中有一个originalEvent属性，而这才是真正的touch事件。jQuery.Event 是一个构造函数，其创建一个可读写的jQuery事件对象，并在event 对象保留了对这个原生事件对象 event 的引用($event.originalEvent)。我们绑定的事件处理程序所处理的事件对象都是 $event。该方法也可以传递一个自定义事件的类型名，用于生成用户自定义事件对象。\n\n\n## touch事件\n\n`touchmove`: 当手指在屏幕上滑动的时候连续地触发。\n`touchstart`: 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发\n`touchend`:  当手指从屏幕上离开的时候触发。\n\n## TouchEvent对象\n每一个touch事件的触发都会产生一个TouchEvent对象，以下是TouchEvent对象三个比较常用的重要属性\n\n+ touches   当前位于屏幕上的所有手指的一个列表。\n+ targetTouches  特定于事件目标的Touch对象的数组。[当前手指]\n+ changeTouches  表示自上次触摸以来发生了什么改变的Touch对象的数组。\n\n在这里，我用js写了一个touch事件，点击屏幕可触发,将其事件事件对象在控制台打印出，结果如下（箭头指向的是上述三个属性）：\n```javascript\nwindow.addEventListener(\"touchstart\",function(event){\n\tconsole.log(event);\n})\n```\n![](https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touch.png)\n## 触摸事件对象属性\ntouches、targetTou、changeTouches都包含以下属性值\n\n+ clientX：触摸目标在视口中的x坐标。\n+ clientY：触摸目标在视口中的y坐标。\n+ identifier：标识触摸的唯一ID。\n+ pageX：触摸目标在页面中的x坐标。\n+ pageY：触摸目标在页面中的y坐标。\n+ screenX：触摸目标在屏幕中的x坐标。\n+ screenY：触摸目标在屏幕中的y坐标。\n+ target：触摸的DOM节点目标。\n\n还是上面的那个例子，changeTouches对象在控制台输出如下：\n![](https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touchclass.png)","source":"_posts/touch触摸事件.md","raw":"# touch触摸事件\n\n## 事件对象\n事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有事件发生时才会产生，并且只能是事件处理函数内部访问，在所有事件处理函数运行结束后，事件对象就被销毁！\n\n+ W3C DOM把事件对象作为事件处理函数的第一个参数传入进去\n+ IE将事件对象作为window对象的一个属性（相当于全局变量）\n\n<!-- more -->\n\n## originalEvent对象\n在一次偶然的使用中，我发现当使用on()函数并且传入第二个选择器参数时,e.touches[0]的访问为undefined，打印e发现，它的事件对象不是原生的事件对象。经查阅发现它是jquery事件对象。\n```javascript\n$(window).on(\"touchstart\",\"body\",function(e){\n\tconsole.log(e)\n})\n```\n![](https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touchclass1.png)\n\n上面例子中event中有一个originalEvent属性，而这才是真正的touch事件。jQuery.Event 是一个构造函数，其创建一个可读写的jQuery事件对象，并在event 对象保留了对这个原生事件对象 event 的引用($event.originalEvent)。我们绑定的事件处理程序所处理的事件对象都是 $event。该方法也可以传递一个自定义事件的类型名，用于生成用户自定义事件对象。\n\n\n## touch事件\n\n`touchmove`: 当手指在屏幕上滑动的时候连续地触发。\n`touchstart`: 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发\n`touchend`:  当手指从屏幕上离开的时候触发。\n\n## TouchEvent对象\n每一个touch事件的触发都会产生一个TouchEvent对象，以下是TouchEvent对象三个比较常用的重要属性\n\n+ touches   当前位于屏幕上的所有手指的一个列表。\n+ targetTouches  特定于事件目标的Touch对象的数组。[当前手指]\n+ changeTouches  表示自上次触摸以来发生了什么改变的Touch对象的数组。\n\n在这里，我用js写了一个touch事件，点击屏幕可触发,将其事件事件对象在控制台打印出，结果如下（箭头指向的是上述三个属性）：\n```javascript\nwindow.addEventListener(\"touchstart\",function(event){\n\tconsole.log(event);\n})\n```\n![](https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touch.png)\n## 触摸事件对象属性\ntouches、targetTou、changeTouches都包含以下属性值\n\n+ clientX：触摸目标在视口中的x坐标。\n+ clientY：触摸目标在视口中的y坐标。\n+ identifier：标识触摸的唯一ID。\n+ pageX：触摸目标在页面中的x坐标。\n+ pageY：触摸目标在页面中的y坐标。\n+ screenX：触摸目标在屏幕中的x坐标。\n+ screenY：触摸目标在屏幕中的y坐标。\n+ target：触摸的DOM节点目标。\n\n还是上面的那个例子，changeTouches对象在控制台输出如下：\n![](https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touchclass.png)","slug":"touch触摸事件","published":1,"date":"2021-12-06T06:07:06.242Z","updated":"2021-12-06T06:07:06.246Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolx0036y4v2fkfbfyt3","content":"<h1 id=\"touch触摸事件\"><a href=\"#touch触摸事件\" class=\"headerlink\" title=\"touch触摸事件\"></a>touch触摸事件</h1><h2 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h2><p>事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有事件发生时才会产生，并且只能是事件处理函数内部访问，在所有事件处理函数运行结束后，事件对象就被销毁！</p>\n<ul>\n<li>W3C DOM把事件对象作为事件处理函数的第一个参数传入进去</li>\n<li>IE将事件对象作为window对象的一个属性（相当于全局变量）</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"originalEvent对象\"><a href=\"#originalEvent对象\" class=\"headerlink\" title=\"originalEvent对象\"></a>originalEvent对象</h2><p>在一次偶然的使用中，我发现当使用on()函数并且传入第二个选择器参数时,e.touches[0]的访问为undefined，打印e发现，它的事件对象不是原生的事件对象。经查阅发现它是jquery事件对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"built_in\">window</span>).on(<span class=\"string\">&quot;touchstart&quot;</span>,<span class=\"string\">&quot;body&quot;</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touchclass1.png\"></p>\n<p>上面例子中event中有一个originalEvent属性，而这才是真正的touch事件。jQuery.Event 是一个构造函数，其创建一个可读写的jQuery事件对象，并在event 对象保留了对这个原生事件对象 event 的引用($event.originalEvent)。我们绑定的事件处理程序所处理的事件对象都是 $event。该方法也可以传递一个自定义事件的类型名，用于生成用户自定义事件对象。</p>\n<h2 id=\"touch事件\"><a href=\"#touch事件\" class=\"headerlink\" title=\"touch事件\"></a>touch事件</h2><p><code>touchmove</code>: 当手指在屏幕上滑动的时候连续地触发。<br><code>touchstart</code>: 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发<br><code>touchend</code>:  当手指从屏幕上离开的时候触发。</p>\n<h2 id=\"TouchEvent对象\"><a href=\"#TouchEvent对象\" class=\"headerlink\" title=\"TouchEvent对象\"></a>TouchEvent对象</h2><p>每一个touch事件的触发都会产生一个TouchEvent对象，以下是TouchEvent对象三个比较常用的重要属性</p>\n<ul>\n<li>touches   当前位于屏幕上的所有手指的一个列表。</li>\n<li>targetTouches  特定于事件目标的Touch对象的数组。[当前手指]</li>\n<li>changeTouches  表示自上次触摸以来发生了什么改变的Touch对象的数组。</li>\n</ul>\n<p>在这里，我用js写了一个touch事件，点击屏幕可触发,将其事件事件对象在控制台打印出，结果如下（箭头指向的是上述三个属性）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;touchstart&quot;</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(event);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touch.png\"></p>\n<h2 id=\"触摸事件对象属性\"><a href=\"#触摸事件对象属性\" class=\"headerlink\" title=\"触摸事件对象属性\"></a>触摸事件对象属性</h2><p>touches、targetTou、changeTouches都包含以下属性值</p>\n<ul>\n<li>clientX：触摸目标在视口中的x坐标。</li>\n<li>clientY：触摸目标在视口中的y坐标。</li>\n<li>identifier：标识触摸的唯一ID。</li>\n<li>pageX：触摸目标在页面中的x坐标。</li>\n<li>pageY：触摸目标在页面中的y坐标。</li>\n<li>screenX：触摸目标在屏幕中的x坐标。</li>\n<li>screenY：触摸目标在屏幕中的y坐标。</li>\n<li>target：触摸的DOM节点目标。</li>\n</ul>\n<p>还是上面的那个例子，changeTouches对象在控制台输出如下：<br><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touchclass.png\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"touch触摸事件\"><a href=\"#touch触摸事件\" class=\"headerlink\" title=\"touch触摸事件\"></a>touch触摸事件</h1><h2 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h2><p>事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有事件发生时才会产生，并且只能是事件处理函数内部访问，在所有事件处理函数运行结束后，事件对象就被销毁！</p>\n<ul>\n<li>W3C DOM把事件对象作为事件处理函数的第一个参数传入进去</li>\n<li>IE将事件对象作为window对象的一个属性（相当于全局变量）</li>\n</ul>","more":"<h2 id=\"originalEvent对象\"><a href=\"#originalEvent对象\" class=\"headerlink\" title=\"originalEvent对象\"></a>originalEvent对象</h2><p>在一次偶然的使用中，我发现当使用on()函数并且传入第二个选择器参数时,e.touches[0]的访问为undefined，打印e发现，它的事件对象不是原生的事件对象。经查阅发现它是jquery事件对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"built_in\">window</span>).on(<span class=\"string\">&quot;touchstart&quot;</span>,<span class=\"string\">&quot;body&quot;</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touchclass1.png\"></p>\n<p>上面例子中event中有一个originalEvent属性，而这才是真正的touch事件。jQuery.Event 是一个构造函数，其创建一个可读写的jQuery事件对象，并在event 对象保留了对这个原生事件对象 event 的引用($event.originalEvent)。我们绑定的事件处理程序所处理的事件对象都是 $event。该方法也可以传递一个自定义事件的类型名，用于生成用户自定义事件对象。</p>\n<h2 id=\"touch事件\"><a href=\"#touch事件\" class=\"headerlink\" title=\"touch事件\"></a>touch事件</h2><p><code>touchmove</code>: 当手指在屏幕上滑动的时候连续地触发。<br><code>touchstart</code>: 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发<br><code>touchend</code>:  当手指从屏幕上离开的时候触发。</p>\n<h2 id=\"TouchEvent对象\"><a href=\"#TouchEvent对象\" class=\"headerlink\" title=\"TouchEvent对象\"></a>TouchEvent对象</h2><p>每一个touch事件的触发都会产生一个TouchEvent对象，以下是TouchEvent对象三个比较常用的重要属性</p>\n<ul>\n<li>touches   当前位于屏幕上的所有手指的一个列表。</li>\n<li>targetTouches  特定于事件目标的Touch对象的数组。[当前手指]</li>\n<li>changeTouches  表示自上次触摸以来发生了什么改变的Touch对象的数组。</li>\n</ul>\n<p>在这里，我用js写了一个touch事件，点击屏幕可触发,将其事件事件对象在控制台打印出，结果如下（箭头指向的是上述三个属性）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;touchstart&quot;</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(event);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touch.png\"></p>\n<h2 id=\"触摸事件对象属性\"><a href=\"#触摸事件对象属性\" class=\"headerlink\" title=\"触摸事件对象属性\"></a>触摸事件对象属性</h2><p>touches、targetTou、changeTouches都包含以下属性值</p>\n<ul>\n<li>clientX：触摸目标在视口中的x坐标。</li>\n<li>clientY：触摸目标在视口中的y坐标。</li>\n<li>identifier：标识触摸的唯一ID。</li>\n<li>pageX：触摸目标在页面中的x坐标。</li>\n<li>pageY：触摸目标在页面中的y坐标。</li>\n<li>screenX：触摸目标在屏幕中的x坐标。</li>\n<li>screenY：触摸目标在屏幕中的y坐标。</li>\n<li>target：触摸的DOM节点目标。</li>\n</ul>\n<p>还是上面的那个例子，changeTouches对象在控制台输出如下：<br><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201601/touchclass.png\"></p>"},{"_content":"book\u0000\u0000\u0000\u0000mark\u0000\u0000\u0000\u00008\u0000\u0000\u00008\u0000\u0000\u0000�\u0003\u0000\u0000\u0000\u0000\u0004\u0010\u0000\u0000\u0000\u0000rs/aw1ݛ���A\u0000\u0000\u0000\u0000/repl\u0002\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000\u0000\u0004\u0000\u0000\u0005\u0000\u0000\u0000\u0001\u0001\u0000\u0000Users\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0001\u0001\u0000\u0000admin\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0001\u0001\u0000\u0000Desktop\u0000\u0004\u0000\u0000\u0000\u0001\u0001\u0000\u0000repo\u0004\u0000\u0000\u0000\u0001\u0001\u0000\u0000blog\u0002\u0000\u0000\u0000\u0001\u0001\u0000\u0000md\u0000\u0000\u0010\u0000\u0000\u0000\u0001\u0001\u0000\u00002016年总结.md\u001c\u0000\u0000\u0000\u0001\u0006\u0000\u0000\u0010\u0000\u0000\u0000 \u0000\u0000\u00000\u0000\u0000\u0000@\u0000\u0000\u0000L\u0000\u0000\u0000X\u0000\u0000\u0000d\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J\t\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J\t\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J\t\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u00007�\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u00009�\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000��\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000��\u000e\u0000\u0000\u0000\u0000\u0000\u001c\u0000\u0000\u0000\u0001\u0006\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000\u0000\u0001\u0000\u0000\b\u0000\u0000\u0000\u0000\u0004\u0000\u0000A�h�9\u0000\u0000\u0000\u0018\u0000\u0000\u0000\u0001\u0002\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001f\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u001f\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0005\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000\u0001\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000\u0005\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000�\u0001\u0000\u0000\b\u0000\u0000\u0000\u0001\t\u0000\u0000file:///\f\u0000\u0000\u0000\u0001\u0001\u0000\u0000Macintosh HD\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000\u0000 �\f\u001c\u0000\u0000\u0000\b\u0000\u0000\u0000\u0000\u0004\u0000\u0000A�&e�\u0000\u0000\u0000$\u0000\u0000\u0000\u0001\u0001\u0000\u0000324D49A4-4A00-37D4-8444-B0A78C5ABBE8\u0018\u0000\u0000\u0000\u0001\u0002\u0000\u0000�\u0000\u0000\u0000\u0001\u0000\u0000\u0000�\u0013\u0000\u0000\u0001\u0000\u0000\u0000�\u0013\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001\u0000\u0000/\u0000\u0000\u00002\u0000\u0000\u0000\u0001\u0002\u0000\u0000dnib\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000md????\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0014\u0001\u0000\u0000����\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0016\u0000\u0000\u0000\u0004\u0010\u0000\u0000|\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0005\u0010\u0000\u0000\u0010\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0010\u0000\u0000D\u0001\u0000\u0000\u0000\u0000\u0000\u0000@\u0010\u0000\u00004\u0001\u0000\u0000\u0000\u0000\u0000\u0000T\u0010\u0000\u0000l\u0001\u0000\u0000\u0000\u0000\u0000\u0000U\u0010\u0000\u0000l\u0001\u0000\u0000\u0000\u0000\u0000\u0000V\u0010\u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0002 \u0000\u0000$\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0005 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0011 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0012 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0013 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000  \u0000\u0000\u0004\u0002\u0000\u0000\u0000\u0000\u0000\u00000 \u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0001�\u0000\u0000x\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0011�\u0000\u0000 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012�\u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0001�\u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010�\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0017�\u0000\u0000d\u0000\u0000\u0000\u0000\u0000\u0000\u0000\"�\u0000\u00000\u0002\u0000\u0000\u0000\u0000\u0000\u0000","source":"_posts/this小记.md","raw":"book\u0000\u0000\u0000\u0000mark\u0000\u0000\u0000\u00008\u0000\u0000\u00008\u0000\u0000\u0000�\u0003\u0000\u0000\u0000\u0000\u0004\u0010\u0000\u0000\u0000\u0000rs/aw1ݛ���A\u0000\u0000\u0000\u0000/repl\u0002\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000\u0000\u0004\u0000\u0000\u0005\u0000\u0000\u0000\u0001\u0001\u0000\u0000Users\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0001\u0001\u0000\u0000admin\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0001\u0001\u0000\u0000Desktop\u0000\u0004\u0000\u0000\u0000\u0001\u0001\u0000\u0000repo\u0004\u0000\u0000\u0000\u0001\u0001\u0000\u0000blog\u0002\u0000\u0000\u0000\u0001\u0001\u0000\u0000md\u0000\u0000\u0010\u0000\u0000\u0000\u0001\u0001\u0000\u00002016年总结.md\u001c\u0000\u0000\u0000\u0001\u0006\u0000\u0000\u0010\u0000\u0000\u0000 \u0000\u0000\u00000\u0000\u0000\u0000@\u0000\u0000\u0000L\u0000\u0000\u0000X\u0000\u0000\u0000d\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J\t\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J\t\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J\t\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u00007�\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u00009�\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000��\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000��\u000e\u0000\u0000\u0000\u0000\u0000\u001c\u0000\u0000\u0000\u0001\u0006\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000\u0000\u0001\u0000\u0000\b\u0000\u0000\u0000\u0000\u0004\u0000\u0000A�h�9\u0000\u0000\u0000\u0018\u0000\u0000\u0000\u0001\u0002\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001f\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u001f\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0005\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000\u0001\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000\u0005\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000�\u0001\u0000\u0000\b\u0000\u0000\u0000\u0001\t\u0000\u0000file:///\f\u0000\u0000\u0000\u0001\u0001\u0000\u0000Macintosh HD\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000\u0000 �\f\u001c\u0000\u0000\u0000\b\u0000\u0000\u0000\u0000\u0004\u0000\u0000A�&e�\u0000\u0000\u0000$\u0000\u0000\u0000\u0001\u0001\u0000\u0000324D49A4-4A00-37D4-8444-B0A78C5ABBE8\u0018\u0000\u0000\u0000\u0001\u0002\u0000\u0000�\u0000\u0000\u0000\u0001\u0000\u0000\u0000�\u0013\u0000\u0000\u0001\u0000\u0000\u0000�\u0013\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001\u0000\u0000/\u0000\u0000\u00002\u0000\u0000\u0000\u0001\u0002\u0000\u0000dnib\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000md????\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0014\u0001\u0000\u0000����\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0016\u0000\u0000\u0000\u0004\u0010\u0000\u0000|\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0005\u0010\u0000\u0000\u0010\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0010\u0000\u0000D\u0001\u0000\u0000\u0000\u0000\u0000\u0000@\u0010\u0000\u00004\u0001\u0000\u0000\u0000\u0000\u0000\u0000T\u0010\u0000\u0000l\u0001\u0000\u0000\u0000\u0000\u0000\u0000U\u0010\u0000\u0000l\u0001\u0000\u0000\u0000\u0000\u0000\u0000V\u0010\u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0002 \u0000\u0000$\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0005 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0011 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0012 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0013 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000  \u0000\u0000\u0004\u0002\u0000\u0000\u0000\u0000\u0000\u00000 \u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0001�\u0000\u0000x\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0011�\u0000\u0000 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012�\u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0001�\u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010�\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0017�\u0000\u0000d\u0000\u0000\u0000\u0000\u0000\u0000\u0000\"�\u0000\u00000\u0002\u0000\u0000\u0000\u0000\u0000\u0000","slug":"this小记","published":1,"date":"2021-12-06T06:07:06.236Z","updated":"2021-12-06T06:07:06.242Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoly0038y4v23zg20uo6","content":"<p>book\u0000\u0000\u0000\u0000mark\u0000\u0000\u0000\u00008\u0000\u0000\u00008\u0000\u0000\u0000�\u0003\u0000\u0000\u0000\u0000\u0004\u0010\u0000\u0000\u0000\u0000rs/aw1ݛ���A\u0000\u0000\u0000\u0000/repl\u0002\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000\u0000\u0004\u0000\u0000\u0005\u0000\u0000\u0000\u0001\u0001\u0000\u0000Users\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0001\u0001\u0000\u0000admin\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0001\u0001\u0000\u0000Desktop\u0000\u0004\u0000\u0000\u0000\u0001\u0001\u0000\u0000repo\u0004\u0000\u0000\u0000\u0001\u0001\u0000\u0000blog\u0002\u0000\u0000\u0000\u0001\u0001\u0000\u0000md\u0000\u0000\u0010\u0000\u0000\u0000\u0001\u0001\u0000\u00002016年总结.md\u001c\u0000\u0000\u0000\u0001\u0006\u0000\u0000\u0010\u0000\u0000\u0000 \u0000\u0000\u00000\u0000\u0000\u0000@\u0000\u0000\u0000L\u0000\u0000\u0000X\u0000\u0000\u0000d\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J    \u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J    \u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J    \u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u00007�\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u00009�\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000��\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000��\u000e\u0000\u0000\u0000\u0000\u0000\u001c\u0000\u0000\u0000\u0001\u0006\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000\u0000\u0001\u0000\u0000\b\u0000\u0000\u0000\u0000\u0004\u0000\u0000A�h�9\u0000\u0000\u0000\u0018\u0000\u0000\u0000\u0001\u0002\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001f\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u001f\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0005\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000\u0001\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000\u0005\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000�\u0001\u0000\u0000\b\u0000\u0000\u0000\u0001    \u0000\u0000file:///\f\u0000\u0000\u0000\u0001\u0001\u0000\u0000Macintosh HD\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000\u0000 �\f\u001c\u0000\u0000\u0000\b\u0000\u0000\u0000\u0000\u0004\u0000\u0000A�&amp;e�\u0000\u0000\u0000$\u0000\u0000\u0000\u0001\u0001\u0000\u0000324D49A4-4A00-37D4-8444-B0A78C5ABBE8\u0018\u0000\u0000\u0000\u0001\u0002\u0000\u0000�\u0000\u0000\u0000\u0001\u0000\u0000\u0000�\u0013\u0000\u0000\u0001\u0000\u0000\u0000�\u0013\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001\u0000\u0000/\u0000\u0000\u00002\u0000\u0000\u0000\u0001\u0002\u0000\u0000dnib\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000md????\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0014\u0001\u0000\u0000����\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0016\u0000\u0000\u0000\u0004\u0010\u0000\u0000|\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0005\u0010\u0000\u0000\u0010\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0010\u0000\u0000D\u0001\u0000\u0000\u0000\u0000\u0000\u0000@\u0010\u0000\u00004\u0001\u0000\u0000\u0000\u0000\u0000\u0000T\u0010\u0000\u0000l\u0001\u0000\u0000\u0000\u0000\u0000\u0000U\u0010\u0000\u0000l\u0001\u0000\u0000\u0000\u0000\u0000\u0000V\u0010\u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0002 \u0000\u0000$\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0005 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0011 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0012 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0013 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000  \u0000\u0000\u0004\u0002\u0000\u0000\u0000\u0000\u0000\u00000 \u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0001�\u0000\u0000x\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0011�\u0000\u0000 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012�\u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0001�\u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010�\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0017�\u0000\u0000d\u0000\u0000\u0000\u0000\u0000\u0000\u0000”�\u0000\u00000\u0002\u0000\u0000\u0000\u0000\u0000\u0000</p>\n","site":{"data":{}},"excerpt":"","more":"<p>book\u0000\u0000\u0000\u0000mark\u0000\u0000\u0000\u00008\u0000\u0000\u00008\u0000\u0000\u0000�\u0003\u0000\u0000\u0000\u0000\u0004\u0010\u0000\u0000\u0000\u0000rs/aw1ݛ���A\u0000\u0000\u0000\u0000/repl\u0002\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000\u0000\u0004\u0000\u0000\u0005\u0000\u0000\u0000\u0001\u0001\u0000\u0000Users\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0001\u0001\u0000\u0000admin\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0001\u0001\u0000\u0000Desktop\u0000\u0004\u0000\u0000\u0000\u0001\u0001\u0000\u0000repo\u0004\u0000\u0000\u0000\u0001\u0001\u0000\u0000blog\u0002\u0000\u0000\u0000\u0001\u0001\u0000\u0000md\u0000\u0000\u0010\u0000\u0000\u0000\u0001\u0001\u0000\u00002016年总结.md\u001c\u0000\u0000\u0000\u0001\u0006\u0000\u0000\u0010\u0000\u0000\u0000 \u0000\u0000\u00000\u0000\u0000\u0000@\u0000\u0000\u0000L\u0000\u0000\u0000X\u0000\u0000\u0000d\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J    \u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J    \u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000�J    \u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u00007�\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u00009�\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000��\u000e\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000��\u000e\u0000\u0000\u0000\u0000\u0000\u001c\u0000\u0000\u0000\u0001\u0006\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000\u0000\u0001\u0000\u0000\b\u0000\u0000\u0000\u0000\u0004\u0000\u0000A�h�9\u0000\u0000\u0000\u0018\u0000\u0000\u0000\u0001\u0002\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001f\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u001f\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0005\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000\u0001\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000\u0005\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0003\u0003\u0000\u0000�\u0001\u0000\u0000\b\u0000\u0000\u0000\u0001    \u0000\u0000file:///\f\u0000\u0000\u0000\u0001\u0001\u0000\u0000Macintosh HD\b\u0000\u0000\u0000\u0004\u0003\u0000\u0000\u0000 �\f\u001c\u0000\u0000\u0000\b\u0000\u0000\u0000\u0000\u0004\u0000\u0000A�&amp;e�\u0000\u0000\u0000$\u0000\u0000\u0000\u0001\u0001\u0000\u0000324D49A4-4A00-37D4-8444-B0A78C5ABBE8\u0018\u0000\u0000\u0000\u0001\u0002\u0000\u0000�\u0000\u0000\u0000\u0001\u0000\u0000\u0000�\u0013\u0000\u0000\u0001\u0000\u0000\u0000�\u0013\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0001\u0000\u0000/\u0000\u0000\u00002\u0000\u0000\u0000\u0001\u0002\u0000\u0000dnib\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000md????\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0014\u0001\u0000\u0000����\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0016\u0000\u0000\u0000\u0004\u0010\u0000\u0000|\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0005\u0010\u0000\u0000\u0010\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0010\u0000\u0000D\u0001\u0000\u0000\u0000\u0000\u0000\u0000@\u0010\u0000\u00004\u0001\u0000\u0000\u0000\u0000\u0000\u0000T\u0010\u0000\u0000l\u0001\u0000\u0000\u0000\u0000\u0000\u0000U\u0010\u0000\u0000l\u0001\u0000\u0000\u0000\u0000\u0000\u0000V\u0010\u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0002 \u0000\u0000$\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0005 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0011 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0012 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0013 \u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000  \u0000\u0000\u0004\u0002\u0000\u0000\u0000\u0000\u0000\u00000 \u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0001�\u0000\u0000x\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0011�\u0000\u0000 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012�\u0000\u0000�\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0001�\u0000\u0000d\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0010�\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0017�\u0000\u0000d\u0000\u0000\u0000\u0000\u0000\u0000\u0000”�\u0000\u00000\u0002\u0000\u0000\u0000\u0000\u0000\u0000</p>\n"},{"_content":"windows下React-native 环境搭建\n\n公司决定试水react-native，mac审批还没下来，没办法，先用windows硬着头皮上吧。\n\n参考文章：\n\n[React Native 中文网官方文档](http://reactnative.cn/docs/0.31/getting-started.html#content)\n\n[史上最全Windows版本搭建安装React Native环境配置](http://www.w2bc.com/article/103350)\n\n##安装windows环境##\n\n- Java Development Kit [JDK] 1.8+\n- Python 2\n- Node\n- react-native-cli (React Native命令行工具)\n\n先把jdk1.8+、Python2、node安装了，这三个不分先后，安装完毕记得添加环境变量，这里就不多说了。详细情况可以参照：\n\n[搭建Java开发环境](http://www.cnblogs.com/yzg1/p/5354763.html)\n\n[Node官网](https://nodejs.org/en/)\n\n[python官网](https://www.python.org/)\n\n你也可以使用`Chocolatey`,它是一个Windows上的包管理器，类似于linux上的yum和 apt-get。\n\n安装Chocolatey：\n\n\t@powershell -NoProfile -ExecutionPolicy Bypass -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\n\n安装Python 2：\n\n\tchoco install python2\n\n安装Node：\n\n\tchoco install nodejs.install\n\n安装react-native-cli：\n\n\tnpm install -g react-native-cli\n\n\n## 搭建Android开发环境 ##\n\n下载Android sdk tools ，它是一个Android sdk 管理工具。[点此下载](http://tools.android-studio.org/index.php/sdk)\n\n下载安装完毕后，选择SDK Manager打开，下载以下package：\n\n- 在Android 6.0 (Marshmallow)中勾选：\n\t- Google APIs\n\t- Intel x86 Atom System Image\n\t- Intel x86 Atom_64 System Image\n\t- Google APIs Intel x86 Atom_64 System Image\n\n- 在SDK Tools中勾选\n\t- Android SDK Build-Tools 23.0.1。（**必须是这个版本**）\n\n安装完毕后，添加ANDROID_HOME环境变量。至此，大功告成。\n\n\n## 安装Android模拟器 ##\n\n官方推荐Genymotion模拟器，我使用了下，确实很好用，并且它对个人是免费的（要注册）。[点此下载](https://www.genymotion.com/)\n\n- genymotion需要依赖VirtualBox虚拟机，下载选项中提供了包含VirtualBox和不包含的选项，请按需选择）。\n\n- 打开Genymotion。如果你还没有安装VirtualBox，则此时会提示你安装。\n\n- 创建一个新模拟器并启动。\n\n- 启动React Native应用后，可以按下F1来打开开发者菜单。\n\n## run ##\n\n初始化react-native项目\n\n\treact-native init <projectName>\n\n启动项目（打开模拟器）\n\n\tcd <projectName>\n\treact-native run-android\n\n这一步会启动服务并在模拟器上安装项目apk。如果在模拟器上看到你的app了，则表示成功了。\n\n如果在你运行react-native run-android命令后，Packger可能不会自动运行，这时可以手动运行：\n\n\treact-native start\n\n判断package运行成功与否可以通过访问：[http://localhost:8081/index.android.bundle?platform=android](http://localhost:8081/index.android.bundle?platform=android)。如果能打开页面则表示启动成功。\n\n\n在模拟器上打开项目app，然后摇一摇手机（模拟器有摇一摇按钮），或者直接输入ctrl+m打开调试窗口，点击Dev Settings后，点击Debug server host & port for device,设置IP和端口，输入你的电脑的ip地址，并加上8081端口号。点击确定，重启app。这时你就能看到react-antive界面了。","source":"_posts/windows下React-native开发Android入门（ 一 ）环境搭建.md","raw":"windows下React-native 环境搭建\n\n公司决定试水react-native，mac审批还没下来，没办法，先用windows硬着头皮上吧。\n\n参考文章：\n\n[React Native 中文网官方文档](http://reactnative.cn/docs/0.31/getting-started.html#content)\n\n[史上最全Windows版本搭建安装React Native环境配置](http://www.w2bc.com/article/103350)\n\n##安装windows环境##\n\n- Java Development Kit [JDK] 1.8+\n- Python 2\n- Node\n- react-native-cli (React Native命令行工具)\n\n先把jdk1.8+、Python2、node安装了，这三个不分先后，安装完毕记得添加环境变量，这里就不多说了。详细情况可以参照：\n\n[搭建Java开发环境](http://www.cnblogs.com/yzg1/p/5354763.html)\n\n[Node官网](https://nodejs.org/en/)\n\n[python官网](https://www.python.org/)\n\n你也可以使用`Chocolatey`,它是一个Windows上的包管理器，类似于linux上的yum和 apt-get。\n\n安装Chocolatey：\n\n\t@powershell -NoProfile -ExecutionPolicy Bypass -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\n\n安装Python 2：\n\n\tchoco install python2\n\n安装Node：\n\n\tchoco install nodejs.install\n\n安装react-native-cli：\n\n\tnpm install -g react-native-cli\n\n\n## 搭建Android开发环境 ##\n\n下载Android sdk tools ，它是一个Android sdk 管理工具。[点此下载](http://tools.android-studio.org/index.php/sdk)\n\n下载安装完毕后，选择SDK Manager打开，下载以下package：\n\n- 在Android 6.0 (Marshmallow)中勾选：\n\t- Google APIs\n\t- Intel x86 Atom System Image\n\t- Intel x86 Atom_64 System Image\n\t- Google APIs Intel x86 Atom_64 System Image\n\n- 在SDK Tools中勾选\n\t- Android SDK Build-Tools 23.0.1。（**必须是这个版本**）\n\n安装完毕后，添加ANDROID_HOME环境变量。至此，大功告成。\n\n\n## 安装Android模拟器 ##\n\n官方推荐Genymotion模拟器，我使用了下，确实很好用，并且它对个人是免费的（要注册）。[点此下载](https://www.genymotion.com/)\n\n- genymotion需要依赖VirtualBox虚拟机，下载选项中提供了包含VirtualBox和不包含的选项，请按需选择）。\n\n- 打开Genymotion。如果你还没有安装VirtualBox，则此时会提示你安装。\n\n- 创建一个新模拟器并启动。\n\n- 启动React Native应用后，可以按下F1来打开开发者菜单。\n\n## run ##\n\n初始化react-native项目\n\n\treact-native init <projectName>\n\n启动项目（打开模拟器）\n\n\tcd <projectName>\n\treact-native run-android\n\n这一步会启动服务并在模拟器上安装项目apk。如果在模拟器上看到你的app了，则表示成功了。\n\n如果在你运行react-native run-android命令后，Packger可能不会自动运行，这时可以手动运行：\n\n\treact-native start\n\n判断package运行成功与否可以通过访问：[http://localhost:8081/index.android.bundle?platform=android](http://localhost:8081/index.android.bundle?platform=android)。如果能打开页面则表示启动成功。\n\n\n在模拟器上打开项目app，然后摇一摇手机（模拟器有摇一摇按钮），或者直接输入ctrl+m打开调试窗口，点击Dev Settings后，点击Debug server host & port for device,设置IP和端口，输入你的电脑的ip地址，并加上8081端口号。点击确定，重启app。这时你就能看到react-antive界面了。","slug":"windows下React-native开发Android入门（ 一 ）环境搭建","published":1,"date":"2021-12-06T06:07:06.246Z","updated":"2021-12-06T06:07:06.246Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolz0039y4v21elg16gs","content":"<p>windows下React-native 环境搭建</p>\n<p>公司决定试水react-native，mac审批还没下来，没办法，先用windows硬着头皮上吧。</p>\n<p>参考文章：</p>\n<p><a href=\"http://reactnative.cn/docs/0.31/getting-started.html#content\">React Native 中文网官方文档</a></p>\n<p><a href=\"http://www.w2bc.com/article/103350\">史上最全Windows版本搭建安装React Native环境配置</a></p>\n<p>##安装windows环境##</p>\n<ul>\n<li>Java Development Kit [JDK] 1.8+</li>\n<li>Python 2</li>\n<li>Node</li>\n<li>react-native-cli (React Native命令行工具)</li>\n</ul>\n<p>先把jdk1.8+、Python2、node安装了，这三个不分先后，安装完毕记得添加环境变量，这里就不多说了。详细情况可以参照：</p>\n<p><a href=\"http://www.cnblogs.com/yzg1/p/5354763.html\">搭建Java开发环境</a></p>\n<p><a href=\"https://nodejs.org/en/\">Node官网</a></p>\n<p><a href=\"https://www.python.org/\">python官网</a></p>\n<p>你也可以使用<code>Chocolatey</code>,它是一个Windows上的包管理器，类似于linux上的yum和 apt-get。</p>\n<p>安装Chocolatey：</p>\n<pre><code>@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((new-object net.webclient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\n</code></pre>\n<p>安装Python 2：</p>\n<pre><code>choco install python2\n</code></pre>\n<p>安装Node：</p>\n<pre><code>choco install nodejs.install\n</code></pre>\n<p>安装react-native-cli：</p>\n<pre><code>npm install -g react-native-cli\n</code></pre>\n<h2 id=\"搭建Android开发环境\"><a href=\"#搭建Android开发环境\" class=\"headerlink\" title=\"搭建Android开发环境\"></a>搭建Android开发环境</h2><p>下载Android sdk tools ，它是一个Android sdk 管理工具。<a href=\"http://tools.android-studio.org/index.php/sdk\">点此下载</a></p>\n<p>下载安装完毕后，选择SDK Manager打开，下载以下package：</p>\n<ul>\n<li><p>在Android 6.0 (Marshmallow)中勾选：</p>\n<ul>\n<li>Google APIs</li>\n<li>Intel x86 Atom System Image</li>\n<li>Intel x86 Atom_64 System Image</li>\n<li>Google APIs Intel x86 Atom_64 System Image</li>\n</ul>\n</li>\n<li><p>在SDK Tools中勾选</p>\n<ul>\n<li>Android SDK Build-Tools 23.0.1。（<strong>必须是这个版本</strong>）</li>\n</ul>\n</li>\n</ul>\n<p>安装完毕后，添加ANDROID_HOME环境变量。至此，大功告成。</p>\n<h2 id=\"安装Android模拟器\"><a href=\"#安装Android模拟器\" class=\"headerlink\" title=\"安装Android模拟器\"></a>安装Android模拟器</h2><p>官方推荐Genymotion模拟器，我使用了下，确实很好用，并且它对个人是免费的（要注册）。<a href=\"https://www.genymotion.com/\">点此下载</a></p>\n<ul>\n<li><p>genymotion需要依赖VirtualBox虚拟机，下载选项中提供了包含VirtualBox和不包含的选项，请按需选择）。</p>\n</li>\n<li><p>打开Genymotion。如果你还没有安装VirtualBox，则此时会提示你安装。</p>\n</li>\n<li><p>创建一个新模拟器并启动。</p>\n</li>\n<li><p>启动React Native应用后，可以按下F1来打开开发者菜单。</p>\n</li>\n</ul>\n<h2 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h2><p>初始化react-native项目</p>\n<pre><code>react-native init &lt;projectName&gt;\n</code></pre>\n<p>启动项目（打开模拟器）</p>\n<pre><code>cd &lt;projectName&gt;\nreact-native run-android\n</code></pre>\n<p>这一步会启动服务并在模拟器上安装项目apk。如果在模拟器上看到你的app了，则表示成功了。</p>\n<p>如果在你运行react-native run-android命令后，Packger可能不会自动运行，这时可以手动运行：</p>\n<pre><code>react-native start\n</code></pre>\n<p>判断package运行成功与否可以通过访问：<a href=\"http://localhost:8081/index.android.bundle?platform=android\">http://localhost:8081/index.android.bundle?platform=android</a>。如果能打开页面则表示启动成功。</p>\n<p>在模拟器上打开项目app，然后摇一摇手机（模拟器有摇一摇按钮），或者直接输入ctrl+m打开调试窗口，点击Dev Settings后，点击Debug server host &amp; port for device,设置IP和端口，输入你的电脑的ip地址，并加上8081端口号。点击确定，重启app。这时你就能看到react-antive界面了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>windows下React-native 环境搭建</p>\n<p>公司决定试水react-native，mac审批还没下来，没办法，先用windows硬着头皮上吧。</p>\n<p>参考文章：</p>\n<p><a href=\"http://reactnative.cn/docs/0.31/getting-started.html#content\">React Native 中文网官方文档</a></p>\n<p><a href=\"http://www.w2bc.com/article/103350\">史上最全Windows版本搭建安装React Native环境配置</a></p>\n<p>##安装windows环境##</p>\n<ul>\n<li>Java Development Kit [JDK] 1.8+</li>\n<li>Python 2</li>\n<li>Node</li>\n<li>react-native-cli (React Native命令行工具)</li>\n</ul>\n<p>先把jdk1.8+、Python2、node安装了，这三个不分先后，安装完毕记得添加环境变量，这里就不多说了。详细情况可以参照：</p>\n<p><a href=\"http://www.cnblogs.com/yzg1/p/5354763.html\">搭建Java开发环境</a></p>\n<p><a href=\"https://nodejs.org/en/\">Node官网</a></p>\n<p><a href=\"https://www.python.org/\">python官网</a></p>\n<p>你也可以使用<code>Chocolatey</code>,它是一个Windows上的包管理器，类似于linux上的yum和 apt-get。</p>\n<p>安装Chocolatey：</p>\n<pre><code>@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((new-object net.webclient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\n</code></pre>\n<p>安装Python 2：</p>\n<pre><code>choco install python2\n</code></pre>\n<p>安装Node：</p>\n<pre><code>choco install nodejs.install\n</code></pre>\n<p>安装react-native-cli：</p>\n<pre><code>npm install -g react-native-cli\n</code></pre>\n<h2 id=\"搭建Android开发环境\"><a href=\"#搭建Android开发环境\" class=\"headerlink\" title=\"搭建Android开发环境\"></a>搭建Android开发环境</h2><p>下载Android sdk tools ，它是一个Android sdk 管理工具。<a href=\"http://tools.android-studio.org/index.php/sdk\">点此下载</a></p>\n<p>下载安装完毕后，选择SDK Manager打开，下载以下package：</p>\n<ul>\n<li><p>在Android 6.0 (Marshmallow)中勾选：</p>\n<ul>\n<li>Google APIs</li>\n<li>Intel x86 Atom System Image</li>\n<li>Intel x86 Atom_64 System Image</li>\n<li>Google APIs Intel x86 Atom_64 System Image</li>\n</ul>\n</li>\n<li><p>在SDK Tools中勾选</p>\n<ul>\n<li>Android SDK Build-Tools 23.0.1。（<strong>必须是这个版本</strong>）</li>\n</ul>\n</li>\n</ul>\n<p>安装完毕后，添加ANDROID_HOME环境变量。至此，大功告成。</p>\n<h2 id=\"安装Android模拟器\"><a href=\"#安装Android模拟器\" class=\"headerlink\" title=\"安装Android模拟器\"></a>安装Android模拟器</h2><p>官方推荐Genymotion模拟器，我使用了下，确实很好用，并且它对个人是免费的（要注册）。<a href=\"https://www.genymotion.com/\">点此下载</a></p>\n<ul>\n<li><p>genymotion需要依赖VirtualBox虚拟机，下载选项中提供了包含VirtualBox和不包含的选项，请按需选择）。</p>\n</li>\n<li><p>打开Genymotion。如果你还没有安装VirtualBox，则此时会提示你安装。</p>\n</li>\n<li><p>创建一个新模拟器并启动。</p>\n</li>\n<li><p>启动React Native应用后，可以按下F1来打开开发者菜单。</p>\n</li>\n</ul>\n<h2 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h2><p>初始化react-native项目</p>\n<pre><code>react-native init &lt;projectName&gt;\n</code></pre>\n<p>启动项目（打开模拟器）</p>\n<pre><code>cd &lt;projectName&gt;\nreact-native run-android\n</code></pre>\n<p>这一步会启动服务并在模拟器上安装项目apk。如果在模拟器上看到你的app了，则表示成功了。</p>\n<p>如果在你运行react-native run-android命令后，Packger可能不会自动运行，这时可以手动运行：</p>\n<pre><code>react-native start\n</code></pre>\n<p>判断package运行成功与否可以通过访问：<a href=\"http://localhost:8081/index.android.bundle?platform=android\">http://localhost:8081/index.android.bundle?platform=android</a>。如果能打开页面则表示启动成功。</p>\n<p>在模拟器上打开项目app，然后摇一摇手机（模拟器有摇一摇按钮），或者直接输入ctrl+m打开调试窗口，点击Dev Settings后，点击Debug server host &amp; port for device,设置IP和端口，输入你的电脑的ip地址，并加上8081端口号。点击确定，重启app。这时你就能看到react-antive界面了。</p>\n"},{"_content":"# url参数解析\n\n```js\n// 参数解析\nfunction parseQuery(url) {\n    let u = url.split('?');\n    if (u.length === 2) {\n        let paramString = u[1].split('&');\n        return paramString.reduce((result, current) => {\n            let param = current.split('=');\n            param.length === 2 && (result[param[0]] = param[1]);\n            return result;\n        }, {});\n    } else {\n        throw '非法参数';\n    }\n}\n```","source":"_posts/url参数解析.md","raw":"# url参数解析\n\n```js\n// 参数解析\nfunction parseQuery(url) {\n    let u = url.split('?');\n    if (u.length === 2) {\n        let paramString = u[1].split('&');\n        return paramString.reduce((result, current) => {\n            let param = current.split('=');\n            param.length === 2 && (result[param[0]] = param[1]);\n            return result;\n        }, {});\n    } else {\n        throw '非法参数';\n    }\n}\n```","slug":"url参数解析","published":1,"date":"2021-12-06T05:35:02.631Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwolz003ay4v25m6ibt2a","content":"<h1 id=\"url参数解析\"><a href=\"#url参数解析\" class=\"headerlink\" title=\"url参数解析\"></a>url参数解析</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数解析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseQuery</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> u = url.split(<span class=\"string\">&#x27;?&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (u.length === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> paramString = u[<span class=\"number\">1</span>].split(<span class=\"string\">&#x27;&amp;&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> paramString.reduce(<span class=\"function\">(<span class=\"params\">result, current</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> param = current.split(<span class=\"string\">&#x27;=&#x27;</span>);</span><br><span class=\"line\">            param.length === <span class=\"number\">2</span> &amp;&amp; (result[param[<span class=\"number\">0</span>]] = param[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;, &#123;&#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">&#x27;非法参数&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"url参数解析\"><a href=\"#url参数解析\" class=\"headerlink\" title=\"url参数解析\"></a>url参数解析</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数解析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseQuery</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> u = url.split(<span class=\"string\">&#x27;?&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (u.length === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> paramString = u[<span class=\"number\">1</span>].split(<span class=\"string\">&#x27;&amp;&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> paramString.reduce(<span class=\"function\">(<span class=\"params\">result, current</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> param = current.split(<span class=\"string\">&#x27;=&#x27;</span>);</span><br><span class=\"line\">            param.length === <span class=\"number\">2</span> &amp;&amp; (result[param[<span class=\"number\">0</span>]] = param[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;, &#123;&#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">&#x27;非法参数&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"_content":"# windows下React-native开发Android入门（ 三 ）布局及样式 #\n\n## Flexbox布局 ##\n\n### flexDirection ###\n\n决定布局的主轴，子元素的排列方式。默认值是竖直轴(column)方向。\n\n### justifyContent ###\n\n决定子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：\n\n- flex-start 靠近主轴的起始端分布\n \n  ![](https://bigdots.github.io/blog/images/201601/flex-start.png)\n\n- center 居中分布\n\n  ![](https://bigdots.github.io/blog/images/201601/flex-center.png)\n\n- flex-end 靠近末尾端的起始端\n\n  ![](https://bigdots.github.io/blog/images/201601/flex-end.png)\n\n- space-around  均匀分布，第一子元素不在容器最左边，最后一个子元素不在最右边\n\n  ![](https://bigdots.github.io/blog/images/201601/flex-around.png)\n\n- space-between 均匀分布，第一子元素在容器最左边，最后一个子元素在最右边。倆端对其\n\n  ![](https://bigdots.github.io/blog/images/201601/flex-between.png)\n\n### alignItems ###\n\n决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。\n\n- flex-start\n- center\n- flex-end\n- stretch。 项目被拉伸以适应容器，但是要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。\n\n ![](https://bigdots.github.io/blog/images/201601/align-items-stretch.png)\n\n## CSS样式 ##\n\nReact Native基本遵循css的样式规则，但它是使用JavaScript来写样式的，所以所有样式属性必须按照JS的语法要求使用了驼峰命名法。\n\n每一个组件都同html一样包含一个style属性，但不同的是，它接收的并不一个字符串，而是一个普通的JavaScript对象或者一个对象数组。实际开发中，我们可以直接在组件style属性中写样式对象，也可以传入一个通过`StyleSheet.create`集中定义的组件样式。\n\n\tclass LotsOfStyles extends Component {\n\t  render() {\n\t    return (\n\t      <View>\n\t        <Text style={{color:red}}>just red</Text>\n\t\t\t<Text style={styles.red}>just red</Text>\n\t        <Text style={[styles.bigblue, styles.red]}>bigblue, then red</Text>\n\t      </View>\n\t    );\n\t  }\n\t}\n\t//集中定义样式组件\n\tconst styles = StyleSheet.create({\n\t  bigblue: {\n\t    color: 'blue',\n\t    fontWeight: 'bold',\n\t    fontSize: 30,\n\t  },\n\t  red: {\n\t    color: 'red',\n\t  },\n\t});","source":"_posts/windows下React-native开发Android入门（ 三 ）布局及样式.md","raw":"# windows下React-native开发Android入门（ 三 ）布局及样式 #\n\n## Flexbox布局 ##\n\n### flexDirection ###\n\n决定布局的主轴，子元素的排列方式。默认值是竖直轴(column)方向。\n\n### justifyContent ###\n\n决定子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：\n\n- flex-start 靠近主轴的起始端分布\n \n  ![](https://bigdots.github.io/blog/images/201601/flex-start.png)\n\n- center 居中分布\n\n  ![](https://bigdots.github.io/blog/images/201601/flex-center.png)\n\n- flex-end 靠近末尾端的起始端\n\n  ![](https://bigdots.github.io/blog/images/201601/flex-end.png)\n\n- space-around  均匀分布，第一子元素不在容器最左边，最后一个子元素不在最右边\n\n  ![](https://bigdots.github.io/blog/images/201601/flex-around.png)\n\n- space-between 均匀分布，第一子元素在容器最左边，最后一个子元素在最右边。倆端对其\n\n  ![](https://bigdots.github.io/blog/images/201601/flex-between.png)\n\n### alignItems ###\n\n决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。\n\n- flex-start\n- center\n- flex-end\n- stretch。 项目被拉伸以适应容器，但是要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。\n\n ![](https://bigdots.github.io/blog/images/201601/align-items-stretch.png)\n\n## CSS样式 ##\n\nReact Native基本遵循css的样式规则，但它是使用JavaScript来写样式的，所以所有样式属性必须按照JS的语法要求使用了驼峰命名法。\n\n每一个组件都同html一样包含一个style属性，但不同的是，它接收的并不一个字符串，而是一个普通的JavaScript对象或者一个对象数组。实际开发中，我们可以直接在组件style属性中写样式对象，也可以传入一个通过`StyleSheet.create`集中定义的组件样式。\n\n\tclass LotsOfStyles extends Component {\n\t  render() {\n\t    return (\n\t      <View>\n\t        <Text style={{color:red}}>just red</Text>\n\t\t\t<Text style={styles.red}>just red</Text>\n\t        <Text style={[styles.bigblue, styles.red]}>bigblue, then red</Text>\n\t      </View>\n\t    );\n\t  }\n\t}\n\t//集中定义样式组件\n\tconst styles = StyleSheet.create({\n\t  bigblue: {\n\t    color: 'blue',\n\t    fontWeight: 'bold',\n\t    fontSize: 30,\n\t  },\n\t  red: {\n\t    color: 'red',\n\t  },\n\t});","slug":"windows下React-native开发Android入门（ 三 ）布局及样式","published":1,"date":"2021-12-06T06:07:06.246Z","updated":"2021-12-06T06:07:06.246Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom0003by4v27olqdg00","content":"<h1 id=\"windows下React-native开发Android入门（-三-）布局及样式\"><a href=\"#windows下React-native开发Android入门（-三-）布局及样式\" class=\"headerlink\" title=\"windows下React-native开发Android入门（ 三 ）布局及样式\"></a>windows下React-native开发Android入门（ 三 ）布局及样式</h1><h2 id=\"Flexbox布局\"><a href=\"#Flexbox布局\" class=\"headerlink\" title=\"Flexbox布局\"></a>Flexbox布局</h2><h3 id=\"flexDirection\"><a href=\"#flexDirection\" class=\"headerlink\" title=\"flexDirection\"></a>flexDirection</h3><p>决定布局的主轴，子元素的排列方式。默认值是竖直轴(column)方向。</p>\n<h3 id=\"justifyContent\"><a href=\"#justifyContent\" class=\"headerlink\" title=\"justifyContent\"></a>justifyContent</h3><p>决定子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：</p>\n<ul>\n<li><p>flex-start 靠近主轴的起始端分布</p>\n<p><img src=\"https://bigdots.github.io/blog/images/201601/flex-start.png\"></p>\n</li>\n<li><p>center 居中分布</p>\n<p><img src=\"https://bigdots.github.io/blog/images/201601/flex-center.png\"></p>\n</li>\n<li><p>flex-end 靠近末尾端的起始端</p>\n<p><img src=\"https://bigdots.github.io/blog/images/201601/flex-end.png\"></p>\n</li>\n<li><p>space-around  均匀分布，第一子元素不在容器最左边，最后一个子元素不在最右边</p>\n<p><img src=\"https://bigdots.github.io/blog/images/201601/flex-around.png\"></p>\n</li>\n<li><p>space-between 均匀分布，第一子元素在容器最左边，最后一个子元素在最右边。倆端对其</p>\n<p><img src=\"https://bigdots.github.io/blog/images/201601/flex-between.png\"></p>\n</li>\n</ul>\n<h3 id=\"alignItems\"><a href=\"#alignItems\" class=\"headerlink\" title=\"alignItems\"></a>alignItems</h3><p>决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。</p>\n<ul>\n<li>flex-start</li>\n<li>center</li>\n<li>flex-end</li>\n<li>stretch。 项目被拉伸以适应容器，但是要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。</li>\n</ul>\n<p> <img src=\"https://bigdots.github.io/blog/images/201601/align-items-stretch.png\"></p>\n<h2 id=\"CSS样式\"><a href=\"#CSS样式\" class=\"headerlink\" title=\"CSS样式\"></a>CSS样式</h2><p>React Native基本遵循css的样式规则，但它是使用JavaScript来写样式的，所以所有样式属性必须按照JS的语法要求使用了驼峰命名法。</p>\n<p>每一个组件都同html一样包含一个style属性，但不同的是，它接收的并不一个字符串，而是一个普通的JavaScript对象或者一个对象数组。实际开发中，我们可以直接在组件style属性中写样式对象，也可以传入一个通过<code>StyleSheet.create</code>集中定义的组件样式。</p>\n<pre><code>class LotsOfStyles extends Component &#123;\n  render() &#123;\n    return (\n      &lt;View&gt;\n        &lt;Text style=&#123;&#123;color:red&#125;&#125;&gt;just red&lt;/Text&gt;\n        &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt;\n        &lt;Text style=&#123;[styles.bigblue, styles.red]&#125;&gt;bigblue, then red&lt;/Text&gt;\n      &lt;/View&gt;\n    );\n  &#125;\n&#125;\n//集中定义样式组件\nconst styles = StyleSheet.create(&#123;\n  bigblue: &#123;\n    color: &#39;blue&#39;,\n    fontWeight: &#39;bold&#39;,\n    fontSize: 30,\n  &#125;,\n  red: &#123;\n    color: &#39;red&#39;,\n  &#125;,\n&#125;);\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"windows下React-native开发Android入门（-三-）布局及样式\"><a href=\"#windows下React-native开发Android入门（-三-）布局及样式\" class=\"headerlink\" title=\"windows下React-native开发Android入门（ 三 ）布局及样式\"></a>windows下React-native开发Android入门（ 三 ）布局及样式</h1><h2 id=\"Flexbox布局\"><a href=\"#Flexbox布局\" class=\"headerlink\" title=\"Flexbox布局\"></a>Flexbox布局</h2><h3 id=\"flexDirection\"><a href=\"#flexDirection\" class=\"headerlink\" title=\"flexDirection\"></a>flexDirection</h3><p>决定布局的主轴，子元素的排列方式。默认值是竖直轴(column)方向。</p>\n<h3 id=\"justifyContent\"><a href=\"#justifyContent\" class=\"headerlink\" title=\"justifyContent\"></a>justifyContent</h3><p>决定子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：</p>\n<ul>\n<li><p>flex-start 靠近主轴的起始端分布</p>\n<p><img src=\"https://bigdots.github.io/blog/images/201601/flex-start.png\"></p>\n</li>\n<li><p>center 居中分布</p>\n<p><img src=\"https://bigdots.github.io/blog/images/201601/flex-center.png\"></p>\n</li>\n<li><p>flex-end 靠近末尾端的起始端</p>\n<p><img src=\"https://bigdots.github.io/blog/images/201601/flex-end.png\"></p>\n</li>\n<li><p>space-around  均匀分布，第一子元素不在容器最左边，最后一个子元素不在最右边</p>\n<p><img src=\"https://bigdots.github.io/blog/images/201601/flex-around.png\"></p>\n</li>\n<li><p>space-between 均匀分布，第一子元素在容器最左边，最后一个子元素在最右边。倆端对其</p>\n<p><img src=\"https://bigdots.github.io/blog/images/201601/flex-between.png\"></p>\n</li>\n</ul>\n<h3 id=\"alignItems\"><a href=\"#alignItems\" class=\"headerlink\" title=\"alignItems\"></a>alignItems</h3><p>决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。</p>\n<ul>\n<li>flex-start</li>\n<li>center</li>\n<li>flex-end</li>\n<li>stretch。 项目被拉伸以适应容器，但是要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。</li>\n</ul>\n<p> <img src=\"https://bigdots.github.io/blog/images/201601/align-items-stretch.png\"></p>\n<h2 id=\"CSS样式\"><a href=\"#CSS样式\" class=\"headerlink\" title=\"CSS样式\"></a>CSS样式</h2><p>React Native基本遵循css的样式规则，但它是使用JavaScript来写样式的，所以所有样式属性必须按照JS的语法要求使用了驼峰命名法。</p>\n<p>每一个组件都同html一样包含一个style属性，但不同的是，它接收的并不一个字符串，而是一个普通的JavaScript对象或者一个对象数组。实际开发中，我们可以直接在组件style属性中写样式对象，也可以传入一个通过<code>StyleSheet.create</code>集中定义的组件样式。</p>\n<pre><code>class LotsOfStyles extends Component &#123;\n  render() &#123;\n    return (\n      &lt;View&gt;\n        &lt;Text style=&#123;&#123;color:red&#125;&#125;&gt;just red&lt;/Text&gt;\n        &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt;\n        &lt;Text style=&#123;[styles.bigblue, styles.red]&#125;&gt;bigblue, then red&lt;/Text&gt;\n      &lt;/View&gt;\n    );\n  &#125;\n&#125;\n//集中定义样式组件\nconst styles = StyleSheet.create(&#123;\n  bigblue: &#123;\n    color: &#39;blue&#39;,\n    fontWeight: &#39;bold&#39;,\n    fontSize: 30,\n  &#125;,\n  red: &#123;\n    color: &#39;red&#39;,\n  &#125;,\n&#125;);\n</code></pre>\n"},{"_content":"# windows下React-native开发Android入门（ 二 ）入口文件 #\n\n\n\n——index.android","source":"_posts/windows下React-native开发Android入门（ 二 ）入口文件.md","raw":"# windows下React-native开发Android入门（ 二 ）入口文件 #\n\n\n\n——index.android","slug":"windows下React-native开发Android入门（ 二 ）入口文件","published":1,"date":"2021-12-06T06:07:06.256Z","updated":"2021-12-06T06:07:06.256Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom0003cy4v2ee3e3i31","content":"<h1 id=\"windows下React-native开发Android入门（-二-）入口文件\"><a href=\"#windows下React-native开发Android入门（-二-）入口文件\" class=\"headerlink\" title=\"windows下React-native开发Android入门（ 二 ）入口文件\"></a>windows下React-native开发Android入门（ 二 ）入口文件</h1><p>——index.android</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"windows下React-native开发Android入门（-二-）入口文件\"><a href=\"#windows下React-native开发Android入门（-二-）入口文件\" class=\"headerlink\" title=\"windows下React-native开发Android入门（ 二 ）入口文件\"></a>windows下React-native开发Android入门（ 二 ）入口文件</h1><p>——index.android</p>\n"},{"_content":"# 网页加载全过程\n\n**过程概述**\n\n+ 浏览器查找域名对应的 IP 地址；\n\n+ 浏览器根据 IP 地址与服务器建立 socket 连接；\n\n+ 浏览器与服务器通信： 浏览器请求，服务器处理请求；\n\n+ 浏览器与服务器断开连接。\n\n## 查找域名对应IP地址\n\n访问服务器需要先知道服务器的ip地址，所以第一步是通过 DNS 把域名解析成一个 IP 地址, DNS 具体的查找过程：（浏览器缓存->系统缓存->路由器缓存）\n\n1. 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n2. 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n3. 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；\n4. 操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求：\n\n\n## 建立连接（TCP的三次握手）\n1. 主机向服务器发送一个建立连接的请求；\n\n2. 服务器接到请求后发送同意连接的信号；\n\n3. 主机接到同意连接的信号后，再次向服务器发送了确认信号 ;\n\n⚠️注意：这里的三次握手中主机两次向服务器发送确认，第二次是为了防止已失效的连接请求报文段传至服务器导致错误。\n\n## 网页请求与构建\n\n### 请求\n1. 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；\n\n2. 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；\n\n3. 服务器将得到的 HTML 文件发送给浏览器；\n\n4. 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；\n\n5. 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；\n\n### 页面构建\n1. HTML代码转化为DOM(DOM Tree)\n\n2. CSS代码转化成CSSOM（CSS Object Model）\n\n3. 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）(Render Tree)\n\n4. 生成布局（layout），即将所有渲染树的所有节点进行平面合成\n\n5. 布局绘制（paint）在屏幕上\n\t\n## 断开连接(TCP的四次挥手)\n1.  主机向服务器发送一个断开连接的请求；\n\n2.  服务器接到请求后发送确认收到请求的信号；(此时服务器可能还有数据要发送至主机)\n\n3. 服务器向主机发送断开通知；(此时服务器确认没有要向主机发送的数据)\n\n4. 主机接到断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接；\n","source":"_posts/一个页面的孕育过程.md","raw":"# 网页加载全过程\n\n**过程概述**\n\n+ 浏览器查找域名对应的 IP 地址；\n\n+ 浏览器根据 IP 地址与服务器建立 socket 连接；\n\n+ 浏览器与服务器通信： 浏览器请求，服务器处理请求；\n\n+ 浏览器与服务器断开连接。\n\n## 查找域名对应IP地址\n\n访问服务器需要先知道服务器的ip地址，所以第一步是通过 DNS 把域名解析成一个 IP 地址, DNS 具体的查找过程：（浏览器缓存->系统缓存->路由器缓存）\n\n1. 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n2. 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n3. 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；\n4. 操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求：\n\n\n## 建立连接（TCP的三次握手）\n1. 主机向服务器发送一个建立连接的请求；\n\n2. 服务器接到请求后发送同意连接的信号；\n\n3. 主机接到同意连接的信号后，再次向服务器发送了确认信号 ;\n\n⚠️注意：这里的三次握手中主机两次向服务器发送确认，第二次是为了防止已失效的连接请求报文段传至服务器导致错误。\n\n## 网页请求与构建\n\n### 请求\n1. 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；\n\n2. 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；\n\n3. 服务器将得到的 HTML 文件发送给浏览器；\n\n4. 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；\n\n5. 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；\n\n### 页面构建\n1. HTML代码转化为DOM(DOM Tree)\n\n2. CSS代码转化成CSSOM（CSS Object Model）\n\n3. 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）(Render Tree)\n\n4. 生成布局（layout），即将所有渲染树的所有节点进行平面合成\n\n5. 布局绘制（paint）在屏幕上\n\t\n## 断开连接(TCP的四次挥手)\n1.  主机向服务器发送一个断开连接的请求；\n\n2.  服务器接到请求后发送确认收到请求的信号；(此时服务器可能还有数据要发送至主机)\n\n3. 服务器向主机发送断开通知；(此时服务器确认没有要向主机发送的数据)\n\n4. 主机接到断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接；\n","slug":"一个页面的孕育过程","published":1,"date":"2021-12-06T06:07:06.256Z","updated":"2021-12-06T06:07:06.256Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom1003dy4v26kl3gnlq","content":"<h1 id=\"网页加载全过程\"><a href=\"#网页加载全过程\" class=\"headerlink\" title=\"网页加载全过程\"></a>网页加载全过程</h1><p><strong>过程概述</strong></p>\n<ul>\n<li><p>浏览器查找域名对应的 IP 地址；</p>\n</li>\n<li><p>浏览器根据 IP 地址与服务器建立 socket 连接；</p>\n</li>\n<li><p>浏览器与服务器通信： 浏览器请求，服务器处理请求；</p>\n</li>\n<li><p>浏览器与服务器断开连接。</p>\n</li>\n</ul>\n<h2 id=\"查找域名对应IP地址\"><a href=\"#查找域名对应IP地址\" class=\"headerlink\" title=\"查找域名对应IP地址\"></a>查找域名对应IP地址</h2><p>访问服务器需要先知道服务器的ip地址，所以第一步是通过 DNS 把域名解析成一个 IP 地址, DNS 具体的查找过程：（浏览器缓存-&gt;系统缓存-&gt;路由器缓存）</p>\n<ol>\n<li>浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li>\n<li>搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li>\n<li>搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；</li>\n<li>操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求：</li>\n</ol>\n<h2 id=\"建立连接（TCP的三次握手）\"><a href=\"#建立连接（TCP的三次握手）\" class=\"headerlink\" title=\"建立连接（TCP的三次握手）\"></a>建立连接（TCP的三次握手）</h2><ol>\n<li><p>主机向服务器发送一个建立连接的请求；</p>\n</li>\n<li><p>服务器接到请求后发送同意连接的信号；</p>\n</li>\n<li><p>主机接到同意连接的信号后，再次向服务器发送了确认信号 ;</p>\n</li>\n</ol>\n<p>⚠️注意：这里的三次握手中主机两次向服务器发送确认，第二次是为了防止已失效的连接请求报文段传至服务器导致错误。</p>\n<h2 id=\"网页请求与构建\"><a href=\"#网页请求与构建\" class=\"headerlink\" title=\"网页请求与构建\"></a>网页请求与构建</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><ol>\n<li><p>浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；</p>\n</li>\n<li><p>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；</p>\n</li>\n<li><p>服务器将得到的 HTML 文件发送给浏览器；</p>\n</li>\n<li><p>在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；</p>\n</li>\n<li><p>在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；</p>\n</li>\n</ol>\n<h3 id=\"页面构建\"><a href=\"#页面构建\" class=\"headerlink\" title=\"页面构建\"></a>页面构建</h3><ol>\n<li><p>HTML代码转化为DOM(DOM Tree)</p>\n</li>\n<li><p>CSS代码转化成CSSOM（CSS Object Model）</p>\n</li>\n<li><p>结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）(Render Tree)</p>\n</li>\n<li><p>生成布局（layout），即将所有渲染树的所有节点进行平面合成</p>\n</li>\n<li><p>布局绘制（paint）在屏幕上</p>\n</li>\n</ol>\n<h2 id=\"断开连接-TCP的四次挥手\"><a href=\"#断开连接-TCP的四次挥手\" class=\"headerlink\" title=\"断开连接(TCP的四次挥手)\"></a>断开连接(TCP的四次挥手)</h2><ol>\n<li><p> 主机向服务器发送一个断开连接的请求；</p>\n</li>\n<li><p> 服务器接到请求后发送确认收到请求的信号；(此时服务器可能还有数据要发送至主机)</p>\n</li>\n<li><p>服务器向主机发送断开通知；(此时服务器确认没有要向主机发送的数据)</p>\n</li>\n<li><p>主机接到断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接；</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"网页加载全过程\"><a href=\"#网页加载全过程\" class=\"headerlink\" title=\"网页加载全过程\"></a>网页加载全过程</h1><p><strong>过程概述</strong></p>\n<ul>\n<li><p>浏览器查找域名对应的 IP 地址；</p>\n</li>\n<li><p>浏览器根据 IP 地址与服务器建立 socket 连接；</p>\n</li>\n<li><p>浏览器与服务器通信： 浏览器请求，服务器处理请求；</p>\n</li>\n<li><p>浏览器与服务器断开连接。</p>\n</li>\n</ul>\n<h2 id=\"查找域名对应IP地址\"><a href=\"#查找域名对应IP地址\" class=\"headerlink\" title=\"查找域名对应IP地址\"></a>查找域名对应IP地址</h2><p>访问服务器需要先知道服务器的ip地址，所以第一步是通过 DNS 把域名解析成一个 IP 地址, DNS 具体的查找过程：（浏览器缓存-&gt;系统缓存-&gt;路由器缓存）</p>\n<ol>\n<li>浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li>\n<li>搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li>\n<li>搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；</li>\n<li>操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求：</li>\n</ol>\n<h2 id=\"建立连接（TCP的三次握手）\"><a href=\"#建立连接（TCP的三次握手）\" class=\"headerlink\" title=\"建立连接（TCP的三次握手）\"></a>建立连接（TCP的三次握手）</h2><ol>\n<li><p>主机向服务器发送一个建立连接的请求；</p>\n</li>\n<li><p>服务器接到请求后发送同意连接的信号；</p>\n</li>\n<li><p>主机接到同意连接的信号后，再次向服务器发送了确认信号 ;</p>\n</li>\n</ol>\n<p>⚠️注意：这里的三次握手中主机两次向服务器发送确认，第二次是为了防止已失效的连接请求报文段传至服务器导致错误。</p>\n<h2 id=\"网页请求与构建\"><a href=\"#网页请求与构建\" class=\"headerlink\" title=\"网页请求与构建\"></a>网页请求与构建</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><ol>\n<li><p>浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；</p>\n</li>\n<li><p>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；</p>\n</li>\n<li><p>服务器将得到的 HTML 文件发送给浏览器；</p>\n</li>\n<li><p>在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；</p>\n</li>\n<li><p>在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；</p>\n</li>\n</ol>\n<h3 id=\"页面构建\"><a href=\"#页面构建\" class=\"headerlink\" title=\"页面构建\"></a>页面构建</h3><ol>\n<li><p>HTML代码转化为DOM(DOM Tree)</p>\n</li>\n<li><p>CSS代码转化成CSSOM（CSS Object Model）</p>\n</li>\n<li><p>结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）(Render Tree)</p>\n</li>\n<li><p>生成布局（layout），即将所有渲染树的所有节点进行平面合成</p>\n</li>\n<li><p>布局绘制（paint）在屏幕上</p>\n</li>\n</ol>\n<h2 id=\"断开连接-TCP的四次挥手\"><a href=\"#断开连接-TCP的四次挥手\" class=\"headerlink\" title=\"断开连接(TCP的四次挥手)\"></a>断开连接(TCP的四次挥手)</h2><ol>\n<li><p> 主机向服务器发送一个断开连接的请求；</p>\n</li>\n<li><p> 服务器接到请求后发送确认收到请求的信号；(此时服务器可能还有数据要发送至主机)</p>\n</li>\n<li><p>服务器向主机发送断开通知；(此时服务器确认没有要向主机发送的数据)</p>\n</li>\n<li><p>主机接到断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接；</p>\n</li>\n</ol>\n"},{"_content":"# JavaScript事件循环(Event Loop)机制\n\n## JavaScript 是单线程单并发语言\n\n1. 什么是单线程\n\n    主程序只有一个线程，即同一时间片断内其只能执行单个任务。\n\n2. 为什么选择单线程？\n\n    JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。\n\n3. 单线程意味着什么？\n\n    单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就需要一直等着。这就会导致`IO操作（耗时但cpu闲置）`时造成性能浪费的问题。\n\n4. 如何解决单线程带来的性能问题？\n\n    答案是**异步**！主线程完全可以不管IO操作，暂时挂起处于等待中的任务，先运行排在后面的任务。等到IO操作返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）\n\n\n\n    **注：**  当主线程阻塞时，任务队列仍然是能够被推入任务的\n\n\n## 事件循环（Event Loop）\n\n1. JavaScript 内存模型\n\n    讲事件循环之前，先看一张下网上看到的 JavaScript 内存模型，相信看完这个会对事件循环机制有一种豁然开朗的感觉。\n\n    ![](https://raw.githubusercontent.com/bigdots/blog/master/images/201709/h-s-q.png)\n\n    + 调用栈（Call Stack）：用于主线程任务的执行\n    + 堆（Heap）： 用于存放非结构化数据，譬如程序分配的变量与对象\n    + 任务队列（Queue）： 用于存放异步任务与定时任务。\n\n2. JavaScript 代码执行机制：\n\n    + 所有同步任务都在主线程上的栈中执行。\n    + 主线程之外，还存在一个\"任务队列\"（task queue）。**只要异步任务有了运行结果**，就在\"任务队列\"之中放置一个事件。\n    + 一旦\"栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，选择出需要首先执行的任务（由浏览器决定，并不按序）。\n\n3. Event Loop\n\n    现在我们来聊事件循环。事件循环顾名思义它就是一个循环，主线程会不断循环执行上面的第三步,其基本的代码逻辑如下所示：\n\n    ```js\n    while (queue.waitForMessage()) {\n    queue.processNextMessage();\n    }\n    ```\n\n4. 常见异步任务进入任务队列时机\n\n    |  行为              |           时机              |\n    |:----              |:----                       |\n    | DOM操作           | 在用户点击等操作事件完成后      |\n    | 网络操作（Ajax等）  | 在网络操作响应后              |\n    | 定时器             | 在规定时间到达后              |\n\n    事件循环机制图解：\n\n    ![](https://raw.githubusercontent.com/bigdots/blog/master/images/201709/eventLoop.png)\n\n## 任务\n\n1. MacroTask（Task）\n    setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering \n\n2. MicroTask（在ES2015规范中称为Job）\n     process.nextTick, Promise, Object.observe, MutationObserver \n\n规范：\n\n+ 每个浏览器环境，至多有一个event loop。\n+ 一个event loop可以有1个或多个task queue，而仅有一个 MicroTask Queue。\n+ 一个task queue是一列有序的task, 每个task定义时都有一个task source，从同一个task source来的task必须放到同一个task queue，从不同源来的则被添加到不同队列。\n+ tasks are scheduled，所以浏览器可以从内部到JS/DOM，保证动作按序发生。\n+ Microtasks are scheduled，Microtask queue 在当前 task queue 的结尾执行。microtask中添加的microtask也被添加到Microtask queue的末尾并处理。\n\n **注：** event loop的每个turn，是由浏览器决定先执行哪个task queue。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。\n\n\n## 示例\n\n```js\n\nfunction ELoop() {\n    // 当前任务\n    let p = new Promise((resolve, reject)=>{\n        console.log(\"current Task\")\n        resolve();\n    });\n    let nextP; \n\n    setTimeout(()=>{\n        console.log(\"MacroTask_1\");\n        nextP.then(()=>{\n            // 第一次执行时，这段代码并没有执行到。\n            console.log(\"MicroTask_promise_1\"); //第一个MicroTask\n        })\n        console.log(\"MacroTask_1 end\")\n    }, 0) // 第一个 MacroTask\n\n    setTimeout(()=>{\n        console.log(\"MacroTask_2\");\n        console.log(\"MacroTask_2 end\")\n    }, 0)// 第二个MacroTask\n\n    nextP = p.then(()=>{\n        console.log(\"MicroTask_promise_2\"); //第一个MicroTask\n        console.log(1)\n    }).then(()=>{\n        console.log(\"MicroTask_promise_3\"); // 第二个MicroTask\n        console.log(1)\n    })\n\n    console.log(\"current Task end\")\n}\n\nELoop();\n\n/**输出结果：\ncurrent Task\nMicroTask_promise_2\nMicroTask_promise_3\nMacroTask_1\nMicroTask_promise_1\nMacroTask_2\n**/\n```\n\n参考文献:\n\n[从Promise来看JavaScript中的Event Loop、Tasks和Microtasks](https://github.com/creeperyang/blog/issues/21)\n\n[JavaScript Event Loop 机制详解与 Vue.js 中实践应用](http://mp.weixin.qq.com/s/qJSmotjzeu02EeK51NgFUQ)\n\n[JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)","source":"_posts/事件循环机制.md","raw":"# JavaScript事件循环(Event Loop)机制\n\n## JavaScript 是单线程单并发语言\n\n1. 什么是单线程\n\n    主程序只有一个线程，即同一时间片断内其只能执行单个任务。\n\n2. 为什么选择单线程？\n\n    JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。\n\n3. 单线程意味着什么？\n\n    单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就需要一直等着。这就会导致`IO操作（耗时但cpu闲置）`时造成性能浪费的问题。\n\n4. 如何解决单线程带来的性能问题？\n\n    答案是**异步**！主线程完全可以不管IO操作，暂时挂起处于等待中的任务，先运行排在后面的任务。等到IO操作返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）\n\n\n\n    **注：**  当主线程阻塞时，任务队列仍然是能够被推入任务的\n\n\n## 事件循环（Event Loop）\n\n1. JavaScript 内存模型\n\n    讲事件循环之前，先看一张下网上看到的 JavaScript 内存模型，相信看完这个会对事件循环机制有一种豁然开朗的感觉。\n\n    ![](https://raw.githubusercontent.com/bigdots/blog/master/images/201709/h-s-q.png)\n\n    + 调用栈（Call Stack）：用于主线程任务的执行\n    + 堆（Heap）： 用于存放非结构化数据，譬如程序分配的变量与对象\n    + 任务队列（Queue）： 用于存放异步任务与定时任务。\n\n2. JavaScript 代码执行机制：\n\n    + 所有同步任务都在主线程上的栈中执行。\n    + 主线程之外，还存在一个\"任务队列\"（task queue）。**只要异步任务有了运行结果**，就在\"任务队列\"之中放置一个事件。\n    + 一旦\"栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，选择出需要首先执行的任务（由浏览器决定，并不按序）。\n\n3. Event Loop\n\n    现在我们来聊事件循环。事件循环顾名思义它就是一个循环，主线程会不断循环执行上面的第三步,其基本的代码逻辑如下所示：\n\n    ```js\n    while (queue.waitForMessage()) {\n    queue.processNextMessage();\n    }\n    ```\n\n4. 常见异步任务进入任务队列时机\n\n    |  行为              |           时机              |\n    |:----              |:----                       |\n    | DOM操作           | 在用户点击等操作事件完成后      |\n    | 网络操作（Ajax等）  | 在网络操作响应后              |\n    | 定时器             | 在规定时间到达后              |\n\n    事件循环机制图解：\n\n    ![](https://raw.githubusercontent.com/bigdots/blog/master/images/201709/eventLoop.png)\n\n## 任务\n\n1. MacroTask（Task）\n    setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering \n\n2. MicroTask（在ES2015规范中称为Job）\n     process.nextTick, Promise, Object.observe, MutationObserver \n\n规范：\n\n+ 每个浏览器环境，至多有一个event loop。\n+ 一个event loop可以有1个或多个task queue，而仅有一个 MicroTask Queue。\n+ 一个task queue是一列有序的task, 每个task定义时都有一个task source，从同一个task source来的task必须放到同一个task queue，从不同源来的则被添加到不同队列。\n+ tasks are scheduled，所以浏览器可以从内部到JS/DOM，保证动作按序发生。\n+ Microtasks are scheduled，Microtask queue 在当前 task queue 的结尾执行。microtask中添加的microtask也被添加到Microtask queue的末尾并处理。\n\n **注：** event loop的每个turn，是由浏览器决定先执行哪个task queue。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。\n\n\n## 示例\n\n```js\n\nfunction ELoop() {\n    // 当前任务\n    let p = new Promise((resolve, reject)=>{\n        console.log(\"current Task\")\n        resolve();\n    });\n    let nextP; \n\n    setTimeout(()=>{\n        console.log(\"MacroTask_1\");\n        nextP.then(()=>{\n            // 第一次执行时，这段代码并没有执行到。\n            console.log(\"MicroTask_promise_1\"); //第一个MicroTask\n        })\n        console.log(\"MacroTask_1 end\")\n    }, 0) // 第一个 MacroTask\n\n    setTimeout(()=>{\n        console.log(\"MacroTask_2\");\n        console.log(\"MacroTask_2 end\")\n    }, 0)// 第二个MacroTask\n\n    nextP = p.then(()=>{\n        console.log(\"MicroTask_promise_2\"); //第一个MicroTask\n        console.log(1)\n    }).then(()=>{\n        console.log(\"MicroTask_promise_3\"); // 第二个MicroTask\n        console.log(1)\n    })\n\n    console.log(\"current Task end\")\n}\n\nELoop();\n\n/**输出结果：\ncurrent Task\nMicroTask_promise_2\nMicroTask_promise_3\nMacroTask_1\nMicroTask_promise_1\nMacroTask_2\n**/\n```\n\n参考文献:\n\n[从Promise来看JavaScript中的Event Loop、Tasks和Microtasks](https://github.com/creeperyang/blog/issues/21)\n\n[JavaScript Event Loop 机制详解与 Vue.js 中实践应用](http://mp.weixin.qq.com/s/qJSmotjzeu02EeK51NgFUQ)\n\n[JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)","slug":"事件循环机制","published":1,"date":"2021-12-06T06:07:06.267Z","updated":"2021-12-06T06:07:06.270Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom2003ey4v23ttc7dfo","content":"<h1 id=\"JavaScript事件循环-Event-Loop-机制\"><a href=\"#JavaScript事件循环-Event-Loop-机制\" class=\"headerlink\" title=\"JavaScript事件循环(Event Loop)机制\"></a>JavaScript事件循环(Event Loop)机制</h1><h2 id=\"JavaScript-是单线程单并发语言\"><a href=\"#JavaScript-是单线程单并发语言\" class=\"headerlink\" title=\"JavaScript 是单线程单并发语言\"></a>JavaScript 是单线程单并发语言</h2><ol>\n<li><p>什么是单线程</p>\n<p> 主程序只有一个线程，即同一时间片断内其只能执行单个任务。</p>\n</li>\n<li><p>为什么选择单线程？</p>\n<p> JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p>\n</li>\n<li><p>单线程意味着什么？</p>\n<p> 单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就需要一直等着。这就会导致<code>IO操作（耗时但cpu闲置）</code>时造成性能浪费的问题。</p>\n</li>\n<li><p>如何解决单线程带来的性能问题？</p>\n<p> 答案是<strong>异步</strong>！主线程完全可以不管IO操作，暂时挂起处于等待中的任务，先运行排在后面的任务。等到IO操作返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）</p>\n</li>\n</ol>\n<pre><code>**注：**  当主线程阻塞时，任务队列仍然是能够被推入任务的\n</code></pre>\n<h2 id=\"事件循环（Event-Loop）\"><a href=\"#事件循环（Event-Loop）\" class=\"headerlink\" title=\"事件循环（Event Loop）\"></a>事件循环（Event Loop）</h2><ol>\n<li><p>JavaScript 内存模型</p>\n<p> 讲事件循环之前，先看一张下网上看到的 JavaScript 内存模型，相信看完这个会对事件循环机制有一种豁然开朗的感觉。</p>\n<p> <img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201709/h-s-q.png\"></p>\n<ul>\n<li>调用栈（Call Stack）：用于主线程任务的执行</li>\n<li>堆（Heap）： 用于存放非结构化数据，譬如程序分配的变量与对象</li>\n<li>任务队列（Queue）： 用于存放异步任务与定时任务。</li>\n</ul>\n</li>\n<li><p>JavaScript 代码执行机制：</p>\n<ul>\n<li>所有同步任务都在主线程上的栈中执行。</li>\n<li>主线程之外，还存在一个”任务队列”（task queue）。<strong>只要异步任务有了运行结果</strong>，就在”任务队列”之中放置一个事件。</li>\n<li>一旦”栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，选择出需要首先执行的任务（由浏览器决定，并不按序）。</li>\n</ul>\n</li>\n<li><p>Event Loop</p>\n<p> 现在我们来聊事件循环。事件循环顾名思义它就是一个循环，主线程会不断循环执行上面的第三步,其基本的代码逻辑如下所示：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (queue.waitForMessage()) &#123;</span><br><span class=\"line\">queue.processNextMessage();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>常见异步任务进入任务队列时机</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">行为</th>\n<th align=\"left\">时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">DOM操作</td>\n<td align=\"left\">在用户点击等操作事件完成后</td>\n</tr>\n<tr>\n<td align=\"left\">网络操作（Ajax等）</td>\n<td align=\"left\">在网络操作响应后</td>\n</tr>\n<tr>\n<td align=\"left\">定时器</td>\n<td align=\"left\">在规定时间到达后</td>\n</tr>\n</tbody></table>\n<p> 事件循环机制图解：</p>\n<p> <img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201709/eventLoop.png\"></p>\n</li>\n</ol>\n<h2 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h2><ol>\n<li><p>MacroTask（Task）<br> setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering </p>\n</li>\n<li><p>MicroTask（在ES2015规范中称为Job）<br>  process.nextTick, Promise, Object.observe, MutationObserver </p>\n</li>\n</ol>\n<p>规范：</p>\n<ul>\n<li>每个浏览器环境，至多有一个event loop。</li>\n<li>一个event loop可以有1个或多个task queue，而仅有一个 MicroTask Queue。</li>\n<li>一个task queue是一列有序的task, 每个task定义时都有一个task source，从同一个task source来的task必须放到同一个task queue，从不同源来的则被添加到不同队列。</li>\n<li>tasks are scheduled，所以浏览器可以从内部到JS/DOM，保证动作按序发生。</li>\n<li>Microtasks are scheduled，Microtask queue 在当前 task queue 的结尾执行。microtask中添加的microtask也被添加到Microtask queue的末尾并处理。</li>\n</ul>\n<p> <strong>注：</strong> event loop的每个turn，是由浏览器决定先执行哪个task queue。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ELoop</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前任务</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;current Task&quot;</span>)</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextP; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_1&quot;</span>);</span><br><span class=\"line\">        nextP.then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 第一次执行时，这段代码并没有执行到。</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_1&quot;</span>); <span class=\"comment\">//第一个MicroTask</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_1 end&quot;</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>) <span class=\"comment\">// 第一个 MacroTask</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_2&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_2 end&quot;</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)<span class=\"comment\">// 第二个MacroTask</span></span><br><span class=\"line\"></span><br><span class=\"line\">    nextP = p.then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_2&quot;</span>); <span class=\"comment\">//第一个MicroTask</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;).then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_3&quot;</span>); <span class=\"comment\">// 第二个MicroTask</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;current Task end&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ELoop();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">current Task</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_2</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_3</span></span><br><span class=\"line\"><span class=\"comment\">MacroTask_1</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_1</span></span><br><span class=\"line\"><span class=\"comment\">MacroTask_2</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n\n<p>参考文献:</p>\n<p><a href=\"https://github.com/creeperyang/blog/issues/21\">从Promise来看JavaScript中的Event Loop、Tasks和Microtasks</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s/qJSmotjzeu02EeK51NgFUQ\">JavaScript Event Loop 机制详解与 Vue.js 中实践应用</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript事件循环-Event-Loop-机制\"><a href=\"#JavaScript事件循环-Event-Loop-机制\" class=\"headerlink\" title=\"JavaScript事件循环(Event Loop)机制\"></a>JavaScript事件循环(Event Loop)机制</h1><h2 id=\"JavaScript-是单线程单并发语言\"><a href=\"#JavaScript-是单线程单并发语言\" class=\"headerlink\" title=\"JavaScript 是单线程单并发语言\"></a>JavaScript 是单线程单并发语言</h2><ol>\n<li><p>什么是单线程</p>\n<p> 主程序只有一个线程，即同一时间片断内其只能执行单个任务。</p>\n</li>\n<li><p>为什么选择单线程？</p>\n<p> JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p>\n</li>\n<li><p>单线程意味着什么？</p>\n<p> 单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就需要一直等着。这就会导致<code>IO操作（耗时但cpu闲置）</code>时造成性能浪费的问题。</p>\n</li>\n<li><p>如何解决单线程带来的性能问题？</p>\n<p> 答案是<strong>异步</strong>！主线程完全可以不管IO操作，暂时挂起处于等待中的任务，先运行排在后面的任务。等到IO操作返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）</p>\n</li>\n</ol>\n<pre><code>**注：**  当主线程阻塞时，任务队列仍然是能够被推入任务的\n</code></pre>\n<h2 id=\"事件循环（Event-Loop）\"><a href=\"#事件循环（Event-Loop）\" class=\"headerlink\" title=\"事件循环（Event Loop）\"></a>事件循环（Event Loop）</h2><ol>\n<li><p>JavaScript 内存模型</p>\n<p> 讲事件循环之前，先看一张下网上看到的 JavaScript 内存模型，相信看完这个会对事件循环机制有一种豁然开朗的感觉。</p>\n<p> <img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201709/h-s-q.png\"></p>\n<ul>\n<li>调用栈（Call Stack）：用于主线程任务的执行</li>\n<li>堆（Heap）： 用于存放非结构化数据，譬如程序分配的变量与对象</li>\n<li>任务队列（Queue）： 用于存放异步任务与定时任务。</li>\n</ul>\n</li>\n<li><p>JavaScript 代码执行机制：</p>\n<ul>\n<li>所有同步任务都在主线程上的栈中执行。</li>\n<li>主线程之外，还存在一个”任务队列”（task queue）。<strong>只要异步任务有了运行结果</strong>，就在”任务队列”之中放置一个事件。</li>\n<li>一旦”栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，选择出需要首先执行的任务（由浏览器决定，并不按序）。</li>\n</ul>\n</li>\n<li><p>Event Loop</p>\n<p> 现在我们来聊事件循环。事件循环顾名思义它就是一个循环，主线程会不断循环执行上面的第三步,其基本的代码逻辑如下所示：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (queue.waitForMessage()) &#123;</span><br><span class=\"line\">queue.processNextMessage();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>常见异步任务进入任务队列时机</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">行为</th>\n<th align=\"left\">时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">DOM操作</td>\n<td align=\"left\">在用户点击等操作事件完成后</td>\n</tr>\n<tr>\n<td align=\"left\">网络操作（Ajax等）</td>\n<td align=\"left\">在网络操作响应后</td>\n</tr>\n<tr>\n<td align=\"left\">定时器</td>\n<td align=\"left\">在规定时间到达后</td>\n</tr>\n</tbody></table>\n<p> 事件循环机制图解：</p>\n<p> <img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201709/eventLoop.png\"></p>\n</li>\n</ol>\n<h2 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h2><ol>\n<li><p>MacroTask（Task）<br> setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering </p>\n</li>\n<li><p>MicroTask（在ES2015规范中称为Job）<br>  process.nextTick, Promise, Object.observe, MutationObserver </p>\n</li>\n</ol>\n<p>规范：</p>\n<ul>\n<li>每个浏览器环境，至多有一个event loop。</li>\n<li>一个event loop可以有1个或多个task queue，而仅有一个 MicroTask Queue。</li>\n<li>一个task queue是一列有序的task, 每个task定义时都有一个task source，从同一个task source来的task必须放到同一个task queue，从不同源来的则被添加到不同队列。</li>\n<li>tasks are scheduled，所以浏览器可以从内部到JS/DOM，保证动作按序发生。</li>\n<li>Microtasks are scheduled，Microtask queue 在当前 task queue 的结尾执行。microtask中添加的microtask也被添加到Microtask queue的末尾并处理。</li>\n</ul>\n<p> <strong>注：</strong> event loop的每个turn，是由浏览器决定先执行哪个task queue。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ELoop</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前任务</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;current Task&quot;</span>)</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextP; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_1&quot;</span>);</span><br><span class=\"line\">        nextP.then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 第一次执行时，这段代码并没有执行到。</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_1&quot;</span>); <span class=\"comment\">//第一个MicroTask</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_1 end&quot;</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>) <span class=\"comment\">// 第一个 MacroTask</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_2&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MacroTask_2 end&quot;</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)<span class=\"comment\">// 第二个MacroTask</span></span><br><span class=\"line\"></span><br><span class=\"line\">    nextP = p.then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_2&quot;</span>); <span class=\"comment\">//第一个MicroTask</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;).then(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;MicroTask_promise_3&quot;</span>); <span class=\"comment\">// 第二个MicroTask</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;current Task end&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ELoop();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">current Task</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_2</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_3</span></span><br><span class=\"line\"><span class=\"comment\">MacroTask_1</span></span><br><span class=\"line\"><span class=\"comment\">MicroTask_promise_1</span></span><br><span class=\"line\"><span class=\"comment\">MacroTask_2</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n\n<p>参考文献:</p>\n<p><a href=\"https://github.com/creeperyang/blog/issues/21\">从Promise来看JavaScript中的Event Loop、Tasks和Microtasks</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s/qJSmotjzeu02EeK51NgFUQ\">JavaScript Event Loop 机制详解与 Vue.js 中实践应用</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop</a></p>\n"},{"title":"了解闭包","date":"2015-12-22T05:03:19.000Z","description":"闭包，了解闭包","_content":"\n江湖上都说要了解闭包，得先了解作用域链，所以，先从作用域链开始吧。\n## 作用域链\n1. 作用域链是一个对象列表或链表，这组对象定义了这段代码“作用域”中的变量；\n2. 每当调用一个函数，这个函数会创建一个新的对象来储存它的变量（变量绑定对象），并且将这个对象添加到作用域链上；当函数返回时，就从作用域链中将这个对象删除；\n3. 当javascript需要查找一个变量时，它会沿着作用域链一级一级地搜索变量。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至作用域链的最顶层（全局对象）为止。\n4. 对于嵌套函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链都指向一个变量绑定对象\n\n<!-- more -->\n\n**我们来看一个栗子**\n\n```\nvar word = \" the window\"\nfunction sayWord(){\n\tvar word = \"sayWord\"\n\t function sayHello(){\n\t\tvar word = \"sayHello\"\n\t\talert(word)\n\t}\n\treturn sayHello\n}\nsayWord()();\n```\n\n上例的作用域链就是： \n`sayHello[word=\"sayHello\"]`——`sayWord[word=\"sayWord\"]`——`window[word=\"the window\"];`\n当执行sayHello函数时，会沿着这个作用域链一级一级往上找word这个变量，直到找到为止。\n\n## 闭包\n\njavacript高级程序设计上说“有不少开发人员总是搞不清匿名函数和闭包这两个概念”。很遗憾，本人就是。\n\n[@javacript高级程序设计](javascript:void(0)\n>闭包是指有权访问另一个函数作用域中的变量的函数。\n\n[@xiaotie](http://www.cnblogs.com/xiaotie/archive/2011/08/03/2126145.html)\n> 闭包是从用户角度考虑的一种设计概念，它基于对上下文的分析，把龌龊的事情、复杂的事情和外部环境交互的事情都自己做了，留给用户一个很自然的接口。\n\n[@javacript权威指南](javascript:void(0)\n>函数对象通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内\n\n----\n\n上栗子\n\n```\nvar word = \" the window\"\nfunction sayWord(){\n\tvar word = \"sayWord\"\n\t function sayHello(){\n\t\talert(word)\n\t}\n\treturn sayHello\n}\nsayWord()();\n```\nsayHello函数在sayWord函数内部，它能访问sayWord函数内部的变量。sayHello函数就是闭包，\n\n\n## 利用闭包实现私有属性\n\n```\nfunction createCounter() {\n  var counter = 0;\n  function increment() {\n    counter = counter + 1;\n    console.log(\"Number of events: \" + counter);\n  }\n  return increment;\n}\n\nvar counter1 = createCounter();\nvar counter2 = createCounter();\n\ncounter1(); // Number of events: 1\ncounter1(); // Number of events: 2\n\ncounter2(); // Number of events: 1\n \ncounter1(); // Number of events: 3\n\n```\n\n\n每次调用函数都会创建变量绑定对象添加到作用域链中，所以每次调用外部函数的时候，作用域链都是不同的。而对于嵌套函数，每次调用外部函数时，内部函数又会重新定义一遍。\n\n\n## 闭包存在的问题\n\n**this对象的指向问题**\n\n```\nvar name = \"The Window\";\nvar object = {\n\tname : \"My Object\",\n\tgetNameFunc : function(){\n\t\tvar name = \"The v\";\n\t\treturn function(){\n\t\t\treturn this.name;\n\t\t};\n\t}\n};\nalert(object.getNameFunc()()); //\"The Window\"（在非严格模式下）\n```\n\n每个函数在被调用时都会自动取得两个特殊变量：`this` 和`arguments`。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。\n\n这里\n>object.getNameFunc()()==(function(){return this.name;})()\n\n所以其活动对象为window;\n\n解决办法\n```\nvar name = \"The Window\";\nvar object = {\n\tname : \"My Object\",\n\tgetNameFunc : function(){\n\t\tvar that = this;\n\t\treturn function(){\n\t\t\treturn that.name;\n\t\t};\n\t}\n};\nalert(object.getNameFunc()()); //\"My Object\"\n```\n\n----\n\n**内存泄露问题**\n```\nfunction sayWord(){\n\tvar word = \"hello\"\n\tadd = function(){\n\t\tword = word + \" world\"\n\t}\n\tfunction sayHello(){\n\t\talert(word)\n\t}\n\treturn sayHello;\n\tword = null;\n}\nvar say = sayWord();\nsay();  //hello\nadd();\nsay();\t//hello world\n```\n\n\n+ 首先调用say();结果输出hello\n+ 然后调用add，add是个全局变量，所以可以在外部调用，因为它又是闭包，所以可以访问到变量word，所以world=“hello world”;\n+ 最后再调用say()；发现结果输出hello world；\n这说明函数sayWord中的局部变量word一直保存在内存中，并没有在sayWord调用后被自动清除。产生这个问题主要是由于匿名函数保存了一个对word的引用，所以它所占用的内存就永远不会被回收。\n\n\n<p style=\"color:red\">注意：因为闭包的这个特性，所以外部函数的变量是其内部所有闭包的共享值，因此，不能在闭包中随意的改变外部函数的变量值，牵一发而动全身。</p>","source":"_posts/了解闭包.md","raw":"title: 了解闭包\ndate: 2015-12-22 13:03:19\ntags: [javascript]\ndescription: 闭包，了解闭包\n\n---\n\n江湖上都说要了解闭包，得先了解作用域链，所以，先从作用域链开始吧。\n## 作用域链\n1. 作用域链是一个对象列表或链表，这组对象定义了这段代码“作用域”中的变量；\n2. 每当调用一个函数，这个函数会创建一个新的对象来储存它的变量（变量绑定对象），并且将这个对象添加到作用域链上；当函数返回时，就从作用域链中将这个对象删除；\n3. 当javascript需要查找一个变量时，它会沿着作用域链一级一级地搜索变量。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至作用域链的最顶层（全局对象）为止。\n4. 对于嵌套函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链都指向一个变量绑定对象\n\n<!-- more -->\n\n**我们来看一个栗子**\n\n```\nvar word = \" the window\"\nfunction sayWord(){\n\tvar word = \"sayWord\"\n\t function sayHello(){\n\t\tvar word = \"sayHello\"\n\t\talert(word)\n\t}\n\treturn sayHello\n}\nsayWord()();\n```\n\n上例的作用域链就是： \n`sayHello[word=\"sayHello\"]`——`sayWord[word=\"sayWord\"]`——`window[word=\"the window\"];`\n当执行sayHello函数时，会沿着这个作用域链一级一级往上找word这个变量，直到找到为止。\n\n## 闭包\n\njavacript高级程序设计上说“有不少开发人员总是搞不清匿名函数和闭包这两个概念”。很遗憾，本人就是。\n\n[@javacript高级程序设计](javascript:void(0)\n>闭包是指有权访问另一个函数作用域中的变量的函数。\n\n[@xiaotie](http://www.cnblogs.com/xiaotie/archive/2011/08/03/2126145.html)\n> 闭包是从用户角度考虑的一种设计概念，它基于对上下文的分析，把龌龊的事情、复杂的事情和外部环境交互的事情都自己做了，留给用户一个很自然的接口。\n\n[@javacript权威指南](javascript:void(0)\n>函数对象通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内\n\n----\n\n上栗子\n\n```\nvar word = \" the window\"\nfunction sayWord(){\n\tvar word = \"sayWord\"\n\t function sayHello(){\n\t\talert(word)\n\t}\n\treturn sayHello\n}\nsayWord()();\n```\nsayHello函数在sayWord函数内部，它能访问sayWord函数内部的变量。sayHello函数就是闭包，\n\n\n## 利用闭包实现私有属性\n\n```\nfunction createCounter() {\n  var counter = 0;\n  function increment() {\n    counter = counter + 1;\n    console.log(\"Number of events: \" + counter);\n  }\n  return increment;\n}\n\nvar counter1 = createCounter();\nvar counter2 = createCounter();\n\ncounter1(); // Number of events: 1\ncounter1(); // Number of events: 2\n\ncounter2(); // Number of events: 1\n \ncounter1(); // Number of events: 3\n\n```\n\n\n每次调用函数都会创建变量绑定对象添加到作用域链中，所以每次调用外部函数的时候，作用域链都是不同的。而对于嵌套函数，每次调用外部函数时，内部函数又会重新定义一遍。\n\n\n## 闭包存在的问题\n\n**this对象的指向问题**\n\n```\nvar name = \"The Window\";\nvar object = {\n\tname : \"My Object\",\n\tgetNameFunc : function(){\n\t\tvar name = \"The v\";\n\t\treturn function(){\n\t\t\treturn this.name;\n\t\t};\n\t}\n};\nalert(object.getNameFunc()()); //\"The Window\"（在非严格模式下）\n```\n\n每个函数在被调用时都会自动取得两个特殊变量：`this` 和`arguments`。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。\n\n这里\n>object.getNameFunc()()==(function(){return this.name;})()\n\n所以其活动对象为window;\n\n解决办法\n```\nvar name = \"The Window\";\nvar object = {\n\tname : \"My Object\",\n\tgetNameFunc : function(){\n\t\tvar that = this;\n\t\treturn function(){\n\t\t\treturn that.name;\n\t\t};\n\t}\n};\nalert(object.getNameFunc()()); //\"My Object\"\n```\n\n----\n\n**内存泄露问题**\n```\nfunction sayWord(){\n\tvar word = \"hello\"\n\tadd = function(){\n\t\tword = word + \" world\"\n\t}\n\tfunction sayHello(){\n\t\talert(word)\n\t}\n\treturn sayHello;\n\tword = null;\n}\nvar say = sayWord();\nsay();  //hello\nadd();\nsay();\t//hello world\n```\n\n\n+ 首先调用say();结果输出hello\n+ 然后调用add，add是个全局变量，所以可以在外部调用，因为它又是闭包，所以可以访问到变量word，所以world=“hello world”;\n+ 最后再调用say()；发现结果输出hello world；\n这说明函数sayWord中的局部变量word一直保存在内存中，并没有在sayWord调用后被自动清除。产生这个问题主要是由于匿名函数保存了一个对word的引用，所以它所占用的内存就永远不会被回收。\n\n\n<p style=\"color:red\">注意：因为闭包的这个特性，所以外部函数的变量是其内部所有闭包的共享值，因此，不能在闭包中随意的改变外部函数的变量值，牵一发而动全身。</p>","slug":"了解闭包","published":1,"updated":"2021-12-06T06:07:06.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom3003fy4v223xfd8ow","content":"<p>江湖上都说要了解闭包，得先了解作用域链，所以，先从作用域链开始吧。</p>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><ol>\n<li>作用域链是一个对象列表或链表，这组对象定义了这段代码“作用域”中的变量；</li>\n<li>每当调用一个函数，这个函数会创建一个新的对象来储存它的变量（变量绑定对象），并且将这个对象添加到作用域链上；当函数返回时，就从作用域链中将这个对象删除；</li>\n<li>当javascript需要查找一个变量时，它会沿着作用域链一级一级地搜索变量。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至作用域链的最顶层（全局对象）为止。</li>\n<li>对于嵌套函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链都指向一个变量绑定对象</li>\n</ol>\n<span id=\"more\"></span>\n\n<p><strong>我们来看一个栗子</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var word = &quot; the window&quot;</span><br><span class=\"line\">function sayWord()&#123;</span><br><span class=\"line\">\tvar word = &quot;sayWord&quot;</span><br><span class=\"line\">\t function sayHello()&#123;</span><br><span class=\"line\">\t\tvar word = &quot;sayHello&quot;</span><br><span class=\"line\">\t\talert(word)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn sayHello</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayWord()();</span><br></pre></td></tr></table></figure>\n\n<p>上例的作用域链就是：<br><code>sayHello[word=&quot;sayHello&quot;]</code>——<code>sayWord[word=&quot;sayWord&quot;]</code>——<code>window[word=&quot;the window&quot;];</code><br>当执行sayHello函数时，会沿着这个作用域链一级一级往上找word这个变量，直到找到为止。</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>javacript高级程序设计上说“有不少开发人员总是搞不清匿名函数和闭包这两个概念”。很遗憾，本人就是。</p>\n<p><a href=\"javascript:void(0\">@javacript高级程序设计</a></p>\n<blockquote>\n<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>\n</blockquote>\n<p><a href=\"http://www.cnblogs.com/xiaotie/archive/2011/08/03/2126145.html\">@xiaotie</a></p>\n<blockquote>\n<p>闭包是从用户角度考虑的一种设计概念，它基于对上下文的分析，把龌龊的事情、复杂的事情和外部环境交互的事情都自己做了，留给用户一个很自然的接口。</p>\n</blockquote>\n<p><a href=\"javascript:void(0\">@javacript权威指南</a></p>\n<blockquote>\n<p>函数对象通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内</p>\n</blockquote>\n<hr>\n<p>上栗子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var word = &quot; the window&quot;</span><br><span class=\"line\">function sayWord()&#123;</span><br><span class=\"line\">\tvar word = &quot;sayWord&quot;</span><br><span class=\"line\">\t function sayHello()&#123;</span><br><span class=\"line\">\t\talert(word)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn sayHello</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayWord()();</span><br></pre></td></tr></table></figure>\n<p>sayHello函数在sayWord函数内部，它能访问sayWord函数内部的变量。sayHello函数就是闭包，</p>\n<h2 id=\"利用闭包实现私有属性\"><a href=\"#利用闭包实现私有属性\" class=\"headerlink\" title=\"利用闭包实现私有属性\"></a>利用闭包实现私有属性</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createCounter() &#123;</span><br><span class=\"line\">  var counter = 0;</span><br><span class=\"line\">  function increment() &#123;</span><br><span class=\"line\">    counter = counter + 1;</span><br><span class=\"line\">    console.log(&quot;Number of events: &quot; + counter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return increment;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var counter1 = createCounter();</span><br><span class=\"line\">var counter2 = createCounter();</span><br><span class=\"line\"></span><br><span class=\"line\">counter1(); // Number of events: 1</span><br><span class=\"line\">counter1(); // Number of events: 2</span><br><span class=\"line\"></span><br><span class=\"line\">counter2(); // Number of events: 1</span><br><span class=\"line\"> </span><br><span class=\"line\">counter1(); // Number of events: 3</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>每次调用函数都会创建变量绑定对象添加到作用域链中，所以每次调用外部函数的时候，作用域链都是不同的。而对于嵌套函数，每次调用外部函数时，内部函数又会重新定义一遍。</p>\n<h2 id=\"闭包存在的问题\"><a href=\"#闭包存在的问题\" class=\"headerlink\" title=\"闭包存在的问题\"></a>闭包存在的问题</h2><p><strong>this对象的指向问题</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;The Window&quot;;</span><br><span class=\"line\">var object = &#123;</span><br><span class=\"line\">\tname : &quot;My Object&quot;,</span><br><span class=\"line\">\tgetNameFunc : function()&#123;</span><br><span class=\"line\">\t\tvar name = &quot;The v&quot;;</span><br><span class=\"line\">\t\treturn function()&#123;</span><br><span class=\"line\">\t\t\treturn this.name;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(object.getNameFunc()()); //&quot;The Window&quot;（在非严格模式下）</span><br></pre></td></tr></table></figure>\n\n<p>每个函数在被调用时都会自动取得两个特殊变量：<code>this</code> 和<code>arguments</code>。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。</p>\n<p>这里</p>\n<blockquote>\n<p>object.getNameFunc()()==(function(){return this.name;})()</p>\n</blockquote>\n<p>所以其活动对象为window;</p>\n<p>解决办法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;The Window&quot;;</span><br><span class=\"line\">var object = &#123;</span><br><span class=\"line\">\tname : &quot;My Object&quot;,</span><br><span class=\"line\">\tgetNameFunc : function()&#123;</span><br><span class=\"line\">\t\tvar that = this;</span><br><span class=\"line\">\t\treturn function()&#123;</span><br><span class=\"line\">\t\t\treturn that.name;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(object.getNameFunc()()); //&quot;My Object&quot;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>内存泄露问题</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sayWord()&#123;</span><br><span class=\"line\">\tvar word = &quot;hello&quot;</span><br><span class=\"line\">\tadd = function()&#123;</span><br><span class=\"line\">\t\tword = word + &quot; world&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfunction sayHello()&#123;</span><br><span class=\"line\">\t\talert(word)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn sayHello;</span><br><span class=\"line\">\tword = null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var say = sayWord();</span><br><span class=\"line\">say();  //hello</span><br><span class=\"line\">add();</span><br><span class=\"line\">say();\t//hello world</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>首先调用say();结果输出hello</li>\n<li>然后调用add，add是个全局变量，所以可以在外部调用，因为它又是闭包，所以可以访问到变量word，所以world=“hello world”;</li>\n<li>最后再调用say()；发现结果输出hello world；<br>这说明函数sayWord中的局部变量word一直保存在内存中，并没有在sayWord调用后被自动清除。产生这个问题主要是由于匿名函数保存了一个对word的引用，所以它所占用的内存就永远不会被回收。</li>\n</ul>\n<p style=\"color:red\">注意：因为闭包的这个特性，所以外部函数的变量是其内部所有闭包的共享值，因此，不能在闭包中随意的改变外部函数的变量值，牵一发而动全身。</p>","site":{"data":{}},"excerpt":"<p>江湖上都说要了解闭包，得先了解作用域链，所以，先从作用域链开始吧。</p>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><ol>\n<li>作用域链是一个对象列表或链表，这组对象定义了这段代码“作用域”中的变量；</li>\n<li>每当调用一个函数，这个函数会创建一个新的对象来储存它的变量（变量绑定对象），并且将这个对象添加到作用域链上；当函数返回时，就从作用域链中将这个对象删除；</li>\n<li>当javascript需要查找一个变量时，它会沿着作用域链一级一级地搜索变量。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至作用域链的最顶层（全局对象）为止。</li>\n<li>对于嵌套函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链都指向一个变量绑定对象</li>\n</ol>","more":"<p><strong>我们来看一个栗子</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var word = &quot; the window&quot;</span><br><span class=\"line\">function sayWord()&#123;</span><br><span class=\"line\">\tvar word = &quot;sayWord&quot;</span><br><span class=\"line\">\t function sayHello()&#123;</span><br><span class=\"line\">\t\tvar word = &quot;sayHello&quot;</span><br><span class=\"line\">\t\talert(word)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn sayHello</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayWord()();</span><br></pre></td></tr></table></figure>\n\n<p>上例的作用域链就是：<br><code>sayHello[word=&quot;sayHello&quot;]</code>——<code>sayWord[word=&quot;sayWord&quot;]</code>——<code>window[word=&quot;the window&quot;];</code><br>当执行sayHello函数时，会沿着这个作用域链一级一级往上找word这个变量，直到找到为止。</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>javacript高级程序设计上说“有不少开发人员总是搞不清匿名函数和闭包这两个概念”。很遗憾，本人就是。</p>\n<p><a href=\"javascript:void(0\">@javacript高级程序设计</a></p>\n<blockquote>\n<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>\n</blockquote>\n<p><a href=\"http://www.cnblogs.com/xiaotie/archive/2011/08/03/2126145.html\">@xiaotie</a></p>\n<blockquote>\n<p>闭包是从用户角度考虑的一种设计概念，它基于对上下文的分析，把龌龊的事情、复杂的事情和外部环境交互的事情都自己做了，留给用户一个很自然的接口。</p>\n</blockquote>\n<p><a href=\"javascript:void(0\">@javacript权威指南</a></p>\n<blockquote>\n<p>函数对象通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内</p>\n</blockquote>\n<hr>\n<p>上栗子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var word = &quot; the window&quot;</span><br><span class=\"line\">function sayWord()&#123;</span><br><span class=\"line\">\tvar word = &quot;sayWord&quot;</span><br><span class=\"line\">\t function sayHello()&#123;</span><br><span class=\"line\">\t\talert(word)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn sayHello</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayWord()();</span><br></pre></td></tr></table></figure>\n<p>sayHello函数在sayWord函数内部，它能访问sayWord函数内部的变量。sayHello函数就是闭包，</p>\n<h2 id=\"利用闭包实现私有属性\"><a href=\"#利用闭包实现私有属性\" class=\"headerlink\" title=\"利用闭包实现私有属性\"></a>利用闭包实现私有属性</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createCounter() &#123;</span><br><span class=\"line\">  var counter = 0;</span><br><span class=\"line\">  function increment() &#123;</span><br><span class=\"line\">    counter = counter + 1;</span><br><span class=\"line\">    console.log(&quot;Number of events: &quot; + counter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return increment;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var counter1 = createCounter();</span><br><span class=\"line\">var counter2 = createCounter();</span><br><span class=\"line\"></span><br><span class=\"line\">counter1(); // Number of events: 1</span><br><span class=\"line\">counter1(); // Number of events: 2</span><br><span class=\"line\"></span><br><span class=\"line\">counter2(); // Number of events: 1</span><br><span class=\"line\"> </span><br><span class=\"line\">counter1(); // Number of events: 3</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>每次调用函数都会创建变量绑定对象添加到作用域链中，所以每次调用外部函数的时候，作用域链都是不同的。而对于嵌套函数，每次调用外部函数时，内部函数又会重新定义一遍。</p>\n<h2 id=\"闭包存在的问题\"><a href=\"#闭包存在的问题\" class=\"headerlink\" title=\"闭包存在的问题\"></a>闭包存在的问题</h2><p><strong>this对象的指向问题</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;The Window&quot;;</span><br><span class=\"line\">var object = &#123;</span><br><span class=\"line\">\tname : &quot;My Object&quot;,</span><br><span class=\"line\">\tgetNameFunc : function()&#123;</span><br><span class=\"line\">\t\tvar name = &quot;The v&quot;;</span><br><span class=\"line\">\t\treturn function()&#123;</span><br><span class=\"line\">\t\t\treturn this.name;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(object.getNameFunc()()); //&quot;The Window&quot;（在非严格模式下）</span><br></pre></td></tr></table></figure>\n\n<p>每个函数在被调用时都会自动取得两个特殊变量：<code>this</code> 和<code>arguments</code>。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。</p>\n<p>这里</p>\n<blockquote>\n<p>object.getNameFunc()()==(function(){return this.name;})()</p>\n</blockquote>\n<p>所以其活动对象为window;</p>\n<p>解决办法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;The Window&quot;;</span><br><span class=\"line\">var object = &#123;</span><br><span class=\"line\">\tname : &quot;My Object&quot;,</span><br><span class=\"line\">\tgetNameFunc : function()&#123;</span><br><span class=\"line\">\t\tvar that = this;</span><br><span class=\"line\">\t\treturn function()&#123;</span><br><span class=\"line\">\t\t\treturn that.name;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(object.getNameFunc()()); //&quot;My Object&quot;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>内存泄露问题</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sayWord()&#123;</span><br><span class=\"line\">\tvar word = &quot;hello&quot;</span><br><span class=\"line\">\tadd = function()&#123;</span><br><span class=\"line\">\t\tword = word + &quot; world&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfunction sayHello()&#123;</span><br><span class=\"line\">\t\talert(word)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn sayHello;</span><br><span class=\"line\">\tword = null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var say = sayWord();</span><br><span class=\"line\">say();  //hello</span><br><span class=\"line\">add();</span><br><span class=\"line\">say();\t//hello world</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>首先调用say();结果输出hello</li>\n<li>然后调用add，add是个全局变量，所以可以在外部调用，因为它又是闭包，所以可以访问到变量word，所以world=“hello world”;</li>\n<li>最后再调用say()；发现结果输出hello world；<br>这说明函数sayWord中的局部变量word一直保存在内存中，并没有在sayWord调用后被自动清除。产生这个问题主要是由于匿名函数保存了一个对word的引用，所以它所占用的内存就永远不会被回收。</li>\n</ul>\n<p style=\"color:red\">注意：因为闭包的这个特性，所以外部函数的变量是其内部所有闭包的共享值，因此，不能在闭包中随意的改变外部函数的变量值，牵一发而动全身。</p>"},{"_content":"# 作用域与闭包\n\n<!-- TOC -->\n\n- [作用域与闭包](#作用域与闭包)\n    - [什么是作用域](#什么是作用域)\n        - [编译器](#编译器)\n        - [理解作用域](#理解作用域)\n        - [嵌套的作用域](#嵌套的作用域)\n    - [词法作用域](#词法作用域)\n        - [词法分析时](#词法分析时)\n        - [欺骗词法作用域](#欺骗词法作用域)\n    - [函数与块作用域](#函数与块作用域)\n        - [函数中的作用域](#函数中的作用域)\n        - [隐藏标识符于普通作用域](#隐藏标识符于普通作用域)\n        - [函数作为作用域](#函数作为作用域)\n        - [块作为作用域](#块作为作用域)\n    - [提升](#提升)\n        - [先有鸡还是先有蛋？](#先有鸡还是先有蛋)\n        - [编译器再次袭来](#编译器再次袭来)\n        - [函数优先](#函数优先)\n    - [作用域闭包](#作用域闭包)\n        - [启蒙](#启蒙)\n        - [事实真相](#事实真相)\n        - [循环 + 闭包](#循环--闭包)\n        - [模块](#模块)\n\n<!-- /TOC -->\n\n## 什么是作用域\n\n> 作用域是一组定义在何处储存变量以及如何访问变量的**规则**。\n\n### 编译器\n\njavascript 是编译型语言。但是与传统编译型语言不同，它是边编译边执行的。编译型语言一般从源码到执行会经历三个步骤：\n\n* 分词／词法分析\n\n  将一连串字符串打断成有意义的片段，成为 token（记号）。\n\n* 解析\n\n  将一个 token 流（数组）转化为一个嵌套元素的树，即抽象语法树（AST）。\n\n* 代码生成\n\n  将抽象语法树转化为可执行的代码。其实是转化成机器指令。\n\n比如`var a = 1`的编译过程：\n\n1. 分词／词法分析： `var a = 1`这段程序可能会被打断成如下 token：`var`、`a`、`=`、`1`，空格保留与否得看其是否具有意义。\n2. 解析：将第一步的 token 形成抽象树：大致如下：\n   ```\n   变量声明: {\n       标识符: a\n       赋值表达式: {\n           数字字面量: 1\n       }\n   }\n   ```\n3. 代码生成： 转化成机器命令：创建一个称为 a 的变量，并分配内存，存入一个值为数字 1。\n\n### 理解作用域\n\n> 作用域就是通过标识符名称查询变量的一组规则。\n\n代码解析运行中的角色：\n\n* 引擎\n\n  负责代码的编译和程序的执行。\n\n* 编译器\n\n  协助引擎，主要负责解析和代码生成。\n\n* 作用域\n\n  协助引擎，收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行的代码如何访问这些变量强制实施一组严格的规则。\n\n比如`var a = 1`的运行：\n\n1. 编译器遇到`var a`，会首先让作用域去查询 a 是否已经存在，存在则忽略，不存在，则让作用域创建它；\n2. 编译器遇到`a = 1`，会编译成引擎稍后需要运行的代码；\n3. 引擎执行编译后的代码，会让当前查看是否存在变量`a`可以访问，存在则引用这个变量，不存在则查看其他其他。\n\n上面过程中，引擎会对变量进行查询，而查询分为 RHS（right-hand Side）查询 和 LHS（left-hand Side）查询，它们根据变量出现在赋值操作的左手边还是右手边来判断查询方式。\n\n* RHS\n\n  变量在赋值的右手边时采用这种方式查询，查不到会抛出错误 `referenceError`\n\n* LHS\n\n  变量在赋值的左手边时采用这种方式查询，在非严格模式下，查不到会再顶层作用域创建这个变量\n\n### 嵌套的作用域\n\n实际工作中，通常会有多于一个的作用域需要考虑，会存在作用域嵌套在其他作用域中的情况。\n\n嵌套作用域的规则：\n\n**从当前作用域开始查找，如果没有，则向上走一级继续查找，以此类推，直至到了最外层全局作用域，无论找到与否，都会停止。**\n\n## 词法作用域\n\n作用域的工作方式一般有俩种模型：词法作用域和动态作用域。javascript 所采用的是词法作用域。\n\n### 词法分析时\n\n> 词法作用域是在词法分析时被定义的作用域。\n\n上述定义的潜在含义即：词法作用域是基于写程序时变量和作用域的块儿在何处被编写所决定的。公认的最佳实践是将词法作用域看作是仅仅依靠词法的。\n\n查询变量：\n\n**引擎查找标识符时会在当前作用域开始一直向最外层作用域查找，一旦匹配到第一个，作用域查询便停止。**\n\n相同名称的标识符可以在嵌套作用域的多个层中被指定，这成为“遮蔽”。\n\n不管函数是从哪里被调用、如何调用，它的词法作用域是由这个函数被声明的位置**唯一**定义的。\n\n### 欺骗词法作用域\n\njavascript 提供了在运行时修改词法作用域的机制——with 和 eval，它们会欺骗词法作用域。实际工作中，这种做法并不被推荐，应当尽量避免使用。\n\n**欺骗词法作用域会导致更低下的性能。**\n\n引擎在编译阶段会对代码做许多优化工作，比如静态地分析代码。但如果代码存在 eval 和 with，导致词法作用域的不固定行为，这一切的优化都有可能毫无意义，所以引擎就会简单地不做任何优化。\n\n1. eval\n\n`eval函数`接收一个字符串作为参数，并在运行时将该字符串的内容在当前位置运行。\n\n```js\nfunction foo(str, a) {\n    eval(str); // 作弊！\n    console.log(a, b);\n}\n\nvar b = 2;\nfoo(\"var b = 3\", 1); //1,3\n```\n\n上面的代码，`var b = 3`会再 eval 位置运行，从而在 foo 作用域内创建了变量`b`。当`console.log(a,b)`调用发生时，引擎会直接访问 foo 作用域内的`b`，而不会再访问外部的`b`变量。\n\n**注意：使用严格模式，在 eval 中作出的声明不会实际上修改包围他的作用域**\n\n2. with\n\n我们通常使用 with 来引用一个对象的多个属性。\n\n```js\nvar obj = {\n    a: 1,\n    b: 2,\n    c: 3\n};\n\nwith (obj) {\n    a = 3;\n    b = 4;\n    c = 5;\n}\n\nconsole.log(obj); //{a: 3, b: 4, c: 5}\n```\n\n但是，with 会做的事，比这要多得多。\n\n```js\nvar o1 = { a: 3 };\nvar o2 = { b: 3 };\n\nfunction foo(obj) {\n    with (obj) {\n        a = 2;\n    }\n}\n\nfoo(o1);\nconsole.log(o1.a); //2\n\nfoo(o2);\nconsole.log(o2.a); // undefined\nconsole.log(a); // 2  全局作用域泄漏\n```\n\nwith 语句接受一个对象，并将这个对象视为一个**完全隔离的词法作用域**。\n\n**但是** with 块内部的一个普通的`var`声明并不会归于这个`with`块儿的作用域，而是归于包含它的函数作用域。\n\n所以，上面代码执行`foo(o2)`时，在执行到 `a = 2` 时，引擎会进行 `LHS查找`，但是一直到最外层都没有找到 a 变量，所以会在最外层创建这个变量，这里就造成了作用域泄漏。\n\n## 函数与块作用域\n\njavascript 中是不是只能通过函数创建新的作用域，有没有其他方式／结构创建作用域？\n\n### 函数中的作用域\n\n> javascript 拥有基于函数的作用域\n\n函数作用域支持着这样的想法：所有变量都属于函数，而去贯穿整个函数都可以使用或重用（包括嵌套的作用域中）。\n\n这样以来，一个声明出现在作用域何处是**无关紧要**的。\n\n### 隐藏标识符于普通作用域\n\n我们可以通过将变量和函数围在一个函数的作用域中来“隐藏”它们。\n\n为什么需要“隐藏”变量和函数？\n\n如果允许外围的作用域访问一个工作的私有细节，不仅没必要，而且可能是危险的。所以软件设计中有一个**最低权限原则**原则：\n\n**最低权限原则**：也称“最低授权”／“最少曝光”，在软件设计中，比如一个模块／对象的 API，你应当只暴露所需要的最低限度的东西，而隐藏其他一切。\n\n将变量和函数隐藏可以避免多个同名但用处不同的标识符之间发生无意的冲突，从而导致值被意外的覆盖。\n\n实际可操作的方式：\n\n1. 全局命名空间\n\n   在引用多个库时，如果他们没有隐藏内部／私有函数和变量，那么它们十分容易出现相互冲突。所以，这些库通常会在全局作用域中使用一个特殊的名称来创建一个单读的变量声明。它经常是一个对象，然后这个对象被用作这个库一个`命名空间`，所有要暴露出来的功能都会作为属性挂载在这个对象上。\n\n   比如，Jquery 的对象就是 jquery/$;\n\n2. 模块管理\n\n   实现命名冲突的另一种方式是模块管理。\n\n### 函数作为作用域\n\n声明一个函数，可以拿来隐藏函数和变量，但这种方式同时也存在着问题：\n\n* 不得不声明一个命名函数，这个函数的标识符名称本身就污染了外围作用域\n* 不得不通过名称明确地调用这个函数\n\n不需要名称，又能自动执行的，js 恰好提供了这样一种方式。\n\n```js\n(function(){\n    ...\n})()\n```\n\n上面的代码使用了匿名函数和立即调用函数表达式：\n\n1. 匿名函数\n\n函数表达式可以匿名，函数声明不能匿名。\n\n匿名函数的缺点：\n\n* 在栈中没有有用的名称可以表示，调试困难；\n* 想要递归自己（arguments.callee）或者解绑事件处理器变得麻烦\n* 更不易代码阅读\n\n最佳的方式总是命名你的函数表达式。\n\n2. 立即调用函数表达式\n\n通过一个`()`，我们可以将函数作为表达式。末尾再加一个括号可以执行这个函数表达式。这种模式被成为 IIFE（立即调用函数表达式；Immediately Invoked Function Expression）\n\n### 块作为作用域\n\n大部门语言都支持块级作用域，从而将信息隐藏到我们的代码块中，块级作用域是一种扩展了`最低权限原则`的工具。\n\n但是，表面上看来 javascript 没有块级作用域。\n\n```js\nfor (var i = 0; i < 10; i++) {\n    console.log(i);\n}\nconsole.log(i); // 10 变量i被划入了外围作用域中\n```\n\n```js\nif (true) {\n    var bar = 9;\n    console.log(bar); //9\n}\nconsole.log(bar); //9 // 变量bar被划入了外围作用域中\n```\n\n但也有特殊情况：\n\n* with\n\n  它从对象中创建的作用域仅存在于这个 with 语句的生命周期中。\n\n* try/catch\n\n  ES3 明确指出 try/catch 中的 cathc 子语句中声明的变量，是属于 catch 块的块级作用域。\n\n  ```js\n  try {\n      var a = 1;\n  } catch (e) {\n      var c = 2;\n  }\n  console.log(a); //1\n  console.log(c); //undefined\n  ```\n\n* let/const\n\n  let 将变量声明依附在它所在的块儿（通常是{...}）作用域中。\n\n  * 隐含使用现存得块儿\n\n  ```js\n  if (true) {\n      let bar = 1;\n      console.log(bar); //1\n  }\n  console.log(bar); // ReferenceError\n  ```\n\n  * 创建明确块儿\n\n  ```js\n  if (true) {\n      {\n          // 明确的块儿\n          let bar = 1;\n          console.log(bar); //1\n      }\n  }\n  console.log(bar); // ReferenceError\n  ```\n\n  const 也创建一个块级作用域，但是它的值是固定的（常量）。\n\n  **注意：** let/const 声明不进行变量提升。\n\n块级作用域的用处：\n\n1. 垃圾回收\n\n   可以处理闭包和释放内存的垃圾回收。\n\n   ```js\n   function process() {\n       // do something\n   }\n   var bigData = {...}; // 大体量数据\n   process(bigData);\n   var btn = document.getElementById('btn');\n   btn.addEventListener(\"click\",function(e){\n       console.log('btn click');\n   })\n   ```\n\n   点击事件的回调函数根本不需要 bigData 这个大体量数据。理论上讲，在执行完 process 函数后，这个消耗巨大内存的数据结构应该被作为垃圾而回收。然而因为 click 函数在整个函数作用域上拥有一个闭包，bigData 将会仍然保持一段事件。\n\n   块级作用域可以解决这个问题：\n\n   ```js\n   function process() {\n      // do something\n   }\n   {\n      let bigData = {...}; // 大体量数据\n      process(bigData);\n   }\n   var btn = document.getElementById('btn');\n   btn.addEventListener(\"click\",function(e){\n      console.log('btn click');\n   })\n   ```\n\n2. 循环\n\n   对每一次循环的迭代重新绑定。\n\n   ```js\n   for (let i = 0; i < 10; i++) {\n       console.log(i);\n   }\n   console.log(i); // ReferenceError\n   ```\n\n   也可以这样：\n\n   ```js\n   {\n       let j;\n       for (j = 0; i < 10; i++) {\n           let i = j; // 每次迭代重新绑定\n           console.log(i);\n       }\n   }\n   ```\n\n## 提升\n\n函数作用域还是块级作用域的行为都依赖于一个相同的规则： 在一个作用域中声明的任何变量都附着在这个作用域上。\n\n但是出现一个作用域内各种位置的声明如何依附作用域？\n\n### 先有鸡还是先有蛋？\n\n我们倾向于认为代码是自上而下地被解释执行的。这大致上是对的，但也有一部分并非如此。\n\n```js\na = 2;\nvar a;\nconsole.log(a); // 2\n```\n\n如果代码自上而下的解释运行，预期应该输出 `undefined` ，因为 `var a` 在 `a = 2` 之后，应该重新定义了变量 a。显然，结果并不是如此。\n\n```js\nconsole.log(a); // undefined\nvar a = 2;\n```\n\n从上面的例子上，你也许会猜测这里会输出 2，或者认为这里会导致一个 ReferenceError 被抛出。不幸的是，结果却是 undefined。\n\n代码究竟如何执行，是先有声明还是赋值？\n\n### 编译器再次袭来\n\n我们知道，引擎在 javascript 执行代码之前会先对代码进行编译，编译的其中一个工作就是找到所有的声明，并将它关联在合适的作用域上。\n\n所以，在我们的代码被执行前，所有的声明，包括变量和函数，都会被首先处理。\n\n对于`var a = 2`，我们认为是一个语句，但 javascript 实际上认为这是俩个语句：`var a` 和 `a = 2`。第一句（声明）会在编译阶段处理，第二句（赋值）会在执行阶段处理。\n\n知道了这些，我想对于上一节的疑惑也就迎刃而解了：**先有声明，后有赋值**。\n\n**注意：提升是以作用域为单位的**\n\n函数声明会被提升，但是表达式不会。\n\n```js\nfoo(); // 1\ngoo(); // TypeError\n\nfunction foo() {\n    console.log(1);\n}\n\nvar goo = function() {\n    console.log(2);\n};\n```\n\n变量 goo 被提升了，但表达式没有，所以调用 goo 时，goo 的值为 undefined。所以会报 TypeError。\n\n### 函数优先\n\n函数声明和变量都会提升。但是函数享有更高的优先级。\n\n```js\nconsole.log(typeof foo); // function\n\nvar foo = 2;\n\nfunction foo() {\n    console.log(1);\n}\n```\n\n从上面代码可以看出，结果输出 function 而不是 undefined 。说明函数声明优先于变量。\n\n**重复声明，后面的会覆盖前面的。**\n\n## 作用域闭包\n\n必须要对作用域有健全和坚实的理解才能理解闭包。\n\n### 启蒙\n\n在 javascript 中闭包无处不在，你只是必须认出它并接纳它。它是依赖于词法作用域编写代码而产生的结果。\n\n### 事实真相\n\n> 闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在他的词法作用域之外执行时\n\n```js\nfunction foo() {\n    var a = 2;\n    function bar() {\n        console.log(2);\n    }\n    bar();\n}\n```\n\n这种形式算闭包吗？技术上算，它实现了闭包，函数 bar 在函数 foo 的作用域上有一个闭包，即 bar 闭住了 foo 的作用域。但是在上面代码中并不是可以严格地观察到。\n\n```js\nfunction foo() {\n    var a = 2;\n    function bar() {\n        console.log(2);\n    }\n    return bar;\n}\nvar baz = foo();\nbaz(); //2  这样使用才算真正意义上的闭包\n```\n\nbar 对于 foo 内的作用域拥有此法作用域访问权，当我们调用 foo 之后返回 bar 的引用。按理来说，foo 执行过后，我们一般会期望 foo 的整个内部作用域消失，因为垃圾回收机制会自动回收不再使用的内存。但 bar 拥有一个词法作用域的闭包，覆盖着 foo 的内部作用域，闭包为了能使 bar 在以后的任意时刻可以引用这个作用域而保持的它的存在。\n\n所以，bar **在词法作用域之外依然拥有对那个作用域的引用，这个引用称为闭包。**\n\n**闭包使一个函数可以继续访问它在编写时被定义的词法作用域。**\n\n```js\nvar a = 2;\n\nfunction bar() {\n    console.log(a);\n}\n\nfunction foo(fn) {\n    fn(); // 发现闭包！\n}\n\nfoo(bar);\n```\n\n上面的代码，函数作为参数被传递，实际上这也是一种观察／使用闭包的例子。\n\n**无论我们使用什么方法将一个函数传送到它的词法作用域之外，它都将维护一个指向它被声明时的作用域的引用。**\n\n### 循环 + 闭包\n\n```js\nfor (var i = 1; i <= 5; i++) {\n    setTimeout(function timer() {\n        console.log(i); // 5\n    }, i * 1000);\n}\n```\n\n这段代码的预期是每隔一秒分别打印数字：1，2，3，4，5。但是我们执行后发现结果一共输出了 5 次 6。\n\n**为什么达不到预期的效果？**\n\n定时器的回调函数会在循环完成之后执行（详见[事件循环机制]('./事件循环机制')）。而 for 不是块级作用域，所以每次执行 timer 函数的时候，它们的闭包都在全局作用域上。而此时全局作用域环境中的变量 i 的值为 6。\n\n**我们的代码缺少了什么？**\n\n因为每一个 timer 函数执行的时候都是使用全局作用域，所以访问的变量必然是一致的，所以想要达到预期的结果，我们必须为每一个 timer 函数创建一个私有作用域，并在这个私有作用域内存在一个可供回调函数访问的变量。现在我们来改写一下：\n\n```js\nfor (var i = 1; i <= 5; i++) {\n    (function() {\n        let j = i;\n        setTimeout(function() {\n            console.log(j); // 1,2,3,4,5\n        }, i * 1000);\n    })();\n}\n```\n\n我们使用 IIFE 为每次迭代创建新的作用域，并且保存每次迭代需要的值。\n\n其实这里主要用到的原理是使用块级作用域，所以，理论上还有其他方式可以实现，比如：with，try/catch,let/const，大家都可以尝试下哦。\n\n### 模块\n\n模块也利用了闭包的力量。\n\n```js\nfunction coolModule() {\n    var something = \"cool\";\n    function doSomething() {\n        console.log(something);\n    }\n\n    return {\n        doSomething: doSomething\n    };\n}\n\nvar foo = coolModule()\nfoo.doSomething() // cool\n```","source":"_posts/作用域与闭包.md","raw":"# 作用域与闭包\n\n<!-- TOC -->\n\n- [作用域与闭包](#作用域与闭包)\n    - [什么是作用域](#什么是作用域)\n        - [编译器](#编译器)\n        - [理解作用域](#理解作用域)\n        - [嵌套的作用域](#嵌套的作用域)\n    - [词法作用域](#词法作用域)\n        - [词法分析时](#词法分析时)\n        - [欺骗词法作用域](#欺骗词法作用域)\n    - [函数与块作用域](#函数与块作用域)\n        - [函数中的作用域](#函数中的作用域)\n        - [隐藏标识符于普通作用域](#隐藏标识符于普通作用域)\n        - [函数作为作用域](#函数作为作用域)\n        - [块作为作用域](#块作为作用域)\n    - [提升](#提升)\n        - [先有鸡还是先有蛋？](#先有鸡还是先有蛋)\n        - [编译器再次袭来](#编译器再次袭来)\n        - [函数优先](#函数优先)\n    - [作用域闭包](#作用域闭包)\n        - [启蒙](#启蒙)\n        - [事实真相](#事实真相)\n        - [循环 + 闭包](#循环--闭包)\n        - [模块](#模块)\n\n<!-- /TOC -->\n\n## 什么是作用域\n\n> 作用域是一组定义在何处储存变量以及如何访问变量的**规则**。\n\n### 编译器\n\njavascript 是编译型语言。但是与传统编译型语言不同，它是边编译边执行的。编译型语言一般从源码到执行会经历三个步骤：\n\n* 分词／词法分析\n\n  将一连串字符串打断成有意义的片段，成为 token（记号）。\n\n* 解析\n\n  将一个 token 流（数组）转化为一个嵌套元素的树，即抽象语法树（AST）。\n\n* 代码生成\n\n  将抽象语法树转化为可执行的代码。其实是转化成机器指令。\n\n比如`var a = 1`的编译过程：\n\n1. 分词／词法分析： `var a = 1`这段程序可能会被打断成如下 token：`var`、`a`、`=`、`1`，空格保留与否得看其是否具有意义。\n2. 解析：将第一步的 token 形成抽象树：大致如下：\n   ```\n   变量声明: {\n       标识符: a\n       赋值表达式: {\n           数字字面量: 1\n       }\n   }\n   ```\n3. 代码生成： 转化成机器命令：创建一个称为 a 的变量，并分配内存，存入一个值为数字 1。\n\n### 理解作用域\n\n> 作用域就是通过标识符名称查询变量的一组规则。\n\n代码解析运行中的角色：\n\n* 引擎\n\n  负责代码的编译和程序的执行。\n\n* 编译器\n\n  协助引擎，主要负责解析和代码生成。\n\n* 作用域\n\n  协助引擎，收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行的代码如何访问这些变量强制实施一组严格的规则。\n\n比如`var a = 1`的运行：\n\n1. 编译器遇到`var a`，会首先让作用域去查询 a 是否已经存在，存在则忽略，不存在，则让作用域创建它；\n2. 编译器遇到`a = 1`，会编译成引擎稍后需要运行的代码；\n3. 引擎执行编译后的代码，会让当前查看是否存在变量`a`可以访问，存在则引用这个变量，不存在则查看其他其他。\n\n上面过程中，引擎会对变量进行查询，而查询分为 RHS（right-hand Side）查询 和 LHS（left-hand Side）查询，它们根据变量出现在赋值操作的左手边还是右手边来判断查询方式。\n\n* RHS\n\n  变量在赋值的右手边时采用这种方式查询，查不到会抛出错误 `referenceError`\n\n* LHS\n\n  变量在赋值的左手边时采用这种方式查询，在非严格模式下，查不到会再顶层作用域创建这个变量\n\n### 嵌套的作用域\n\n实际工作中，通常会有多于一个的作用域需要考虑，会存在作用域嵌套在其他作用域中的情况。\n\n嵌套作用域的规则：\n\n**从当前作用域开始查找，如果没有，则向上走一级继续查找，以此类推，直至到了最外层全局作用域，无论找到与否，都会停止。**\n\n## 词法作用域\n\n作用域的工作方式一般有俩种模型：词法作用域和动态作用域。javascript 所采用的是词法作用域。\n\n### 词法分析时\n\n> 词法作用域是在词法分析时被定义的作用域。\n\n上述定义的潜在含义即：词法作用域是基于写程序时变量和作用域的块儿在何处被编写所决定的。公认的最佳实践是将词法作用域看作是仅仅依靠词法的。\n\n查询变量：\n\n**引擎查找标识符时会在当前作用域开始一直向最外层作用域查找，一旦匹配到第一个，作用域查询便停止。**\n\n相同名称的标识符可以在嵌套作用域的多个层中被指定，这成为“遮蔽”。\n\n不管函数是从哪里被调用、如何调用，它的词法作用域是由这个函数被声明的位置**唯一**定义的。\n\n### 欺骗词法作用域\n\njavascript 提供了在运行时修改词法作用域的机制——with 和 eval，它们会欺骗词法作用域。实际工作中，这种做法并不被推荐，应当尽量避免使用。\n\n**欺骗词法作用域会导致更低下的性能。**\n\n引擎在编译阶段会对代码做许多优化工作，比如静态地分析代码。但如果代码存在 eval 和 with，导致词法作用域的不固定行为，这一切的优化都有可能毫无意义，所以引擎就会简单地不做任何优化。\n\n1. eval\n\n`eval函数`接收一个字符串作为参数，并在运行时将该字符串的内容在当前位置运行。\n\n```js\nfunction foo(str, a) {\n    eval(str); // 作弊！\n    console.log(a, b);\n}\n\nvar b = 2;\nfoo(\"var b = 3\", 1); //1,3\n```\n\n上面的代码，`var b = 3`会再 eval 位置运行，从而在 foo 作用域内创建了变量`b`。当`console.log(a,b)`调用发生时，引擎会直接访问 foo 作用域内的`b`，而不会再访问外部的`b`变量。\n\n**注意：使用严格模式，在 eval 中作出的声明不会实际上修改包围他的作用域**\n\n2. with\n\n我们通常使用 with 来引用一个对象的多个属性。\n\n```js\nvar obj = {\n    a: 1,\n    b: 2,\n    c: 3\n};\n\nwith (obj) {\n    a = 3;\n    b = 4;\n    c = 5;\n}\n\nconsole.log(obj); //{a: 3, b: 4, c: 5}\n```\n\n但是，with 会做的事，比这要多得多。\n\n```js\nvar o1 = { a: 3 };\nvar o2 = { b: 3 };\n\nfunction foo(obj) {\n    with (obj) {\n        a = 2;\n    }\n}\n\nfoo(o1);\nconsole.log(o1.a); //2\n\nfoo(o2);\nconsole.log(o2.a); // undefined\nconsole.log(a); // 2  全局作用域泄漏\n```\n\nwith 语句接受一个对象，并将这个对象视为一个**完全隔离的词法作用域**。\n\n**但是** with 块内部的一个普通的`var`声明并不会归于这个`with`块儿的作用域，而是归于包含它的函数作用域。\n\n所以，上面代码执行`foo(o2)`时，在执行到 `a = 2` 时，引擎会进行 `LHS查找`，但是一直到最外层都没有找到 a 变量，所以会在最外层创建这个变量，这里就造成了作用域泄漏。\n\n## 函数与块作用域\n\njavascript 中是不是只能通过函数创建新的作用域，有没有其他方式／结构创建作用域？\n\n### 函数中的作用域\n\n> javascript 拥有基于函数的作用域\n\n函数作用域支持着这样的想法：所有变量都属于函数，而去贯穿整个函数都可以使用或重用（包括嵌套的作用域中）。\n\n这样以来，一个声明出现在作用域何处是**无关紧要**的。\n\n### 隐藏标识符于普通作用域\n\n我们可以通过将变量和函数围在一个函数的作用域中来“隐藏”它们。\n\n为什么需要“隐藏”变量和函数？\n\n如果允许外围的作用域访问一个工作的私有细节，不仅没必要，而且可能是危险的。所以软件设计中有一个**最低权限原则**原则：\n\n**最低权限原则**：也称“最低授权”／“最少曝光”，在软件设计中，比如一个模块／对象的 API，你应当只暴露所需要的最低限度的东西，而隐藏其他一切。\n\n将变量和函数隐藏可以避免多个同名但用处不同的标识符之间发生无意的冲突，从而导致值被意外的覆盖。\n\n实际可操作的方式：\n\n1. 全局命名空间\n\n   在引用多个库时，如果他们没有隐藏内部／私有函数和变量，那么它们十分容易出现相互冲突。所以，这些库通常会在全局作用域中使用一个特殊的名称来创建一个单读的变量声明。它经常是一个对象，然后这个对象被用作这个库一个`命名空间`，所有要暴露出来的功能都会作为属性挂载在这个对象上。\n\n   比如，Jquery 的对象就是 jquery/$;\n\n2. 模块管理\n\n   实现命名冲突的另一种方式是模块管理。\n\n### 函数作为作用域\n\n声明一个函数，可以拿来隐藏函数和变量，但这种方式同时也存在着问题：\n\n* 不得不声明一个命名函数，这个函数的标识符名称本身就污染了外围作用域\n* 不得不通过名称明确地调用这个函数\n\n不需要名称，又能自动执行的，js 恰好提供了这样一种方式。\n\n```js\n(function(){\n    ...\n})()\n```\n\n上面的代码使用了匿名函数和立即调用函数表达式：\n\n1. 匿名函数\n\n函数表达式可以匿名，函数声明不能匿名。\n\n匿名函数的缺点：\n\n* 在栈中没有有用的名称可以表示，调试困难；\n* 想要递归自己（arguments.callee）或者解绑事件处理器变得麻烦\n* 更不易代码阅读\n\n最佳的方式总是命名你的函数表达式。\n\n2. 立即调用函数表达式\n\n通过一个`()`，我们可以将函数作为表达式。末尾再加一个括号可以执行这个函数表达式。这种模式被成为 IIFE（立即调用函数表达式；Immediately Invoked Function Expression）\n\n### 块作为作用域\n\n大部门语言都支持块级作用域，从而将信息隐藏到我们的代码块中，块级作用域是一种扩展了`最低权限原则`的工具。\n\n但是，表面上看来 javascript 没有块级作用域。\n\n```js\nfor (var i = 0; i < 10; i++) {\n    console.log(i);\n}\nconsole.log(i); // 10 变量i被划入了外围作用域中\n```\n\n```js\nif (true) {\n    var bar = 9;\n    console.log(bar); //9\n}\nconsole.log(bar); //9 // 变量bar被划入了外围作用域中\n```\n\n但也有特殊情况：\n\n* with\n\n  它从对象中创建的作用域仅存在于这个 with 语句的生命周期中。\n\n* try/catch\n\n  ES3 明确指出 try/catch 中的 cathc 子语句中声明的变量，是属于 catch 块的块级作用域。\n\n  ```js\n  try {\n      var a = 1;\n  } catch (e) {\n      var c = 2;\n  }\n  console.log(a); //1\n  console.log(c); //undefined\n  ```\n\n* let/const\n\n  let 将变量声明依附在它所在的块儿（通常是{...}）作用域中。\n\n  * 隐含使用现存得块儿\n\n  ```js\n  if (true) {\n      let bar = 1;\n      console.log(bar); //1\n  }\n  console.log(bar); // ReferenceError\n  ```\n\n  * 创建明确块儿\n\n  ```js\n  if (true) {\n      {\n          // 明确的块儿\n          let bar = 1;\n          console.log(bar); //1\n      }\n  }\n  console.log(bar); // ReferenceError\n  ```\n\n  const 也创建一个块级作用域，但是它的值是固定的（常量）。\n\n  **注意：** let/const 声明不进行变量提升。\n\n块级作用域的用处：\n\n1. 垃圾回收\n\n   可以处理闭包和释放内存的垃圾回收。\n\n   ```js\n   function process() {\n       // do something\n   }\n   var bigData = {...}; // 大体量数据\n   process(bigData);\n   var btn = document.getElementById('btn');\n   btn.addEventListener(\"click\",function(e){\n       console.log('btn click');\n   })\n   ```\n\n   点击事件的回调函数根本不需要 bigData 这个大体量数据。理论上讲，在执行完 process 函数后，这个消耗巨大内存的数据结构应该被作为垃圾而回收。然而因为 click 函数在整个函数作用域上拥有一个闭包，bigData 将会仍然保持一段事件。\n\n   块级作用域可以解决这个问题：\n\n   ```js\n   function process() {\n      // do something\n   }\n   {\n      let bigData = {...}; // 大体量数据\n      process(bigData);\n   }\n   var btn = document.getElementById('btn');\n   btn.addEventListener(\"click\",function(e){\n      console.log('btn click');\n   })\n   ```\n\n2. 循环\n\n   对每一次循环的迭代重新绑定。\n\n   ```js\n   for (let i = 0; i < 10; i++) {\n       console.log(i);\n   }\n   console.log(i); // ReferenceError\n   ```\n\n   也可以这样：\n\n   ```js\n   {\n       let j;\n       for (j = 0; i < 10; i++) {\n           let i = j; // 每次迭代重新绑定\n           console.log(i);\n       }\n   }\n   ```\n\n## 提升\n\n函数作用域还是块级作用域的行为都依赖于一个相同的规则： 在一个作用域中声明的任何变量都附着在这个作用域上。\n\n但是出现一个作用域内各种位置的声明如何依附作用域？\n\n### 先有鸡还是先有蛋？\n\n我们倾向于认为代码是自上而下地被解释执行的。这大致上是对的，但也有一部分并非如此。\n\n```js\na = 2;\nvar a;\nconsole.log(a); // 2\n```\n\n如果代码自上而下的解释运行，预期应该输出 `undefined` ，因为 `var a` 在 `a = 2` 之后，应该重新定义了变量 a。显然，结果并不是如此。\n\n```js\nconsole.log(a); // undefined\nvar a = 2;\n```\n\n从上面的例子上，你也许会猜测这里会输出 2，或者认为这里会导致一个 ReferenceError 被抛出。不幸的是，结果却是 undefined。\n\n代码究竟如何执行，是先有声明还是赋值？\n\n### 编译器再次袭来\n\n我们知道，引擎在 javascript 执行代码之前会先对代码进行编译，编译的其中一个工作就是找到所有的声明，并将它关联在合适的作用域上。\n\n所以，在我们的代码被执行前，所有的声明，包括变量和函数，都会被首先处理。\n\n对于`var a = 2`，我们认为是一个语句，但 javascript 实际上认为这是俩个语句：`var a` 和 `a = 2`。第一句（声明）会在编译阶段处理，第二句（赋值）会在执行阶段处理。\n\n知道了这些，我想对于上一节的疑惑也就迎刃而解了：**先有声明，后有赋值**。\n\n**注意：提升是以作用域为单位的**\n\n函数声明会被提升，但是表达式不会。\n\n```js\nfoo(); // 1\ngoo(); // TypeError\n\nfunction foo() {\n    console.log(1);\n}\n\nvar goo = function() {\n    console.log(2);\n};\n```\n\n变量 goo 被提升了，但表达式没有，所以调用 goo 时，goo 的值为 undefined。所以会报 TypeError。\n\n### 函数优先\n\n函数声明和变量都会提升。但是函数享有更高的优先级。\n\n```js\nconsole.log(typeof foo); // function\n\nvar foo = 2;\n\nfunction foo() {\n    console.log(1);\n}\n```\n\n从上面代码可以看出，结果输出 function 而不是 undefined 。说明函数声明优先于变量。\n\n**重复声明，后面的会覆盖前面的。**\n\n## 作用域闭包\n\n必须要对作用域有健全和坚实的理解才能理解闭包。\n\n### 启蒙\n\n在 javascript 中闭包无处不在，你只是必须认出它并接纳它。它是依赖于词法作用域编写代码而产生的结果。\n\n### 事实真相\n\n> 闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在他的词法作用域之外执行时\n\n```js\nfunction foo() {\n    var a = 2;\n    function bar() {\n        console.log(2);\n    }\n    bar();\n}\n```\n\n这种形式算闭包吗？技术上算，它实现了闭包，函数 bar 在函数 foo 的作用域上有一个闭包，即 bar 闭住了 foo 的作用域。但是在上面代码中并不是可以严格地观察到。\n\n```js\nfunction foo() {\n    var a = 2;\n    function bar() {\n        console.log(2);\n    }\n    return bar;\n}\nvar baz = foo();\nbaz(); //2  这样使用才算真正意义上的闭包\n```\n\nbar 对于 foo 内的作用域拥有此法作用域访问权，当我们调用 foo 之后返回 bar 的引用。按理来说，foo 执行过后，我们一般会期望 foo 的整个内部作用域消失，因为垃圾回收机制会自动回收不再使用的内存。但 bar 拥有一个词法作用域的闭包，覆盖着 foo 的内部作用域，闭包为了能使 bar 在以后的任意时刻可以引用这个作用域而保持的它的存在。\n\n所以，bar **在词法作用域之外依然拥有对那个作用域的引用，这个引用称为闭包。**\n\n**闭包使一个函数可以继续访问它在编写时被定义的词法作用域。**\n\n```js\nvar a = 2;\n\nfunction bar() {\n    console.log(a);\n}\n\nfunction foo(fn) {\n    fn(); // 发现闭包！\n}\n\nfoo(bar);\n```\n\n上面的代码，函数作为参数被传递，实际上这也是一种观察／使用闭包的例子。\n\n**无论我们使用什么方法将一个函数传送到它的词法作用域之外，它都将维护一个指向它被声明时的作用域的引用。**\n\n### 循环 + 闭包\n\n```js\nfor (var i = 1; i <= 5; i++) {\n    setTimeout(function timer() {\n        console.log(i); // 5\n    }, i * 1000);\n}\n```\n\n这段代码的预期是每隔一秒分别打印数字：1，2，3，4，5。但是我们执行后发现结果一共输出了 5 次 6。\n\n**为什么达不到预期的效果？**\n\n定时器的回调函数会在循环完成之后执行（详见[事件循环机制]('./事件循环机制')）。而 for 不是块级作用域，所以每次执行 timer 函数的时候，它们的闭包都在全局作用域上。而此时全局作用域环境中的变量 i 的值为 6。\n\n**我们的代码缺少了什么？**\n\n因为每一个 timer 函数执行的时候都是使用全局作用域，所以访问的变量必然是一致的，所以想要达到预期的结果，我们必须为每一个 timer 函数创建一个私有作用域，并在这个私有作用域内存在一个可供回调函数访问的变量。现在我们来改写一下：\n\n```js\nfor (var i = 1; i <= 5; i++) {\n    (function() {\n        let j = i;\n        setTimeout(function() {\n            console.log(j); // 1,2,3,4,5\n        }, i * 1000);\n    })();\n}\n```\n\n我们使用 IIFE 为每次迭代创建新的作用域，并且保存每次迭代需要的值。\n\n其实这里主要用到的原理是使用块级作用域，所以，理论上还有其他方式可以实现，比如：with，try/catch,let/const，大家都可以尝试下哦。\n\n### 模块\n\n模块也利用了闭包的力量。\n\n```js\nfunction coolModule() {\n    var something = \"cool\";\n    function doSomething() {\n        console.log(something);\n    }\n\n    return {\n        doSomething: doSomething\n    };\n}\n\nvar foo = coolModule()\nfoo.doSomething() // cool\n```","slug":"作用域与闭包","published":1,"date":"2021-12-06T06:07:05.874Z","updated":"2021-12-06T06:07:05.874Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom3003gy4v26yvwf3wr","content":"<h1 id=\"作用域与闭包\"><a href=\"#作用域与闭包\" class=\"headerlink\" title=\"作用域与闭包\"></a>作用域与闭包</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85\">作用域与闭包</a><ul>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F\">什么是作用域</a><ul>\n<li><a href=\"#%E7%BC%96%E8%AF%91%E5%99%A8\">编译器</a></li>\n<li><a href=\"#%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F\">理解作用域</a></li>\n<li><a href=\"#%E5%B5%8C%E5%A5%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">嵌套的作用域</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\">词法作用域</a><ul>\n<li><a href=\"#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E6%97%B6\">词法分析时</a></li>\n<li><a href=\"#%E6%AC%BA%E9%AA%97%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\">欺骗词法作用域</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F\">函数与块作用域</a><ul>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">函数中的作用域</a></li>\n<li><a href=\"#%E9%9A%90%E8%97%8F%E6%A0%87%E8%AF%86%E7%AC%A6%E4%BA%8E%E6%99%AE%E9%80%9A%E4%BD%9C%E7%94%A8%E5%9F%9F\">隐藏标识符于普通作用域</a></li>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E4%BD%9C%E7%94%A8%E5%9F%9F\">函数作为作用域</a></li>\n<li><a href=\"#%E5%9D%97%E4%BD%9C%E4%B8%BA%E4%BD%9C%E7%94%A8%E5%9F%9F\">块作为作用域</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%8F%90%E5%8D%87\">提升</a><ul>\n<li><a href=\"#%E5%85%88%E6%9C%89%E9%B8%A1%E8%BF%98%E6%98%AF%E5%85%88%E6%9C%89%E8%9B%8B\">先有鸡还是先有蛋？</a></li>\n<li><a href=\"#%E7%BC%96%E8%AF%91%E5%99%A8%E5%86%8D%E6%AC%A1%E8%A2%AD%E6%9D%A5\">编译器再次袭来</a></li>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E4%BC%98%E5%85%88\">函数优先</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85\">作用域闭包</a><ul>\n<li><a href=\"#%E5%90%AF%E8%92%99\">启蒙</a></li>\n<li><a href=\"#%E4%BA%8B%E5%AE%9E%E7%9C%9F%E7%9B%B8\">事实真相</a></li>\n<li><a href=\"#%E5%BE%AA%E7%8E%AF--%E9%97%AD%E5%8C%85\">循环 + 闭包</a></li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97\">模块</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<h2 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h2><blockquote>\n<p>作用域是一组定义在何处储存变量以及如何访问变量的<strong>规则</strong>。</p>\n</blockquote>\n<h3 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h3><p>javascript 是编译型语言。但是与传统编译型语言不同，它是边编译边执行的。编译型语言一般从源码到执行会经历三个步骤：</p>\n<ul>\n<li><p>分词／词法分析</p>\n<p>将一连串字符串打断成有意义的片段，成为 token（记号）。</p>\n</li>\n<li><p>解析</p>\n<p>将一个 token 流（数组）转化为一个嵌套元素的树，即抽象语法树（AST）。</p>\n</li>\n<li><p>代码生成</p>\n<p>将抽象语法树转化为可执行的代码。其实是转化成机器指令。</p>\n</li>\n</ul>\n<p>比如<code>var a = 1</code>的编译过程：</p>\n<ol>\n<li>分词／词法分析： <code>var a = 1</code>这段程序可能会被打断成如下 token：<code>var</code>、<code>a</code>、<code>=</code>、<code>1</code>，空格保留与否得看其是否具有意义。</li>\n<li>解析：将第一步的 token 形成抽象树：大致如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量声明: &#123;</span><br><span class=\"line\">    标识符: a</span><br><span class=\"line\">    赋值表达式: &#123;</span><br><span class=\"line\">        数字字面量: 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>代码生成： 转化成机器命令：创建一个称为 a 的变量，并分配内存，存入一个值为数字 1。</li>\n</ol>\n<h3 id=\"理解作用域\"><a href=\"#理解作用域\" class=\"headerlink\" title=\"理解作用域\"></a>理解作用域</h3><blockquote>\n<p>作用域就是通过标识符名称查询变量的一组规则。</p>\n</blockquote>\n<p>代码解析运行中的角色：</p>\n<ul>\n<li><p>引擎</p>\n<p>负责代码的编译和程序的执行。</p>\n</li>\n<li><p>编译器</p>\n<p>协助引擎，主要负责解析和代码生成。</p>\n</li>\n<li><p>作用域</p>\n<p>协助引擎，收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行的代码如何访问这些变量强制实施一组严格的规则。</p>\n</li>\n</ul>\n<p>比如<code>var a = 1</code>的运行：</p>\n<ol>\n<li>编译器遇到<code>var a</code>，会首先让作用域去查询 a 是否已经存在，存在则忽略，不存在，则让作用域创建它；</li>\n<li>编译器遇到<code>a = 1</code>，会编译成引擎稍后需要运行的代码；</li>\n<li>引擎执行编译后的代码，会让当前查看是否存在变量<code>a</code>可以访问，存在则引用这个变量，不存在则查看其他其他。</li>\n</ol>\n<p>上面过程中，引擎会对变量进行查询，而查询分为 RHS（right-hand Side）查询 和 LHS（left-hand Side）查询，它们根据变量出现在赋值操作的左手边还是右手边来判断查询方式。</p>\n<ul>\n<li><p>RHS</p>\n<p>变量在赋值的右手边时采用这种方式查询，查不到会抛出错误 <code>referenceError</code></p>\n</li>\n<li><p>LHS</p>\n<p>变量在赋值的左手边时采用这种方式查询，在非严格模式下，查不到会再顶层作用域创建这个变量</p>\n</li>\n</ul>\n<h3 id=\"嵌套的作用域\"><a href=\"#嵌套的作用域\" class=\"headerlink\" title=\"嵌套的作用域\"></a>嵌套的作用域</h3><p>实际工作中，通常会有多于一个的作用域需要考虑，会存在作用域嵌套在其他作用域中的情况。</p>\n<p>嵌套作用域的规则：</p>\n<p><strong>从当前作用域开始查找，如果没有，则向上走一级继续查找，以此类推，直至到了最外层全局作用域，无论找到与否，都会停止。</strong></p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p>作用域的工作方式一般有俩种模型：词法作用域和动态作用域。javascript 所采用的是词法作用域。</p>\n<h3 id=\"词法分析时\"><a href=\"#词法分析时\" class=\"headerlink\" title=\"词法分析时\"></a>词法分析时</h3><blockquote>\n<p>词法作用域是在词法分析时被定义的作用域。</p>\n</blockquote>\n<p>上述定义的潜在含义即：词法作用域是基于写程序时变量和作用域的块儿在何处被编写所决定的。公认的最佳实践是将词法作用域看作是仅仅依靠词法的。</p>\n<p>查询变量：</p>\n<p><strong>引擎查找标识符时会在当前作用域开始一直向最外层作用域查找，一旦匹配到第一个，作用域查询便停止。</strong></p>\n<p>相同名称的标识符可以在嵌套作用域的多个层中被指定，这成为“遮蔽”。</p>\n<p>不管函数是从哪里被调用、如何调用，它的词法作用域是由这个函数被声明的位置<strong>唯一</strong>定义的。</p>\n<h3 id=\"欺骗词法作用域\"><a href=\"#欺骗词法作用域\" class=\"headerlink\" title=\"欺骗词法作用域\"></a>欺骗词法作用域</h3><p>javascript 提供了在运行时修改词法作用域的机制——with 和 eval，它们会欺骗词法作用域。实际工作中，这种做法并不被推荐，应当尽量避免使用。</p>\n<p><strong>欺骗词法作用域会导致更低下的性能。</strong></p>\n<p>引擎在编译阶段会对代码做许多优化工作，比如静态地分析代码。但如果代码存在 eval 和 with，导致词法作用域的不固定行为，这一切的优化都有可能毫无意义，所以引擎就会简单地不做任何优化。</p>\n<ol>\n<li>eval</li>\n</ol>\n<p><code>eval函数</code>接收一个字符串作为参数，并在运行时将该字符串的内容在当前位置运行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">str, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">eval</span>(str); <span class=\"comment\">// 作弊！</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo(<span class=\"string\">&quot;var b = 3&quot;</span>, <span class=\"number\">1</span>); <span class=\"comment\">//1,3</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，<code>var b = 3</code>会再 eval 位置运行，从而在 foo 作用域内创建了变量<code>b</code>。当<code>console.log(a,b)</code>调用发生时，引擎会直接访问 foo 作用域内的<code>b</code>，而不会再访问外部的<code>b</code>变量。</p>\n<p><strong>注意：使用严格模式，在 eval 中作出的声明不会实际上修改包围他的作用域</strong></p>\n<ol start=\"2\">\n<li>with</li>\n</ol>\n<p>我们通常使用 with 来引用一个对象的多个属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    b = <span class=\"number\">4</span>;</span><br><span class=\"line\">    c = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">//&#123;a: 3, b: 4, c: 5&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>但是，with 会做的事，比这要多得多。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o1 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(o1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o1.a); <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo(o2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o2.a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2  全局作用域泄漏</span></span><br></pre></td></tr></table></figure>\n\n<p>with 语句接受一个对象，并将这个对象视为一个<strong>完全隔离的词法作用域</strong>。</p>\n<p><strong>但是</strong> with 块内部的一个普通的<code>var</code>声明并不会归于这个<code>with</code>块儿的作用域，而是归于包含它的函数作用域。</p>\n<p>所以，上面代码执行<code>foo(o2)</code>时，在执行到 <code>a = 2</code> 时，引擎会进行 <code>LHS查找</code>，但是一直到最外层都没有找到 a 变量，所以会在最外层创建这个变量，这里就造成了作用域泄漏。</p>\n<h2 id=\"函数与块作用域\"><a href=\"#函数与块作用域\" class=\"headerlink\" title=\"函数与块作用域\"></a>函数与块作用域</h2><p>javascript 中是不是只能通过函数创建新的作用域，有没有其他方式／结构创建作用域？</p>\n<h3 id=\"函数中的作用域\"><a href=\"#函数中的作用域\" class=\"headerlink\" title=\"函数中的作用域\"></a>函数中的作用域</h3><blockquote>\n<p>javascript 拥有基于函数的作用域</p>\n</blockquote>\n<p>函数作用域支持着这样的想法：所有变量都属于函数，而去贯穿整个函数都可以使用或重用（包括嵌套的作用域中）。</p>\n<p>这样以来，一个声明出现在作用域何处是<strong>无关紧要</strong>的。</p>\n<h3 id=\"隐藏标识符于普通作用域\"><a href=\"#隐藏标识符于普通作用域\" class=\"headerlink\" title=\"隐藏标识符于普通作用域\"></a>隐藏标识符于普通作用域</h3><p>我们可以通过将变量和函数围在一个函数的作用域中来“隐藏”它们。</p>\n<p>为什么需要“隐藏”变量和函数？</p>\n<p>如果允许外围的作用域访问一个工作的私有细节，不仅没必要，而且可能是危险的。所以软件设计中有一个<strong>最低权限原则</strong>原则：</p>\n<p><strong>最低权限原则</strong>：也称“最低授权”／“最少曝光”，在软件设计中，比如一个模块／对象的 API，你应当只暴露所需要的最低限度的东西，而隐藏其他一切。</p>\n<p>将变量和函数隐藏可以避免多个同名但用处不同的标识符之间发生无意的冲突，从而导致值被意外的覆盖。</p>\n<p>实际可操作的方式：</p>\n<ol>\n<li><p>全局命名空间</p>\n<p>在引用多个库时，如果他们没有隐藏内部／私有函数和变量，那么它们十分容易出现相互冲突。所以，这些库通常会在全局作用域中使用一个特殊的名称来创建一个单读的变量声明。它经常是一个对象，然后这个对象被用作这个库一个<code>命名空间</code>，所有要暴露出来的功能都会作为属性挂载在这个对象上。</p>\n<p>比如，Jquery 的对象就是 jquery/$;</p>\n</li>\n<li><p>模块管理</p>\n<p>实现命名冲突的另一种方式是模块管理。</p>\n</li>\n</ol>\n<h3 id=\"函数作为作用域\"><a href=\"#函数作为作用域\" class=\"headerlink\" title=\"函数作为作用域\"></a>函数作为作用域</h3><p>声明一个函数，可以拿来隐藏函数和变量，但这种方式同时也存在着问题：</p>\n<ul>\n<li>不得不声明一个命名函数，这个函数的标识符名称本身就污染了外围作用域</li>\n<li>不得不通过名称明确地调用这个函数</li>\n</ul>\n<p>不需要名称，又能自动执行的，js 恰好提供了这样一种方式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码使用了匿名函数和立即调用函数表达式：</p>\n<ol>\n<li>匿名函数</li>\n</ol>\n<p>函数表达式可以匿名，函数声明不能匿名。</p>\n<p>匿名函数的缺点：</p>\n<ul>\n<li>在栈中没有有用的名称可以表示，调试困难；</li>\n<li>想要递归自己（arguments.callee）或者解绑事件处理器变得麻烦</li>\n<li>更不易代码阅读</li>\n</ul>\n<p>最佳的方式总是命名你的函数表达式。</p>\n<ol start=\"2\">\n<li>立即调用函数表达式</li>\n</ol>\n<p>通过一个<code>()</code>，我们可以将函数作为表达式。末尾再加一个括号可以执行这个函数表达式。这种模式被成为 IIFE（立即调用函数表达式；Immediately Invoked Function Expression）</p>\n<h3 id=\"块作为作用域\"><a href=\"#块作为作用域\" class=\"headerlink\" title=\"块作为作用域\"></a>块作为作用域</h3><p>大部门语言都支持块级作用域，从而将信息隐藏到我们的代码块中，块级作用域是一种扩展了<code>最低权限原则</code>的工具。</p>\n<p>但是，表面上看来 javascript 没有块级作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 10 变量i被划入了外围作用域中</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">//9</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">//9 // 变量bar被划入了外围作用域中</span></span><br></pre></td></tr></table></figure>\n\n<p>但也有特殊情况：</p>\n<ul>\n<li><p>with</p>\n<p>它从对象中创建的作用域仅存在于这个 with 语句的生命周期中。</p>\n</li>\n<li><p>try/catch</p>\n<p>ES3 明确指出 try/catch 中的 cathc 子语句中声明的变量，是属于 catch 块的块级作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure></li>\n<li><p>let/const</p>\n<p>let 将变量声明依附在它所在的块儿（通常是{…}）作用域中。</p>\n<ul>\n<li>隐含使用现存得块儿</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">//1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建明确块儿</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 明确的块儿</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> bar = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">//1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n\n<p>const 也创建一个块级作用域，但是它的值是固定的（常量）。</p>\n<p><strong>注意：</strong> let/const 声明不进行变量提升。</p>\n</li>\n</ul>\n<p>块级作用域的用处：</p>\n<ol>\n<li><p>垃圾回收</p>\n<p>可以处理闭包和释放内存的垃圾回收。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">process</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bigData = &#123;...&#125;; <span class=\"comment\">// 大体量数据</span></span><br><span class=\"line\">process(bigData);</span><br><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;btn&#x27;</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;btn click&#x27;</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>点击事件的回调函数根本不需要 bigData 这个大体量数据。理论上讲，在执行完 process 函数后，这个消耗巨大内存的数据结构应该被作为垃圾而回收。然而因为 click 函数在整个函数作用域上拥有一个闭包，bigData 将会仍然保持一段事件。</p>\n<p>块级作用域可以解决这个问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">process</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> bigData = &#123;...&#125;; <span class=\"comment\">// 大体量数据</span></span><br><span class=\"line\">   process(bigData);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;btn&#x27;</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;btn click&#x27;</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>循环</p>\n<p>对每一次循环的迭代重新绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n\n<p>也可以这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> i = j; <span class=\"comment\">// 每次迭代重新绑定</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h2><p>函数作用域还是块级作用域的行为都依赖于一个相同的规则： 在一个作用域中声明的任何变量都附着在这个作用域上。</p>\n<p>但是出现一个作用域内各种位置的声明如何依附作用域？</p>\n<h3 id=\"先有鸡还是先有蛋？\"><a href=\"#先有鸡还是先有蛋？\" class=\"headerlink\" title=\"先有鸡还是先有蛋？\"></a>先有鸡还是先有蛋？</h3><p>我们倾向于认为代码是自上而下地被解释执行的。这大致上是对的，但也有一部分并非如此。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>如果代码自上而下的解释运行，预期应该输出 <code>undefined</code> ，因为 <code>var a</code> 在 <code>a = 2</code> 之后，应该重新定义了变量 a。显然，结果并不是如此。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的例子上，你也许会猜测这里会输出 2，或者认为这里会导致一个 ReferenceError 被抛出。不幸的是，结果却是 undefined。</p>\n<p>代码究竟如何执行，是先有声明还是赋值？</p>\n<h3 id=\"编译器再次袭来\"><a href=\"#编译器再次袭来\" class=\"headerlink\" title=\"编译器再次袭来\"></a>编译器再次袭来</h3><p>我们知道，引擎在 javascript 执行代码之前会先对代码进行编译，编译的其中一个工作就是找到所有的声明，并将它关联在合适的作用域上。</p>\n<p>所以，在我们的代码被执行前，所有的声明，包括变量和函数，都会被首先处理。</p>\n<p>对于<code>var a = 2</code>，我们认为是一个语句，但 javascript 实际上认为这是俩个语句：<code>var a</code> 和 <code>a = 2</code>。第一句（声明）会在编译阶段处理，第二句（赋值）会在执行阶段处理。</p>\n<p>知道了这些，我想对于上一节的疑惑也就迎刃而解了：<strong>先有声明，后有赋值</strong>。</p>\n<p><strong>注意：提升是以作用域为单位的</strong></p>\n<p>函数声明会被提升，但是表达式不会。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">goo(); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> goo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>变量 goo 被提升了，但表达式没有，所以调用 goo 时，goo 的值为 undefined。所以会报 TypeError。</p>\n<h3 id=\"函数优先\"><a href=\"#函数优先\" class=\"headerlink\" title=\"函数优先\"></a>函数优先</h3><p>函数声明和变量都会提升。但是函数享有更高的优先级。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> foo); <span class=\"comment\">// function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面代码可以看出，结果输出 function 而不是 undefined 。说明函数声明优先于变量。</p>\n<p><strong>重复声明，后面的会覆盖前面的。</strong></p>\n<h2 id=\"作用域闭包\"><a href=\"#作用域闭包\" class=\"headerlink\" title=\"作用域闭包\"></a>作用域闭包</h2><p>必须要对作用域有健全和坚实的理解才能理解闭包。</p>\n<h3 id=\"启蒙\"><a href=\"#启蒙\" class=\"headerlink\" title=\"启蒙\"></a>启蒙</h3><p>在 javascript 中闭包无处不在，你只是必须认出它并接纳它。它是依赖于词法作用域编写代码而产生的结果。</p>\n<h3 id=\"事实真相\"><a href=\"#事实真相\" class=\"headerlink\" title=\"事实真相\"></a>事实真相</h3><blockquote>\n<p>闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在他的词法作用域之外执行时</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种形式算闭包吗？技术上算，它实现了闭包，函数 bar 在函数 foo 的作用域上有一个闭包，即 bar 闭住了 foo 的作用域。但是在上面代码中并不是可以严格地观察到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\">baz(); <span class=\"comment\">//2  这样使用才算真正意义上的闭包</span></span><br></pre></td></tr></table></figure>\n\n<p>bar 对于 foo 内的作用域拥有此法作用域访问权，当我们调用 foo 之后返回 bar 的引用。按理来说，foo 执行过后，我们一般会期望 foo 的整个内部作用域消失，因为垃圾回收机制会自动回收不再使用的内存。但 bar 拥有一个词法作用域的闭包，覆盖着 foo 的内部作用域，闭包为了能使 bar 在以后的任意时刻可以引用这个作用域而保持的它的存在。</p>\n<p>所以，bar <strong>在词法作用域之外依然拥有对那个作用域的引用，这个引用称为闭包。</strong></p>\n<p><strong>闭包使一个函数可以继续访问它在编写时被定义的词法作用域。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    fn(); <span class=\"comment\">// 发现闭包！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(bar);</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，函数作为参数被传递，实际上这也是一种观察／使用闭包的例子。</p>\n<p><strong>无论我们使用什么方法将一个函数传送到它的词法作用域之外，它都将维护一个指向它被声明时的作用域的引用。</strong></p>\n<h3 id=\"循环-闭包\"><a href=\"#循环-闭包\" class=\"headerlink\" title=\"循环 + 闭包\"></a>循环 + 闭包</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 5</span></span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的预期是每隔一秒分别打印数字：1，2，3，4，5。但是我们执行后发现结果一共输出了 5 次 6。</p>\n<p><strong>为什么达不到预期的效果？</strong></p>\n<p>定时器的回调函数会在循环完成之后执行（详见<a href=\"'./%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6'\">事件循环机制</a>）。而 for 不是块级作用域，所以每次执行 timer 函数的时候，它们的闭包都在全局作用域上。而此时全局作用域环境中的变量 i 的值为 6。</p>\n<p><strong>我们的代码缺少了什么？</strong></p>\n<p>因为每一个 timer 函数执行的时候都是使用全局作用域，所以访问的变量必然是一致的，所以想要达到预期的结果，我们必须为每一个 timer 函数创建一个私有作用域，并在这个私有作用域内存在一个可供回调函数访问的变量。现在我们来改写一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> j = i;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(j); <span class=\"comment\">// 1,2,3,4,5</span></span><br><span class=\"line\">        &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用 IIFE 为每次迭代创建新的作用域，并且保存每次迭代需要的值。</p>\n<p>其实这里主要用到的原理是使用块级作用域，所以，理论上还有其他方式可以实现，比如：with，try/catch,let/const，大家都可以尝试下哦。</p>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>模块也利用了闭包的力量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">coolModule</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> something = <span class=\"string\">&quot;cool&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(something);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSomething</span>: doSomething</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = coolModule()</span><br><span class=\"line\">foo.doSomething() <span class=\"comment\">// cool</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"作用域与闭包\"><a href=\"#作用域与闭包\" class=\"headerlink\" title=\"作用域与闭包\"></a>作用域与闭包</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85\">作用域与闭包</a><ul>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F\">什么是作用域</a><ul>\n<li><a href=\"#%E7%BC%96%E8%AF%91%E5%99%A8\">编译器</a></li>\n<li><a href=\"#%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F\">理解作用域</a></li>\n<li><a href=\"#%E5%B5%8C%E5%A5%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">嵌套的作用域</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\">词法作用域</a><ul>\n<li><a href=\"#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E6%97%B6\">词法分析时</a></li>\n<li><a href=\"#%E6%AC%BA%E9%AA%97%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\">欺骗词法作用域</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F\">函数与块作用域</a><ul>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">函数中的作用域</a></li>\n<li><a href=\"#%E9%9A%90%E8%97%8F%E6%A0%87%E8%AF%86%E7%AC%A6%E4%BA%8E%E6%99%AE%E9%80%9A%E4%BD%9C%E7%94%A8%E5%9F%9F\">隐藏标识符于普通作用域</a></li>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E4%BD%9C%E7%94%A8%E5%9F%9F\">函数作为作用域</a></li>\n<li><a href=\"#%E5%9D%97%E4%BD%9C%E4%B8%BA%E4%BD%9C%E7%94%A8%E5%9F%9F\">块作为作用域</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%8F%90%E5%8D%87\">提升</a><ul>\n<li><a href=\"#%E5%85%88%E6%9C%89%E9%B8%A1%E8%BF%98%E6%98%AF%E5%85%88%E6%9C%89%E8%9B%8B\">先有鸡还是先有蛋？</a></li>\n<li><a href=\"#%E7%BC%96%E8%AF%91%E5%99%A8%E5%86%8D%E6%AC%A1%E8%A2%AD%E6%9D%A5\">编译器再次袭来</a></li>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E4%BC%98%E5%85%88\">函数优先</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85\">作用域闭包</a><ul>\n<li><a href=\"#%E5%90%AF%E8%92%99\">启蒙</a></li>\n<li><a href=\"#%E4%BA%8B%E5%AE%9E%E7%9C%9F%E7%9B%B8\">事实真相</a></li>\n<li><a href=\"#%E5%BE%AA%E7%8E%AF--%E9%97%AD%E5%8C%85\">循环 + 闭包</a></li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97\">模块</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<h2 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h2><blockquote>\n<p>作用域是一组定义在何处储存变量以及如何访问变量的<strong>规则</strong>。</p>\n</blockquote>\n<h3 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h3><p>javascript 是编译型语言。但是与传统编译型语言不同，它是边编译边执行的。编译型语言一般从源码到执行会经历三个步骤：</p>\n<ul>\n<li><p>分词／词法分析</p>\n<p>将一连串字符串打断成有意义的片段，成为 token（记号）。</p>\n</li>\n<li><p>解析</p>\n<p>将一个 token 流（数组）转化为一个嵌套元素的树，即抽象语法树（AST）。</p>\n</li>\n<li><p>代码生成</p>\n<p>将抽象语法树转化为可执行的代码。其实是转化成机器指令。</p>\n</li>\n</ul>\n<p>比如<code>var a = 1</code>的编译过程：</p>\n<ol>\n<li>分词／词法分析： <code>var a = 1</code>这段程序可能会被打断成如下 token：<code>var</code>、<code>a</code>、<code>=</code>、<code>1</code>，空格保留与否得看其是否具有意义。</li>\n<li>解析：将第一步的 token 形成抽象树：大致如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量声明: &#123;</span><br><span class=\"line\">    标识符: a</span><br><span class=\"line\">    赋值表达式: &#123;</span><br><span class=\"line\">        数字字面量: 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>代码生成： 转化成机器命令：创建一个称为 a 的变量，并分配内存，存入一个值为数字 1。</li>\n</ol>\n<h3 id=\"理解作用域\"><a href=\"#理解作用域\" class=\"headerlink\" title=\"理解作用域\"></a>理解作用域</h3><blockquote>\n<p>作用域就是通过标识符名称查询变量的一组规则。</p>\n</blockquote>\n<p>代码解析运行中的角色：</p>\n<ul>\n<li><p>引擎</p>\n<p>负责代码的编译和程序的执行。</p>\n</li>\n<li><p>编译器</p>\n<p>协助引擎，主要负责解析和代码生成。</p>\n</li>\n<li><p>作用域</p>\n<p>协助引擎，收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行的代码如何访问这些变量强制实施一组严格的规则。</p>\n</li>\n</ul>\n<p>比如<code>var a = 1</code>的运行：</p>\n<ol>\n<li>编译器遇到<code>var a</code>，会首先让作用域去查询 a 是否已经存在，存在则忽略，不存在，则让作用域创建它；</li>\n<li>编译器遇到<code>a = 1</code>，会编译成引擎稍后需要运行的代码；</li>\n<li>引擎执行编译后的代码，会让当前查看是否存在变量<code>a</code>可以访问，存在则引用这个变量，不存在则查看其他其他。</li>\n</ol>\n<p>上面过程中，引擎会对变量进行查询，而查询分为 RHS（right-hand Side）查询 和 LHS（left-hand Side）查询，它们根据变量出现在赋值操作的左手边还是右手边来判断查询方式。</p>\n<ul>\n<li><p>RHS</p>\n<p>变量在赋值的右手边时采用这种方式查询，查不到会抛出错误 <code>referenceError</code></p>\n</li>\n<li><p>LHS</p>\n<p>变量在赋值的左手边时采用这种方式查询，在非严格模式下，查不到会再顶层作用域创建这个变量</p>\n</li>\n</ul>\n<h3 id=\"嵌套的作用域\"><a href=\"#嵌套的作用域\" class=\"headerlink\" title=\"嵌套的作用域\"></a>嵌套的作用域</h3><p>实际工作中，通常会有多于一个的作用域需要考虑，会存在作用域嵌套在其他作用域中的情况。</p>\n<p>嵌套作用域的规则：</p>\n<p><strong>从当前作用域开始查找，如果没有，则向上走一级继续查找，以此类推，直至到了最外层全局作用域，无论找到与否，都会停止。</strong></p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p>作用域的工作方式一般有俩种模型：词法作用域和动态作用域。javascript 所采用的是词法作用域。</p>\n<h3 id=\"词法分析时\"><a href=\"#词法分析时\" class=\"headerlink\" title=\"词法分析时\"></a>词法分析时</h3><blockquote>\n<p>词法作用域是在词法分析时被定义的作用域。</p>\n</blockquote>\n<p>上述定义的潜在含义即：词法作用域是基于写程序时变量和作用域的块儿在何处被编写所决定的。公认的最佳实践是将词法作用域看作是仅仅依靠词法的。</p>\n<p>查询变量：</p>\n<p><strong>引擎查找标识符时会在当前作用域开始一直向最外层作用域查找，一旦匹配到第一个，作用域查询便停止。</strong></p>\n<p>相同名称的标识符可以在嵌套作用域的多个层中被指定，这成为“遮蔽”。</p>\n<p>不管函数是从哪里被调用、如何调用，它的词法作用域是由这个函数被声明的位置<strong>唯一</strong>定义的。</p>\n<h3 id=\"欺骗词法作用域\"><a href=\"#欺骗词法作用域\" class=\"headerlink\" title=\"欺骗词法作用域\"></a>欺骗词法作用域</h3><p>javascript 提供了在运行时修改词法作用域的机制——with 和 eval，它们会欺骗词法作用域。实际工作中，这种做法并不被推荐，应当尽量避免使用。</p>\n<p><strong>欺骗词法作用域会导致更低下的性能。</strong></p>\n<p>引擎在编译阶段会对代码做许多优化工作，比如静态地分析代码。但如果代码存在 eval 和 with，导致词法作用域的不固定行为，这一切的优化都有可能毫无意义，所以引擎就会简单地不做任何优化。</p>\n<ol>\n<li>eval</li>\n</ol>\n<p><code>eval函数</code>接收一个字符串作为参数，并在运行时将该字符串的内容在当前位置运行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">str, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">eval</span>(str); <span class=\"comment\">// 作弊！</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo(<span class=\"string\">&quot;var b = 3&quot;</span>, <span class=\"number\">1</span>); <span class=\"comment\">//1,3</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，<code>var b = 3</code>会再 eval 位置运行，从而在 foo 作用域内创建了变量<code>b</code>。当<code>console.log(a,b)</code>调用发生时，引擎会直接访问 foo 作用域内的<code>b</code>，而不会再访问外部的<code>b</code>变量。</p>\n<p><strong>注意：使用严格模式，在 eval 中作出的声明不会实际上修改包围他的作用域</strong></p>\n<ol start=\"2\">\n<li>with</li>\n</ol>\n<p>我们通常使用 with 来引用一个对象的多个属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    b = <span class=\"number\">4</span>;</span><br><span class=\"line\">    c = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">//&#123;a: 3, b: 4, c: 5&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>但是，with 会做的事，比这要多得多。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o1 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(o1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o1.a); <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo(o2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o2.a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2  全局作用域泄漏</span></span><br></pre></td></tr></table></figure>\n\n<p>with 语句接受一个对象，并将这个对象视为一个<strong>完全隔离的词法作用域</strong>。</p>\n<p><strong>但是</strong> with 块内部的一个普通的<code>var</code>声明并不会归于这个<code>with</code>块儿的作用域，而是归于包含它的函数作用域。</p>\n<p>所以，上面代码执行<code>foo(o2)</code>时，在执行到 <code>a = 2</code> 时，引擎会进行 <code>LHS查找</code>，但是一直到最外层都没有找到 a 变量，所以会在最外层创建这个变量，这里就造成了作用域泄漏。</p>\n<h2 id=\"函数与块作用域\"><a href=\"#函数与块作用域\" class=\"headerlink\" title=\"函数与块作用域\"></a>函数与块作用域</h2><p>javascript 中是不是只能通过函数创建新的作用域，有没有其他方式／结构创建作用域？</p>\n<h3 id=\"函数中的作用域\"><a href=\"#函数中的作用域\" class=\"headerlink\" title=\"函数中的作用域\"></a>函数中的作用域</h3><blockquote>\n<p>javascript 拥有基于函数的作用域</p>\n</blockquote>\n<p>函数作用域支持着这样的想法：所有变量都属于函数，而去贯穿整个函数都可以使用或重用（包括嵌套的作用域中）。</p>\n<p>这样以来，一个声明出现在作用域何处是<strong>无关紧要</strong>的。</p>\n<h3 id=\"隐藏标识符于普通作用域\"><a href=\"#隐藏标识符于普通作用域\" class=\"headerlink\" title=\"隐藏标识符于普通作用域\"></a>隐藏标识符于普通作用域</h3><p>我们可以通过将变量和函数围在一个函数的作用域中来“隐藏”它们。</p>\n<p>为什么需要“隐藏”变量和函数？</p>\n<p>如果允许外围的作用域访问一个工作的私有细节，不仅没必要，而且可能是危险的。所以软件设计中有一个<strong>最低权限原则</strong>原则：</p>\n<p><strong>最低权限原则</strong>：也称“最低授权”／“最少曝光”，在软件设计中，比如一个模块／对象的 API，你应当只暴露所需要的最低限度的东西，而隐藏其他一切。</p>\n<p>将变量和函数隐藏可以避免多个同名但用处不同的标识符之间发生无意的冲突，从而导致值被意外的覆盖。</p>\n<p>实际可操作的方式：</p>\n<ol>\n<li><p>全局命名空间</p>\n<p>在引用多个库时，如果他们没有隐藏内部／私有函数和变量，那么它们十分容易出现相互冲突。所以，这些库通常会在全局作用域中使用一个特殊的名称来创建一个单读的变量声明。它经常是一个对象，然后这个对象被用作这个库一个<code>命名空间</code>，所有要暴露出来的功能都会作为属性挂载在这个对象上。</p>\n<p>比如，Jquery 的对象就是 jquery/$;</p>\n</li>\n<li><p>模块管理</p>\n<p>实现命名冲突的另一种方式是模块管理。</p>\n</li>\n</ol>\n<h3 id=\"函数作为作用域\"><a href=\"#函数作为作用域\" class=\"headerlink\" title=\"函数作为作用域\"></a>函数作为作用域</h3><p>声明一个函数，可以拿来隐藏函数和变量，但这种方式同时也存在着问题：</p>\n<ul>\n<li>不得不声明一个命名函数，这个函数的标识符名称本身就污染了外围作用域</li>\n<li>不得不通过名称明确地调用这个函数</li>\n</ul>\n<p>不需要名称，又能自动执行的，js 恰好提供了这样一种方式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码使用了匿名函数和立即调用函数表达式：</p>\n<ol>\n<li>匿名函数</li>\n</ol>\n<p>函数表达式可以匿名，函数声明不能匿名。</p>\n<p>匿名函数的缺点：</p>\n<ul>\n<li>在栈中没有有用的名称可以表示，调试困难；</li>\n<li>想要递归自己（arguments.callee）或者解绑事件处理器变得麻烦</li>\n<li>更不易代码阅读</li>\n</ul>\n<p>最佳的方式总是命名你的函数表达式。</p>\n<ol start=\"2\">\n<li>立即调用函数表达式</li>\n</ol>\n<p>通过一个<code>()</code>，我们可以将函数作为表达式。末尾再加一个括号可以执行这个函数表达式。这种模式被成为 IIFE（立即调用函数表达式；Immediately Invoked Function Expression）</p>\n<h3 id=\"块作为作用域\"><a href=\"#块作为作用域\" class=\"headerlink\" title=\"块作为作用域\"></a>块作为作用域</h3><p>大部门语言都支持块级作用域，从而将信息隐藏到我们的代码块中，块级作用域是一种扩展了<code>最低权限原则</code>的工具。</p>\n<p>但是，表面上看来 javascript 没有块级作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 10 变量i被划入了外围作用域中</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">//9</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">//9 // 变量bar被划入了外围作用域中</span></span><br></pre></td></tr></table></figure>\n\n<p>但也有特殊情况：</p>\n<ul>\n<li><p>with</p>\n<p>它从对象中创建的作用域仅存在于这个 with 语句的生命周期中。</p>\n</li>\n<li><p>try/catch</p>\n<p>ES3 明确指出 try/catch 中的 cathc 子语句中声明的变量，是属于 catch 块的块级作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure></li>\n<li><p>let/const</p>\n<p>let 将变量声明依附在它所在的块儿（通常是{…}）作用域中。</p>\n<ul>\n<li>隐含使用现存得块儿</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">//1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建明确块儿</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 明确的块儿</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> bar = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">//1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n\n<p>const 也创建一个块级作用域，但是它的值是固定的（常量）。</p>\n<p><strong>注意：</strong> let/const 声明不进行变量提升。</p>\n</li>\n</ul>\n<p>块级作用域的用处：</p>\n<ol>\n<li><p>垃圾回收</p>\n<p>可以处理闭包和释放内存的垃圾回收。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">process</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bigData = &#123;...&#125;; <span class=\"comment\">// 大体量数据</span></span><br><span class=\"line\">process(bigData);</span><br><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;btn&#x27;</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;btn click&#x27;</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>点击事件的回调函数根本不需要 bigData 这个大体量数据。理论上讲，在执行完 process 函数后，这个消耗巨大内存的数据结构应该被作为垃圾而回收。然而因为 click 函数在整个函数作用域上拥有一个闭包，bigData 将会仍然保持一段事件。</p>\n<p>块级作用域可以解决这个问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">process</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> bigData = &#123;...&#125;; <span class=\"comment\">// 大体量数据</span></span><br><span class=\"line\">   process(bigData);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;btn&#x27;</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;btn click&#x27;</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>循环</p>\n<p>对每一次循环的迭代重新绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n\n<p>也可以这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> i = j; <span class=\"comment\">// 每次迭代重新绑定</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h2><p>函数作用域还是块级作用域的行为都依赖于一个相同的规则： 在一个作用域中声明的任何变量都附着在这个作用域上。</p>\n<p>但是出现一个作用域内各种位置的声明如何依附作用域？</p>\n<h3 id=\"先有鸡还是先有蛋？\"><a href=\"#先有鸡还是先有蛋？\" class=\"headerlink\" title=\"先有鸡还是先有蛋？\"></a>先有鸡还是先有蛋？</h3><p>我们倾向于认为代码是自上而下地被解释执行的。这大致上是对的，但也有一部分并非如此。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>如果代码自上而下的解释运行，预期应该输出 <code>undefined</code> ，因为 <code>var a</code> 在 <code>a = 2</code> 之后，应该重新定义了变量 a。显然，结果并不是如此。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的例子上，你也许会猜测这里会输出 2，或者认为这里会导致一个 ReferenceError 被抛出。不幸的是，结果却是 undefined。</p>\n<p>代码究竟如何执行，是先有声明还是赋值？</p>\n<h3 id=\"编译器再次袭来\"><a href=\"#编译器再次袭来\" class=\"headerlink\" title=\"编译器再次袭来\"></a>编译器再次袭来</h3><p>我们知道，引擎在 javascript 执行代码之前会先对代码进行编译，编译的其中一个工作就是找到所有的声明，并将它关联在合适的作用域上。</p>\n<p>所以，在我们的代码被执行前，所有的声明，包括变量和函数，都会被首先处理。</p>\n<p>对于<code>var a = 2</code>，我们认为是一个语句，但 javascript 实际上认为这是俩个语句：<code>var a</code> 和 <code>a = 2</code>。第一句（声明）会在编译阶段处理，第二句（赋值）会在执行阶段处理。</p>\n<p>知道了这些，我想对于上一节的疑惑也就迎刃而解了：<strong>先有声明，后有赋值</strong>。</p>\n<p><strong>注意：提升是以作用域为单位的</strong></p>\n<p>函数声明会被提升，但是表达式不会。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">goo(); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> goo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>变量 goo 被提升了，但表达式没有，所以调用 goo 时，goo 的值为 undefined。所以会报 TypeError。</p>\n<h3 id=\"函数优先\"><a href=\"#函数优先\" class=\"headerlink\" title=\"函数优先\"></a>函数优先</h3><p>函数声明和变量都会提升。但是函数享有更高的优先级。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> foo); <span class=\"comment\">// function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面代码可以看出，结果输出 function 而不是 undefined 。说明函数声明优先于变量。</p>\n<p><strong>重复声明，后面的会覆盖前面的。</strong></p>\n<h2 id=\"作用域闭包\"><a href=\"#作用域闭包\" class=\"headerlink\" title=\"作用域闭包\"></a>作用域闭包</h2><p>必须要对作用域有健全和坚实的理解才能理解闭包。</p>\n<h3 id=\"启蒙\"><a href=\"#启蒙\" class=\"headerlink\" title=\"启蒙\"></a>启蒙</h3><p>在 javascript 中闭包无处不在，你只是必须认出它并接纳它。它是依赖于词法作用域编写代码而产生的结果。</p>\n<h3 id=\"事实真相\"><a href=\"#事实真相\" class=\"headerlink\" title=\"事实真相\"></a>事实真相</h3><blockquote>\n<p>闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在他的词法作用域之外执行时</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种形式算闭包吗？技术上算，它实现了闭包，函数 bar 在函数 foo 的作用域上有一个闭包，即 bar 闭住了 foo 的作用域。但是在上面代码中并不是可以严格地观察到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\">baz(); <span class=\"comment\">//2  这样使用才算真正意义上的闭包</span></span><br></pre></td></tr></table></figure>\n\n<p>bar 对于 foo 内的作用域拥有此法作用域访问权，当我们调用 foo 之后返回 bar 的引用。按理来说，foo 执行过后，我们一般会期望 foo 的整个内部作用域消失，因为垃圾回收机制会自动回收不再使用的内存。但 bar 拥有一个词法作用域的闭包，覆盖着 foo 的内部作用域，闭包为了能使 bar 在以后的任意时刻可以引用这个作用域而保持的它的存在。</p>\n<p>所以，bar <strong>在词法作用域之外依然拥有对那个作用域的引用，这个引用称为闭包。</strong></p>\n<p><strong>闭包使一个函数可以继续访问它在编写时被定义的词法作用域。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    fn(); <span class=\"comment\">// 发现闭包！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(bar);</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，函数作为参数被传递，实际上这也是一种观察／使用闭包的例子。</p>\n<p><strong>无论我们使用什么方法将一个函数传送到它的词法作用域之外，它都将维护一个指向它被声明时的作用域的引用。</strong></p>\n<h3 id=\"循环-闭包\"><a href=\"#循环-闭包\" class=\"headerlink\" title=\"循环 + 闭包\"></a>循环 + 闭包</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 5</span></span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的预期是每隔一秒分别打印数字：1，2，3，4，5。但是我们执行后发现结果一共输出了 5 次 6。</p>\n<p><strong>为什么达不到预期的效果？</strong></p>\n<p>定时器的回调函数会在循环完成之后执行（详见<a href=\"'./%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6'\">事件循环机制</a>）。而 for 不是块级作用域，所以每次执行 timer 函数的时候，它们的闭包都在全局作用域上。而此时全局作用域环境中的变量 i 的值为 6。</p>\n<p><strong>我们的代码缺少了什么？</strong></p>\n<p>因为每一个 timer 函数执行的时候都是使用全局作用域，所以访问的变量必然是一致的，所以想要达到预期的结果，我们必须为每一个 timer 函数创建一个私有作用域，并在这个私有作用域内存在一个可供回调函数访问的变量。现在我们来改写一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> j = i;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(j); <span class=\"comment\">// 1,2,3,4,5</span></span><br><span class=\"line\">        &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用 IIFE 为每次迭代创建新的作用域，并且保存每次迭代需要的值。</p>\n<p>其实这里主要用到的原理是使用块级作用域，所以，理论上还有其他方式可以实现，比如：with，try/catch,let/const，大家都可以尝试下哦。</p>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>模块也利用了闭包的力量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">coolModule</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> something = <span class=\"string\">&quot;cool&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(something);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSomething</span>: doSomething</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = coolModule()</span><br><span class=\"line\">foo.doSomething() <span class=\"comment\">// cool</span></span><br></pre></td></tr></table></figure>"},{"_content":"# 使用gulp构建自动化工作流\n\n+ 简单易用\n+ 高效构建\n+ 高质量的生态圈\n\n可能很多人会说现在提gulp也太落后了吧，但我想说写点东西并不是为了讨论它是否过时，而是来帮助我们自己来记忆、整理和学习。任何工具，我需要，我才去使用它，正如此时我需要gulp一样。\n\n> 为了效率而使用工具\n\n\n## 安装\n- 全局安装 gulp命令：\n\n```\n$ npm install --global gulp-cli\n```\n\n+ 作为项目的开发依赖（devDependencie）安装：\n\n```\n$ npm install --save-dev gulp\n```\n\n## 创建配置文件\n在项目根目录下创建一个名为 gulpfile.js 的文件:\n\n```\ntouch gulpfile.js\n```\n\n\n## API\n\n+ gulp.src(globs[, options])\n\n\t读取目标源文件\n\n+ gulp.dest(path[, options])\n\n\t向目标路径输出结果\n\n+ gulp.pipe()\n\n\t将目标文件通过插件处理\n\n+ gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])\n\n\t监视文件系统，并且可以在文件发生改动时候做一些事情\n\n+ gulp.task(name[, deps], fn): 任务\n\n\t定义一个gulp任务\n\n\n## 使用\n当配置完gulp.file后运行 gulp：\n\n```\n$ gulp\n```\n\n## 常用工具插件\n+ [gulp-sass](https://github.com/dlmanning/gulp-sass)\n\n\tsass/scss编译\n\n+ [gulp-eslint](https://github.com/adametry/gulp-eslint)\n\n\tjs代码校对\n\n+ [gulp.spritesmith](https://github.com/twolfson/gulp.spritesmith)\n\n\t生成sprite雪碧图\n\n+ [gulp-connect](https://github.com/AveVlad/gulp-connect)\n\n\t本地起一个websocket服务，实时刷新浏览器\n\n+ [gulp-changed](https://github.com/sindresorhus/gulp-changed)\n\t\n\t1. 不浪费宝贵的时间处理没有改动的文件.`gulp-changed`会首先把文件进行比对，如果文件没有改动，则跳过后续任务，。\n\t2. 默认情况下，gulp只能检测流中的文件是否更改。`gulp-changed`的对比功能更加强大，比如可以知道导入/依赖的文件是否更改。\n\t\n+ [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware)\n   路由代理中间件\n\n## 示例\n以下是我的gulp文件，仅供交流。\n\n```\n\n'use strict';\nconst gulp = require(\"gulp\");\n\n/**\n * [sass sass/scss编译]\n */\nconst sass = require(\"gulp-sass\");\n\n/**\n * [eslint js代码检测]\n */\nconst eslint = require('gulp-eslint');\n\n/**\n * [connect 本地起一个websocket服务，实时刷新浏览器]\n */\nconst connect = require('gulp-connect');\n\n/**\n * [changed 比较文件变动]\n * 默认情况下，gulp只能检测流中的文件是否更改。\n * 如果您需要更高级的东西，比如知道导入/依赖的文件是否更改，则可以使用该插件。\n */\nconst changed = require('gulp-changed');\n\n/**\n * [spritesmith 合并成雪碧图]\n */\nconst spritesmith= (\"gulp.spritesmith\");\n\n/**\n * [proxy 中间代理件]\n */\nconst proxy = require('http-proxy-middleware');\n\nlet Pathconfig = {\n    sassCompilePath: __dirname + \"/scss/**/*.scss\", //需要编译的scss文件路径\n    sassDestPath: __dirname + \"/css/\",  //编译后的scss文件存放处\n    htmlSrcPath: __dirname + \"/html/*.html\", //监控的html路径\n    jsSrcPath: __dirname + \"/js/*.js\",  //监控的js文件路径\n}\n\n// html任务\ngulp.task(\"html\",function(){\n    gulp.src(Pathconfig.htmlSrcPath)\n    .pipe(connect.reload());\n})\n\n// 样式任务\ngulp.task(\"stylus\",function(){\n    gulp.src(Pathconfig.sassCompilePath)\n        .pipe(changed(Pathconfig.sassDestPath))\n        .pipe(sass())\n        .pipe(gulp.dest(Pathconfig.sassDestPath))\n        .pipe(connect.reload());\n})\n\n// js任务\ngulp.task(\"js\",function(){\n    gulp.src([Pathconfig.jsSrcPath,'!node_modules/**'])\n        .pipe(eslint())\n        .pipe(eslint.formatEach('compact', process.stderr))\n        .pipe(connect.reload());\n})\n\n// 监控变动\ngulp.task(\"watch\",function(){\n    gulp.watch([Pathconfig.htmlSrcPath], ['html']);\n    gulp.watch([Pathconfig.sassCompilePath], ['stylus']);\n    gulp.watch([Pathconfig.jsSrcPath], ['js']);\n})\n\n//定义livereload任务，起一个本地服务\ngulp.task('connect',function () {\n    connect.server({\n        root: __dirname,\n        port: 8000,\n        livereload: true\n    });\n});\n\n\ngulp.task(\"default\",['connect','watch'])\n```\n\n","source":"_posts/使用gulp构建自动化工作流.md","raw":"# 使用gulp构建自动化工作流\n\n+ 简单易用\n+ 高效构建\n+ 高质量的生态圈\n\n可能很多人会说现在提gulp也太落后了吧，但我想说写点东西并不是为了讨论它是否过时，而是来帮助我们自己来记忆、整理和学习。任何工具，我需要，我才去使用它，正如此时我需要gulp一样。\n\n> 为了效率而使用工具\n\n\n## 安装\n- 全局安装 gulp命令：\n\n```\n$ npm install --global gulp-cli\n```\n\n+ 作为项目的开发依赖（devDependencie）安装：\n\n```\n$ npm install --save-dev gulp\n```\n\n## 创建配置文件\n在项目根目录下创建一个名为 gulpfile.js 的文件:\n\n```\ntouch gulpfile.js\n```\n\n\n## API\n\n+ gulp.src(globs[, options])\n\n\t读取目标源文件\n\n+ gulp.dest(path[, options])\n\n\t向目标路径输出结果\n\n+ gulp.pipe()\n\n\t将目标文件通过插件处理\n\n+ gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])\n\n\t监视文件系统，并且可以在文件发生改动时候做一些事情\n\n+ gulp.task(name[, deps], fn): 任务\n\n\t定义一个gulp任务\n\n\n## 使用\n当配置完gulp.file后运行 gulp：\n\n```\n$ gulp\n```\n\n## 常用工具插件\n+ [gulp-sass](https://github.com/dlmanning/gulp-sass)\n\n\tsass/scss编译\n\n+ [gulp-eslint](https://github.com/adametry/gulp-eslint)\n\n\tjs代码校对\n\n+ [gulp.spritesmith](https://github.com/twolfson/gulp.spritesmith)\n\n\t生成sprite雪碧图\n\n+ [gulp-connect](https://github.com/AveVlad/gulp-connect)\n\n\t本地起一个websocket服务，实时刷新浏览器\n\n+ [gulp-changed](https://github.com/sindresorhus/gulp-changed)\n\t\n\t1. 不浪费宝贵的时间处理没有改动的文件.`gulp-changed`会首先把文件进行比对，如果文件没有改动，则跳过后续任务，。\n\t2. 默认情况下，gulp只能检测流中的文件是否更改。`gulp-changed`的对比功能更加强大，比如可以知道导入/依赖的文件是否更改。\n\t\n+ [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware)\n   路由代理中间件\n\n## 示例\n以下是我的gulp文件，仅供交流。\n\n```\n\n'use strict';\nconst gulp = require(\"gulp\");\n\n/**\n * [sass sass/scss编译]\n */\nconst sass = require(\"gulp-sass\");\n\n/**\n * [eslint js代码检测]\n */\nconst eslint = require('gulp-eslint');\n\n/**\n * [connect 本地起一个websocket服务，实时刷新浏览器]\n */\nconst connect = require('gulp-connect');\n\n/**\n * [changed 比较文件变动]\n * 默认情况下，gulp只能检测流中的文件是否更改。\n * 如果您需要更高级的东西，比如知道导入/依赖的文件是否更改，则可以使用该插件。\n */\nconst changed = require('gulp-changed');\n\n/**\n * [spritesmith 合并成雪碧图]\n */\nconst spritesmith= (\"gulp.spritesmith\");\n\n/**\n * [proxy 中间代理件]\n */\nconst proxy = require('http-proxy-middleware');\n\nlet Pathconfig = {\n    sassCompilePath: __dirname + \"/scss/**/*.scss\", //需要编译的scss文件路径\n    sassDestPath: __dirname + \"/css/\",  //编译后的scss文件存放处\n    htmlSrcPath: __dirname + \"/html/*.html\", //监控的html路径\n    jsSrcPath: __dirname + \"/js/*.js\",  //监控的js文件路径\n}\n\n// html任务\ngulp.task(\"html\",function(){\n    gulp.src(Pathconfig.htmlSrcPath)\n    .pipe(connect.reload());\n})\n\n// 样式任务\ngulp.task(\"stylus\",function(){\n    gulp.src(Pathconfig.sassCompilePath)\n        .pipe(changed(Pathconfig.sassDestPath))\n        .pipe(sass())\n        .pipe(gulp.dest(Pathconfig.sassDestPath))\n        .pipe(connect.reload());\n})\n\n// js任务\ngulp.task(\"js\",function(){\n    gulp.src([Pathconfig.jsSrcPath,'!node_modules/**'])\n        .pipe(eslint())\n        .pipe(eslint.formatEach('compact', process.stderr))\n        .pipe(connect.reload());\n})\n\n// 监控变动\ngulp.task(\"watch\",function(){\n    gulp.watch([Pathconfig.htmlSrcPath], ['html']);\n    gulp.watch([Pathconfig.sassCompilePath], ['stylus']);\n    gulp.watch([Pathconfig.jsSrcPath], ['js']);\n})\n\n//定义livereload任务，起一个本地服务\ngulp.task('connect',function () {\n    connect.server({\n        root: __dirname,\n        port: 8000,\n        livereload: true\n    });\n});\n\n\ngulp.task(\"default\",['connect','watch'])\n```\n\n","slug":"使用gulp构建自动化工作流","published":1,"date":"2021-12-06T06:07:06.270Z","updated":"2021-12-06T06:07:06.270Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom4003iy4v29vvm3oeu","content":"<h1 id=\"使用gulp构建自动化工作流\"><a href=\"#使用gulp构建自动化工作流\" class=\"headerlink\" title=\"使用gulp构建自动化工作流\"></a>使用gulp构建自动化工作流</h1><ul>\n<li>简单易用</li>\n<li>高效构建</li>\n<li>高质量的生态圈</li>\n</ul>\n<p>可能很多人会说现在提gulp也太落后了吧，但我想说写点东西并不是为了讨论它是否过时，而是来帮助我们自己来记忆、整理和学习。任何工具，我需要，我才去使用它，正如此时我需要gulp一样。</p>\n<blockquote>\n<p>为了效率而使用工具</p>\n</blockquote>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ul>\n<li>全局安装 gulp命令：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --global gulp-cli</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>作为项目的开发依赖（devDependencie）安装：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建配置文件\"><a href=\"#创建配置文件\" class=\"headerlink\" title=\"创建配置文件\"></a>创建配置文件</h2><p>在项目根目录下创建一个名为 gulpfile.js 的文件:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch gulpfile.js</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><ul>\n<li><p>gulp.src(globs[, options])</p>\n<p>  读取目标源文件</p>\n</li>\n<li><p>gulp.dest(path[, options])</p>\n<p>  向目标路径输出结果</p>\n</li>\n<li><p>gulp.pipe()</p>\n<p>  将目标文件通过插件处理</p>\n</li>\n<li><p>gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])</p>\n<p>  监视文件系统，并且可以在文件发生改动时候做一些事情</p>\n</li>\n<li><p>gulp.task(name[, deps], fn): 任务</p>\n<p>  定义一个gulp任务</p>\n</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>当配置完gulp.file后运行 gulp：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gulp</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用工具插件\"><a href=\"#常用工具插件\" class=\"headerlink\" title=\"常用工具插件\"></a>常用工具插件</h2><ul>\n<li><p><a href=\"https://github.com/dlmanning/gulp-sass\">gulp-sass</a></p>\n<p>  sass/scss编译</p>\n</li>\n<li><p><a href=\"https://github.com/adametry/gulp-eslint\">gulp-eslint</a></p>\n<p>  js代码校对</p>\n</li>\n<li><p><a href=\"https://github.com/twolfson/gulp.spritesmith\">gulp.spritesmith</a></p>\n<p>  生成sprite雪碧图</p>\n</li>\n<li><p><a href=\"https://github.com/AveVlad/gulp-connect\">gulp-connect</a></p>\n<p>  本地起一个websocket服务，实时刷新浏览器</p>\n</li>\n<li><p><a href=\"https://github.com/sindresorhus/gulp-changed\">gulp-changed</a></p>\n<ol>\n<li>不浪费宝贵的时间处理没有改动的文件.<code>gulp-changed</code>会首先把文件进行比对，如果文件没有改动，则跳过后续任务，。</li>\n<li>默认情况下，gulp只能检测流中的文件是否更改。<code>gulp-changed</code>的对比功能更加强大，比如可以知道导入/依赖的文件是否更改。</li>\n</ol>\n</li>\n<li><p><a href=\"https://github.com/chimurai/http-proxy-middleware\">http-proxy-middleware</a><br> 路由代理中间件</p>\n</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>以下是我的gulp文件，仅供交流。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x27;use strict&#x27;;</span><br><span class=\"line\">const gulp = require(&quot;gulp&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [sass sass/scss编译]</span><br><span class=\"line\"> */</span><br><span class=\"line\">const sass = require(&quot;gulp-sass&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [eslint js代码检测]</span><br><span class=\"line\"> */</span><br><span class=\"line\">const eslint = require(&#x27;gulp-eslint&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [connect 本地起一个websocket服务，实时刷新浏览器]</span><br><span class=\"line\"> */</span><br><span class=\"line\">const connect = require(&#x27;gulp-connect&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [changed 比较文件变动]</span><br><span class=\"line\"> * 默认情况下，gulp只能检测流中的文件是否更改。</span><br><span class=\"line\"> * 如果您需要更高级的东西，比如知道导入/依赖的文件是否更改，则可以使用该插件。</span><br><span class=\"line\"> */</span><br><span class=\"line\">const changed = require(&#x27;gulp-changed&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [spritesmith 合并成雪碧图]</span><br><span class=\"line\"> */</span><br><span class=\"line\">const spritesmith= (&quot;gulp.spritesmith&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [proxy 中间代理件]</span><br><span class=\"line\"> */</span><br><span class=\"line\">const proxy = require(&#x27;http-proxy-middleware&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let Pathconfig = &#123;</span><br><span class=\"line\">    sassCompilePath: __dirname + &quot;/scss/**/*.scss&quot;, //需要编译的scss文件路径</span><br><span class=\"line\">    sassDestPath: __dirname + &quot;/css/&quot;,  //编译后的scss文件存放处</span><br><span class=\"line\">    htmlSrcPath: __dirname + &quot;/html/*.html&quot;, //监控的html路径</span><br><span class=\"line\">    jsSrcPath: __dirname + &quot;/js/*.js&quot;,  //监控的js文件路径</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// html任务</span><br><span class=\"line\">gulp.task(&quot;html&quot;,function()&#123;</span><br><span class=\"line\">    gulp.src(Pathconfig.htmlSrcPath)</span><br><span class=\"line\">    .pipe(connect.reload());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 样式任务</span><br><span class=\"line\">gulp.task(&quot;stylus&quot;,function()&#123;</span><br><span class=\"line\">    gulp.src(Pathconfig.sassCompilePath)</span><br><span class=\"line\">        .pipe(changed(Pathconfig.sassDestPath))</span><br><span class=\"line\">        .pipe(sass())</span><br><span class=\"line\">        .pipe(gulp.dest(Pathconfig.sassDestPath))</span><br><span class=\"line\">        .pipe(connect.reload());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// js任务</span><br><span class=\"line\">gulp.task(&quot;js&quot;,function()&#123;</span><br><span class=\"line\">    gulp.src([Pathconfig.jsSrcPath,&#x27;!node_modules/**&#x27;])</span><br><span class=\"line\">        .pipe(eslint())</span><br><span class=\"line\">        .pipe(eslint.formatEach(&#x27;compact&#x27;, process.stderr))</span><br><span class=\"line\">        .pipe(connect.reload());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 监控变动</span><br><span class=\"line\">gulp.task(&quot;watch&quot;,function()&#123;</span><br><span class=\"line\">    gulp.watch([Pathconfig.htmlSrcPath], [&#x27;html&#x27;]);</span><br><span class=\"line\">    gulp.watch([Pathconfig.sassCompilePath], [&#x27;stylus&#x27;]);</span><br><span class=\"line\">    gulp.watch([Pathconfig.jsSrcPath], [&#x27;js&#x27;]);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//定义livereload任务，起一个本地服务</span><br><span class=\"line\">gulp.task(&#x27;connect&#x27;,function () &#123;</span><br><span class=\"line\">    connect.server(&#123;</span><br><span class=\"line\">        root: __dirname,</span><br><span class=\"line\">        port: 8000,</span><br><span class=\"line\">        livereload: true</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(&quot;default&quot;,[&#x27;connect&#x27;,&#x27;watch&#x27;])</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用gulp构建自动化工作流\"><a href=\"#使用gulp构建自动化工作流\" class=\"headerlink\" title=\"使用gulp构建自动化工作流\"></a>使用gulp构建自动化工作流</h1><ul>\n<li>简单易用</li>\n<li>高效构建</li>\n<li>高质量的生态圈</li>\n</ul>\n<p>可能很多人会说现在提gulp也太落后了吧，但我想说写点东西并不是为了讨论它是否过时，而是来帮助我们自己来记忆、整理和学习。任何工具，我需要，我才去使用它，正如此时我需要gulp一样。</p>\n<blockquote>\n<p>为了效率而使用工具</p>\n</blockquote>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ul>\n<li>全局安装 gulp命令：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --global gulp-cli</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>作为项目的开发依赖（devDependencie）安装：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建配置文件\"><a href=\"#创建配置文件\" class=\"headerlink\" title=\"创建配置文件\"></a>创建配置文件</h2><p>在项目根目录下创建一个名为 gulpfile.js 的文件:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch gulpfile.js</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><ul>\n<li><p>gulp.src(globs[, options])</p>\n<p>  读取目标源文件</p>\n</li>\n<li><p>gulp.dest(path[, options])</p>\n<p>  向目标路径输出结果</p>\n</li>\n<li><p>gulp.pipe()</p>\n<p>  将目标文件通过插件处理</p>\n</li>\n<li><p>gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])</p>\n<p>  监视文件系统，并且可以在文件发生改动时候做一些事情</p>\n</li>\n<li><p>gulp.task(name[, deps], fn): 任务</p>\n<p>  定义一个gulp任务</p>\n</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>当配置完gulp.file后运行 gulp：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gulp</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用工具插件\"><a href=\"#常用工具插件\" class=\"headerlink\" title=\"常用工具插件\"></a>常用工具插件</h2><ul>\n<li><p><a href=\"https://github.com/dlmanning/gulp-sass\">gulp-sass</a></p>\n<p>  sass/scss编译</p>\n</li>\n<li><p><a href=\"https://github.com/adametry/gulp-eslint\">gulp-eslint</a></p>\n<p>  js代码校对</p>\n</li>\n<li><p><a href=\"https://github.com/twolfson/gulp.spritesmith\">gulp.spritesmith</a></p>\n<p>  生成sprite雪碧图</p>\n</li>\n<li><p><a href=\"https://github.com/AveVlad/gulp-connect\">gulp-connect</a></p>\n<p>  本地起一个websocket服务，实时刷新浏览器</p>\n</li>\n<li><p><a href=\"https://github.com/sindresorhus/gulp-changed\">gulp-changed</a></p>\n<ol>\n<li>不浪费宝贵的时间处理没有改动的文件.<code>gulp-changed</code>会首先把文件进行比对，如果文件没有改动，则跳过后续任务，。</li>\n<li>默认情况下，gulp只能检测流中的文件是否更改。<code>gulp-changed</code>的对比功能更加强大，比如可以知道导入/依赖的文件是否更改。</li>\n</ol>\n</li>\n<li><p><a href=\"https://github.com/chimurai/http-proxy-middleware\">http-proxy-middleware</a><br> 路由代理中间件</p>\n</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>以下是我的gulp文件，仅供交流。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x27;use strict&#x27;;</span><br><span class=\"line\">const gulp = require(&quot;gulp&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [sass sass/scss编译]</span><br><span class=\"line\"> */</span><br><span class=\"line\">const sass = require(&quot;gulp-sass&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [eslint js代码检测]</span><br><span class=\"line\"> */</span><br><span class=\"line\">const eslint = require(&#x27;gulp-eslint&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [connect 本地起一个websocket服务，实时刷新浏览器]</span><br><span class=\"line\"> */</span><br><span class=\"line\">const connect = require(&#x27;gulp-connect&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [changed 比较文件变动]</span><br><span class=\"line\"> * 默认情况下，gulp只能检测流中的文件是否更改。</span><br><span class=\"line\"> * 如果您需要更高级的东西，比如知道导入/依赖的文件是否更改，则可以使用该插件。</span><br><span class=\"line\"> */</span><br><span class=\"line\">const changed = require(&#x27;gulp-changed&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [spritesmith 合并成雪碧图]</span><br><span class=\"line\"> */</span><br><span class=\"line\">const spritesmith= (&quot;gulp.spritesmith&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * [proxy 中间代理件]</span><br><span class=\"line\"> */</span><br><span class=\"line\">const proxy = require(&#x27;http-proxy-middleware&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let Pathconfig = &#123;</span><br><span class=\"line\">    sassCompilePath: __dirname + &quot;/scss/**/*.scss&quot;, //需要编译的scss文件路径</span><br><span class=\"line\">    sassDestPath: __dirname + &quot;/css/&quot;,  //编译后的scss文件存放处</span><br><span class=\"line\">    htmlSrcPath: __dirname + &quot;/html/*.html&quot;, //监控的html路径</span><br><span class=\"line\">    jsSrcPath: __dirname + &quot;/js/*.js&quot;,  //监控的js文件路径</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// html任务</span><br><span class=\"line\">gulp.task(&quot;html&quot;,function()&#123;</span><br><span class=\"line\">    gulp.src(Pathconfig.htmlSrcPath)</span><br><span class=\"line\">    .pipe(connect.reload());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 样式任务</span><br><span class=\"line\">gulp.task(&quot;stylus&quot;,function()&#123;</span><br><span class=\"line\">    gulp.src(Pathconfig.sassCompilePath)</span><br><span class=\"line\">        .pipe(changed(Pathconfig.sassDestPath))</span><br><span class=\"line\">        .pipe(sass())</span><br><span class=\"line\">        .pipe(gulp.dest(Pathconfig.sassDestPath))</span><br><span class=\"line\">        .pipe(connect.reload());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// js任务</span><br><span class=\"line\">gulp.task(&quot;js&quot;,function()&#123;</span><br><span class=\"line\">    gulp.src([Pathconfig.jsSrcPath,&#x27;!node_modules/**&#x27;])</span><br><span class=\"line\">        .pipe(eslint())</span><br><span class=\"line\">        .pipe(eslint.formatEach(&#x27;compact&#x27;, process.stderr))</span><br><span class=\"line\">        .pipe(connect.reload());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 监控变动</span><br><span class=\"line\">gulp.task(&quot;watch&quot;,function()&#123;</span><br><span class=\"line\">    gulp.watch([Pathconfig.htmlSrcPath], [&#x27;html&#x27;]);</span><br><span class=\"line\">    gulp.watch([Pathconfig.sassCompilePath], [&#x27;stylus&#x27;]);</span><br><span class=\"line\">    gulp.watch([Pathconfig.jsSrcPath], [&#x27;js&#x27;]);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//定义livereload任务，起一个本地服务</span><br><span class=\"line\">gulp.task(&#x27;connect&#x27;,function () &#123;</span><br><span class=\"line\">    connect.server(&#123;</span><br><span class=\"line\">        root: __dirname,</span><br><span class=\"line\">        port: 8000,</span><br><span class=\"line\">        livereload: true</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(&quot;default&quot;,[&#x27;connect&#x27;,&#x27;watch&#x27;])</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"# 二分查找\n\n二分查找即二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）[1]、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。\n\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/binarySearch.png)\n\n## 搜索过程\n\n从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半\n\n## 算法实现\n\n### 递归\n\n```js\n/**\n * throttle\n * @param {*} key 要查找的目标\n * @param {*} low 可选，查找数组的起始位置，默认为0\n * @param {*} high 可选，查找数组的结束位置，默认为数组的最大索引值\n */\nArray.prototype.binarySearch = function(key, low, high) {\n    if (typeof low === \"undefined\") {\n        low = 0;\n    }\n    if (typeof high === \"undefined\") {\n        high = this.length - 1;\n    }\n\n    if (low > high) {\n        return -1;\n    }\n\n    var mid = parseInt((high + low) / 2);\n    if (this[mid] > key) {\n        return this.binary_search(key, low, mid - 1);\n    }\n    if (this[mid] < key) {\n        return this.binary_search(key, mid + 1, high);\n    }\n    return mid;\n};\n```\n\n### 非递归\n\n```js\n/**\n * throttle\n * @param {*} key 要查找的目标\n */\nArray.prototype.binarySearch = function(key) {\n    var low = 0,\n        high = this.length - 1;\n    while (low <= high) {\n        var mid = parseInt((high + low) / 2);\n        if (key == this[mid]) {\n            return mid;\n        } else if (key > this[mid]) {\n            low = mid + 1;\n        } else if (key < this[mid]) {\n            high = mid - 1;\n        } else {\n            return -1;\n        }\n    }\n};\n```\n","source":"_posts/二分查找.md","raw":"# 二分查找\n\n二分查找即二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）[1]、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。\n\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/binarySearch.png)\n\n## 搜索过程\n\n从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半\n\n## 算法实现\n\n### 递归\n\n```js\n/**\n * throttle\n * @param {*} key 要查找的目标\n * @param {*} low 可选，查找数组的起始位置，默认为0\n * @param {*} high 可选，查找数组的结束位置，默认为数组的最大索引值\n */\nArray.prototype.binarySearch = function(key, low, high) {\n    if (typeof low === \"undefined\") {\n        low = 0;\n    }\n    if (typeof high === \"undefined\") {\n        high = this.length - 1;\n    }\n\n    if (low > high) {\n        return -1;\n    }\n\n    var mid = parseInt((high + low) / 2);\n    if (this[mid] > key) {\n        return this.binary_search(key, low, mid - 1);\n    }\n    if (this[mid] < key) {\n        return this.binary_search(key, mid + 1, high);\n    }\n    return mid;\n};\n```\n\n### 非递归\n\n```js\n/**\n * throttle\n * @param {*} key 要查找的目标\n */\nArray.prototype.binarySearch = function(key) {\n    var low = 0,\n        high = this.length - 1;\n    while (low <= high) {\n        var mid = parseInt((high + low) / 2);\n        if (key == this[mid]) {\n            return mid;\n        } else if (key > this[mid]) {\n            low = mid + 1;\n        } else if (key < this[mid]) {\n            high = mid - 1;\n        } else {\n            return -1;\n        }\n    }\n};\n```\n","slug":"二分查找","published":1,"date":"2021-12-06T06:07:06.067Z","updated":"2021-12-06T06:07:06.067Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom5003jy4v2bivufn52","content":"<h1 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h1><p>二分查找即二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）[1]、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。</p>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/binarySearch.png\" alt=\"image\"></p>\n<h2 id=\"搜索过程\"><a href=\"#搜索过程\" class=\"headerlink\" title=\"搜索过程\"></a>搜索过程</h2><p>从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半</p>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * throttle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>key 要查找的目标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>low 可选，查找数组的起始位置，默认为0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>high 可选，查找数组的结束位置，默认为数组的最大索引值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.binarySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, low, high</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> low === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">        low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> high === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">        high = <span class=\"built_in\">this</span>.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &gt; high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> mid = <span class=\"built_in\">parseInt</span>((high + low) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>[mid] &gt; key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.binary_search(key, low, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>[mid] &lt; key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.binary_search(key, mid + <span class=\"number\">1</span>, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * throttle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>key 要查找的目标</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.binarySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> low = <span class=\"number\">0</span>,</span><br><span class=\"line\">        high = <span class=\"built_in\">this</span>.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> mid = <span class=\"built_in\">parseInt</span>((high + low) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"built_in\">this</span>[mid]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; <span class=\"built_in\">this</span>[mid]) &#123;</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; <span class=\"built_in\">this</span>[mid]) &#123;</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h1><p>二分查找即二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）[1]、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。</p>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/binarySearch.png\" alt=\"image\"></p>\n<h2 id=\"搜索过程\"><a href=\"#搜索过程\" class=\"headerlink\" title=\"搜索过程\"></a>搜索过程</h2><p>从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半</p>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * throttle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>key 要查找的目标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>low 可选，查找数组的起始位置，默认为0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>high 可选，查找数组的结束位置，默认为数组的最大索引值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.binarySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, low, high</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> low === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">        low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> high === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">        high = <span class=\"built_in\">this</span>.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &gt; high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> mid = <span class=\"built_in\">parseInt</span>((high + low) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>[mid] &gt; key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.binary_search(key, low, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>[mid] &lt; key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.binary_search(key, mid + <span class=\"number\">1</span>, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * throttle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>key 要查找的目标</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.binarySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> low = <span class=\"number\">0</span>,</span><br><span class=\"line\">        high = <span class=\"built_in\">this</span>.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> mid = <span class=\"built_in\">parseInt</span>((high + low) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"built_in\">this</span>[mid]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; <span class=\"built_in\">this</span>[mid]) &#123;</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; <span class=\"built_in\">this</span>[mid]) &#123;</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 使用ssh连接gitHub\ngithub每次pull/push代码时要求推送代码的用户是合法的，所以每次推送时候都要输入账号密码用以验证用户是否为合法用户，而ssh是一种安全的传输模式，可以代替用户的这一“输入账号密码”的行为来验证用户。\n\n##github的俩种操作方式\n1. https\n\n\t可以随意克隆github上的项目，而不管是谁的；在pull/push的时候是需要验证用户名和密码的\n2. ssh\n\n\t克隆者必须是拥者或管理员，且需要先添加 SSH key ，否则无法克隆。在pull/push的时候不再是验证用户名和密码，而是通过验证ssh的方式来验证用户。\n\n## ssh（安全外壳协议）##\n定义：\n> SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 --百度百科\n\n功能： \n\n>传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的， 就是很容易受到“中间人”（man-in-the-middle）这种方式的攻击。所谓“中间人”的攻击方式， 就是“中间人”冒充真正的服务器接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人”一转手做了手脚之后，就会出现很严重的问题。通过使用SSH，你可以把所有传输的数据进行加密，这样\"中间人\"这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的\"通道\"。 --百度百科\n\n## 使用步骤\n1. 查看是否已经存在ssh秘钥\n\n\t打开git bash，输入\n\n\t\t$ cd ~/.ssh\n    \t$ ls\n如果，提示不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。\n\n\n2. 生成ssh秘钥\n\n\t\t$ ssh-keygen -t rsa -C \"your_email@example.com\"\n\n\t代码参数含义：\n\t- -t 指定密钥类型，默认是 rsa ，可以省略。\n\t- -C 设置注释文字，比如邮箱。\n\t- -f 指定密钥文件存储文件名。\n\t\n    根据提示，需要指定文件位置和密码，如果是你足够放心，其实都可以直接回车，不需要什么密码。执行完以后，可在/c/Users/you/.ssh/路径下看到刚生成的文件：id_rsa和id_rsa.pub。即公钥和私钥。\n\t\n3. 在GitHub账户中添加公钥\n\n\t- 登录你的github，头像处下拉框选择settings。\n\t- 进入设置页后点击侧边栏的`SSH and GPG keys`按钮。\n\t- 点击`New SSH key`,title可以任意填，并且将上一步骤生成的id_rsa.pub的内容复制到这里的`key`输入框中。\n\n4. 确认\n\n\t\t$ ssh -T git@github.com\n\n\t在这里我收到一个提示：\n\n\t*Warning: Permanently added the RSA host key for IP address '192.30.253.113' to the list of known hosts.*\n\t\n    直接回车，最后看到这个就说明大功告成：\n\t\n\t*Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.*\n\n## 遇到的问题 ##\n\n添加完公钥后，使用小乌龟（TortoiseGit）pull代码时报错：\n\n*no supported authentication methods aviaible(server sent:publickey)*\n\n查了一下，发现是因为TortoiseGit和Git的冲突 我们需要把TortoiseGit设置改正如下。\n\n- 右键TortoiseGit -> Settings -> Network\n- 将SSH client指向~\\Git\\usr\\bin\\ssh.exe(Git安装路径下)\n\n\n\n\n\n","source":"_posts/使用ssh 连接gitHub.md","raw":"# 使用ssh连接gitHub\ngithub每次pull/push代码时要求推送代码的用户是合法的，所以每次推送时候都要输入账号密码用以验证用户是否为合法用户，而ssh是一种安全的传输模式，可以代替用户的这一“输入账号密码”的行为来验证用户。\n\n##github的俩种操作方式\n1. https\n\n\t可以随意克隆github上的项目，而不管是谁的；在pull/push的时候是需要验证用户名和密码的\n2. ssh\n\n\t克隆者必须是拥者或管理员，且需要先添加 SSH key ，否则无法克隆。在pull/push的时候不再是验证用户名和密码，而是通过验证ssh的方式来验证用户。\n\n## ssh（安全外壳协议）##\n定义：\n> SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 --百度百科\n\n功能： \n\n>传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的， 就是很容易受到“中间人”（man-in-the-middle）这种方式的攻击。所谓“中间人”的攻击方式， 就是“中间人”冒充真正的服务器接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人”一转手做了手脚之后，就会出现很严重的问题。通过使用SSH，你可以把所有传输的数据进行加密，这样\"中间人\"这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的\"通道\"。 --百度百科\n\n## 使用步骤\n1. 查看是否已经存在ssh秘钥\n\n\t打开git bash，输入\n\n\t\t$ cd ~/.ssh\n    \t$ ls\n如果，提示不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。\n\n\n2. 生成ssh秘钥\n\n\t\t$ ssh-keygen -t rsa -C \"your_email@example.com\"\n\n\t代码参数含义：\n\t- -t 指定密钥类型，默认是 rsa ，可以省略。\n\t- -C 设置注释文字，比如邮箱。\n\t- -f 指定密钥文件存储文件名。\n\t\n    根据提示，需要指定文件位置和密码，如果是你足够放心，其实都可以直接回车，不需要什么密码。执行完以后，可在/c/Users/you/.ssh/路径下看到刚生成的文件：id_rsa和id_rsa.pub。即公钥和私钥。\n\t\n3. 在GitHub账户中添加公钥\n\n\t- 登录你的github，头像处下拉框选择settings。\n\t- 进入设置页后点击侧边栏的`SSH and GPG keys`按钮。\n\t- 点击`New SSH key`,title可以任意填，并且将上一步骤生成的id_rsa.pub的内容复制到这里的`key`输入框中。\n\n4. 确认\n\n\t\t$ ssh -T git@github.com\n\n\t在这里我收到一个提示：\n\n\t*Warning: Permanently added the RSA host key for IP address '192.30.253.113' to the list of known hosts.*\n\t\n    直接回车，最后看到这个就说明大功告成：\n\t\n\t*Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.*\n\n## 遇到的问题 ##\n\n添加完公钥后，使用小乌龟（TortoiseGit）pull代码时报错：\n\n*no supported authentication methods aviaible(server sent:publickey)*\n\n查了一下，发现是因为TortoiseGit和Git的冲突 我们需要把TortoiseGit设置改正如下。\n\n- 右键TortoiseGit -> Settings -> Network\n- 将SSH client指向~\\Git\\usr\\bin\\ssh.exe(Git安装路径下)\n\n\n\n\n\n","slug":"使用ssh 连接gitHub","published":1,"date":"2021-12-06T06:07:06.276Z","updated":"2021-12-06T06:07:06.276Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom5003ky4v20x16ad00","content":"<h1 id=\"使用ssh连接gitHub\"><a href=\"#使用ssh连接gitHub\" class=\"headerlink\" title=\"使用ssh连接gitHub\"></a>使用ssh连接gitHub</h1><p>github每次pull/push代码时要求推送代码的用户是合法的，所以每次推送时候都要输入账号密码用以验证用户是否为合法用户，而ssh是一种安全的传输模式，可以代替用户的这一“输入账号密码”的行为来验证用户。</p>\n<p>##github的俩种操作方式</p>\n<ol>\n<li><p>https</p>\n<p> 可以随意克隆github上的项目，而不管是谁的；在pull/push的时候是需要验证用户名和密码的</p>\n</li>\n<li><p>ssh</p>\n<p> 克隆者必须是拥者或管理员，且需要先添加 SSH key ，否则无法克隆。在pull/push的时候不再是验证用户名和密码，而是通过验证ssh的方式来验证用户。</p>\n</li>\n</ol>\n<h2 id=\"ssh（安全外壳协议）\"><a href=\"#ssh（安全外壳协议）\" class=\"headerlink\" title=\"ssh（安全外壳协议）##\"></a>ssh（安全外壳协议）##</h2><p>定义：</p>\n<blockquote>\n<p>SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 –百度百科</p>\n</blockquote>\n<p>功能： </p>\n<blockquote>\n<p>传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的， 就是很容易受到“中间人”（man-in-the-middle）这种方式的攻击。所谓“中间人”的攻击方式， 就是“中间人”冒充真正的服务器接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人”一转手做了手脚之后，就会出现很严重的问题。通过使用SSH，你可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的”通道”。 –百度百科</p>\n</blockquote>\n<h2 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h2><ol>\n<li><p>查看是否已经存在ssh秘钥</p>\n<p> 打开git bash，输入</p>\n<pre><code> $ cd ~/.ssh\n $ ls\n</code></pre>\n<p>如果，提示不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>生成ssh秘钥</p>\n<pre><code> $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;\n</code></pre>\n<p> 代码参数含义：</p>\n<ul>\n<li>-t 指定密钥类型，默认是 rsa ，可以省略。</li>\n<li>-C 设置注释文字，比如邮箱。</li>\n<li>-f 指定密钥文件存储文件名。</li>\n</ul>\n<p> 根据提示，需要指定文件位置和密码，如果是你足够放心，其实都可以直接回车，不需要什么密码。执行完以后，可在/c/Users/you/.ssh/路径下看到刚生成的文件：id_rsa和id_rsa.pub。即公钥和私钥。</p>\n</li>\n<li><p>在GitHub账户中添加公钥</p>\n<ul>\n<li>登录你的github，头像处下拉框选择settings。</li>\n<li>进入设置页后点击侧边栏的<code>SSH and GPG keys</code>按钮。</li>\n<li>点击<code>New SSH key</code>,title可以任意填，并且将上一步骤生成的id_rsa.pub的内容复制到这里的<code>key</code>输入框中。</li>\n</ul>\n</li>\n<li><p>确认</p>\n<pre><code> $ ssh -T git@github.com\n</code></pre>\n<p> 在这里我收到一个提示：</p>\n<p> <em>Warning: Permanently added the RSA host key for IP address ‘192.30.253.113’ to the list of known hosts.</em></p>\n<p> 直接回车，最后看到这个就说明大功告成：</p>\n<p> <em>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</em></p>\n</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>添加完公钥后，使用小乌龟（TortoiseGit）pull代码时报错：</p>\n<p><em>no supported authentication methods aviaible(server sent:publickey)</em></p>\n<p>查了一下，发现是因为TortoiseGit和Git的冲突 我们需要把TortoiseGit设置改正如下。</p>\n<ul>\n<li>右键TortoiseGit -&gt; Settings -&gt; Network</li>\n<li>将SSH client指向~\\Git\\usr\\bin\\ssh.exe(Git安装路径下)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用ssh连接gitHub\"><a href=\"#使用ssh连接gitHub\" class=\"headerlink\" title=\"使用ssh连接gitHub\"></a>使用ssh连接gitHub</h1><p>github每次pull/push代码时要求推送代码的用户是合法的，所以每次推送时候都要输入账号密码用以验证用户是否为合法用户，而ssh是一种安全的传输模式，可以代替用户的这一“输入账号密码”的行为来验证用户。</p>\n<p>##github的俩种操作方式</p>\n<ol>\n<li><p>https</p>\n<p> 可以随意克隆github上的项目，而不管是谁的；在pull/push的时候是需要验证用户名和密码的</p>\n</li>\n<li><p>ssh</p>\n<p> 克隆者必须是拥者或管理员，且需要先添加 SSH key ，否则无法克隆。在pull/push的时候不再是验证用户名和密码，而是通过验证ssh的方式来验证用户。</p>\n</li>\n</ol>\n<h2 id=\"ssh（安全外壳协议）\"><a href=\"#ssh（安全外壳协议）\" class=\"headerlink\" title=\"ssh（安全外壳协议）##\"></a>ssh（安全外壳协议）##</h2><p>定义：</p>\n<blockquote>\n<p>SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 –百度百科</p>\n</blockquote>\n<p>功能： </p>\n<blockquote>\n<p>传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的， 就是很容易受到“中间人”（man-in-the-middle）这种方式的攻击。所谓“中间人”的攻击方式， 就是“中间人”冒充真正的服务器接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人”一转手做了手脚之后，就会出现很严重的问题。通过使用SSH，你可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的”通道”。 –百度百科</p>\n</blockquote>\n<h2 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h2><ol>\n<li><p>查看是否已经存在ssh秘钥</p>\n<p> 打开git bash，输入</p>\n<pre><code> $ cd ~/.ssh\n $ ls\n</code></pre>\n<p>如果，提示不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>生成ssh秘钥</p>\n<pre><code> $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;\n</code></pre>\n<p> 代码参数含义：</p>\n<ul>\n<li>-t 指定密钥类型，默认是 rsa ，可以省略。</li>\n<li>-C 设置注释文字，比如邮箱。</li>\n<li>-f 指定密钥文件存储文件名。</li>\n</ul>\n<p> 根据提示，需要指定文件位置和密码，如果是你足够放心，其实都可以直接回车，不需要什么密码。执行完以后，可在/c/Users/you/.ssh/路径下看到刚生成的文件：id_rsa和id_rsa.pub。即公钥和私钥。</p>\n</li>\n<li><p>在GitHub账户中添加公钥</p>\n<ul>\n<li>登录你的github，头像处下拉框选择settings。</li>\n<li>进入设置页后点击侧边栏的<code>SSH and GPG keys</code>按钮。</li>\n<li>点击<code>New SSH key</code>,title可以任意填，并且将上一步骤生成的id_rsa.pub的内容复制到这里的<code>key</code>输入框中。</li>\n</ul>\n</li>\n<li><p>确认</p>\n<pre><code> $ ssh -T git@github.com\n</code></pre>\n<p> 在这里我收到一个提示：</p>\n<p> <em>Warning: Permanently added the RSA host key for IP address ‘192.30.253.113’ to the list of known hosts.</em></p>\n<p> 直接回车，最后看到这个就说明大功告成：</p>\n<p> <em>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</em></p>\n</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>添加完公钥后，使用小乌龟（TortoiseGit）pull代码时报错：</p>\n<p><em>no supported authentication methods aviaible(server sent:publickey)</em></p>\n<p>查了一下，发现是因为TortoiseGit和Git的冲突 我们需要把TortoiseGit设置改正如下。</p>\n<ul>\n<li>右键TortoiseGit -&gt; Settings -&gt; Network</li>\n<li>将SSH client指向~\\Git\\usr\\bin\\ssh.exe(Git安装路径下)</li>\n</ul>\n"},{"title":"关于viewport","date":"2015-12-03T03:25:31.000Z","description":"响应式布局,viewport.html5","_content":"\n本文是我学习了无双的【[移动前端开发之viewport的深入理解](http://www.cnblogs.com/2050/p/3877280.html)】后，所做的学习笔记。\n\n## 1.什么是viewport？\n移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。\n\n<!-- more -->\n\n## 2.css中的px与设备物理px的关系\ncss的px并不等于物理的px。css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。这个因素在为桌面浏览器设计的网页中影响不大，但在移动设备中，就要考虑这个因素了。\n\n## 3.三个viewport概念\n+ layout viewport：浏览器默认的viewport。这个layout viewport的宽度可以通过 document.documentElement.clientWidth 来获取。\n\n+ visual viewport：浏览器可视区域的大小\n\n+ ideal viewport：能完美适配移动设备的viewport。\n\t+ 所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。\n\t+ 每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度\n\n![](/images/201511/3.jpg)\n## 4.viewport控制\n下面这段代码可以实现对浏览器viewport的控制\n\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">\n\n属性参数：\n\n+ width:设置layout viewport  的宽度，为一个正整数，或字符串\"width-device\"\n+ initial-scale:设置页面的初始缩放值，为一个数字，可以带小数。\n+ minimum-scale:允许用户的最小缩放值，为一个数字，可以带小数\n+ maximum-scale:允许用户的最大缩放值，为一个数字，可以带小数\n+ height\t设置layout viewport  的高度，这个属性对我们并不重要，很少使用\n+ user-scalable:是否允许用户进行缩放，值为\"no\"或\"yes\", no 代表不允许，yes代表允许\n\n<b style=\"color:red\">initial-scale缩放是相对于 ideal viewport来进行缩放，即width值。</b>\n\n把当前的viewport宽度设置为 ideal viewport 的宽度并兼容所有设备的写法：\n\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n 因为（initial-scale=1 ）（width=device-width）虽然都能把当前的viewport宽度变成 ideal viewport 的宽度，但（width=device-width）在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度，（initial-scale=1 ）在windows phone 上的IE 无论是竖屏还是横屏都把宽度设为竖屏时ideal viewport的宽度。<b style=\"color:red\">但当俩者同时出现时，浏览器会取它们两个中较大的那个值。</b>\n\n\n","source":"_posts/关于viewport.md","raw":"title: 关于viewport\ndate: 2015-12-03 11:25:31\ntags: [web,H5]\ndescription: 响应式布局,viewport.html5\n\n---\n\n本文是我学习了无双的【[移动前端开发之viewport的深入理解](http://www.cnblogs.com/2050/p/3877280.html)】后，所做的学习笔记。\n\n## 1.什么是viewport？\n移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。\n\n<!-- more -->\n\n## 2.css中的px与设备物理px的关系\ncss的px并不等于物理的px。css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。这个因素在为桌面浏览器设计的网页中影响不大，但在移动设备中，就要考虑这个因素了。\n\n## 3.三个viewport概念\n+ layout viewport：浏览器默认的viewport。这个layout viewport的宽度可以通过 document.documentElement.clientWidth 来获取。\n\n+ visual viewport：浏览器可视区域的大小\n\n+ ideal viewport：能完美适配移动设备的viewport。\n\t+ 所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。\n\t+ 每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度\n\n![](/images/201511/3.jpg)\n## 4.viewport控制\n下面这段代码可以实现对浏览器viewport的控制\n\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">\n\n属性参数：\n\n+ width:设置layout viewport  的宽度，为一个正整数，或字符串\"width-device\"\n+ initial-scale:设置页面的初始缩放值，为一个数字，可以带小数。\n+ minimum-scale:允许用户的最小缩放值，为一个数字，可以带小数\n+ maximum-scale:允许用户的最大缩放值，为一个数字，可以带小数\n+ height\t设置layout viewport  的高度，这个属性对我们并不重要，很少使用\n+ user-scalable:是否允许用户进行缩放，值为\"no\"或\"yes\", no 代表不允许，yes代表允许\n\n<b style=\"color:red\">initial-scale缩放是相对于 ideal viewport来进行缩放，即width值。</b>\n\n把当前的viewport宽度设置为 ideal viewport 的宽度并兼容所有设备的写法：\n\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n 因为（initial-scale=1 ）（width=device-width）虽然都能把当前的viewport宽度变成 ideal viewport 的宽度，但（width=device-width）在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度，（initial-scale=1 ）在windows phone 上的IE 无论是竖屏还是横屏都把宽度设为竖屏时ideal viewport的宽度。<b style=\"color:red\">但当俩者同时出现时，浏览器会取它们两个中较大的那个值。</b>\n\n\n","slug":"关于viewport","published":1,"updated":"2021-12-06T06:07:06.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom6003ly4v20wjngnzk","content":"<p>本文是我学习了无双的【<a href=\"http://www.cnblogs.com/2050/p/3877280.html\">移动前端开发之viewport的深入理解</a>】后，所做的学习笔记。</p>\n<h2 id=\"1-什么是viewport？\"><a href=\"#1-什么是viewport？\" class=\"headerlink\" title=\"1.什么是viewport？\"></a>1.什么是viewport？</h2><p>移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"2-css中的px与设备物理px的关系\"><a href=\"#2-css中的px与设备物理px的关系\" class=\"headerlink\" title=\"2.css中的px与设备物理px的关系\"></a>2.css中的px与设备物理px的关系</h2><p>css的px并不等于物理的px。css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。这个因素在为桌面浏览器设计的网页中影响不大，但在移动设备中，就要考虑这个因素了。</p>\n<h2 id=\"3-三个viewport概念\"><a href=\"#3-三个viewport概念\" class=\"headerlink\" title=\"3.三个viewport概念\"></a>3.三个viewport概念</h2><ul>\n<li><p>layout viewport：浏览器默认的viewport。这个layout viewport的宽度可以通过 document.documentElement.clientWidth 来获取。</p>\n</li>\n<li><p>visual viewport：浏览器可视区域的大小</p>\n</li>\n<li><p>ideal viewport：能完美适配移动设备的viewport。</p>\n<ul>\n<li>所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。</li>\n<li>每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/images/201511/3.jpg\"></p>\n<h2 id=\"4-viewport控制\"><a href=\"#4-viewport控制\" class=\"headerlink\" title=\"4.viewport控制\"></a>4.viewport控制</h2><p>下面这段代码可以实现对浏览器viewport的控制</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;\n</code></pre>\n<p>属性参数：</p>\n<ul>\n<li>width:设置layout viewport  的宽度，为一个正整数，或字符串”width-device”</li>\n<li>initial-scale:设置页面的初始缩放值，为一个数字，可以带小数。</li>\n<li>minimum-scale:允许用户的最小缩放值，为一个数字，可以带小数</li>\n<li>maximum-scale:允许用户的最大缩放值，为一个数字，可以带小数</li>\n<li>height    设置layout viewport  的高度，这个属性对我们并不重要，很少使用</li>\n<li>user-scalable:是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许</li>\n</ul>\n<p><b style=\"color:red\">initial-scale缩放是相对于 ideal viewport来进行缩放，即width值。</b></p>\n<p>把当前的viewport宽度设置为 ideal viewport 的宽度并兼容所有设备的写法：</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n</code></pre>\n<p> 因为（initial-scale=1 ）（width=device-width）虽然都能把当前的viewport宽度变成 ideal viewport 的宽度，但（width=device-width）在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度，（initial-scale=1 ）在windows phone 上的IE 无论是竖屏还是横屏都把宽度设为竖屏时ideal viewport的宽度。<b style=\"color:red\">但当俩者同时出现时，浏览器会取它们两个中较大的那个值。</b></p>\n","site":{"data":{}},"excerpt":"<p>本文是我学习了无双的【<a href=\"http://www.cnblogs.com/2050/p/3877280.html\">移动前端开发之viewport的深入理解</a>】后，所做的学习笔记。</p>\n<h2 id=\"1-什么是viewport？\"><a href=\"#1-什么是viewport？\" class=\"headerlink\" title=\"1.什么是viewport？\"></a>1.什么是viewport？</h2><p>移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。</p>","more":"<h2 id=\"2-css中的px与设备物理px的关系\"><a href=\"#2-css中的px与设备物理px的关系\" class=\"headerlink\" title=\"2.css中的px与设备物理px的关系\"></a>2.css中的px与设备物理px的关系</h2><p>css的px并不等于物理的px。css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。这个因素在为桌面浏览器设计的网页中影响不大，但在移动设备中，就要考虑这个因素了。</p>\n<h2 id=\"3-三个viewport概念\"><a href=\"#3-三个viewport概念\" class=\"headerlink\" title=\"3.三个viewport概念\"></a>3.三个viewport概念</h2><ul>\n<li><p>layout viewport：浏览器默认的viewport。这个layout viewport的宽度可以通过 document.documentElement.clientWidth 来获取。</p>\n</li>\n<li><p>visual viewport：浏览器可视区域的大小</p>\n</li>\n<li><p>ideal viewport：能完美适配移动设备的viewport。</p>\n<ul>\n<li>所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。</li>\n<li>每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/images/201511/3.jpg\"></p>\n<h2 id=\"4-viewport控制\"><a href=\"#4-viewport控制\" class=\"headerlink\" title=\"4.viewport控制\"></a>4.viewport控制</h2><p>下面这段代码可以实现对浏览器viewport的控制</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;\n</code></pre>\n<p>属性参数：</p>\n<ul>\n<li>width:设置layout viewport  的宽度，为一个正整数，或字符串”width-device”</li>\n<li>initial-scale:设置页面的初始缩放值，为一个数字，可以带小数。</li>\n<li>minimum-scale:允许用户的最小缩放值，为一个数字，可以带小数</li>\n<li>maximum-scale:允许用户的最大缩放值，为一个数字，可以带小数</li>\n<li>height    设置layout viewport  的高度，这个属性对我们并不重要，很少使用</li>\n<li>user-scalable:是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许</li>\n</ul>\n<p><b style=\"color:red\">initial-scale缩放是相对于 ideal viewport来进行缩放，即width值。</b></p>\n<p>把当前的viewport宽度设置为 ideal viewport 的宽度并兼容所有设备的写法：</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n</code></pre>\n<p> 因为（initial-scale=1 ）（width=device-width）虽然都能把当前的viewport宽度变成 ideal viewport 的宽度，但（width=device-width）在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度，（initial-scale=1 ）在windows phone 上的IE 无论是竖屏还是横屏都把宽度设为竖屏时ideal viewport的宽度。<b style=\"color:red\">但当俩者同时出现时，浏览器会取它们两个中较大的那个值。</b></p>"},{"title":"使用sublimeText至今我所遇到的问题及解决方法","date":"2015-05-04T14:13:01.000Z","description":"sublimeText","_content":"\n### 1.汉化：\n下载汉化包 、打开程序Preference下的浏览包文件夹、将解压的程序包粘贴进包文件夹\n\n### 2.破解：标题栏上面有带（unregistered）表示还没有注册；\n打开HELP→Enter license粘贴如下代码:\n版本2：\n<!-- more -->\n\n\t----- BEGIN LICENSE ----- \n\tAndrew Weber \n\tSingle User License \n\tEA7E-855605 \n\t813A03DD 5E4AD9E6 6C0EEB94 BC99798F \n\t942194A6 02396E98 E62C9979 4BB979FE \n\t91424C9D A45400BF F6747D88 2FB88078 \n\t90F5CC94 1CDC92DC 8457107A F151657B \n\t1D22E383 A997F016 42397640 33F41CFC \n\tE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D \n\t5CDB7036 E56DE1C0 EFCC0840 650CD3A6 \n\tB98FC99C 8FAC73EE D2B95564 DF450523 \n\t------ END LICENSE ------\n\n版本3：\n\n\t—– BEGIN LICENSE —–\n\tAndrew Weber\n\tSingle User License\n\tEA7E-855605\n\t813A03DD 5E4AD9E6 6C0EEB94 BC99798F\n\t942194A6 02396E98 E62C9979 4BB979FE\n\t91424C9D A45400BF F6747D88 2FB88078\n\t90F5CC94 1CDC92DC 8457107A F151657B\n\t1D22E383 A997F016 42397640 33F41CFC\n\tE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D\n\t5CDB7036 E56DE1C0 EFCC0840 650CD3A6\n\tB98FC99C 8FAC73EE D2B95564 DF450523\n\t—— END LICENSE ——\n\n\n### 3.安装包控制器(这个安装成功后就可以通过Preference-package control-Install package安装插件了)\n首先按Ctrl+~打开控制台，输入以下代码：\n版本2：\n\n\timport urllib2,os; pf='Package Control.sublime-package'; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()); print('Please restart Sublime Text to finish installation')\n\n版本3：\n\n\timport urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())\n\n### 4.显示无法启动此程序，因为计算机丢失php_mbstring.dll：\n\n修改php.ini配置。去掉“;extension=php_mbstring.dll”和“;extension=php_exif.dll”前的分号，并保证php_mbstring.dll在php_exif.dll之前加载，因为加载php_exif.dll需要用到php_mbstring.dll。然后保存php.ini，并重启web服务器。\n\n\n### 5.弹出错误信息：\nA plugin (SublimeCodeIntel) may be making Sublime Text unresponsive by taking too long (0.020000s) in its on_modified callback.\n\nThis message can be disabled via the detect_slow_plugins setting\n\n\n解决方法：打开preference->setting_user\n添加\n“detect_slow_plugins”: false\n这样以后就不会弹出类似提示了\n\n\n### 6.弹出错误信息：\nError trying to parse settings: No data in ~/Library/Application Support/Sublime Text 2/Packages/User/JavaScript.sublime-settings:1:1\n\n\nStack Overflow的回答是：Most likely you or something has created an empty file in your User config directory.\n\nThe config files must be valid JSON. The file in the question is empty and is not JSON.\n\nTry deleting the file or get a fixed version from somewhere (not sure for what the file is being used for)\n\n最有可能你或者在您的用户配置目录中创建一个空文件。\n\n配置文件必须是有效的JSON。 问题文件是空的,不是JSON。\n\n试着从某个地方删除文件或得到一个固定的版本\n\n---\n\n<p style=\"text-align:right\">整理于2015-11-27 16:28:24</p>","source":"_posts/使用sublimeText至今我所遇到的问题及解决方法.md","raw":"title: 使用sublimeText至今我所遇到的问题及解决方法\ndate: 2015-05-04 22:13:01\ntags: [web,工具]\ndescription: sublimeText\n\n---\n\n### 1.汉化：\n下载汉化包 、打开程序Preference下的浏览包文件夹、将解压的程序包粘贴进包文件夹\n\n### 2.破解：标题栏上面有带（unregistered）表示还没有注册；\n打开HELP→Enter license粘贴如下代码:\n版本2：\n<!-- more -->\n\n\t----- BEGIN LICENSE ----- \n\tAndrew Weber \n\tSingle User License \n\tEA7E-855605 \n\t813A03DD 5E4AD9E6 6C0EEB94 BC99798F \n\t942194A6 02396E98 E62C9979 4BB979FE \n\t91424C9D A45400BF F6747D88 2FB88078 \n\t90F5CC94 1CDC92DC 8457107A F151657B \n\t1D22E383 A997F016 42397640 33F41CFC \n\tE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D \n\t5CDB7036 E56DE1C0 EFCC0840 650CD3A6 \n\tB98FC99C 8FAC73EE D2B95564 DF450523 \n\t------ END LICENSE ------\n\n版本3：\n\n\t—– BEGIN LICENSE —–\n\tAndrew Weber\n\tSingle User License\n\tEA7E-855605\n\t813A03DD 5E4AD9E6 6C0EEB94 BC99798F\n\t942194A6 02396E98 E62C9979 4BB979FE\n\t91424C9D A45400BF F6747D88 2FB88078\n\t90F5CC94 1CDC92DC 8457107A F151657B\n\t1D22E383 A997F016 42397640 33F41CFC\n\tE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D\n\t5CDB7036 E56DE1C0 EFCC0840 650CD3A6\n\tB98FC99C 8FAC73EE D2B95564 DF450523\n\t—— END LICENSE ——\n\n\n### 3.安装包控制器(这个安装成功后就可以通过Preference-package control-Install package安装插件了)\n首先按Ctrl+~打开控制台，输入以下代码：\n版本2：\n\n\timport urllib2,os; pf='Package Control.sublime-package'; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()); print('Please restart Sublime Text to finish installation')\n\n版本3：\n\n\timport urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())\n\n### 4.显示无法启动此程序，因为计算机丢失php_mbstring.dll：\n\n修改php.ini配置。去掉“;extension=php_mbstring.dll”和“;extension=php_exif.dll”前的分号，并保证php_mbstring.dll在php_exif.dll之前加载，因为加载php_exif.dll需要用到php_mbstring.dll。然后保存php.ini，并重启web服务器。\n\n\n### 5.弹出错误信息：\nA plugin (SublimeCodeIntel) may be making Sublime Text unresponsive by taking too long (0.020000s) in its on_modified callback.\n\nThis message can be disabled via the detect_slow_plugins setting\n\n\n解决方法：打开preference->setting_user\n添加\n“detect_slow_plugins”: false\n这样以后就不会弹出类似提示了\n\n\n### 6.弹出错误信息：\nError trying to parse settings: No data in ~/Library/Application Support/Sublime Text 2/Packages/User/JavaScript.sublime-settings:1:1\n\n\nStack Overflow的回答是：Most likely you or something has created an empty file in your User config directory.\n\nThe config files must be valid JSON. The file in the question is empty and is not JSON.\n\nTry deleting the file or get a fixed version from somewhere (not sure for what the file is being used for)\n\n最有可能你或者在您的用户配置目录中创建一个空文件。\n\n配置文件必须是有效的JSON。 问题文件是空的,不是JSON。\n\n试着从某个地方删除文件或得到一个固定的版本\n\n---\n\n<p style=\"text-align:right\">整理于2015-11-27 16:28:24</p>","slug":"使用sublimeText至今我所遇到的问题及解决方法","published":1,"updated":"2021-12-06T06:07:06.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom6003my4v28azncick","content":"<h3 id=\"1-汉化：\"><a href=\"#1-汉化：\" class=\"headerlink\" title=\"1.汉化：\"></a>1.汉化：</h3><p>下载汉化包 、打开程序Preference下的浏览包文件夹、将解压的程序包粘贴进包文件夹</p>\n<h3 id=\"2-破解：标题栏上面有带（unregistered）表示还没有注册；\"><a href=\"#2-破解：标题栏上面有带（unregistered）表示还没有注册；\" class=\"headerlink\" title=\"2.破解：标题栏上面有带（unregistered）表示还没有注册；\"></a>2.破解：标题栏上面有带（unregistered）表示还没有注册；</h3><p>打开HELP→Enter license粘贴如下代码:<br>版本2：</p>\n<span id=\"more\"></span>\n\n<pre><code>----- BEGIN LICENSE ----- \nAndrew Weber \nSingle User License \nEA7E-855605 \n813A03DD 5E4AD9E6 6C0EEB94 BC99798F \n942194A6 02396E98 E62C9979 4BB979FE \n91424C9D A45400BF F6747D88 2FB88078 \n90F5CC94 1CDC92DC 8457107A F151657B \n1D22E383 A997F016 42397640 33F41CFC \nE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D \n5CDB7036 E56DE1C0 EFCC0840 650CD3A6 \nB98FC99C 8FAC73EE D2B95564 DF450523 \n------ END LICENSE ------\n</code></pre>\n<p>版本3：</p>\n<pre><code>—– BEGIN LICENSE —–\nAndrew Weber\nSingle User License\nEA7E-855605\n813A03DD 5E4AD9E6 6C0EEB94 BC99798F\n942194A6 02396E98 E62C9979 4BB979FE\n91424C9D A45400BF F6747D88 2FB88078\n90F5CC94 1CDC92DC 8457107A F151657B\n1D22E383 A997F016 42397640 33F41CFC\nE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D\n5CDB7036 E56DE1C0 EFCC0840 650CD3A6\nB98FC99C 8FAC73EE D2B95564 DF450523\n—— END LICENSE ——\n</code></pre>\n<h3 id=\"3-安装包控制器-这个安装成功后就可以通过Preference-package-control-Install-package安装插件了\"><a href=\"#3-安装包控制器-这个安装成功后就可以通过Preference-package-control-Install-package安装插件了\" class=\"headerlink\" title=\"3.安装包控制器(这个安装成功后就可以通过Preference-package control-Install package安装插件了)\"></a>3.安装包控制器(这个安装成功后就可以通过Preference-package control-Install package安装插件了)</h3><p>首先按Ctrl+~打开控制台，输入以下代码：<br>版本2：</p>\n<pre><code>import urllib2,os; pf=&#39;Package Control.sublime-package&#39;; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),&#39;wb&#39;).write(urllib2.urlopen(&#39;http://sublime.wbond.net/&#39;+pf.replace(&#39; &#39;,&#39;%20&#39;)).read()); print(&#39;Please restart Sublime Text to finish installation&#39;)\n</code></pre>\n<p>版本3：</p>\n<pre><code>import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read())\n</code></pre>\n<h3 id=\"4-显示无法启动此程序，因为计算机丢失php-mbstring-dll：\"><a href=\"#4-显示无法启动此程序，因为计算机丢失php-mbstring-dll：\" class=\"headerlink\" title=\"4.显示无法启动此程序，因为计算机丢失php_mbstring.dll：\"></a>4.显示无法启动此程序，因为计算机丢失php_mbstring.dll：</h3><p>修改php.ini配置。去掉“;extension=php_mbstring.dll”和“;extension=php_exif.dll”前的分号，并保证php_mbstring.dll在php_exif.dll之前加载，因为加载php_exif.dll需要用到php_mbstring.dll。然后保存php.ini，并重启web服务器。</p>\n<h3 id=\"5-弹出错误信息：\"><a href=\"#5-弹出错误信息：\" class=\"headerlink\" title=\"5.弹出错误信息：\"></a>5.弹出错误信息：</h3><p>A plugin (SublimeCodeIntel) may be making Sublime Text unresponsive by taking too long (0.020000s) in its on_modified callback.</p>\n<p>This message can be disabled via the detect_slow_plugins setting</p>\n<p>解决方法：打开preference-&gt;setting_user<br>添加<br>“detect_slow_plugins”: false<br>这样以后就不会弹出类似提示了</p>\n<h3 id=\"6-弹出错误信息：\"><a href=\"#6-弹出错误信息：\" class=\"headerlink\" title=\"6.弹出错误信息：\"></a>6.弹出错误信息：</h3><p>Error trying to parse settings: No data in ~/Library/Application Support/Sublime Text 2/Packages/User/JavaScript.sublime-settings:1:1</p>\n<p>Stack Overflow的回答是：Most likely you or something has created an empty file in your User config directory.</p>\n<p>The config files must be valid JSON. The file in the question is empty and is not JSON.</p>\n<p>Try deleting the file or get a fixed version from somewhere (not sure for what the file is being used for)</p>\n<p>最有可能你或者在您的用户配置目录中创建一个空文件。</p>\n<p>配置文件必须是有效的JSON。 问题文件是空的,不是JSON。</p>\n<p>试着从某个地方删除文件或得到一个固定的版本</p>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-27 16:28:24</p>","site":{"data":{}},"excerpt":"<h3 id=\"1-汉化：\"><a href=\"#1-汉化：\" class=\"headerlink\" title=\"1.汉化：\"></a>1.汉化：</h3><p>下载汉化包 、打开程序Preference下的浏览包文件夹、将解压的程序包粘贴进包文件夹</p>\n<h3 id=\"2-破解：标题栏上面有带（unregistered）表示还没有注册；\"><a href=\"#2-破解：标题栏上面有带（unregistered）表示还没有注册；\" class=\"headerlink\" title=\"2.破解：标题栏上面有带（unregistered）表示还没有注册；\"></a>2.破解：标题栏上面有带（unregistered）表示还没有注册；</h3><p>打开HELP→Enter license粘贴如下代码:<br>版本2：</p>","more":"<pre><code>----- BEGIN LICENSE ----- \nAndrew Weber \nSingle User License \nEA7E-855605 \n813A03DD 5E4AD9E6 6C0EEB94 BC99798F \n942194A6 02396E98 E62C9979 4BB979FE \n91424C9D A45400BF F6747D88 2FB88078 \n90F5CC94 1CDC92DC 8457107A F151657B \n1D22E383 A997F016 42397640 33F41CFC \nE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D \n5CDB7036 E56DE1C0 EFCC0840 650CD3A6 \nB98FC99C 8FAC73EE D2B95564 DF450523 \n------ END LICENSE ------\n</code></pre>\n<p>版本3：</p>\n<pre><code>—– BEGIN LICENSE —–\nAndrew Weber\nSingle User License\nEA7E-855605\n813A03DD 5E4AD9E6 6C0EEB94 BC99798F\n942194A6 02396E98 E62C9979 4BB979FE\n91424C9D A45400BF F6747D88 2FB88078\n90F5CC94 1CDC92DC 8457107A F151657B\n1D22E383 A997F016 42397640 33F41CFC\nE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D\n5CDB7036 E56DE1C0 EFCC0840 650CD3A6\nB98FC99C 8FAC73EE D2B95564 DF450523\n—— END LICENSE ——\n</code></pre>\n<h3 id=\"3-安装包控制器-这个安装成功后就可以通过Preference-package-control-Install-package安装插件了\"><a href=\"#3-安装包控制器-这个安装成功后就可以通过Preference-package-control-Install-package安装插件了\" class=\"headerlink\" title=\"3.安装包控制器(这个安装成功后就可以通过Preference-package control-Install package安装插件了)\"></a>3.安装包控制器(这个安装成功后就可以通过Preference-package control-Install package安装插件了)</h3><p>首先按Ctrl+~打开控制台，输入以下代码：<br>版本2：</p>\n<pre><code>import urllib2,os; pf=&#39;Package Control.sublime-package&#39;; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),&#39;wb&#39;).write(urllib2.urlopen(&#39;http://sublime.wbond.net/&#39;+pf.replace(&#39; &#39;,&#39;%20&#39;)).read()); print(&#39;Please restart Sublime Text to finish installation&#39;)\n</code></pre>\n<p>版本3：</p>\n<pre><code>import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read())\n</code></pre>\n<h3 id=\"4-显示无法启动此程序，因为计算机丢失php-mbstring-dll：\"><a href=\"#4-显示无法启动此程序，因为计算机丢失php-mbstring-dll：\" class=\"headerlink\" title=\"4.显示无法启动此程序，因为计算机丢失php_mbstring.dll：\"></a>4.显示无法启动此程序，因为计算机丢失php_mbstring.dll：</h3><p>修改php.ini配置。去掉“;extension=php_mbstring.dll”和“;extension=php_exif.dll”前的分号，并保证php_mbstring.dll在php_exif.dll之前加载，因为加载php_exif.dll需要用到php_mbstring.dll。然后保存php.ini，并重启web服务器。</p>\n<h3 id=\"5-弹出错误信息：\"><a href=\"#5-弹出错误信息：\" class=\"headerlink\" title=\"5.弹出错误信息：\"></a>5.弹出错误信息：</h3><p>A plugin (SublimeCodeIntel) may be making Sublime Text unresponsive by taking too long (0.020000s) in its on_modified callback.</p>\n<p>This message can be disabled via the detect_slow_plugins setting</p>\n<p>解决方法：打开preference-&gt;setting_user<br>添加<br>“detect_slow_plugins”: false<br>这样以后就不会弹出类似提示了</p>\n<h3 id=\"6-弹出错误信息：\"><a href=\"#6-弹出错误信息：\" class=\"headerlink\" title=\"6.弹出错误信息：\"></a>6.弹出错误信息：</h3><p>Error trying to parse settings: No data in ~/Library/Application Support/Sublime Text 2/Packages/User/JavaScript.sublime-settings:1:1</p>\n<p>Stack Overflow的回答是：Most likely you or something has created an empty file in your User config directory.</p>\n<p>The config files must be valid JSON. The file in the question is empty and is not JSON.</p>\n<p>Try deleting the file or get a fixed version from somewhere (not sure for what the file is being used for)</p>\n<p>最有可能你或者在您的用户配置目录中创建一个空文件。</p>\n<p>配置文件必须是有效的JSON。 问题文件是空的,不是JSON。</p>\n<p>试着从某个地方删除文件或得到一个固定的版本</p>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-27 16:28:24</p>"},{"_content":"# 函数节流 & 函数防抖\n\n函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。它们都是通过减少操作的多次触发，从而达到优化性能的目的。\n\n## 函数节流\n\n节流简单理解就是通过调整水龙头将水以一个更小的频率从水龙头流出。同理，在这里，函数节流就是指让函数以一个固定的周期执行。\n\n基本思想： 函数每隔一段时间周期执行一次。\n\n\n```js\n/**\n * throttle\n * @param {*} fn 待执行的函数\n * @param {*} duration 执行周期，单位ms,即每一duration内执行一次\n */\nfunction throttle(fn, duration) {\n    var last = 0;\n    return () => {\n        var now = new Date().getTime(),\n            context = this,\n            args = arguments;\n        if (now - last >= cycle) {\n            fn.apply(context, args);\n            last = now;\n        }\n    };\n}\n```\n\n## 函数防抖\n\n机械按键在按下时，并非按下就接触的很好，尤其是有簧片的机械开关，会在接触的瞬间反复的开合多次。这就造成了开关的多次触发，为了解决这一问题，提出了**去抖动（debounce）**的解决方案。\n\n而函数防抖就是将**去抖动（debounce）**的这一机制运用到计算机中，指函数在特定的时间内不再被调用后执行。\n\n\n基本思想： 函数不可以在没有间断的情况下连续重复执行。\n\n\n```js\nfunction debounce(fn, delay) {\n    var timer;\n    return function() {\n        var context = this,\n            args = arguments;\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n            fn.apply(context, args);\n        }, idle);\n    };\n}\n```\n","source":"_posts/函数节流&函数防抖.md","raw":"# 函数节流 & 函数防抖\n\n函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。它们都是通过减少操作的多次触发，从而达到优化性能的目的。\n\n## 函数节流\n\n节流简单理解就是通过调整水龙头将水以一个更小的频率从水龙头流出。同理，在这里，函数节流就是指让函数以一个固定的周期执行。\n\n基本思想： 函数每隔一段时间周期执行一次。\n\n\n```js\n/**\n * throttle\n * @param {*} fn 待执行的函数\n * @param {*} duration 执行周期，单位ms,即每一duration内执行一次\n */\nfunction throttle(fn, duration) {\n    var last = 0;\n    return () => {\n        var now = new Date().getTime(),\n            context = this,\n            args = arguments;\n        if (now - last >= cycle) {\n            fn.apply(context, args);\n            last = now;\n        }\n    };\n}\n```\n\n## 函数防抖\n\n机械按键在按下时，并非按下就接触的很好，尤其是有簧片的机械开关，会在接触的瞬间反复的开合多次。这就造成了开关的多次触发，为了解决这一问题，提出了**去抖动（debounce）**的解决方案。\n\n而函数防抖就是将**去抖动（debounce）**的这一机制运用到计算机中，指函数在特定的时间内不再被调用后执行。\n\n\n基本思想： 函数不可以在没有间断的情况下连续重复执行。\n\n\n```js\nfunction debounce(fn, delay) {\n    var timer;\n    return function() {\n        var context = this,\n            args = arguments;\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n            fn.apply(context, args);\n        }, idle);\n    };\n}\n```\n","slug":"函数节流&函数防抖","published":1,"date":"2021-12-06T05:35:02.631Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom7003oy4v25pif9mqy","content":"<h1 id=\"函数节流-amp-函数防抖\"><a href=\"#函数节流-amp-函数防抖\" class=\"headerlink\" title=\"函数节流 &amp; 函数防抖\"></a>函数节流 &amp; 函数防抖</h1><p>函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。它们都是通过减少操作的多次触发，从而达到优化性能的目的。</p>\n<h2 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h2><p>节流简单理解就是通过调整水龙头将水以一个更小的频率从水龙头流出。同理，在这里，函数节流就是指让函数以一个固定的周期执行。</p>\n<p>基本思想： 函数每隔一段时间周期执行一次。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * throttle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>fn 待执行的函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>duration 执行周期，单位ms,即每一duration内执行一次</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, duration</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime(),</span><br><span class=\"line\">            context = <span class=\"built_in\">this</span>,</span><br><span class=\"line\">            args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now - last &gt;= cycle) &#123;</span><br><span class=\"line\">            fn.apply(context, args);</span><br><span class=\"line\">            last = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数防抖\"><a href=\"#函数防抖\" class=\"headerlink\" title=\"函数防抖\"></a>函数防抖</h2><p>机械按键在按下时，并非按下就接触的很好，尤其是有簧片的机械开关，会在接触的瞬间反复的开合多次。这就造成了开关的多次触发，为了解决这一问题，提出了<strong>去抖动（debounce）</strong>的解决方案。</p>\n<p>而函数防抖就是将<strong>去抖动（debounce）</strong>的这一机制运用到计算机中，指函数在特定的时间内不再被调用后执行。</p>\n<p>基本思想： 函数不可以在没有间断的情况下连续重复执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>,</span><br><span class=\"line\">            args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            fn.apply(context, args);</span><br><span class=\"line\">        &#125;, idle);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"函数节流-amp-函数防抖\"><a href=\"#函数节流-amp-函数防抖\" class=\"headerlink\" title=\"函数节流 &amp; 函数防抖\"></a>函数节流 &amp; 函数防抖</h1><p>函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。它们都是通过减少操作的多次触发，从而达到优化性能的目的。</p>\n<h2 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h2><p>节流简单理解就是通过调整水龙头将水以一个更小的频率从水龙头流出。同理，在这里，函数节流就是指让函数以一个固定的周期执行。</p>\n<p>基本思想： 函数每隔一段时间周期执行一次。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * throttle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>fn 待执行的函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>duration 执行周期，单位ms,即每一duration内执行一次</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, duration</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime(),</span><br><span class=\"line\">            context = <span class=\"built_in\">this</span>,</span><br><span class=\"line\">            args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now - last &gt;= cycle) &#123;</span><br><span class=\"line\">            fn.apply(context, args);</span><br><span class=\"line\">            last = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数防抖\"><a href=\"#函数防抖\" class=\"headerlink\" title=\"函数防抖\"></a>函数防抖</h2><p>机械按键在按下时，并非按下就接触的很好，尤其是有簧片的机械开关，会在接触的瞬间反复的开合多次。这就造成了开关的多次触发，为了解决这一问题，提出了<strong>去抖动（debounce）</strong>的解决方案。</p>\n<p>而函数防抖就是将<strong>去抖动（debounce）</strong>的这一机制运用到计算机中，指函数在特定的时间内不再被调用后执行。</p>\n<p>基本思想： 函数不可以在没有间断的情况下连续重复执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>,</span><br><span class=\"line\">            args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            fn.apply(context, args);</span><br><span class=\"line\">        &#125;, idle);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"关于居中","date":"2015-07-14T06:32:32.000Z","description":"水平居中 垂直居中","_content":"\n## 水平居中：\n\n1. text-align:center\n\n2. margin:0 auto;  <i style=\"color:red\">(必须设置父元素和元素本身的宽度)</i>\n\n\n<i style=\"color:red\">margin: 0 auto 不能居中的原因 :</i>\n<!-- more -->\n\n* 没有设置本身元素和父元素的宽度\n\n* 本身元素使用了绝对定位和浮动\n\n* 没声明DOCTYPE\n\n \n\n## 垂直居中;\n\n1.vertical-align:middle\n\n该属性适用于只有一个元素属于inline或是inline-block（table-cell也可以理解为inline-block水平）水平，其身上的vertical-align属性才会起作用。例如图片，按钮，单复选框，单行/多行文本框等HTML控件；\n\n2.line-height\n\n该属性适用于单行文本的垂直居中；多行文字的垂直居中可以使用span标签将文本包裹，然后使用vertical-align属性使其居中；\n\n3.以下是关于内容垂直居中的实用方法\n\n\t<div class=\"contain\">\n\t        <div class=\"one\">方法1：position+margin负值</div>\n\t        <div class=\"two_1\"></div>\n\t        <div class=\"two\">方法2：float+height+margin负值</div>\n\t        <div class=\"three\">方法3：position+margin;IE8-是不支持的,实现垂直水平居中</div>\n\t</div>\n\t\n\t.contain{\n            height:800px;\n            width: 800px;\n            border: 1px solid #000;\n            position: relative;\n    }\n\t.two_1{\n            height:50%;\n            margin-bottom: -150px;\n            float: left;\n    }\n\n 方法1：position+margin\n\n\t.one{\n\t        height:600px;\n\t        width: 400px;\n\t        border: 1px solid #000;\n\t        position: absolute;\n\t        top:50%;\n\t        margin-top: -300px;\n\t    }\n\n 方法2：float+height+margin\n\n\t.two{\n\t        height:300px;\n\t        width: 200px;\n\t        border: 1px solid red;\n\t        clear: both;\n\t    }\n 方法3：position+margin;IE8-不支持 \n\n\t.three{\n        width: 200px;\n        position: absolute;\n        margin: auto;\n        top:0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        height:400px;\n        border: 1px solid green;\n    }\n\n<b style=\"color:red\">注意：top:50%需要定位为absolute时才有效</b>\n\n---\n\n<p style=\"text-align:right\">整理于2015-11-27 15:36:24</p>","source":"_posts/关于居中.md","raw":"title: 关于居中\ndate: 2015-07-14 14:32:32\ntags: [web,css]\ndescription: 水平居中 垂直居中\n\n---\n\n## 水平居中：\n\n1. text-align:center\n\n2. margin:0 auto;  <i style=\"color:red\">(必须设置父元素和元素本身的宽度)</i>\n\n\n<i style=\"color:red\">margin: 0 auto 不能居中的原因 :</i>\n<!-- more -->\n\n* 没有设置本身元素和父元素的宽度\n\n* 本身元素使用了绝对定位和浮动\n\n* 没声明DOCTYPE\n\n \n\n## 垂直居中;\n\n1.vertical-align:middle\n\n该属性适用于只有一个元素属于inline或是inline-block（table-cell也可以理解为inline-block水平）水平，其身上的vertical-align属性才会起作用。例如图片，按钮，单复选框，单行/多行文本框等HTML控件；\n\n2.line-height\n\n该属性适用于单行文本的垂直居中；多行文字的垂直居中可以使用span标签将文本包裹，然后使用vertical-align属性使其居中；\n\n3.以下是关于内容垂直居中的实用方法\n\n\t<div class=\"contain\">\n\t        <div class=\"one\">方法1：position+margin负值</div>\n\t        <div class=\"two_1\"></div>\n\t        <div class=\"two\">方法2：float+height+margin负值</div>\n\t        <div class=\"three\">方法3：position+margin;IE8-是不支持的,实现垂直水平居中</div>\n\t</div>\n\t\n\t.contain{\n            height:800px;\n            width: 800px;\n            border: 1px solid #000;\n            position: relative;\n    }\n\t.two_1{\n            height:50%;\n            margin-bottom: -150px;\n            float: left;\n    }\n\n 方法1：position+margin\n\n\t.one{\n\t        height:600px;\n\t        width: 400px;\n\t        border: 1px solid #000;\n\t        position: absolute;\n\t        top:50%;\n\t        margin-top: -300px;\n\t    }\n\n 方法2：float+height+margin\n\n\t.two{\n\t        height:300px;\n\t        width: 200px;\n\t        border: 1px solid red;\n\t        clear: both;\n\t    }\n 方法3：position+margin;IE8-不支持 \n\n\t.three{\n        width: 200px;\n        position: absolute;\n        margin: auto;\n        top:0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        height:400px;\n        border: 1px solid green;\n    }\n\n<b style=\"color:red\">注意：top:50%需要定位为absolute时才有效</b>\n\n---\n\n<p style=\"text-align:right\">整理于2015-11-27 15:36:24</p>","slug":"关于居中","published":1,"updated":"2021-12-06T06:07:06.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom8003qy4v28oiubzkg","content":"<h2 id=\"水平居中：\"><a href=\"#水平居中：\" class=\"headerlink\" title=\"水平居中：\"></a>水平居中：</h2><ol>\n<li><p>text-align:center</p>\n</li>\n<li><p>margin:0 auto;  <i style=\"color:red\">(必须设置父元素和元素本身的宽度)</i></p>\n</li>\n</ol>\n<p><i style=\"color:red\">margin: 0 auto 不能居中的原因 :</i></p>\n<span id=\"more\"></span>\n\n<ul>\n<li><p>没有设置本身元素和父元素的宽度</p>\n</li>\n<li><p>本身元素使用了绝对定位和浮动</p>\n</li>\n<li><p>没声明DOCTYPE</p>\n</li>\n</ul>\n<h2 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中;\"></a>垂直居中;</h2><p>1.vertical-align:middle</p>\n<p>该属性适用于只有一个元素属于inline或是inline-block（table-cell也可以理解为inline-block水平）水平，其身上的vertical-align属性才会起作用。例如图片，按钮，单复选框，单行/多行文本框等HTML控件；</p>\n<p>2.line-height</p>\n<p>该属性适用于单行文本的垂直居中；多行文字的垂直居中可以使用span标签将文本包裹，然后使用vertical-align属性使其居中；</p>\n<p>3.以下是关于内容垂直居中的实用方法</p>\n<pre><code>&lt;div class=&quot;contain&quot;&gt;\n        &lt;div class=&quot;one&quot;&gt;方法1：position+margin负值&lt;/div&gt;\n        &lt;div class=&quot;two_1&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;two&quot;&gt;方法2：float+height+margin负值&lt;/div&gt;\n        &lt;div class=&quot;three&quot;&gt;方法3：position+margin;IE8-是不支持的,实现垂直水平居中&lt;/div&gt;\n&lt;/div&gt;\n\n.contain&#123;\n        height:800px;\n        width: 800px;\n        border: 1px solid #000;\n        position: relative;\n&#125;\n.two_1&#123;\n        height:50%;\n        margin-bottom: -150px;\n        float: left;\n&#125;\n</code></pre>\n<p> 方法1：position+margin</p>\n<pre><code>.one&#123;\n        height:600px;\n        width: 400px;\n        border: 1px solid #000;\n        position: absolute;\n        top:50%;\n        margin-top: -300px;\n    &#125;\n</code></pre>\n<p> 方法2：float+height+margin</p>\n<pre><code>.two&#123;\n        height:300px;\n        width: 200px;\n        border: 1px solid red;\n        clear: both;\n    &#125;\n</code></pre>\n<p> 方法3：position+margin;IE8-不支持 </p>\n<pre><code>.three&#123;\n    width: 200px;\n    position: absolute;\n    margin: auto;\n    top:0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    height:400px;\n    border: 1px solid green;\n&#125;\n</code></pre>\n<p><b style=\"color:red\">注意：top:50%需要定位为absolute时才有效</b></p>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-27 15:36:24</p>","site":{"data":{}},"excerpt":"<h2 id=\"水平居中：\"><a href=\"#水平居中：\" class=\"headerlink\" title=\"水平居中：\"></a>水平居中：</h2><ol>\n<li><p>text-align:center</p>\n</li>\n<li><p>margin:0 auto;  <i style=\"color:red\">(必须设置父元素和元素本身的宽度)</i></p>\n</li>\n</ol>\n<p><i style=\"color:red\">margin: 0 auto 不能居中的原因 :</i></p>","more":"<ul>\n<li><p>没有设置本身元素和父元素的宽度</p>\n</li>\n<li><p>本身元素使用了绝对定位和浮动</p>\n</li>\n<li><p>没声明DOCTYPE</p>\n</li>\n</ul>\n<h2 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中;\"></a>垂直居中;</h2><p>1.vertical-align:middle</p>\n<p>该属性适用于只有一个元素属于inline或是inline-block（table-cell也可以理解为inline-block水平）水平，其身上的vertical-align属性才会起作用。例如图片，按钮，单复选框，单行/多行文本框等HTML控件；</p>\n<p>2.line-height</p>\n<p>该属性适用于单行文本的垂直居中；多行文字的垂直居中可以使用span标签将文本包裹，然后使用vertical-align属性使其居中；</p>\n<p>3.以下是关于内容垂直居中的实用方法</p>\n<pre><code>&lt;div class=&quot;contain&quot;&gt;\n        &lt;div class=&quot;one&quot;&gt;方法1：position+margin负值&lt;/div&gt;\n        &lt;div class=&quot;two_1&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;two&quot;&gt;方法2：float+height+margin负值&lt;/div&gt;\n        &lt;div class=&quot;three&quot;&gt;方法3：position+margin;IE8-是不支持的,实现垂直水平居中&lt;/div&gt;\n&lt;/div&gt;\n\n.contain&#123;\n        height:800px;\n        width: 800px;\n        border: 1px solid #000;\n        position: relative;\n&#125;\n.two_1&#123;\n        height:50%;\n        margin-bottom: -150px;\n        float: left;\n&#125;\n</code></pre>\n<p> 方法1：position+margin</p>\n<pre><code>.one&#123;\n        height:600px;\n        width: 400px;\n        border: 1px solid #000;\n        position: absolute;\n        top:50%;\n        margin-top: -300px;\n    &#125;\n</code></pre>\n<p> 方法2：float+height+margin</p>\n<pre><code>.two&#123;\n        height:300px;\n        width: 200px;\n        border: 1px solid red;\n        clear: both;\n    &#125;\n</code></pre>\n<p> 方法3：position+margin;IE8-不支持 </p>\n<pre><code>.three&#123;\n    width: 200px;\n    position: absolute;\n    margin: auto;\n    top:0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    height:400px;\n    border: 1px solid green;\n&#125;\n</code></pre>\n<p><b style=\"color:red\">注意：top:50%需要定位为absolute时才有效</b></p>\n<hr>\n<p style=\"text-align:right\">整理于2015-11-27 15:36:24</p>"},{"_content":"# 冒泡排序\n\n冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。\n\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/bubble_sort.gif)\n\n- 最坏时间复杂度\t O(n^2)\n- 最优时间复杂度\t O(n)}\n- 平均时间复杂度\tO(n^2)\n- 空间复杂度\t总共 O(n)}，需要辅助空间 O(1)\n\n冒泡排序对n个项目需要O(n^2)的比较次数，且可以原地排序。所以它对于包含大量的元素的数列排序是很**没有效率**的。\n\n## 算法步骤\n\n- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n- 针对所有的元素重复以上的步骤，除了最后一个。\n- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n每一次排序：\n- 都会把元素俩俩对比，一共会对比n-1次。\n- 都会把越小／越大的元素经由交换慢慢“浮”到数列的顶端。\n\n## 伪代码\n\n```js\nfunction bubble_sort (array) {\n    var i, j;\n    for(i from 0 to length-1){\n        for(j from 0 to length-1-i){\n            if (array[j] > array[j+1])\n               // 交换 array[j] 和 array[j + 1] 的值 \n        }\n    }\n}\n```\n\n## JS实现\n\n```js\nfunction bubble_sort(arr) {\n    let l = arr.length;\n    for(let i=0;i<l-1;i++){ // 排序n-1次\n        for(let j=0;j<l-i-1;j++){\n            if(arr[j]>arr[j+1]){\n                //进行交换\n                var bf = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = bf;\n            }\n        }\n    }\n    return arr\n}\n```","source":"_posts/冒泡排序.md","raw":"# 冒泡排序\n\n冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。\n\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/bubble_sort.gif)\n\n- 最坏时间复杂度\t O(n^2)\n- 最优时间复杂度\t O(n)}\n- 平均时间复杂度\tO(n^2)\n- 空间复杂度\t总共 O(n)}，需要辅助空间 O(1)\n\n冒泡排序对n个项目需要O(n^2)的比较次数，且可以原地排序。所以它对于包含大量的元素的数列排序是很**没有效率**的。\n\n## 算法步骤\n\n- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n- 针对所有的元素重复以上的步骤，除了最后一个。\n- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n每一次排序：\n- 都会把元素俩俩对比，一共会对比n-1次。\n- 都会把越小／越大的元素经由交换慢慢“浮”到数列的顶端。\n\n## 伪代码\n\n```js\nfunction bubble_sort (array) {\n    var i, j;\n    for(i from 0 to length-1){\n        for(j from 0 to length-1-i){\n            if (array[j] > array[j+1])\n               // 交换 array[j] 和 array[j + 1] 的值 \n        }\n    }\n}\n```\n\n## JS实现\n\n```js\nfunction bubble_sort(arr) {\n    let l = arr.length;\n    for(let i=0;i<l-1;i++){ // 排序n-1次\n        for(let j=0;j<l-i-1;j++){\n            if(arr[j]>arr[j+1]){\n                //进行交换\n                var bf = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = bf;\n            }\n        }\n    }\n    return arr\n}\n```","slug":"冒泡排序","published":1,"date":"2021-12-06T06:07:06.072Z","updated":"2021-12-06T06:07:06.072Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwom9003sy4v282nxh5ud","content":"<h1 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h1><p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/bubble_sort.gif\" alt=\"image\"></p>\n<ul>\n<li>最坏时间复杂度     O(n^2)</li>\n<li>最优时间复杂度     O(n)}</li>\n<li>平均时间复杂度    O(n^2)</li>\n<li>空间复杂度    总共 O(n)}，需要辅助空间 O(1)</li>\n</ul>\n<p>冒泡排序对n个项目需要O(n^2)的比较次数，且可以原地排序。所以它对于包含大量的元素的数列排序是很<strong>没有效率</strong>的。</p>\n<h2 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h2><ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ul>\n<p>每一次排序：</p>\n<ul>\n<li>都会把元素俩俩对比，一共会对比n-1次。</li>\n<li>都会把越小／越大的元素经由交换慢慢“浮”到数列的顶端。</li>\n</ul>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubble_sort</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i <span class=\"keyword\">from</span> <span class=\"number\">0</span> to length-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j <span class=\"keyword\">from</span> <span class=\"number\">0</span> to length-<span class=\"number\">1</span>-i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (array[j] &gt; array[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">               <span class=\"comment\">// 交换 array[j] 和 array[j + 1] 的值 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JS实现\"><a href=\"#JS实现\" class=\"headerlink\" title=\"JS实现\"></a>JS实现</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubble_sort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;l-<span class=\"number\">1</span>;i++)&#123; <span class=\"comment\">// 排序n-1次</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j=<span class=\"number\">0</span>;j&lt;l-i-<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j]&gt;arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"comment\">//进行交换</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> bf = arr[j];</span><br><span class=\"line\">                arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = bf;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h1><p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/bubble_sort.gif\" alt=\"image\"></p>\n<ul>\n<li>最坏时间复杂度     O(n^2)</li>\n<li>最优时间复杂度     O(n)}</li>\n<li>平均时间复杂度    O(n^2)</li>\n<li>空间复杂度    总共 O(n)}，需要辅助空间 O(1)</li>\n</ul>\n<p>冒泡排序对n个项目需要O(n^2)的比较次数，且可以原地排序。所以它对于包含大量的元素的数列排序是很<strong>没有效率</strong>的。</p>\n<h2 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h2><ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ul>\n<p>每一次排序：</p>\n<ul>\n<li>都会把元素俩俩对比，一共会对比n-1次。</li>\n<li>都会把越小／越大的元素经由交换慢慢“浮”到数列的顶端。</li>\n</ul>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubble_sort</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i <span class=\"keyword\">from</span> <span class=\"number\">0</span> to length-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j <span class=\"keyword\">from</span> <span class=\"number\">0</span> to length-<span class=\"number\">1</span>-i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (array[j] &gt; array[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">               <span class=\"comment\">// 交换 array[j] 和 array[j + 1] 的值 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JS实现\"><a href=\"#JS实现\" class=\"headerlink\" title=\"JS实现\"></a>JS实现</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubble_sort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;l-<span class=\"number\">1</span>;i++)&#123; <span class=\"comment\">// 排序n-1次</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j=<span class=\"number\">0</span>;j&lt;l-i-<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j]&gt;arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"comment\">//进行交换</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> bf = arr[j];</span><br><span class=\"line\">                arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = bf;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"_content":"\n## ES6 \n\n解构赋值／ 模版字符串 ／ 箭头函数 ／ 模块 ／ 扩展运算符 ／ 函数默认参数 ／ Promise／ assign\n\n## this\n1. 指向函数的调用者\n2. 没有调用者，普通模式指向window，严格模式指向undefined\n3. 箭头函数本身没有自己的this，导致内部的this就是外层代码块的this。（所以定义时就确定）\n4. call,apply,bind(ES5新增)绑定的,this指的是绑定的对象\n\n## 原型链\n\n构造函数有一个原型对象，原型对象有一个指向构造函数的指针，实例对象有一个指向原型对象的指针。\n\n实现继承：将子类的原型对象等于父类的实例对象。\n\n## 浏览器工作原理\n\n（解析HTML构建DOM树 && 解析CSS信息生成样式规则） -> 构建渲染树 ->  布局  -> 绘制\n\n1. 解析HTML过程中遇到<img>标签请求图片\n2. 构建渲染树会忽略display:none的元素 ，此时才请求css中的背景图，\n\n**⚠️**整个过程并不是逐步的，而是解析完一部分内容就构建显示一部分内容。\n\n##  数组方法\n\n1. shift()\n    删除并返回数组的第一个元素\n\n2. unshift()\n    向数组的开头添加一个或更多元素，并返回新的长度。\n\n3. pop():\n    删除并返回数组的最后一个元素\n\n4. push()\n    向数组的末尾添加一个或更多元素，并返回新的长度。\n\n5. concat()\n    连接两个或更多的数组，并返回结果。\n\n6. splice()\n    删除元素，并向数组添加新元素。\n\n7. reverse()\n    颠倒数组中元素的顺序。\n\n8. sort()\n    对数组的元素进行排序\n\n9. slice()\n    从某个已有的数组返回选定的元素\n\n10. join()\n    把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。\n\n## null和undefined的区别？\n1. typeof 区别\n2. null是一个表示\"无\"的**对象**，转为数值时为0；undefined是一个表示\"无\"的**原始值**，转为数值时为NaN。\n3. null表示\"没有对象\"，即该处不应该有值。undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。\n\n## TCP 三次握手\n[参考文献](http://www.jellythink.com/archives/705)\n\n1. 客户端发送连接请求SYN报文段；\n\n2. 服务器收到客户端的SYN报文段，并将SYN+ACK报文段发送回客户端\n\n3. 客户端收到服务器的SYN+ACK报文段，向服务器发送ACK报文段\n\n> 为什么要三次握手? 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。\n\n## TCP 四次挥手\n\n1. 主机1（可以使客户端，也可以是服务器端）向主机2发送一个FIN报文段\n\n2. 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，\n\n3. 主机2向主机1发送FIN报文段，请求关闭连接\n\n4. 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，主机2收到主机1的ACK报文段以后，就关闭连接\n\n## react组建生命周期\n\n1. 创建期\n\n    + construct( getInitState, getDefaultProps)\n    + componentWillMount\n    + render\n    + componentDidMount\n\n2. 存在期：\n\n    + componentWillReceiveProps\n    + componentShouldUpdate\n    + componentWillupdate\n    + render\n    + componentDidUpdate\n\n3. 销毁期：\n\n    + componentWillUnmount\n\n## js 内存\n\n执行上下文 －> (变量对象 | 作用域链 | this指向)\n\n变量对象 －> (arguments ｜ function声明 ｜ var声明 )\n\n## 闭包\n闭包就是能够读取其他函数内部变量的函数。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。\n\n## 跨域\n\n**同源策略（协议／域名／端口号）**\n\n1. jsonp\n\n    动态创建script标签，将（回调函数）函数名通过script的src属性传递给服务器－> 服务器接收到回调函数，将数据同函数一起发送给客户端－> 客户端执行该函数\n\n2. window.name\n    一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的\n\n3. postMessage（H5）\n    它允许程序员跨域在两个窗口/frames间发送数据信息，但不是浏览器跟服务器之间交互，而是在两个客户端之间通信。\n\n4. CORS\n    服务器发送一个响应标头`Access-Control-Allow-Origin: *`。\n\n## cookies, sessionStorage 和 localStorage \n\ncookie数据保存在客户端，session数据保存在服务器端。\n\n1. 是否在所有同源窗口中都是共享 (cookies 和 localStorage )\n2. 大小限制 （ sessionStorage 和 localStorage大 ）\n3. 是否过期  (cookies在设定时间内一直有效，sessionStorage在浏览器窗口关闭失效，localStorage永久有效)\n4. 是否自动在请求中携带(cookies)\n\n## new 操作符\n```js\nfunction Person(){\n    this.name = \"jack\"\n}\n\nvar p = new Person();\n\n// 等价于\nvar p = newAlias(Person);\n\nfunction newAlias(constructor){\n    var obj ={};  //创建一个新对象\n    obj._proto_ = constructor.prototype; //将新对象的`_proto_`指向构造函数的原型\n    Person.call(obj); //将this指向这个新对象\n    this = {} //或者\n    return obj;  // 返回这个新对象\n}\n```\n\n## 浏览器原理\n1. 渲染引擎\n2. JS引擎。\n\n\n## 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？\n\n1. 查找浏览器缓存\n2. DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求\n3. 进行HTTP协议会话\n4. 客户端发送报头(请求报头)\n5. 服务器回馈报头(响应报头)\n6. html文档开始下载\n7. 文档树建立，根据标记请求所需指定MIME类型的文件\n8. 文件显示\n\n## 单页面应用的路由实现\n1. ajax请求替换内容\n1. Hash值\n3. h5的history\n\n## 浏览器缓存｜http缓存\n\n缓存状态码： 304\n\n[参考](http://web.jobbole.com/82997/)\n\n实现思路：\n1. 服务端与客户端约定有效时间,未过期则读缓存\n    + Expires ／ Cache-Control\n    \n        Expires规定了缓存失效时间（日期格式）,Cache-Control规定了缓存有效时间（秒单位的时长格式）\n\n2. 有效时间过期后，check服务端文件是否更新，没有更新则读取缓存\n    + Last-Modified/If-Modified-Since\n\n        要配合Cache-Control使用，If-Modified-Since的日期会和服务端该文件的最后修改日期对比，如果相同，则从缓存读数据；如果不相同，则返回新文件数据，同时通过响应头更新last-Modified的值（以备下次对比）。\n\n    + ETag/If-None-Match\n\n   \t\tETag的值，是一串可以代表该文件唯一的字符串，通过在请求中发送If-None-Match选项，值即为上次请求后响应头的ETag值，该值在服务端和服务端代表该文件唯一的字符串对比（如果服务端该文件改变了，该值就会变），如果相同，则直接读取缓存，如果不相同，下载正确的数据，更新ETag值。\n\n## http 和 HTTPs 的脚本能相互加载吗\nhttp能加载HTTPs的脚本\nHTTPs不能加载http的脚本，会报“不安全”的错误\n\n## cookie作用域\n1. 当前域名或者父域名下的Cookie；\n2. 当前路径或父路径下的Cookie。\n要满足以上两个条件的Cookie才会被提交\n\n## 网站优化\n1. CDN加速\n    实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。\n2. HTTP缓存\n3.  静态资源设置多域名\n    http1.0/1.1 支持同时发多个请求，并发请求多个资源当然比一个一个的请求快，可是在同一个域名下，浏览器并发请求的数量是有限制的（chrome为6个），如果先要突破限制，就只能使用不同域名来请求资源。\n4. 开启GZip\n\n## react通信：\n1. 父元素到子元素\n    直接通过props传递。\n2. 子元素到父元素\n    子元素通过调用父元素传递过来的函数来修改父元素状态。\n3. 兄弟元素\n    上面俩者的结合，子元素通过调用父元素传递过来的函数来修改父元素状态，父元素状态修改之后，另外一个子元素的this.props会发生变化。\n\n## 客户端／服务端 清除缓存\n\n1. 客户端\n    + meta方法，设置不缓存\n        ```html\n        <META HTTP-EQUIV=\"pragma\" CONTENT=\"no-cache\"> \n        <META HTTP-EQUIV=\"Cache-Control\" CONTENT=\"no-cache, must-revalidate\"> \n        <META HTTP-EQUIV=\"expires\" CONTENT=\"0\">\n        ```\n    + ajax请求服务器最新文件，并加上请求头If-Modified-Since和Cache-Control\n    + 版本号\n\n## webview与H5之间的通信\n\n## react setState后发生了什么\n1. React 会将传入的参数对象与组件当前的状态合并；\n2. 根据新的状态构建 React 元素树，并且计算出新的树与老树的节点差异；\n3. 根据差异对界面进行最小化重渲染。\n\n\n\n## microTask(微任务) 和 macroTask(宏任务)\n\n\nmicroTask： Promise、MutationObserver、process.nextTick、Object.observe\n\n\nmacroTask： setTimeout、setInterval、setImmediate、I/O、UI渲染\n\n\n\n## 网络API\n\nXMLHttpRequest\n\nFetch\n\n\n\n\n\n## 有赞面试总结\n1. 如何创建私有作用域，及私有变量\n2. 任务队列 [Event Loop](https://juejin.im/post/59e85eebf265da430d571f89?utm_source=gold_browser_extension)\n3. this.xx在原型链中取值\n4. 实现继承\n\n\n","source":"_posts/关于求职.md","raw":"\n## ES6 \n\n解构赋值／ 模版字符串 ／ 箭头函数 ／ 模块 ／ 扩展运算符 ／ 函数默认参数 ／ Promise／ assign\n\n## this\n1. 指向函数的调用者\n2. 没有调用者，普通模式指向window，严格模式指向undefined\n3. 箭头函数本身没有自己的this，导致内部的this就是外层代码块的this。（所以定义时就确定）\n4. call,apply,bind(ES5新增)绑定的,this指的是绑定的对象\n\n## 原型链\n\n构造函数有一个原型对象，原型对象有一个指向构造函数的指针，实例对象有一个指向原型对象的指针。\n\n实现继承：将子类的原型对象等于父类的实例对象。\n\n## 浏览器工作原理\n\n（解析HTML构建DOM树 && 解析CSS信息生成样式规则） -> 构建渲染树 ->  布局  -> 绘制\n\n1. 解析HTML过程中遇到<img>标签请求图片\n2. 构建渲染树会忽略display:none的元素 ，此时才请求css中的背景图，\n\n**⚠️**整个过程并不是逐步的，而是解析完一部分内容就构建显示一部分内容。\n\n##  数组方法\n\n1. shift()\n    删除并返回数组的第一个元素\n\n2. unshift()\n    向数组的开头添加一个或更多元素，并返回新的长度。\n\n3. pop():\n    删除并返回数组的最后一个元素\n\n4. push()\n    向数组的末尾添加一个或更多元素，并返回新的长度。\n\n5. concat()\n    连接两个或更多的数组，并返回结果。\n\n6. splice()\n    删除元素，并向数组添加新元素。\n\n7. reverse()\n    颠倒数组中元素的顺序。\n\n8. sort()\n    对数组的元素进行排序\n\n9. slice()\n    从某个已有的数组返回选定的元素\n\n10. join()\n    把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。\n\n## null和undefined的区别？\n1. typeof 区别\n2. null是一个表示\"无\"的**对象**，转为数值时为0；undefined是一个表示\"无\"的**原始值**，转为数值时为NaN。\n3. null表示\"没有对象\"，即该处不应该有值。undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。\n\n## TCP 三次握手\n[参考文献](http://www.jellythink.com/archives/705)\n\n1. 客户端发送连接请求SYN报文段；\n\n2. 服务器收到客户端的SYN报文段，并将SYN+ACK报文段发送回客户端\n\n3. 客户端收到服务器的SYN+ACK报文段，向服务器发送ACK报文段\n\n> 为什么要三次握手? 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。\n\n## TCP 四次挥手\n\n1. 主机1（可以使客户端，也可以是服务器端）向主机2发送一个FIN报文段\n\n2. 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，\n\n3. 主机2向主机1发送FIN报文段，请求关闭连接\n\n4. 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，主机2收到主机1的ACK报文段以后，就关闭连接\n\n## react组建生命周期\n\n1. 创建期\n\n    + construct( getInitState, getDefaultProps)\n    + componentWillMount\n    + render\n    + componentDidMount\n\n2. 存在期：\n\n    + componentWillReceiveProps\n    + componentShouldUpdate\n    + componentWillupdate\n    + render\n    + componentDidUpdate\n\n3. 销毁期：\n\n    + componentWillUnmount\n\n## js 内存\n\n执行上下文 －> (变量对象 | 作用域链 | this指向)\n\n变量对象 －> (arguments ｜ function声明 ｜ var声明 )\n\n## 闭包\n闭包就是能够读取其他函数内部变量的函数。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。\n\n## 跨域\n\n**同源策略（协议／域名／端口号）**\n\n1. jsonp\n\n    动态创建script标签，将（回调函数）函数名通过script的src属性传递给服务器－> 服务器接收到回调函数，将数据同函数一起发送给客户端－> 客户端执行该函数\n\n2. window.name\n    一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的\n\n3. postMessage（H5）\n    它允许程序员跨域在两个窗口/frames间发送数据信息，但不是浏览器跟服务器之间交互，而是在两个客户端之间通信。\n\n4. CORS\n    服务器发送一个响应标头`Access-Control-Allow-Origin: *`。\n\n## cookies, sessionStorage 和 localStorage \n\ncookie数据保存在客户端，session数据保存在服务器端。\n\n1. 是否在所有同源窗口中都是共享 (cookies 和 localStorage )\n2. 大小限制 （ sessionStorage 和 localStorage大 ）\n3. 是否过期  (cookies在设定时间内一直有效，sessionStorage在浏览器窗口关闭失效，localStorage永久有效)\n4. 是否自动在请求中携带(cookies)\n\n## new 操作符\n```js\nfunction Person(){\n    this.name = \"jack\"\n}\n\nvar p = new Person();\n\n// 等价于\nvar p = newAlias(Person);\n\nfunction newAlias(constructor){\n    var obj ={};  //创建一个新对象\n    obj._proto_ = constructor.prototype; //将新对象的`_proto_`指向构造函数的原型\n    Person.call(obj); //将this指向这个新对象\n    this = {} //或者\n    return obj;  // 返回这个新对象\n}\n```\n\n## 浏览器原理\n1. 渲染引擎\n2. JS引擎。\n\n\n## 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？\n\n1. 查找浏览器缓存\n2. DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求\n3. 进行HTTP协议会话\n4. 客户端发送报头(请求报头)\n5. 服务器回馈报头(响应报头)\n6. html文档开始下载\n7. 文档树建立，根据标记请求所需指定MIME类型的文件\n8. 文件显示\n\n## 单页面应用的路由实现\n1. ajax请求替换内容\n1. Hash值\n3. h5的history\n\n## 浏览器缓存｜http缓存\n\n缓存状态码： 304\n\n[参考](http://web.jobbole.com/82997/)\n\n实现思路：\n1. 服务端与客户端约定有效时间,未过期则读缓存\n    + Expires ／ Cache-Control\n    \n        Expires规定了缓存失效时间（日期格式）,Cache-Control规定了缓存有效时间（秒单位的时长格式）\n\n2. 有效时间过期后，check服务端文件是否更新，没有更新则读取缓存\n    + Last-Modified/If-Modified-Since\n\n        要配合Cache-Control使用，If-Modified-Since的日期会和服务端该文件的最后修改日期对比，如果相同，则从缓存读数据；如果不相同，则返回新文件数据，同时通过响应头更新last-Modified的值（以备下次对比）。\n\n    + ETag/If-None-Match\n\n   \t\tETag的值，是一串可以代表该文件唯一的字符串，通过在请求中发送If-None-Match选项，值即为上次请求后响应头的ETag值，该值在服务端和服务端代表该文件唯一的字符串对比（如果服务端该文件改变了，该值就会变），如果相同，则直接读取缓存，如果不相同，下载正确的数据，更新ETag值。\n\n## http 和 HTTPs 的脚本能相互加载吗\nhttp能加载HTTPs的脚本\nHTTPs不能加载http的脚本，会报“不安全”的错误\n\n## cookie作用域\n1. 当前域名或者父域名下的Cookie；\n2. 当前路径或父路径下的Cookie。\n要满足以上两个条件的Cookie才会被提交\n\n## 网站优化\n1. CDN加速\n    实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。\n2. HTTP缓存\n3.  静态资源设置多域名\n    http1.0/1.1 支持同时发多个请求，并发请求多个资源当然比一个一个的请求快，可是在同一个域名下，浏览器并发请求的数量是有限制的（chrome为6个），如果先要突破限制，就只能使用不同域名来请求资源。\n4. 开启GZip\n\n## react通信：\n1. 父元素到子元素\n    直接通过props传递。\n2. 子元素到父元素\n    子元素通过调用父元素传递过来的函数来修改父元素状态。\n3. 兄弟元素\n    上面俩者的结合，子元素通过调用父元素传递过来的函数来修改父元素状态，父元素状态修改之后，另外一个子元素的this.props会发生变化。\n\n## 客户端／服务端 清除缓存\n\n1. 客户端\n    + meta方法，设置不缓存\n        ```html\n        <META HTTP-EQUIV=\"pragma\" CONTENT=\"no-cache\"> \n        <META HTTP-EQUIV=\"Cache-Control\" CONTENT=\"no-cache, must-revalidate\"> \n        <META HTTP-EQUIV=\"expires\" CONTENT=\"0\">\n        ```\n    + ajax请求服务器最新文件，并加上请求头If-Modified-Since和Cache-Control\n    + 版本号\n\n## webview与H5之间的通信\n\n## react setState后发生了什么\n1. React 会将传入的参数对象与组件当前的状态合并；\n2. 根据新的状态构建 React 元素树，并且计算出新的树与老树的节点差异；\n3. 根据差异对界面进行最小化重渲染。\n\n\n\n## microTask(微任务) 和 macroTask(宏任务)\n\n\nmicroTask： Promise、MutationObserver、process.nextTick、Object.observe\n\n\nmacroTask： setTimeout、setInterval、setImmediate、I/O、UI渲染\n\n\n\n## 网络API\n\nXMLHttpRequest\n\nFetch\n\n\n\n\n\n## 有赞面试总结\n1. 如何创建私有作用域，及私有变量\n2. 任务队列 [Event Loop](https://juejin.im/post/59e85eebf265da430d571f89?utm_source=gold_browser_extension)\n3. this.xx在原型链中取值\n4. 实现继承\n\n\n","slug":"关于求职","published":1,"date":"2021-12-06T06:07:06.286Z","updated":"2021-12-06T06:07:06.286Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoma003uy4v24dzi5lgc","content":"<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><p>解构赋值／ 模版字符串 ／ 箭头函数 ／ 模块 ／ 扩展运算符 ／ 函数默认参数 ／ Promise／ assign</p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><ol>\n<li>指向函数的调用者</li>\n<li>没有调用者，普通模式指向window，严格模式指向undefined</li>\n<li>箭头函数本身没有自己的this，导致内部的this就是外层代码块的this。（所以定义时就确定）</li>\n<li>call,apply,bind(ES5新增)绑定的,this指的是绑定的对象</li>\n</ol>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>构造函数有一个原型对象，原型对象有一个指向构造函数的指针，实例对象有一个指向原型对象的指针。</p>\n<p>实现继承：将子类的原型对象等于父类的实例对象。</p>\n<h2 id=\"浏览器工作原理\"><a href=\"#浏览器工作原理\" class=\"headerlink\" title=\"浏览器工作原理\"></a>浏览器工作原理</h2><p>（解析HTML构建DOM树 &amp;&amp; 解析CSS信息生成样式规则） -&gt; 构建渲染树 -&gt;  布局  -&gt; 绘制</p>\n<ol>\n<li>解析HTML过程中遇到<img>标签请求图片</li>\n<li>构建渲染树会忽略display:none的元素 ，此时才请求css中的背景图，</li>\n</ol>\n<p><strong>⚠️</strong>整个过程并不是逐步的，而是解析完一部分内容就构建显示一部分内容。</p>\n<h2 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h2><ol>\n<li><p>shift()<br> 删除并返回数组的第一个元素</p>\n</li>\n<li><p>unshift()<br> 向数组的开头添加一个或更多元素，并返回新的长度。</p>\n</li>\n<li><p>pop():<br> 删除并返回数组的最后一个元素</p>\n</li>\n<li><p>push()<br> 向数组的末尾添加一个或更多元素，并返回新的长度。</p>\n</li>\n<li><p>concat()<br> 连接两个或更多的数组，并返回结果。</p>\n</li>\n<li><p>splice()<br> 删除元素，并向数组添加新元素。</p>\n</li>\n<li><p>reverse()<br> 颠倒数组中元素的顺序。</p>\n</li>\n<li><p>sort()<br> 对数组的元素进行排序</p>\n</li>\n<li><p>slice()<br> 从某个已有的数组返回选定的元素</p>\n</li>\n<li><p>join()<br>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</p>\n</li>\n</ol>\n<h2 id=\"null和undefined的区别？\"><a href=\"#null和undefined的区别？\" class=\"headerlink\" title=\"null和undefined的区别？\"></a>null和undefined的区别？</h2><ol>\n<li>typeof 区别</li>\n<li>null是一个表示”无”的<strong>对象</strong>，转为数值时为0；undefined是一个表示”无”的<strong>原始值</strong>，转为数值时为NaN。</li>\n<li>null表示”没有对象”，即该处不应该有值。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</li>\n</ol>\n<h2 id=\"TCP-三次握手\"><a href=\"#TCP-三次握手\" class=\"headerlink\" title=\"TCP 三次握手\"></a>TCP 三次握手</h2><p><a href=\"http://www.jellythink.com/archives/705\">参考文献</a></p>\n<ol>\n<li><p>客户端发送连接请求SYN报文段；</p>\n</li>\n<li><p>服务器收到客户端的SYN报文段，并将SYN+ACK报文段发送回客户端</p>\n</li>\n<li><p>客户端收到服务器的SYN+ACK报文段，向服务器发送ACK报文段</p>\n</li>\n</ol>\n<blockquote>\n<p>为什么要三次握手? 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>\n</blockquote>\n<h2 id=\"TCP-四次挥手\"><a href=\"#TCP-四次挥手\" class=\"headerlink\" title=\"TCP 四次挥手\"></a>TCP 四次挥手</h2><ol>\n<li><p>主机1（可以使客户端，也可以是服务器端）向主机2发送一个FIN报文段</p>\n</li>\n<li><p>主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，</p>\n</li>\n<li><p>主机2向主机1发送FIN报文段，请求关闭连接</p>\n</li>\n<li><p>主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，主机2收到主机1的ACK报文段以后，就关闭连接</p>\n</li>\n</ol>\n<h2 id=\"react组建生命周期\"><a href=\"#react组建生命周期\" class=\"headerlink\" title=\"react组建生命周期\"></a>react组建生命周期</h2><ol>\n<li><p>创建期</p>\n<ul>\n<li>construct( getInitState, getDefaultProps)</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n</li>\n<li><p>存在期：</p>\n<ul>\n<li>componentWillReceiveProps</li>\n<li>componentShouldUpdate</li>\n<li>componentWillupdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n</li>\n<li><p>销毁期：</p>\n<ul>\n<li>componentWillUnmount</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"js-内存\"><a href=\"#js-内存\" class=\"headerlink\" title=\"js 内存\"></a>js 内存</h2><p>执行上下文 －&gt; (变量对象 | 作用域链 | this指向)</p>\n<p>变量对象 －&gt; (arguments ｜ function声明 ｜ var声明 )</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>闭包就是能够读取其他函数内部变量的函数。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。</p>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><p><strong>同源策略（协议／域名／端口号）</strong></p>\n<ol>\n<li><p>jsonp</p>\n<p> 动态创建script标签，将（回调函数）函数名通过script的src属性传递给服务器－&gt; 服务器接收到回调函数，将数据同函数一起发送给客户端－&gt; 客户端执行该函数</p>\n</li>\n<li><p>window.name<br> 一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的</p>\n</li>\n<li><p>postMessage（H5）<br> 它允许程序员跨域在两个窗口/frames间发送数据信息，但不是浏览器跟服务器之间交互，而是在两个客户端之间通信。</p>\n</li>\n<li><p>CORS<br> 服务器发送一个响应标头<code>Access-Control-Allow-Origin: *</code>。</p>\n</li>\n</ol>\n<h2 id=\"cookies-sessionStorage-和-localStorage\"><a href=\"#cookies-sessionStorage-和-localStorage\" class=\"headerlink\" title=\"cookies, sessionStorage 和 localStorage\"></a>cookies, sessionStorage 和 localStorage</h2><p>cookie数据保存在客户端，session数据保存在服务器端。</p>\n<ol>\n<li>是否在所有同源窗口中都是共享 (cookies 和 localStorage )</li>\n<li>大小限制 （ sessionStorage 和 localStorage大 ）</li>\n<li>是否过期  (cookies在设定时间内一直有效，sessionStorage在浏览器窗口关闭失效，localStorage永久有效)</li>\n<li>是否自动在请求中携带(cookies)</li>\n</ol>\n<h2 id=\"new-操作符\"><a href=\"#new-操作符\" class=\"headerlink\" title=\"new 操作符\"></a>new 操作符</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = <span class=\"string\">&quot;jack&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = newAlias(Person);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">newAlias</span>(<span class=\"params\">constructor</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj =&#123;&#125;;  <span class=\"comment\">//创建一个新对象</span></span><br><span class=\"line\">    obj._proto_ = <span class=\"title\">constructor</span>.<span class=\"title\">prototype</span>; <span class=\"comment\">//将新对象的`_proto_`指向构造函数的原型</span></span><br><span class=\"line\">    Person.call(obj); <span class=\"comment\">//将this指向这个新对象</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span> = &#123;&#125; <span class=\"comment\">//或者</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;  <span class=\"comment\">// 返回这个新对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"浏览器原理\"><a href=\"#浏览器原理\" class=\"headerlink\" title=\"浏览器原理\"></a>浏览器原理</h2><ol>\n<li>渲染引擎</li>\n<li>JS引擎。</li>\n</ol>\n<h2 id=\"一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？\"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2><ol>\n<li>查找浏览器缓存</li>\n<li>DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求</li>\n<li>进行HTTP协议会话</li>\n<li>客户端发送报头(请求报头)</li>\n<li>服务器回馈报头(响应报头)</li>\n<li>html文档开始下载</li>\n<li>文档树建立，根据标记请求所需指定MIME类型的文件</li>\n<li>文件显示</li>\n</ol>\n<h2 id=\"单页面应用的路由实现\"><a href=\"#单页面应用的路由实现\" class=\"headerlink\" title=\"单页面应用的路由实现\"></a>单页面应用的路由实现</h2><ol>\n<li>ajax请求替换内容</li>\n<li>Hash值</li>\n<li>h5的history</li>\n</ol>\n<h2 id=\"浏览器缓存｜http缓存\"><a href=\"#浏览器缓存｜http缓存\" class=\"headerlink\" title=\"浏览器缓存｜http缓存\"></a>浏览器缓存｜http缓存</h2><p>缓存状态码： 304</p>\n<p><a href=\"http://web.jobbole.com/82997/\">参考</a></p>\n<p>实现思路：</p>\n<ol>\n<li><p>服务端与客户端约定有效时间,未过期则读缓存</p>\n<ul>\n<li>Expires ／ Cache-Control  Expires规定了缓存失效时间（日期格式）,Cache-Control规定了缓存有效时间（秒单位的时长格式）</li>\n</ul>\n</li>\n<li><p>有效时间过期后，check服务端文件是否更新，没有更新则读取缓存</p>\n<ul>\n<li><p>Last-Modified/If-Modified-Since</p>\n<p>  要配合Cache-Control使用，If-Modified-Since的日期会和服务端该文件的最后修改日期对比，如果相同，则从缓存读数据；如果不相同，则返回新文件数据，同时通过响应头更新last-Modified的值（以备下次对比）。</p>\n</li>\n<li><p>ETag/If-None-Match</p>\n<pre><code> ETag的值，是一串可以代表该文件唯一的字符串，通过在请求中发送If-None-Match选项，值即为上次请求后响应头的ETag值，该值在服务端和服务端代表该文件唯一的字符串对比（如果服务端该文件改变了，该值就会变），如果相同，则直接读取缓存，如果不相同，下载正确的数据，更新ETag值。\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"http-和-HTTPs-的脚本能相互加载吗\"><a href=\"#http-和-HTTPs-的脚本能相互加载吗\" class=\"headerlink\" title=\"http 和 HTTPs 的脚本能相互加载吗\"></a>http 和 HTTPs 的脚本能相互加载吗</h2><p>http能加载HTTPs的脚本<br>HTTPs不能加载http的脚本，会报“不安全”的错误</p>\n<h2 id=\"cookie作用域\"><a href=\"#cookie作用域\" class=\"headerlink\" title=\"cookie作用域\"></a>cookie作用域</h2><ol>\n<li>当前域名或者父域名下的Cookie；</li>\n<li>当前路径或父路径下的Cookie。<br>要满足以上两个条件的Cookie才会被提交</li>\n</ol>\n<h2 id=\"网站优化\"><a href=\"#网站优化\" class=\"headerlink\" title=\"网站优化\"></a>网站优化</h2><ol>\n<li>CDN加速<br> 实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</li>\n<li>HTTP缓存</li>\n<li>静态资源设置多域名<br> http1.0/1.1 支持同时发多个请求，并发请求多个资源当然比一个一个的请求快，可是在同一个域名下，浏览器并发请求的数量是有限制的（chrome为6个），如果先要突破限制，就只能使用不同域名来请求资源。</li>\n<li>开启GZip</li>\n</ol>\n<h2 id=\"react通信：\"><a href=\"#react通信：\" class=\"headerlink\" title=\"react通信：\"></a>react通信：</h2><ol>\n<li>父元素到子元素<br> 直接通过props传递。</li>\n<li>子元素到父元素<br> 子元素通过调用父元素传递过来的函数来修改父元素状态。</li>\n<li>兄弟元素<br> 上面俩者的结合，子元素通过调用父元素传递过来的函数来修改父元素状态，父元素状态修改之后，另外一个子元素的this.props会发生变化。</li>\n</ol>\n<h2 id=\"客户端／服务端-清除缓存\"><a href=\"#客户端／服务端-清除缓存\" class=\"headerlink\" title=\"客户端／服务端 清除缓存\"></a>客户端／服务端 清除缓存</h2><ol>\n<li>客户端<ul>\n<li>meta方法，设置不缓存  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">META</span> <span class=\"attr\">HTTP-EQUIV</span>=<span class=\"string\">&quot;pragma&quot;</span> <span class=\"attr\">CONTENT</span>=<span class=\"string\">&quot;no-cache&quot;</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">META</span> <span class=\"attr\">HTTP-EQUIV</span>=<span class=\"string\">&quot;Cache-Control&quot;</span> <span class=\"attr\">CONTENT</span>=<span class=\"string\">&quot;no-cache, must-revalidate&quot;</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">META</span> <span class=\"attr\">HTTP-EQUIV</span>=<span class=\"string\">&quot;expires&quot;</span> <span class=\"attr\">CONTENT</span>=<span class=\"string\">&quot;0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>ajax请求服务器最新文件，并加上请求头If-Modified-Since和Cache-Control</li>\n<li>版本号</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"webview与H5之间的通信\"><a href=\"#webview与H5之间的通信\" class=\"headerlink\" title=\"webview与H5之间的通信\"></a>webview与H5之间的通信</h2><h2 id=\"react-setState后发生了什么\"><a href=\"#react-setState后发生了什么\" class=\"headerlink\" title=\"react setState后发生了什么\"></a>react setState后发生了什么</h2><ol>\n<li>React 会将传入的参数对象与组件当前的状态合并；</li>\n<li>根据新的状态构建 React 元素树，并且计算出新的树与老树的节点差异；</li>\n<li>根据差异对界面进行最小化重渲染。</li>\n</ol>\n<h2 id=\"microTask-微任务-和-macroTask-宏任务\"><a href=\"#microTask-微任务-和-macroTask-宏任务\" class=\"headerlink\" title=\"microTask(微任务) 和 macroTask(宏任务)\"></a>microTask(微任务) 和 macroTask(宏任务)</h2><p>microTask： Promise、MutationObserver、process.nextTick、Object.observe</p>\n<p>macroTask： setTimeout、setInterval、setImmediate、I/O、UI渲染</p>\n<h2 id=\"网络API\"><a href=\"#网络API\" class=\"headerlink\" title=\"网络API\"></a>网络API</h2><p>XMLHttpRequest</p>\n<p>Fetch</p>\n<h2 id=\"有赞面试总结\"><a href=\"#有赞面试总结\" class=\"headerlink\" title=\"有赞面试总结\"></a>有赞面试总结</h2><ol>\n<li>如何创建私有作用域，及私有变量</li>\n<li>任务队列 <a href=\"https://juejin.im/post/59e85eebf265da430d571f89?utm_source=gold_browser_extension\">Event Loop</a></li>\n<li>this.xx在原型链中取值</li>\n<li>实现继承</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><p>解构赋值／ 模版字符串 ／ 箭头函数 ／ 模块 ／ 扩展运算符 ／ 函数默认参数 ／ Promise／ assign</p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><ol>\n<li>指向函数的调用者</li>\n<li>没有调用者，普通模式指向window，严格模式指向undefined</li>\n<li>箭头函数本身没有自己的this，导致内部的this就是外层代码块的this。（所以定义时就确定）</li>\n<li>call,apply,bind(ES5新增)绑定的,this指的是绑定的对象</li>\n</ol>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>构造函数有一个原型对象，原型对象有一个指向构造函数的指针，实例对象有一个指向原型对象的指针。</p>\n<p>实现继承：将子类的原型对象等于父类的实例对象。</p>\n<h2 id=\"浏览器工作原理\"><a href=\"#浏览器工作原理\" class=\"headerlink\" title=\"浏览器工作原理\"></a>浏览器工作原理</h2><p>（解析HTML构建DOM树 &amp;&amp; 解析CSS信息生成样式规则） -&gt; 构建渲染树 -&gt;  布局  -&gt; 绘制</p>\n<ol>\n<li>解析HTML过程中遇到<img>标签请求图片</li>\n<li>构建渲染树会忽略display:none的元素 ，此时才请求css中的背景图，</li>\n</ol>\n<p><strong>⚠️</strong>整个过程并不是逐步的，而是解析完一部分内容就构建显示一部分内容。</p>\n<h2 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h2><ol>\n<li><p>shift()<br> 删除并返回数组的第一个元素</p>\n</li>\n<li><p>unshift()<br> 向数组的开头添加一个或更多元素，并返回新的长度。</p>\n</li>\n<li><p>pop():<br> 删除并返回数组的最后一个元素</p>\n</li>\n<li><p>push()<br> 向数组的末尾添加一个或更多元素，并返回新的长度。</p>\n</li>\n<li><p>concat()<br> 连接两个或更多的数组，并返回结果。</p>\n</li>\n<li><p>splice()<br> 删除元素，并向数组添加新元素。</p>\n</li>\n<li><p>reverse()<br> 颠倒数组中元素的顺序。</p>\n</li>\n<li><p>sort()<br> 对数组的元素进行排序</p>\n</li>\n<li><p>slice()<br> 从某个已有的数组返回选定的元素</p>\n</li>\n<li><p>join()<br>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</p>\n</li>\n</ol>\n<h2 id=\"null和undefined的区别？\"><a href=\"#null和undefined的区别？\" class=\"headerlink\" title=\"null和undefined的区别？\"></a>null和undefined的区别？</h2><ol>\n<li>typeof 区别</li>\n<li>null是一个表示”无”的<strong>对象</strong>，转为数值时为0；undefined是一个表示”无”的<strong>原始值</strong>，转为数值时为NaN。</li>\n<li>null表示”没有对象”，即该处不应该有值。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</li>\n</ol>\n<h2 id=\"TCP-三次握手\"><a href=\"#TCP-三次握手\" class=\"headerlink\" title=\"TCP 三次握手\"></a>TCP 三次握手</h2><p><a href=\"http://www.jellythink.com/archives/705\">参考文献</a></p>\n<ol>\n<li><p>客户端发送连接请求SYN报文段；</p>\n</li>\n<li><p>服务器收到客户端的SYN报文段，并将SYN+ACK报文段发送回客户端</p>\n</li>\n<li><p>客户端收到服务器的SYN+ACK报文段，向服务器发送ACK报文段</p>\n</li>\n</ol>\n<blockquote>\n<p>为什么要三次握手? 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>\n</blockquote>\n<h2 id=\"TCP-四次挥手\"><a href=\"#TCP-四次挥手\" class=\"headerlink\" title=\"TCP 四次挥手\"></a>TCP 四次挥手</h2><ol>\n<li><p>主机1（可以使客户端，也可以是服务器端）向主机2发送一个FIN报文段</p>\n</li>\n<li><p>主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，</p>\n</li>\n<li><p>主机2向主机1发送FIN报文段，请求关闭连接</p>\n</li>\n<li><p>主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，主机2收到主机1的ACK报文段以后，就关闭连接</p>\n</li>\n</ol>\n<h2 id=\"react组建生命周期\"><a href=\"#react组建生命周期\" class=\"headerlink\" title=\"react组建生命周期\"></a>react组建生命周期</h2><ol>\n<li><p>创建期</p>\n<ul>\n<li>construct( getInitState, getDefaultProps)</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n</li>\n<li><p>存在期：</p>\n<ul>\n<li>componentWillReceiveProps</li>\n<li>componentShouldUpdate</li>\n<li>componentWillupdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n</li>\n<li><p>销毁期：</p>\n<ul>\n<li>componentWillUnmount</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"js-内存\"><a href=\"#js-内存\" class=\"headerlink\" title=\"js 内存\"></a>js 内存</h2><p>执行上下文 －&gt; (变量对象 | 作用域链 | this指向)</p>\n<p>变量对象 －&gt; (arguments ｜ function声明 ｜ var声明 )</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>闭包就是能够读取其他函数内部变量的函数。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。</p>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><p><strong>同源策略（协议／域名／端口号）</strong></p>\n<ol>\n<li><p>jsonp</p>\n<p> 动态创建script标签，将（回调函数）函数名通过script的src属性传递给服务器－&gt; 服务器接收到回调函数，将数据同函数一起发送给客户端－&gt; 客户端执行该函数</p>\n</li>\n<li><p>window.name<br> 一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的</p>\n</li>\n<li><p>postMessage（H5）<br> 它允许程序员跨域在两个窗口/frames间发送数据信息，但不是浏览器跟服务器之间交互，而是在两个客户端之间通信。</p>\n</li>\n<li><p>CORS<br> 服务器发送一个响应标头<code>Access-Control-Allow-Origin: *</code>。</p>\n</li>\n</ol>\n<h2 id=\"cookies-sessionStorage-和-localStorage\"><a href=\"#cookies-sessionStorage-和-localStorage\" class=\"headerlink\" title=\"cookies, sessionStorage 和 localStorage\"></a>cookies, sessionStorage 和 localStorage</h2><p>cookie数据保存在客户端，session数据保存在服务器端。</p>\n<ol>\n<li>是否在所有同源窗口中都是共享 (cookies 和 localStorage )</li>\n<li>大小限制 （ sessionStorage 和 localStorage大 ）</li>\n<li>是否过期  (cookies在设定时间内一直有效，sessionStorage在浏览器窗口关闭失效，localStorage永久有效)</li>\n<li>是否自动在请求中携带(cookies)</li>\n</ol>\n<h2 id=\"new-操作符\"><a href=\"#new-操作符\" class=\"headerlink\" title=\"new 操作符\"></a>new 操作符</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = <span class=\"string\">&quot;jack&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = newAlias(Person);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">newAlias</span>(<span class=\"params\">constructor</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj =&#123;&#125;;  <span class=\"comment\">//创建一个新对象</span></span><br><span class=\"line\">    obj._proto_ = <span class=\"title\">constructor</span>.<span class=\"title\">prototype</span>; <span class=\"comment\">//将新对象的`_proto_`指向构造函数的原型</span></span><br><span class=\"line\">    Person.call(obj); <span class=\"comment\">//将this指向这个新对象</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span> = &#123;&#125; <span class=\"comment\">//或者</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;  <span class=\"comment\">// 返回这个新对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"浏览器原理\"><a href=\"#浏览器原理\" class=\"headerlink\" title=\"浏览器原理\"></a>浏览器原理</h2><ol>\n<li>渲染引擎</li>\n<li>JS引擎。</li>\n</ol>\n<h2 id=\"一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？\"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2><ol>\n<li>查找浏览器缓存</li>\n<li>DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求</li>\n<li>进行HTTP协议会话</li>\n<li>客户端发送报头(请求报头)</li>\n<li>服务器回馈报头(响应报头)</li>\n<li>html文档开始下载</li>\n<li>文档树建立，根据标记请求所需指定MIME类型的文件</li>\n<li>文件显示</li>\n</ol>\n<h2 id=\"单页面应用的路由实现\"><a href=\"#单页面应用的路由实现\" class=\"headerlink\" title=\"单页面应用的路由实现\"></a>单页面应用的路由实现</h2><ol>\n<li>ajax请求替换内容</li>\n<li>Hash值</li>\n<li>h5的history</li>\n</ol>\n<h2 id=\"浏览器缓存｜http缓存\"><a href=\"#浏览器缓存｜http缓存\" class=\"headerlink\" title=\"浏览器缓存｜http缓存\"></a>浏览器缓存｜http缓存</h2><p>缓存状态码： 304</p>\n<p><a href=\"http://web.jobbole.com/82997/\">参考</a></p>\n<p>实现思路：</p>\n<ol>\n<li><p>服务端与客户端约定有效时间,未过期则读缓存</p>\n<ul>\n<li>Expires ／ Cache-Control  Expires规定了缓存失效时间（日期格式）,Cache-Control规定了缓存有效时间（秒单位的时长格式）</li>\n</ul>\n</li>\n<li><p>有效时间过期后，check服务端文件是否更新，没有更新则读取缓存</p>\n<ul>\n<li><p>Last-Modified/If-Modified-Since</p>\n<p>  要配合Cache-Control使用，If-Modified-Since的日期会和服务端该文件的最后修改日期对比，如果相同，则从缓存读数据；如果不相同，则返回新文件数据，同时通过响应头更新last-Modified的值（以备下次对比）。</p>\n</li>\n<li><p>ETag/If-None-Match</p>\n<pre><code> ETag的值，是一串可以代表该文件唯一的字符串，通过在请求中发送If-None-Match选项，值即为上次请求后响应头的ETag值，该值在服务端和服务端代表该文件唯一的字符串对比（如果服务端该文件改变了，该值就会变），如果相同，则直接读取缓存，如果不相同，下载正确的数据，更新ETag值。\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"http-和-HTTPs-的脚本能相互加载吗\"><a href=\"#http-和-HTTPs-的脚本能相互加载吗\" class=\"headerlink\" title=\"http 和 HTTPs 的脚本能相互加载吗\"></a>http 和 HTTPs 的脚本能相互加载吗</h2><p>http能加载HTTPs的脚本<br>HTTPs不能加载http的脚本，会报“不安全”的错误</p>\n<h2 id=\"cookie作用域\"><a href=\"#cookie作用域\" class=\"headerlink\" title=\"cookie作用域\"></a>cookie作用域</h2><ol>\n<li>当前域名或者父域名下的Cookie；</li>\n<li>当前路径或父路径下的Cookie。<br>要满足以上两个条件的Cookie才会被提交</li>\n</ol>\n<h2 id=\"网站优化\"><a href=\"#网站优化\" class=\"headerlink\" title=\"网站优化\"></a>网站优化</h2><ol>\n<li>CDN加速<br> 实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</li>\n<li>HTTP缓存</li>\n<li>静态资源设置多域名<br> http1.0/1.1 支持同时发多个请求，并发请求多个资源当然比一个一个的请求快，可是在同一个域名下，浏览器并发请求的数量是有限制的（chrome为6个），如果先要突破限制，就只能使用不同域名来请求资源。</li>\n<li>开启GZip</li>\n</ol>\n<h2 id=\"react通信：\"><a href=\"#react通信：\" class=\"headerlink\" title=\"react通信：\"></a>react通信：</h2><ol>\n<li>父元素到子元素<br> 直接通过props传递。</li>\n<li>子元素到父元素<br> 子元素通过调用父元素传递过来的函数来修改父元素状态。</li>\n<li>兄弟元素<br> 上面俩者的结合，子元素通过调用父元素传递过来的函数来修改父元素状态，父元素状态修改之后，另外一个子元素的this.props会发生变化。</li>\n</ol>\n<h2 id=\"客户端／服务端-清除缓存\"><a href=\"#客户端／服务端-清除缓存\" class=\"headerlink\" title=\"客户端／服务端 清除缓存\"></a>客户端／服务端 清除缓存</h2><ol>\n<li>客户端<ul>\n<li>meta方法，设置不缓存  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">META</span> <span class=\"attr\">HTTP-EQUIV</span>=<span class=\"string\">&quot;pragma&quot;</span> <span class=\"attr\">CONTENT</span>=<span class=\"string\">&quot;no-cache&quot;</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">META</span> <span class=\"attr\">HTTP-EQUIV</span>=<span class=\"string\">&quot;Cache-Control&quot;</span> <span class=\"attr\">CONTENT</span>=<span class=\"string\">&quot;no-cache, must-revalidate&quot;</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">META</span> <span class=\"attr\">HTTP-EQUIV</span>=<span class=\"string\">&quot;expires&quot;</span> <span class=\"attr\">CONTENT</span>=<span class=\"string\">&quot;0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>ajax请求服务器最新文件，并加上请求头If-Modified-Since和Cache-Control</li>\n<li>版本号</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"webview与H5之间的通信\"><a href=\"#webview与H5之间的通信\" class=\"headerlink\" title=\"webview与H5之间的通信\"></a>webview与H5之间的通信</h2><h2 id=\"react-setState后发生了什么\"><a href=\"#react-setState后发生了什么\" class=\"headerlink\" title=\"react setState后发生了什么\"></a>react setState后发生了什么</h2><ol>\n<li>React 会将传入的参数对象与组件当前的状态合并；</li>\n<li>根据新的状态构建 React 元素树，并且计算出新的树与老树的节点差异；</li>\n<li>根据差异对界面进行最小化重渲染。</li>\n</ol>\n<h2 id=\"microTask-微任务-和-macroTask-宏任务\"><a href=\"#microTask-微任务-和-macroTask-宏任务\" class=\"headerlink\" title=\"microTask(微任务) 和 macroTask(宏任务)\"></a>microTask(微任务) 和 macroTask(宏任务)</h2><p>microTask： Promise、MutationObserver、process.nextTick、Object.observe</p>\n<p>macroTask： setTimeout、setInterval、setImmediate、I/O、UI渲染</p>\n<h2 id=\"网络API\"><a href=\"#网络API\" class=\"headerlink\" title=\"网络API\"></a>网络API</h2><p>XMLHttpRequest</p>\n<p>Fetch</p>\n<h2 id=\"有赞面试总结\"><a href=\"#有赞面试总结\" class=\"headerlink\" title=\"有赞面试总结\"></a>有赞面试总结</h2><ol>\n<li>如何创建私有作用域，及私有变量</li>\n<li>任务队列 <a href=\"https://juejin.im/post/59e85eebf265da430d571f89?utm_source=gold_browser_extension\">Event Loop</a></li>\n<li>this.xx在原型链中取值</li>\n<li>实现继承</li>\n</ol>\n"},{"title":"前端代码指南(一)","date":"2015-12-24T06:24:34.000Z","description":"前端代码指南","_content":"\n本文翻译自bendc的[《Frontend Guidelines》](https://github.com/bendc/frontend-guidelines?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)，由于篇幅过长，这里我分成了三篇，分别为HTML、CSS、Javascript，主要介绍了HTML/CSS/Javascript的代码指南，文章中所提出的指南也并不绝对，一切从实际出发，大家可以根据自己所需来取舍。说实话，英语真的不好,请见谅，欢迎大家纠错，Thanks。\n\n[前端代码指南(一)](/2015/12/24/前端代码指南-一/)\n[前端代码指南(二)](/2015/12/25/前端代码指南-二/)\n[前端代码指南(三)](/2015/12/25/前端代码指南-三/)\n\n# HTML\n\n\n<!-- more -->\n\n### 语义化\n\nHTML5为我们提供了大量的语义化标签使我们可以准确地描述内容，所以请使用这些语义化标签。\n\n```\n<!-- 糟糕的 -->\n<div id=\"main\">\n  <div class=\"article\">\n    <div class=\"header\">\n      <h1>Blog post</h1>\n      <p>Published: <span>21st Feb, 2015</span></p>\n    </div>\n    <p>…</p>\n  </div>\n</div>\n\n<!-- 推荐的-->\n<main>\n  <article>\n    <header>\n      <h1>Blog post</h1>\n      <p>Published: <time datetime=\"2015-02-21\">21st Feb, 2015</time></p>\n    </header>\n    <p>…</p>\n  </article>\n</main>\n\n```\n\n但是请确保你了解你使用的语义化标签。如果错误地使用语义化标签还不如不用。\n```\n<!-- 糟糕的 -->\n<h1>\n  <figure>\n    <img alt=Company src=logo.png>\n  </figure>\n</h1>\n\n<!-- 推荐的 -->\n<h1>\n  <img alt=Company src=logo.png>\n</h1>\n```\n\n### 简洁\n\n保持代码简洁，忘记你XHTML的旧习惯。\n```\n<!-- 糟糕的 -->\n<!doctype html>\n<html lang=en>\n  <head>\n    <meta http-equiv=Content-Type content=\"text/html; charset=utf-8\" />\n    <title>Contact</title>\n    <link rel=stylesheet href=style.css type=text/css />\n  </head>\n  <body>\n    <h1>Contact me</h1>\n    <label>\n      Email address:\n      <input type=email placeholder=you@email.com required=required />\n    </label>\n    <script src=main.js type=text/javascript></script>\n  </body>\n</html>\n\n<!-- 推荐的 -->\n<!doctype html>\n<html lang=en>\n  <meta charset=utf-8>\n  <title>Contact</title>\n  <link rel=stylesheet href=style.css>\n\n  <h1>Contact me</h1>\n  <label>\n    Email address:\n    <input type=email placeholder=you@email.com required>\n  </label>\n  <script src=main.js></script>\n</html>\n```\n\n### 可访问性\n可访问性不是事后才解决的。你不需要成为一个WCAG专家才能提高你网站的可访问性,你可以通过修复一些小细节来实现,比如：\n\n+ 学会正确使用alt属性;\n+ 确保标记你的超链接和按钮(即让别人看到就明白那个地方是超链接或按钮)\n+ 不要仅使用色彩来传达意思(主要考虑视力障碍者)\n+ 显式地标记(label)字段(使用label标签)\n\n```\n<!-- 糟糕的 -->\n<h1><img alt=\"Logo\" src=\"logo.png\"></h1>\n\n<!-- 推荐的 -->\n<h1><img alt=\"My Company, Inc.\" src=\"logo.png\"></h1>\n```\n\n### 语言\n\n虽然声明语言和字符编码是可选的,但是强烈建议在文档内声明(即使他们已经在HTTP头内指定)。编码格式建议优先考虑utf-8。\n```\n<!-- 糟糕的 -->\n<!doctype html>\n<title>Hello, world.</title>\n\n<!-- 推荐的 -->\n<!doctype html>\n<html lang=en>\n  <meta charset=utf-8>\n  <title>Hello, world.</title>\n</html>\n```\n\n### 性能\n除非某个脚本必须在内容之前加载,否则不要让js阻止页面的呈现。如果你的css文件很大，请将这个css文件分离为俩个css文件(`需要首先加载的`和`可延迟加载的`)。俩个http请求虽然比一个慢得多，但是\"感官上的速度\"才是最重要的因素。\n```\n<!-- 糟糕的 -->\n<!doctype html>\n<meta charset=utf-8>\n<script src=analytics.js></script>\n<title>Hello, world.</title>\n<p>...</p>\n\n<!-- 推荐的 -->\n<!doctype html>\n<meta charset=utf-8>\n<title>Hello, world.</title>\n<p>...</p>\n<script src=analytics.js></script>\n```","source":"_posts/前端代码指南-一.md","raw":"title: 前端代码指南(一)\ndate: 2015-12-24 14:24:34\ntags: [web]\ndescription: 前端代码指南\n\n---\n\n本文翻译自bendc的[《Frontend Guidelines》](https://github.com/bendc/frontend-guidelines?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)，由于篇幅过长，这里我分成了三篇，分别为HTML、CSS、Javascript，主要介绍了HTML/CSS/Javascript的代码指南，文章中所提出的指南也并不绝对，一切从实际出发，大家可以根据自己所需来取舍。说实话，英语真的不好,请见谅，欢迎大家纠错，Thanks。\n\n[前端代码指南(一)](/2015/12/24/前端代码指南-一/)\n[前端代码指南(二)](/2015/12/25/前端代码指南-二/)\n[前端代码指南(三)](/2015/12/25/前端代码指南-三/)\n\n# HTML\n\n\n<!-- more -->\n\n### 语义化\n\nHTML5为我们提供了大量的语义化标签使我们可以准确地描述内容，所以请使用这些语义化标签。\n\n```\n<!-- 糟糕的 -->\n<div id=\"main\">\n  <div class=\"article\">\n    <div class=\"header\">\n      <h1>Blog post</h1>\n      <p>Published: <span>21st Feb, 2015</span></p>\n    </div>\n    <p>…</p>\n  </div>\n</div>\n\n<!-- 推荐的-->\n<main>\n  <article>\n    <header>\n      <h1>Blog post</h1>\n      <p>Published: <time datetime=\"2015-02-21\">21st Feb, 2015</time></p>\n    </header>\n    <p>…</p>\n  </article>\n</main>\n\n```\n\n但是请确保你了解你使用的语义化标签。如果错误地使用语义化标签还不如不用。\n```\n<!-- 糟糕的 -->\n<h1>\n  <figure>\n    <img alt=Company src=logo.png>\n  </figure>\n</h1>\n\n<!-- 推荐的 -->\n<h1>\n  <img alt=Company src=logo.png>\n</h1>\n```\n\n### 简洁\n\n保持代码简洁，忘记你XHTML的旧习惯。\n```\n<!-- 糟糕的 -->\n<!doctype html>\n<html lang=en>\n  <head>\n    <meta http-equiv=Content-Type content=\"text/html; charset=utf-8\" />\n    <title>Contact</title>\n    <link rel=stylesheet href=style.css type=text/css />\n  </head>\n  <body>\n    <h1>Contact me</h1>\n    <label>\n      Email address:\n      <input type=email placeholder=you@email.com required=required />\n    </label>\n    <script src=main.js type=text/javascript></script>\n  </body>\n</html>\n\n<!-- 推荐的 -->\n<!doctype html>\n<html lang=en>\n  <meta charset=utf-8>\n  <title>Contact</title>\n  <link rel=stylesheet href=style.css>\n\n  <h1>Contact me</h1>\n  <label>\n    Email address:\n    <input type=email placeholder=you@email.com required>\n  </label>\n  <script src=main.js></script>\n</html>\n```\n\n### 可访问性\n可访问性不是事后才解决的。你不需要成为一个WCAG专家才能提高你网站的可访问性,你可以通过修复一些小细节来实现,比如：\n\n+ 学会正确使用alt属性;\n+ 确保标记你的超链接和按钮(即让别人看到就明白那个地方是超链接或按钮)\n+ 不要仅使用色彩来传达意思(主要考虑视力障碍者)\n+ 显式地标记(label)字段(使用label标签)\n\n```\n<!-- 糟糕的 -->\n<h1><img alt=\"Logo\" src=\"logo.png\"></h1>\n\n<!-- 推荐的 -->\n<h1><img alt=\"My Company, Inc.\" src=\"logo.png\"></h1>\n```\n\n### 语言\n\n虽然声明语言和字符编码是可选的,但是强烈建议在文档内声明(即使他们已经在HTTP头内指定)。编码格式建议优先考虑utf-8。\n```\n<!-- 糟糕的 -->\n<!doctype html>\n<title>Hello, world.</title>\n\n<!-- 推荐的 -->\n<!doctype html>\n<html lang=en>\n  <meta charset=utf-8>\n  <title>Hello, world.</title>\n</html>\n```\n\n### 性能\n除非某个脚本必须在内容之前加载,否则不要让js阻止页面的呈现。如果你的css文件很大，请将这个css文件分离为俩个css文件(`需要首先加载的`和`可延迟加载的`)。俩个http请求虽然比一个慢得多，但是\"感官上的速度\"才是最重要的因素。\n```\n<!-- 糟糕的 -->\n<!doctype html>\n<meta charset=utf-8>\n<script src=analytics.js></script>\n<title>Hello, world.</title>\n<p>...</p>\n\n<!-- 推荐的 -->\n<!doctype html>\n<meta charset=utf-8>\n<title>Hello, world.</title>\n<p>...</p>\n<script src=analytics.js></script>\n```","slug":"前端代码指南-一","published":1,"updated":"2021-12-06T06:07:06.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomb003wy4v2dmjuh0y6","content":"<p>本文翻译自bendc的<a href=\"https://github.com/bendc/frontend-guidelines?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io\">《Frontend Guidelines》</a>，由于篇幅过长，这里我分成了三篇，分别为HTML、CSS、Javascript，主要介绍了HTML/CSS/Javascript的代码指南，文章中所提出的指南也并不绝对，一切从实际出发，大家可以根据自己所需来取舍。说实话，英语真的不好,请见谅，欢迎大家纠错，Thanks。</p>\n<p><a href=\"/2015/12/24/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%80/\">前端代码指南(一)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%BA%8C/\">前端代码指南(二)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%89/\">前端代码指南(三)</a></p>\n<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><span id=\"more\"></span>\n\n<h3 id=\"语义化\"><a href=\"#语义化\" class=\"headerlink\" title=\"语义化\"></a>语义化</h3><p>HTML5为我们提供了大量的语义化标签使我们可以准确地描述内容，所以请使用这些语义化标签。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;div id=&quot;main&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;article&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;header&quot;&gt;</span><br><span class=\"line\">      &lt;h1&gt;Blog post&lt;/h1&gt;</span><br><span class=\"line\">      &lt;p&gt;Published: &lt;span&gt;21st Feb, 2015&lt;/span&gt;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;p&gt;…&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的--&gt;</span><br><span class=\"line\">&lt;main&gt;</span><br><span class=\"line\">  &lt;article&gt;</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &lt;h1&gt;Blog post&lt;/h1&gt;</span><br><span class=\"line\">      &lt;p&gt;Published: &lt;time datetime=&quot;2015-02-21&quot;&gt;21st Feb, 2015&lt;/time&gt;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">    &lt;p&gt;…&lt;/p&gt;</span><br><span class=\"line\">  &lt;/article&gt;</span><br><span class=\"line\">&lt;/main&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>但是请确保你了解你使用的语义化标签。如果错误地使用语义化标签还不如不用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;h1&gt;</span><br><span class=\"line\">  &lt;figure&gt;</span><br><span class=\"line\">    &lt;img alt=Company src=logo.png&gt;</span><br><span class=\"line\">  &lt;/figure&gt;</span><br><span class=\"line\">&lt;/h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的 --&gt;</span><br><span class=\"line\">&lt;h1&gt;</span><br><span class=\"line\">  &lt;img alt=Company src=logo.png&gt;</span><br><span class=\"line\">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简洁\"><a href=\"#简洁\" class=\"headerlink\" title=\"简洁\"></a>简洁</h3><p>保持代码简洁，忘记你XHTML的旧习惯。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html lang=en&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=Content-Type content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class=\"line\">    &lt;title&gt;Contact&lt;/title&gt;</span><br><span class=\"line\">    &lt;link rel=stylesheet href=style.css type=text/css /&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;h1&gt;Contact me&lt;/h1&gt;</span><br><span class=\"line\">    &lt;label&gt;</span><br><span class=\"line\">      Email address:</span><br><span class=\"line\">      &lt;input type=email placeholder=you@email.com required=required /&gt;</span><br><span class=\"line\">    &lt;/label&gt;</span><br><span class=\"line\">    &lt;script src=main.js type=text/javascript&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html lang=en&gt;</span><br><span class=\"line\">  &lt;meta charset=utf-8&gt;</span><br><span class=\"line\">  &lt;title&gt;Contact&lt;/title&gt;</span><br><span class=\"line\">  &lt;link rel=stylesheet href=style.css&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;h1&gt;Contact me&lt;/h1&gt;</span><br><span class=\"line\">  &lt;label&gt;</span><br><span class=\"line\">    Email address:</span><br><span class=\"line\">    &lt;input type=email placeholder=you@email.com required&gt;</span><br><span class=\"line\">  &lt;/label&gt;</span><br><span class=\"line\">  &lt;script src=main.js&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可访问性\"><a href=\"#可访问性\" class=\"headerlink\" title=\"可访问性\"></a>可访问性</h3><p>可访问性不是事后才解决的。你不需要成为一个WCAG专家才能提高你网站的可访问性,你可以通过修复一些小细节来实现,比如：</p>\n<ul>\n<li>学会正确使用alt属性;</li>\n<li>确保标记你的超链接和按钮(即让别人看到就明白那个地方是超链接或按钮)</li>\n<li>不要仅使用色彩来传达意思(主要考虑视力障碍者)</li>\n<li>显式地标记(label)字段(使用label标签)</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;h1&gt;&lt;img alt=&quot;Logo&quot; src=&quot;logo.png&quot;&gt;&lt;/h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的 --&gt;</span><br><span class=\"line\">&lt;h1&gt;&lt;img alt=&quot;My Company, Inc.&quot; src=&quot;logo.png&quot;&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h3><p>虽然声明语言和字符编码是可选的,但是强烈建议在文档内声明(即使他们已经在HTTP头内指定)。编码格式建议优先考虑utf-8。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;title&gt;Hello, world.&lt;/title&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html lang=en&gt;</span><br><span class=\"line\">  &lt;meta charset=utf-8&gt;</span><br><span class=\"line\">  &lt;title&gt;Hello, world.&lt;/title&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>除非某个脚本必须在内容之前加载,否则不要让js阻止页面的呈现。如果你的css文件很大，请将这个css文件分离为俩个css文件(<code>需要首先加载的</code>和<code>可延迟加载的</code>)。俩个http请求虽然比一个慢得多，但是”感官上的速度”才是最重要的因素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;meta charset=utf-8&gt;</span><br><span class=\"line\">&lt;script src=analytics.js&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;title&gt;Hello, world.&lt;/title&gt;</span><br><span class=\"line\">&lt;p&gt;...&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;meta charset=utf-8&gt;</span><br><span class=\"line\">&lt;title&gt;Hello, world.&lt;/title&gt;</span><br><span class=\"line\">&lt;p&gt;...&lt;/p&gt;</span><br><span class=\"line\">&lt;script src=analytics.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>本文翻译自bendc的<a href=\"https://github.com/bendc/frontend-guidelines?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io\">《Frontend Guidelines》</a>，由于篇幅过长，这里我分成了三篇，分别为HTML、CSS、Javascript，主要介绍了HTML/CSS/Javascript的代码指南，文章中所提出的指南也并不绝对，一切从实际出发，大家可以根据自己所需来取舍。说实话，英语真的不好,请见谅，欢迎大家纠错，Thanks。</p>\n<p><a href=\"/2015/12/24/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%80/\">前端代码指南(一)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%BA%8C/\">前端代码指南(二)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%89/\">前端代码指南(三)</a></p>\n<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1>","more":"<h3 id=\"语义化\"><a href=\"#语义化\" class=\"headerlink\" title=\"语义化\"></a>语义化</h3><p>HTML5为我们提供了大量的语义化标签使我们可以准确地描述内容，所以请使用这些语义化标签。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;div id=&quot;main&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;article&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;header&quot;&gt;</span><br><span class=\"line\">      &lt;h1&gt;Blog post&lt;/h1&gt;</span><br><span class=\"line\">      &lt;p&gt;Published: &lt;span&gt;21st Feb, 2015&lt;/span&gt;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;p&gt;…&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的--&gt;</span><br><span class=\"line\">&lt;main&gt;</span><br><span class=\"line\">  &lt;article&gt;</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &lt;h1&gt;Blog post&lt;/h1&gt;</span><br><span class=\"line\">      &lt;p&gt;Published: &lt;time datetime=&quot;2015-02-21&quot;&gt;21st Feb, 2015&lt;/time&gt;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">    &lt;p&gt;…&lt;/p&gt;</span><br><span class=\"line\">  &lt;/article&gt;</span><br><span class=\"line\">&lt;/main&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>但是请确保你了解你使用的语义化标签。如果错误地使用语义化标签还不如不用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;h1&gt;</span><br><span class=\"line\">  &lt;figure&gt;</span><br><span class=\"line\">    &lt;img alt=Company src=logo.png&gt;</span><br><span class=\"line\">  &lt;/figure&gt;</span><br><span class=\"line\">&lt;/h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的 --&gt;</span><br><span class=\"line\">&lt;h1&gt;</span><br><span class=\"line\">  &lt;img alt=Company src=logo.png&gt;</span><br><span class=\"line\">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简洁\"><a href=\"#简洁\" class=\"headerlink\" title=\"简洁\"></a>简洁</h3><p>保持代码简洁，忘记你XHTML的旧习惯。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html lang=en&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=Content-Type content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class=\"line\">    &lt;title&gt;Contact&lt;/title&gt;</span><br><span class=\"line\">    &lt;link rel=stylesheet href=style.css type=text/css /&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;h1&gt;Contact me&lt;/h1&gt;</span><br><span class=\"line\">    &lt;label&gt;</span><br><span class=\"line\">      Email address:</span><br><span class=\"line\">      &lt;input type=email placeholder=you@email.com required=required /&gt;</span><br><span class=\"line\">    &lt;/label&gt;</span><br><span class=\"line\">    &lt;script src=main.js type=text/javascript&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html lang=en&gt;</span><br><span class=\"line\">  &lt;meta charset=utf-8&gt;</span><br><span class=\"line\">  &lt;title&gt;Contact&lt;/title&gt;</span><br><span class=\"line\">  &lt;link rel=stylesheet href=style.css&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;h1&gt;Contact me&lt;/h1&gt;</span><br><span class=\"line\">  &lt;label&gt;</span><br><span class=\"line\">    Email address:</span><br><span class=\"line\">    &lt;input type=email placeholder=you@email.com required&gt;</span><br><span class=\"line\">  &lt;/label&gt;</span><br><span class=\"line\">  &lt;script src=main.js&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可访问性\"><a href=\"#可访问性\" class=\"headerlink\" title=\"可访问性\"></a>可访问性</h3><p>可访问性不是事后才解决的。你不需要成为一个WCAG专家才能提高你网站的可访问性,你可以通过修复一些小细节来实现,比如：</p>\n<ul>\n<li>学会正确使用alt属性;</li>\n<li>确保标记你的超链接和按钮(即让别人看到就明白那个地方是超链接或按钮)</li>\n<li>不要仅使用色彩来传达意思(主要考虑视力障碍者)</li>\n<li>显式地标记(label)字段(使用label标签)</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;h1&gt;&lt;img alt=&quot;Logo&quot; src=&quot;logo.png&quot;&gt;&lt;/h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的 --&gt;</span><br><span class=\"line\">&lt;h1&gt;&lt;img alt=&quot;My Company, Inc.&quot; src=&quot;logo.png&quot;&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h3><p>虽然声明语言和字符编码是可选的,但是强烈建议在文档内声明(即使他们已经在HTTP头内指定)。编码格式建议优先考虑utf-8。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;title&gt;Hello, world.&lt;/title&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html lang=en&gt;</span><br><span class=\"line\">  &lt;meta charset=utf-8&gt;</span><br><span class=\"line\">  &lt;title&gt;Hello, world.&lt;/title&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>除非某个脚本必须在内容之前加载,否则不要让js阻止页面的呈现。如果你的css文件很大，请将这个css文件分离为俩个css文件(<code>需要首先加载的</code>和<code>可延迟加载的</code>)。俩个http请求虽然比一个慢得多，但是”感官上的速度”才是最重要的因素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 糟糕的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;meta charset=utf-8&gt;</span><br><span class=\"line\">&lt;script src=analytics.js&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;title&gt;Hello, world.&lt;/title&gt;</span><br><span class=\"line\">&lt;p&gt;...&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 推荐的 --&gt;</span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;meta charset=utf-8&gt;</span><br><span class=\"line\">&lt;title&gt;Hello, world.&lt;/title&gt;</span><br><span class=\"line\">&lt;p&gt;...&lt;/p&gt;</span><br><span class=\"line\">&lt;script src=analytics.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>"},{"title":"前端代码指南(三)","date":"2015-12-25T02:05:47.000Z","description":"前端代码指南","_content":"\n[前端代码指南(一)](/2015/12/24/前端代码指南-一/)\n[前端代码指南(二)](/2015/12/25/前端代码指南-二/)\n[前端代码指南(三)](/2015/12/25/前端代码指南-三/)\n\n# javascript\n\n<!-- more -->\n\n<b style=\"color:#d44950\">注：</b> 下面ES6的语法\n\n### 性能\n性能中最重要的是可读性、正确性和可表达性，JavaScript基本上永远不会成为你的性能瓶颈。我们可以通过图像压缩、网络存取和减少回流等来优化性能。如果你看过整篇篇文章后只能记住一条，请记住这条。\n\n\n\n```\n// 糟糕的 (albeit way faster)\nconst arr = [1, 2, 3, 4];\nconst len = arr.length;\nvar i = -1;\nvar result = [];\nwhile (++i < len) {\n  var n = arr[i];\n  if (n % 2 > 0) continue;\n  result.push(n * n);\n}\n\n// 推荐的\nconst arr = [1, 2, 3, 4];\nconst isEven = n => n % 2 == 0;\nconst square = n => n * n;\n\nconst result = arr.filter(isEven).map(square);\n```\n\n### 无领域\n尽量保持你函数的纯净。理想地，应该创建无副作用的、不使用外部数据的并返回新对象(而不是改变现有的)的函数。\n```\n// 糟糕的\nconst merge = (target, ...sources) => Object.assign(target, ...sources);\nmerge({ foo: \"foo\" }, { bar: \"bar\" }); // => { foo: \"foo\", bar: \"bar\" }\n\n// 推荐的\nconst merge = (...sources) => Object.assign({}, ...sources);\nmerge({ foo: \"foo\" }, { bar: \"bar\" }); // => { foo: \"foo\", bar: \"bar\" }\n```\n\n### 原生\n尽可能依赖原生的方法\n```\n// 糟糕的\nconst toArray = obj => [].slice.call(obj);\n\n// 推荐的\nconst toArray = (() =>\n  Array.from ? Array.from : obj => [].slice.call(obj)\n)();\n```\n\n### 强制\n不要在不必要的时候使用隐形强制\n```\n// 糟糕的\nif (x === undefined || x === null) { ... }\n\n// 推荐的\nif (x == undefined) { ... }\n```\n\n### 循环\n不要使用循环,因为他们强迫你使用可变的对象。可以依赖`array.prototype`方法\n```\n// 糟糕的\nconst sum = arr => {\n  var sum = 0;\n  var i = -1;\n  for (;arr[++i];) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nsum([1, 2, 3]); // => 6\n\n// 推荐的\nconst sum = arr =>\n  arr.reduce((x, y) => x + y);\n\nsum([1, 2, 3]); // => 6\n```\n\n如果你不能避免使用循环,或者使用`array.prototype`方法对你来说是一种受虐的行为,可以使用递归\n```\n// 糟糕的\nconst createDivs = howMany => {\n  while (howMany--) {\n    document.body.insertAdjacentHTML(\"beforeend\", \"<div></div>\");\n  }\n};\ncreateDivs(5);\n\n// 糟糕的\nconst createDivs = howMany =>\n  [...Array(howMany)].forEach(() =>\n    document.body.insertAdjacentHTML(\"beforeend\", \"<div></div>\")\n  );\ncreateDivs(5);\n\n// 推荐的\nconst createDivs = howMany => {\n  if (!howMany) return;\n  document.body.insertAdjacentHTML(\"beforeend\", \"<div></div>\");\n  return createDivs(howMany - 1);\n};\ncreateDivs(5);\n```\n\n### 参数\n忘记`arguments `对象。使用其余的参数才是更好的选择,这是因为：\n\n1. 其余的参数是被命名的,所以你可以给这个函数的参数一个更好的注意\n2. 其余的参数是一个真正的数组,这使得它更容易使用。\n\n```\n// 糟糕的\nconst sortNumbers = () =>\n  Array.prototype.slice.call(arguments).sort();\n\n// 推荐的\nconst sortNumbers = (...numbers) => numbers.sort();\n```\n\n### Apply\n忘记Apply()函数，使用扩展来代替\n```\nconst greet = (first, last) => `Hi ${first} ${last}`;\nconst person = [\"John\", \"Doe\"];\n\n// 糟糕的\ngreet.apply(null, person);\n\n// 推荐的\ngreet(...person);\n```\n\n### 绑定\n忘记bind()函数，这里有个更惯用的方法\n```\n// 糟糕的\n[\"foo\", \"bar\"].forEach(func.bind(this));\n\n// 推荐的\n[\"foo\", \"bar\"].forEach(func, this);\n```\n```\n// 糟糕的\nconst person = {\n  first: \"John\",\n  last: \"Doe\",\n  greet() {\n    const full = function() {\n      return `${this.first} ${this.last}`;\n    }.bind(this);\n    return `Hello ${full()}`;\n  }\n}\n\n// 推荐的\nconst person = {\n  first: \"John\",\n  last: \"Doe\",\n  greet() {\n    const full = () => `${this.first} ${this.last}`;\n    return `Hello ${full()}`;\n  }\n}\n```\n\n### 高层级的函数\n在不必需的时候避免使用嵌套函数\n```\n// 糟糕的\n[1, 2, 3].map(num => String(num));\n\n// 推荐的\n[1, 2, 3].map(String);\n```\n\n### 结构\n\n避免函数的多层次调用，合理使用结构来解决问题\n```\nconst plus1 = a => a + 1;\nconst mult2 = a => a * 2;\n\n// 糟糕的\nmult2(plus1(5)); // => 12\n\n// 推荐的\nconst pipeline = (...funcs) => val => funcs.reduce((a, b) => b(a), val);\nconst addThenMult = pipeline(plus1, mult2);\naddThenMult(5); // => 12\n```\n\n### 缓存\n缓存功能测试、大数据结构和任何昂贵的操作。\n```\n// 糟糕的\nconst contains = (arr, value) =>\n  Array.prototype.includes\n    ? arr.includes(value)\n    : arr.some(el => el === value);\ncontains([\"foo\", \"bar\"], \"baz\"); // => false\n\n// 推荐的\nconst contains = (() =>\n  Array.prototype.includes\n    ? (arr, value) => arr.includes(value)\n    : (arr, value) => arr.some(el => el === value)\n)();\ncontains([\"foo\", \"bar\"], \"baz\"); // => false\n```\n\n### 变量\n`const`优于 `let`优于 `var`\n```\n// 糟糕的\nvar me = new Map();\nme.set(\"name\", \"Ben\").set(\"country\", \"Belgium\");\n\n// 推荐的\nconst me = new Map();\nme.set(\"name\", \"Ben\").set(\"country\", \"Belgium\");\n```\n### 条件\n`if+return语句`  优于 `if...else if...else` 和`switch`\n```\n// 糟糕的\nvar grade;\nif (result < 50)\n  grade = \"糟糕的\";\nelse if (result < 90)\n  grade = \"推荐的\";\nelse\n  grade = \"excellent\";\n\n// 推荐的\nconst grade = (() => {\n  if (result < 50)\n    return \"糟糕的\";\n  if (result < 90)\n    return \"推荐的\";\n  return \"excellent\";\n})();\n```\n\n### 对象迭代\n避免使用`for...in`\n```\nconst shared = { foo: \"foo\" };\nconst obj = Object.create(shared, {\n  bar: {\n    value: \"bar\",\n    enumerable: true\n  }\n});\n\n// 糟糕的\nfor (var prop in obj) {\n  if (obj.hasOwnProperty(prop))\n    console.log(prop);\n}\n\n// 推荐的\nObject.keys(obj).forEach(prop => console.log(prop));\n```\n\n### 把对象作为maps\n虽然对象是一个合法的用例，但map是一个更好更强大的选择\n```\n// 糟糕的\nconst me = {\n  name: \"Ben\",\n  age: 30\n};\nvar meSize = Object.keys(me).length;\nmeSize; // => 2\nme.country = \"Belgium\";\nmeSize++;\nmeSize; // => 3\n\n// 推荐的\nconst me = new Map();\nme.set(\"name\", \"Ben\");\nme.set(\"age\", 30);\nme.size; // => 2\nme.set(\"country\", \"Belgium\");\nme.size; // => 3\n```\n### 柯里化\n对许多开发者来说，柯里化是一个带有国外范的强大形式。合理化地使用它是非常妙的，但是请不要滥用它\n```\n// 糟糕的\nconst sum = a => b => a + b;\nsum(5)(3); // => 8\n\n// 推荐的\nconst sum = (a, b) => a + b;\nsum(5, 3); // => 8\n```\n\n### 可读性\n不要使用一些表面看起来很巧妙的技巧来导致你代码的意思模糊不清(即不可读)\n```\n// 糟糕的\nfoo || doSomething();\n\n// 推荐的\nif (!foo) doSomething();\n```\n```\n// 糟糕的\nvoid function() { /* IIFE */ }();\n\n// 推荐的\n(function() { /* IIFE */ }());\n```\n```\n// 糟糕的\nconst n = ~~3.14;\n\n// 推荐的\nconst n = Math.floor(3.14);\n```\n\n### 代码复用\n不要抗拒去创建一些体积小,高度可组合、可重用的函数。\n```\n// 糟糕的\narr[arr.length - 1];\n\n// 推荐的\nconst first = arr => arr[0];\nconst last = arr => first(arr.slice(-1));\nlast(arr);\n```\n```\n// 糟糕的\nconst product = (a, b) => a * b;\nconst triple = n => n * 3;\n\n// 推荐的\nconst product = (a, b) => a * b;\nconst triple = product.bind(null, 3);\n```\n### 依赖性\n减少依赖。第三方的代码是你不了解的,不要仅仅为了几个可复制的函数而加载整个第三方文件。\n```\n// 糟糕的\nvar _ = require(\"underscore\");\n_.compact([\"foo\", 0]));\n_.unique([\"foo\", \"foo\"]);\n_.union([\"foo\"], [\"bar\"], [\"foo\"]);\n\n// 推荐的\nconst compact = arr => arr.filter(el => el);\nconst unique = arr => [...Set(arr)];\nconst union = (...arr) => unique([].concat(...arr));\n\ncompact([\"foo\", 0]);\nunique([\"foo\", \"foo\"]);\nunion([\"foo\"], [\"bar\"], [\"foo\"]);\n```","source":"_posts/前端代码指南-三.md","raw":"title: 前端代码指南(三)\ndate: 2015-12-25 10:05:47\ntags: [web]\ndescription: 前端代码指南\n\n---\n\n[前端代码指南(一)](/2015/12/24/前端代码指南-一/)\n[前端代码指南(二)](/2015/12/25/前端代码指南-二/)\n[前端代码指南(三)](/2015/12/25/前端代码指南-三/)\n\n# javascript\n\n<!-- more -->\n\n<b style=\"color:#d44950\">注：</b> 下面ES6的语法\n\n### 性能\n性能中最重要的是可读性、正确性和可表达性，JavaScript基本上永远不会成为你的性能瓶颈。我们可以通过图像压缩、网络存取和减少回流等来优化性能。如果你看过整篇篇文章后只能记住一条，请记住这条。\n\n\n\n```\n// 糟糕的 (albeit way faster)\nconst arr = [1, 2, 3, 4];\nconst len = arr.length;\nvar i = -1;\nvar result = [];\nwhile (++i < len) {\n  var n = arr[i];\n  if (n % 2 > 0) continue;\n  result.push(n * n);\n}\n\n// 推荐的\nconst arr = [1, 2, 3, 4];\nconst isEven = n => n % 2 == 0;\nconst square = n => n * n;\n\nconst result = arr.filter(isEven).map(square);\n```\n\n### 无领域\n尽量保持你函数的纯净。理想地，应该创建无副作用的、不使用外部数据的并返回新对象(而不是改变现有的)的函数。\n```\n// 糟糕的\nconst merge = (target, ...sources) => Object.assign(target, ...sources);\nmerge({ foo: \"foo\" }, { bar: \"bar\" }); // => { foo: \"foo\", bar: \"bar\" }\n\n// 推荐的\nconst merge = (...sources) => Object.assign({}, ...sources);\nmerge({ foo: \"foo\" }, { bar: \"bar\" }); // => { foo: \"foo\", bar: \"bar\" }\n```\n\n### 原生\n尽可能依赖原生的方法\n```\n// 糟糕的\nconst toArray = obj => [].slice.call(obj);\n\n// 推荐的\nconst toArray = (() =>\n  Array.from ? Array.from : obj => [].slice.call(obj)\n)();\n```\n\n### 强制\n不要在不必要的时候使用隐形强制\n```\n// 糟糕的\nif (x === undefined || x === null) { ... }\n\n// 推荐的\nif (x == undefined) { ... }\n```\n\n### 循环\n不要使用循环,因为他们强迫你使用可变的对象。可以依赖`array.prototype`方法\n```\n// 糟糕的\nconst sum = arr => {\n  var sum = 0;\n  var i = -1;\n  for (;arr[++i];) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nsum([1, 2, 3]); // => 6\n\n// 推荐的\nconst sum = arr =>\n  arr.reduce((x, y) => x + y);\n\nsum([1, 2, 3]); // => 6\n```\n\n如果你不能避免使用循环,或者使用`array.prototype`方法对你来说是一种受虐的行为,可以使用递归\n```\n// 糟糕的\nconst createDivs = howMany => {\n  while (howMany--) {\n    document.body.insertAdjacentHTML(\"beforeend\", \"<div></div>\");\n  }\n};\ncreateDivs(5);\n\n// 糟糕的\nconst createDivs = howMany =>\n  [...Array(howMany)].forEach(() =>\n    document.body.insertAdjacentHTML(\"beforeend\", \"<div></div>\")\n  );\ncreateDivs(5);\n\n// 推荐的\nconst createDivs = howMany => {\n  if (!howMany) return;\n  document.body.insertAdjacentHTML(\"beforeend\", \"<div></div>\");\n  return createDivs(howMany - 1);\n};\ncreateDivs(5);\n```\n\n### 参数\n忘记`arguments `对象。使用其余的参数才是更好的选择,这是因为：\n\n1. 其余的参数是被命名的,所以你可以给这个函数的参数一个更好的注意\n2. 其余的参数是一个真正的数组,这使得它更容易使用。\n\n```\n// 糟糕的\nconst sortNumbers = () =>\n  Array.prototype.slice.call(arguments).sort();\n\n// 推荐的\nconst sortNumbers = (...numbers) => numbers.sort();\n```\n\n### Apply\n忘记Apply()函数，使用扩展来代替\n```\nconst greet = (first, last) => `Hi ${first} ${last}`;\nconst person = [\"John\", \"Doe\"];\n\n// 糟糕的\ngreet.apply(null, person);\n\n// 推荐的\ngreet(...person);\n```\n\n### 绑定\n忘记bind()函数，这里有个更惯用的方法\n```\n// 糟糕的\n[\"foo\", \"bar\"].forEach(func.bind(this));\n\n// 推荐的\n[\"foo\", \"bar\"].forEach(func, this);\n```\n```\n// 糟糕的\nconst person = {\n  first: \"John\",\n  last: \"Doe\",\n  greet() {\n    const full = function() {\n      return `${this.first} ${this.last}`;\n    }.bind(this);\n    return `Hello ${full()}`;\n  }\n}\n\n// 推荐的\nconst person = {\n  first: \"John\",\n  last: \"Doe\",\n  greet() {\n    const full = () => `${this.first} ${this.last}`;\n    return `Hello ${full()}`;\n  }\n}\n```\n\n### 高层级的函数\n在不必需的时候避免使用嵌套函数\n```\n// 糟糕的\n[1, 2, 3].map(num => String(num));\n\n// 推荐的\n[1, 2, 3].map(String);\n```\n\n### 结构\n\n避免函数的多层次调用，合理使用结构来解决问题\n```\nconst plus1 = a => a + 1;\nconst mult2 = a => a * 2;\n\n// 糟糕的\nmult2(plus1(5)); // => 12\n\n// 推荐的\nconst pipeline = (...funcs) => val => funcs.reduce((a, b) => b(a), val);\nconst addThenMult = pipeline(plus1, mult2);\naddThenMult(5); // => 12\n```\n\n### 缓存\n缓存功能测试、大数据结构和任何昂贵的操作。\n```\n// 糟糕的\nconst contains = (arr, value) =>\n  Array.prototype.includes\n    ? arr.includes(value)\n    : arr.some(el => el === value);\ncontains([\"foo\", \"bar\"], \"baz\"); // => false\n\n// 推荐的\nconst contains = (() =>\n  Array.prototype.includes\n    ? (arr, value) => arr.includes(value)\n    : (arr, value) => arr.some(el => el === value)\n)();\ncontains([\"foo\", \"bar\"], \"baz\"); // => false\n```\n\n### 变量\n`const`优于 `let`优于 `var`\n```\n// 糟糕的\nvar me = new Map();\nme.set(\"name\", \"Ben\").set(\"country\", \"Belgium\");\n\n// 推荐的\nconst me = new Map();\nme.set(\"name\", \"Ben\").set(\"country\", \"Belgium\");\n```\n### 条件\n`if+return语句`  优于 `if...else if...else` 和`switch`\n```\n// 糟糕的\nvar grade;\nif (result < 50)\n  grade = \"糟糕的\";\nelse if (result < 90)\n  grade = \"推荐的\";\nelse\n  grade = \"excellent\";\n\n// 推荐的\nconst grade = (() => {\n  if (result < 50)\n    return \"糟糕的\";\n  if (result < 90)\n    return \"推荐的\";\n  return \"excellent\";\n})();\n```\n\n### 对象迭代\n避免使用`for...in`\n```\nconst shared = { foo: \"foo\" };\nconst obj = Object.create(shared, {\n  bar: {\n    value: \"bar\",\n    enumerable: true\n  }\n});\n\n// 糟糕的\nfor (var prop in obj) {\n  if (obj.hasOwnProperty(prop))\n    console.log(prop);\n}\n\n// 推荐的\nObject.keys(obj).forEach(prop => console.log(prop));\n```\n\n### 把对象作为maps\n虽然对象是一个合法的用例，但map是一个更好更强大的选择\n```\n// 糟糕的\nconst me = {\n  name: \"Ben\",\n  age: 30\n};\nvar meSize = Object.keys(me).length;\nmeSize; // => 2\nme.country = \"Belgium\";\nmeSize++;\nmeSize; // => 3\n\n// 推荐的\nconst me = new Map();\nme.set(\"name\", \"Ben\");\nme.set(\"age\", 30);\nme.size; // => 2\nme.set(\"country\", \"Belgium\");\nme.size; // => 3\n```\n### 柯里化\n对许多开发者来说，柯里化是一个带有国外范的强大形式。合理化地使用它是非常妙的，但是请不要滥用它\n```\n// 糟糕的\nconst sum = a => b => a + b;\nsum(5)(3); // => 8\n\n// 推荐的\nconst sum = (a, b) => a + b;\nsum(5, 3); // => 8\n```\n\n### 可读性\n不要使用一些表面看起来很巧妙的技巧来导致你代码的意思模糊不清(即不可读)\n```\n// 糟糕的\nfoo || doSomething();\n\n// 推荐的\nif (!foo) doSomething();\n```\n```\n// 糟糕的\nvoid function() { /* IIFE */ }();\n\n// 推荐的\n(function() { /* IIFE */ }());\n```\n```\n// 糟糕的\nconst n = ~~3.14;\n\n// 推荐的\nconst n = Math.floor(3.14);\n```\n\n### 代码复用\n不要抗拒去创建一些体积小,高度可组合、可重用的函数。\n```\n// 糟糕的\narr[arr.length - 1];\n\n// 推荐的\nconst first = arr => arr[0];\nconst last = arr => first(arr.slice(-1));\nlast(arr);\n```\n```\n// 糟糕的\nconst product = (a, b) => a * b;\nconst triple = n => n * 3;\n\n// 推荐的\nconst product = (a, b) => a * b;\nconst triple = product.bind(null, 3);\n```\n### 依赖性\n减少依赖。第三方的代码是你不了解的,不要仅仅为了几个可复制的函数而加载整个第三方文件。\n```\n// 糟糕的\nvar _ = require(\"underscore\");\n_.compact([\"foo\", 0]));\n_.unique([\"foo\", \"foo\"]);\n_.union([\"foo\"], [\"bar\"], [\"foo\"]);\n\n// 推荐的\nconst compact = arr => arr.filter(el => el);\nconst unique = arr => [...Set(arr)];\nconst union = (...arr) => unique([].concat(...arr));\n\ncompact([\"foo\", 0]);\nunique([\"foo\", \"foo\"]);\nunion([\"foo\"], [\"bar\"], [\"foo\"]);\n```","slug":"前端代码指南-三","published":1,"updated":"2021-12-06T06:07:06.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomb003yy4v2cc036lnp","content":"<p><a href=\"/2015/12/24/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%80/\">前端代码指南(一)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%BA%8C/\">前端代码指南(二)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%89/\">前端代码指南(三)</a></p>\n<h1 id=\"javascript\"><a href=\"#javascript\" class=\"headerlink\" title=\"javascript\"></a>javascript</h1><span id=\"more\"></span>\n\n<p><b style=\"color:#d44950\">注：</b> 下面ES6的语法</p>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>性能中最重要的是可读性、正确性和可表达性，JavaScript基本上永远不会成为你的性能瓶颈。我们可以通过图像压缩、网络存取和减少回流等来优化性能。如果你看过整篇篇文章后只能记住一条，请记住这条。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的 (albeit way faster)</span><br><span class=\"line\">const arr = [1, 2, 3, 4];</span><br><span class=\"line\">const len = arr.length;</span><br><span class=\"line\">var i = -1;</span><br><span class=\"line\">var result = [];</span><br><span class=\"line\">while (++i &lt; len) &#123;</span><br><span class=\"line\">  var n = arr[i];</span><br><span class=\"line\">  if (n % 2 &gt; 0) continue;</span><br><span class=\"line\">  result.push(n * n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const arr = [1, 2, 3, 4];</span><br><span class=\"line\">const isEven = n =&gt; n % 2 == 0;</span><br><span class=\"line\">const square = n =&gt; n * n;</span><br><span class=\"line\"></span><br><span class=\"line\">const result = arr.filter(isEven).map(square);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"无领域\"><a href=\"#无领域\" class=\"headerlink\" title=\"无领域\"></a>无领域</h3><p>尽量保持你函数的纯净。理想地，应该创建无副作用的、不使用外部数据的并返回新对象(而不是改变现有的)的函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const merge = (target, ...sources) =&gt; Object.assign(target, ...sources);</span><br><span class=\"line\">merge(&#123; foo: &quot;foo&quot; &#125;, &#123; bar: &quot;bar&quot; &#125;); // =&gt; &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources);</span><br><span class=\"line\">merge(&#123; foo: &quot;foo&quot; &#125;, &#123; bar: &quot;bar&quot; &#125;); // =&gt; &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原生\"><a href=\"#原生\" class=\"headerlink\" title=\"原生\"></a>原生</h3><p>尽可能依赖原生的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const toArray = obj =&gt; [].slice.call(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const toArray = (() =&gt;</span><br><span class=\"line\">  Array.from ? Array.from : obj =&gt; [].slice.call(obj)</span><br><span class=\"line\">)();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"强制\"><a href=\"#强制\" class=\"headerlink\" title=\"强制\"></a>强制</h3><p>不要在不必要的时候使用隐形强制</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">if (x === undefined || x === null) &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">if (x == undefined) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><p>不要使用循环,因为他们强迫你使用可变的对象。可以依赖<code>array.prototype</code>方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const sum = arr =&gt; &#123;</span><br><span class=\"line\">  var sum = 0;</span><br><span class=\"line\">  var i = -1;</span><br><span class=\"line\">  for (;arr[++i];) &#123;</span><br><span class=\"line\">    sum += arr[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return sum;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">sum([1, 2, 3]); // =&gt; 6</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const sum = arr =&gt;</span><br><span class=\"line\">  arr.reduce((x, y) =&gt; x + y);</span><br><span class=\"line\"></span><br><span class=\"line\">sum([1, 2, 3]); // =&gt; 6</span><br></pre></td></tr></table></figure>\n\n<p>如果你不能避免使用循环,或者使用<code>array.prototype</code>方法对你来说是一种受虐的行为,可以使用递归</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const createDivs = howMany =&gt; &#123;</span><br><span class=\"line\">  while (howMany--) &#123;</span><br><span class=\"line\">    document.body.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;div&gt;&lt;/div&gt;&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">createDivs(5);</span><br><span class=\"line\"></span><br><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const createDivs = howMany =&gt;</span><br><span class=\"line\">  [...Array(howMany)].forEach(() =&gt;</span><br><span class=\"line\">    document.body.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;div&gt;&lt;/div&gt;&quot;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">createDivs(5);</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const createDivs = howMany =&gt; &#123;</span><br><span class=\"line\">  if (!howMany) return;</span><br><span class=\"line\">  document.body.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;div&gt;&lt;/div&gt;&quot;);</span><br><span class=\"line\">  return createDivs(howMany - 1);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">createDivs(5);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>忘记<code>arguments </code>对象。使用其余的参数才是更好的选择,这是因为：</p>\n<ol>\n<li>其余的参数是被命名的,所以你可以给这个函数的参数一个更好的注意</li>\n<li>其余的参数是一个真正的数组,这使得它更容易使用。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const sortNumbers = () =&gt;</span><br><span class=\"line\">  Array.prototype.slice.call(arguments).sort();</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const sortNumbers = (...numbers) =&gt; numbers.sort();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Apply\"><a href=\"#Apply\" class=\"headerlink\" title=\"Apply\"></a>Apply</h3><p>忘记Apply()函数，使用扩展来代替</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const greet = (first, last) =&gt; `Hi $&#123;first&#125; $&#123;last&#125;`;</span><br><span class=\"line\">const person = [&quot;John&quot;, &quot;Doe&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 糟糕的</span><br><span class=\"line\">greet.apply(null, person);</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">greet(...person);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h3><p>忘记bind()函数，这里有个更惯用的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">[&quot;foo&quot;, &quot;bar&quot;].forEach(func.bind(this));</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">[&quot;foo&quot;, &quot;bar&quot;].forEach(func, this);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const person = &#123;</span><br><span class=\"line\">  first: &quot;John&quot;,</span><br><span class=\"line\">  last: &quot;Doe&quot;,</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    const full = function() &#123;</span><br><span class=\"line\">      return `$&#123;this.first&#125; $&#123;this.last&#125;`;</span><br><span class=\"line\">    &#125;.bind(this);</span><br><span class=\"line\">    return `Hello $&#123;full()&#125;`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const person = &#123;</span><br><span class=\"line\">  first: &quot;John&quot;,</span><br><span class=\"line\">  last: &quot;Doe&quot;,</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    const full = () =&gt; `$&#123;this.first&#125; $&#123;this.last&#125;`;</span><br><span class=\"line\">    return `Hello $&#123;full()&#125;`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高层级的函数\"><a href=\"#高层级的函数\" class=\"headerlink\" title=\"高层级的函数\"></a>高层级的函数</h3><p>在不必需的时候避免使用嵌套函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">[1, 2, 3].map(num =&gt; String(num));</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">[1, 2, 3].map(String);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>避免函数的多层次调用，合理使用结构来解决问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const plus1 = a =&gt; a + 1;</span><br><span class=\"line\">const mult2 = a =&gt; a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// 糟糕的</span><br><span class=\"line\">mult2(plus1(5)); // =&gt; 12</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);</span><br><span class=\"line\">const addThenMult = pipeline(plus1, mult2);</span><br><span class=\"line\">addThenMult(5); // =&gt; 12</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>缓存功能测试、大数据结构和任何昂贵的操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const contains = (arr, value) =&gt;</span><br><span class=\"line\">  Array.prototype.includes</span><br><span class=\"line\">    ? arr.includes(value)</span><br><span class=\"line\">    : arr.some(el =&gt; el === value);</span><br><span class=\"line\">contains([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;); // =&gt; false</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const contains = (() =&gt;</span><br><span class=\"line\">  Array.prototype.includes</span><br><span class=\"line\">    ? (arr, value) =&gt; arr.includes(value)</span><br><span class=\"line\">    : (arr, value) =&gt; arr.some(el =&gt; el === value)</span><br><span class=\"line\">)();</span><br><span class=\"line\">contains([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;); // =&gt; false</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p><code>const</code>优于 <code>let</code>优于 <code>var</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">var me = new Map();</span><br><span class=\"line\">me.set(&quot;name&quot;, &quot;Ben&quot;).set(&quot;country&quot;, &quot;Belgium&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const me = new Map();</span><br><span class=\"line\">me.set(&quot;name&quot;, &quot;Ben&quot;).set(&quot;country&quot;, &quot;Belgium&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"条件\"><a href=\"#条件\" class=\"headerlink\" title=\"条件\"></a>条件</h3><p><code>if+return语句</code>  优于 <code>if...else if...else</code> 和<code>switch</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">var grade;</span><br><span class=\"line\">if (result &lt; 50)</span><br><span class=\"line\">  grade = &quot;糟糕的&quot;;</span><br><span class=\"line\">else if (result &lt; 90)</span><br><span class=\"line\">  grade = &quot;推荐的&quot;;</span><br><span class=\"line\">else</span><br><span class=\"line\">  grade = &quot;excellent&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const grade = (() =&gt; &#123;</span><br><span class=\"line\">  if (result &lt; 50)</span><br><span class=\"line\">    return &quot;糟糕的&quot;;</span><br><span class=\"line\">  if (result &lt; 90)</span><br><span class=\"line\">    return &quot;推荐的&quot;;</span><br><span class=\"line\">  return &quot;excellent&quot;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对象迭代\"><a href=\"#对象迭代\" class=\"headerlink\" title=\"对象迭代\"></a>对象迭代</h3><p>避免使用<code>for...in</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const shared = &#123; foo: &quot;foo&quot; &#125;;</span><br><span class=\"line\">const obj = Object.create(shared, &#123;</span><br><span class=\"line\">  bar: &#123;</span><br><span class=\"line\">    value: &quot;bar&quot;,</span><br><span class=\"line\">    enumerable: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 糟糕的</span><br><span class=\"line\">for (var prop in obj) &#123;</span><br><span class=\"line\">  if (obj.hasOwnProperty(prop))</span><br><span class=\"line\">    console.log(prop);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">Object.keys(obj).forEach(prop =&gt; console.log(prop));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"把对象作为maps\"><a href=\"#把对象作为maps\" class=\"headerlink\" title=\"把对象作为maps\"></a>把对象作为maps</h3><p>虽然对象是一个合法的用例，但map是一个更好更强大的选择</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const me = &#123;</span><br><span class=\"line\">  name: &quot;Ben&quot;,</span><br><span class=\"line\">  age: 30</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var meSize = Object.keys(me).length;</span><br><span class=\"line\">meSize; // =&gt; 2</span><br><span class=\"line\">me.country = &quot;Belgium&quot;;</span><br><span class=\"line\">meSize++;</span><br><span class=\"line\">meSize; // =&gt; 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const me = new Map();</span><br><span class=\"line\">me.set(&quot;name&quot;, &quot;Ben&quot;);</span><br><span class=\"line\">me.set(&quot;age&quot;, 30);</span><br><span class=\"line\">me.size; // =&gt; 2</span><br><span class=\"line\">me.set(&quot;country&quot;, &quot;Belgium&quot;);</span><br><span class=\"line\">me.size; // =&gt; 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h3><p>对许多开发者来说，柯里化是一个带有国外范的强大形式。合理化地使用它是非常妙的，但是请不要滥用它</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const sum = a =&gt; b =&gt; a + b;</span><br><span class=\"line\">sum(5)(3); // =&gt; 8</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const sum = (a, b) =&gt; a + b;</span><br><span class=\"line\">sum(5, 3); // =&gt; 8</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可读性\"><a href=\"#可读性\" class=\"headerlink\" title=\"可读性\"></a>可读性</h3><p>不要使用一些表面看起来很巧妙的技巧来导致你代码的意思模糊不清(即不可读)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">foo || doSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">if (!foo) doSomething();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">void function() &#123; /* IIFE */ &#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">(function() &#123; /* IIFE */ &#125;());</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const n = ~~3.14;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const n = Math.floor(3.14);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码复用\"><a href=\"#代码复用\" class=\"headerlink\" title=\"代码复用\"></a>代码复用</h3><p>不要抗拒去创建一些体积小,高度可组合、可重用的函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">arr[arr.length - 1];</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const first = arr =&gt; arr[0];</span><br><span class=\"line\">const last = arr =&gt; first(arr.slice(-1));</span><br><span class=\"line\">last(arr);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const product = (a, b) =&gt; a * b;</span><br><span class=\"line\">const triple = n =&gt; n * 3;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const product = (a, b) =&gt; a * b;</span><br><span class=\"line\">const triple = product.bind(null, 3);</span><br></pre></td></tr></table></figure>\n<h3 id=\"依赖性\"><a href=\"#依赖性\" class=\"headerlink\" title=\"依赖性\"></a>依赖性</h3><p>减少依赖。第三方的代码是你不了解的,不要仅仅为了几个可复制的函数而加载整个第三方文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">var _ = require(&quot;underscore&quot;);</span><br><span class=\"line\">_.compact([&quot;foo&quot;, 0]));</span><br><span class=\"line\">_.unique([&quot;foo&quot;, &quot;foo&quot;]);</span><br><span class=\"line\">_.union([&quot;foo&quot;], [&quot;bar&quot;], [&quot;foo&quot;]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const compact = arr =&gt; arr.filter(el =&gt; el);</span><br><span class=\"line\">const unique = arr =&gt; [...Set(arr)];</span><br><span class=\"line\">const union = (...arr) =&gt; unique([].concat(...arr));</span><br><span class=\"line\"></span><br><span class=\"line\">compact([&quot;foo&quot;, 0]);</span><br><span class=\"line\">unique([&quot;foo&quot;, &quot;foo&quot;]);</span><br><span class=\"line\">union([&quot;foo&quot;], [&quot;bar&quot;], [&quot;foo&quot;]);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p><a href=\"/2015/12/24/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%80/\">前端代码指南(一)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%BA%8C/\">前端代码指南(二)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%89/\">前端代码指南(三)</a></p>\n<h1 id=\"javascript\"><a href=\"#javascript\" class=\"headerlink\" title=\"javascript\"></a>javascript</h1>","more":"<p><b style=\"color:#d44950\">注：</b> 下面ES6的语法</p>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>性能中最重要的是可读性、正确性和可表达性，JavaScript基本上永远不会成为你的性能瓶颈。我们可以通过图像压缩、网络存取和减少回流等来优化性能。如果你看过整篇篇文章后只能记住一条，请记住这条。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的 (albeit way faster)</span><br><span class=\"line\">const arr = [1, 2, 3, 4];</span><br><span class=\"line\">const len = arr.length;</span><br><span class=\"line\">var i = -1;</span><br><span class=\"line\">var result = [];</span><br><span class=\"line\">while (++i &lt; len) &#123;</span><br><span class=\"line\">  var n = arr[i];</span><br><span class=\"line\">  if (n % 2 &gt; 0) continue;</span><br><span class=\"line\">  result.push(n * n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const arr = [1, 2, 3, 4];</span><br><span class=\"line\">const isEven = n =&gt; n % 2 == 0;</span><br><span class=\"line\">const square = n =&gt; n * n;</span><br><span class=\"line\"></span><br><span class=\"line\">const result = arr.filter(isEven).map(square);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"无领域\"><a href=\"#无领域\" class=\"headerlink\" title=\"无领域\"></a>无领域</h3><p>尽量保持你函数的纯净。理想地，应该创建无副作用的、不使用外部数据的并返回新对象(而不是改变现有的)的函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const merge = (target, ...sources) =&gt; Object.assign(target, ...sources);</span><br><span class=\"line\">merge(&#123; foo: &quot;foo&quot; &#125;, &#123; bar: &quot;bar&quot; &#125;); // =&gt; &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources);</span><br><span class=\"line\">merge(&#123; foo: &quot;foo&quot; &#125;, &#123; bar: &quot;bar&quot; &#125;); // =&gt; &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原生\"><a href=\"#原生\" class=\"headerlink\" title=\"原生\"></a>原生</h3><p>尽可能依赖原生的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const toArray = obj =&gt; [].slice.call(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const toArray = (() =&gt;</span><br><span class=\"line\">  Array.from ? Array.from : obj =&gt; [].slice.call(obj)</span><br><span class=\"line\">)();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"强制\"><a href=\"#强制\" class=\"headerlink\" title=\"强制\"></a>强制</h3><p>不要在不必要的时候使用隐形强制</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">if (x === undefined || x === null) &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">if (x == undefined) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><p>不要使用循环,因为他们强迫你使用可变的对象。可以依赖<code>array.prototype</code>方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const sum = arr =&gt; &#123;</span><br><span class=\"line\">  var sum = 0;</span><br><span class=\"line\">  var i = -1;</span><br><span class=\"line\">  for (;arr[++i];) &#123;</span><br><span class=\"line\">    sum += arr[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return sum;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">sum([1, 2, 3]); // =&gt; 6</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const sum = arr =&gt;</span><br><span class=\"line\">  arr.reduce((x, y) =&gt; x + y);</span><br><span class=\"line\"></span><br><span class=\"line\">sum([1, 2, 3]); // =&gt; 6</span><br></pre></td></tr></table></figure>\n\n<p>如果你不能避免使用循环,或者使用<code>array.prototype</code>方法对你来说是一种受虐的行为,可以使用递归</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const createDivs = howMany =&gt; &#123;</span><br><span class=\"line\">  while (howMany--) &#123;</span><br><span class=\"line\">    document.body.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;div&gt;&lt;/div&gt;&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">createDivs(5);</span><br><span class=\"line\"></span><br><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const createDivs = howMany =&gt;</span><br><span class=\"line\">  [...Array(howMany)].forEach(() =&gt;</span><br><span class=\"line\">    document.body.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;div&gt;&lt;/div&gt;&quot;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">createDivs(5);</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const createDivs = howMany =&gt; &#123;</span><br><span class=\"line\">  if (!howMany) return;</span><br><span class=\"line\">  document.body.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;div&gt;&lt;/div&gt;&quot;);</span><br><span class=\"line\">  return createDivs(howMany - 1);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">createDivs(5);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>忘记<code>arguments </code>对象。使用其余的参数才是更好的选择,这是因为：</p>\n<ol>\n<li>其余的参数是被命名的,所以你可以给这个函数的参数一个更好的注意</li>\n<li>其余的参数是一个真正的数组,这使得它更容易使用。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const sortNumbers = () =&gt;</span><br><span class=\"line\">  Array.prototype.slice.call(arguments).sort();</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const sortNumbers = (...numbers) =&gt; numbers.sort();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Apply\"><a href=\"#Apply\" class=\"headerlink\" title=\"Apply\"></a>Apply</h3><p>忘记Apply()函数，使用扩展来代替</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const greet = (first, last) =&gt; `Hi $&#123;first&#125; $&#123;last&#125;`;</span><br><span class=\"line\">const person = [&quot;John&quot;, &quot;Doe&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 糟糕的</span><br><span class=\"line\">greet.apply(null, person);</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">greet(...person);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h3><p>忘记bind()函数，这里有个更惯用的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">[&quot;foo&quot;, &quot;bar&quot;].forEach(func.bind(this));</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">[&quot;foo&quot;, &quot;bar&quot;].forEach(func, this);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const person = &#123;</span><br><span class=\"line\">  first: &quot;John&quot;,</span><br><span class=\"line\">  last: &quot;Doe&quot;,</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    const full = function() &#123;</span><br><span class=\"line\">      return `$&#123;this.first&#125; $&#123;this.last&#125;`;</span><br><span class=\"line\">    &#125;.bind(this);</span><br><span class=\"line\">    return `Hello $&#123;full()&#125;`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const person = &#123;</span><br><span class=\"line\">  first: &quot;John&quot;,</span><br><span class=\"line\">  last: &quot;Doe&quot;,</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    const full = () =&gt; `$&#123;this.first&#125; $&#123;this.last&#125;`;</span><br><span class=\"line\">    return `Hello $&#123;full()&#125;`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高层级的函数\"><a href=\"#高层级的函数\" class=\"headerlink\" title=\"高层级的函数\"></a>高层级的函数</h3><p>在不必需的时候避免使用嵌套函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">[1, 2, 3].map(num =&gt; String(num));</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">[1, 2, 3].map(String);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>避免函数的多层次调用，合理使用结构来解决问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const plus1 = a =&gt; a + 1;</span><br><span class=\"line\">const mult2 = a =&gt; a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// 糟糕的</span><br><span class=\"line\">mult2(plus1(5)); // =&gt; 12</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);</span><br><span class=\"line\">const addThenMult = pipeline(plus1, mult2);</span><br><span class=\"line\">addThenMult(5); // =&gt; 12</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>缓存功能测试、大数据结构和任何昂贵的操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const contains = (arr, value) =&gt;</span><br><span class=\"line\">  Array.prototype.includes</span><br><span class=\"line\">    ? arr.includes(value)</span><br><span class=\"line\">    : arr.some(el =&gt; el === value);</span><br><span class=\"line\">contains([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;); // =&gt; false</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const contains = (() =&gt;</span><br><span class=\"line\">  Array.prototype.includes</span><br><span class=\"line\">    ? (arr, value) =&gt; arr.includes(value)</span><br><span class=\"line\">    : (arr, value) =&gt; arr.some(el =&gt; el === value)</span><br><span class=\"line\">)();</span><br><span class=\"line\">contains([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;); // =&gt; false</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p><code>const</code>优于 <code>let</code>优于 <code>var</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">var me = new Map();</span><br><span class=\"line\">me.set(&quot;name&quot;, &quot;Ben&quot;).set(&quot;country&quot;, &quot;Belgium&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const me = new Map();</span><br><span class=\"line\">me.set(&quot;name&quot;, &quot;Ben&quot;).set(&quot;country&quot;, &quot;Belgium&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"条件\"><a href=\"#条件\" class=\"headerlink\" title=\"条件\"></a>条件</h3><p><code>if+return语句</code>  优于 <code>if...else if...else</code> 和<code>switch</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">var grade;</span><br><span class=\"line\">if (result &lt; 50)</span><br><span class=\"line\">  grade = &quot;糟糕的&quot;;</span><br><span class=\"line\">else if (result &lt; 90)</span><br><span class=\"line\">  grade = &quot;推荐的&quot;;</span><br><span class=\"line\">else</span><br><span class=\"line\">  grade = &quot;excellent&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const grade = (() =&gt; &#123;</span><br><span class=\"line\">  if (result &lt; 50)</span><br><span class=\"line\">    return &quot;糟糕的&quot;;</span><br><span class=\"line\">  if (result &lt; 90)</span><br><span class=\"line\">    return &quot;推荐的&quot;;</span><br><span class=\"line\">  return &quot;excellent&quot;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对象迭代\"><a href=\"#对象迭代\" class=\"headerlink\" title=\"对象迭代\"></a>对象迭代</h3><p>避免使用<code>for...in</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const shared = &#123; foo: &quot;foo&quot; &#125;;</span><br><span class=\"line\">const obj = Object.create(shared, &#123;</span><br><span class=\"line\">  bar: &#123;</span><br><span class=\"line\">    value: &quot;bar&quot;,</span><br><span class=\"line\">    enumerable: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 糟糕的</span><br><span class=\"line\">for (var prop in obj) &#123;</span><br><span class=\"line\">  if (obj.hasOwnProperty(prop))</span><br><span class=\"line\">    console.log(prop);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">Object.keys(obj).forEach(prop =&gt; console.log(prop));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"把对象作为maps\"><a href=\"#把对象作为maps\" class=\"headerlink\" title=\"把对象作为maps\"></a>把对象作为maps</h3><p>虽然对象是一个合法的用例，但map是一个更好更强大的选择</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const me = &#123;</span><br><span class=\"line\">  name: &quot;Ben&quot;,</span><br><span class=\"line\">  age: 30</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var meSize = Object.keys(me).length;</span><br><span class=\"line\">meSize; // =&gt; 2</span><br><span class=\"line\">me.country = &quot;Belgium&quot;;</span><br><span class=\"line\">meSize++;</span><br><span class=\"line\">meSize; // =&gt; 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const me = new Map();</span><br><span class=\"line\">me.set(&quot;name&quot;, &quot;Ben&quot;);</span><br><span class=\"line\">me.set(&quot;age&quot;, 30);</span><br><span class=\"line\">me.size; // =&gt; 2</span><br><span class=\"line\">me.set(&quot;country&quot;, &quot;Belgium&quot;);</span><br><span class=\"line\">me.size; // =&gt; 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h3><p>对许多开发者来说，柯里化是一个带有国外范的强大形式。合理化地使用它是非常妙的，但是请不要滥用它</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const sum = a =&gt; b =&gt; a + b;</span><br><span class=\"line\">sum(5)(3); // =&gt; 8</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const sum = (a, b) =&gt; a + b;</span><br><span class=\"line\">sum(5, 3); // =&gt; 8</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可读性\"><a href=\"#可读性\" class=\"headerlink\" title=\"可读性\"></a>可读性</h3><p>不要使用一些表面看起来很巧妙的技巧来导致你代码的意思模糊不清(即不可读)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">foo || doSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">if (!foo) doSomething();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">void function() &#123; /* IIFE */ &#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">(function() &#123; /* IIFE */ &#125;());</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const n = ~~3.14;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const n = Math.floor(3.14);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码复用\"><a href=\"#代码复用\" class=\"headerlink\" title=\"代码复用\"></a>代码复用</h3><p>不要抗拒去创建一些体积小,高度可组合、可重用的函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">arr[arr.length - 1];</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const first = arr =&gt; arr[0];</span><br><span class=\"line\">const last = arr =&gt; first(arr.slice(-1));</span><br><span class=\"line\">last(arr);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">const product = (a, b) =&gt; a * b;</span><br><span class=\"line\">const triple = n =&gt; n * 3;</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const product = (a, b) =&gt; a * b;</span><br><span class=\"line\">const triple = product.bind(null, 3);</span><br></pre></td></tr></table></figure>\n<h3 id=\"依赖性\"><a href=\"#依赖性\" class=\"headerlink\" title=\"依赖性\"></a>依赖性</h3><p>减少依赖。第三方的代码是你不了解的,不要仅仅为了几个可复制的函数而加载整个第三方文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 糟糕的</span><br><span class=\"line\">var _ = require(&quot;underscore&quot;);</span><br><span class=\"line\">_.compact([&quot;foo&quot;, 0]));</span><br><span class=\"line\">_.unique([&quot;foo&quot;, &quot;foo&quot;]);</span><br><span class=\"line\">_.union([&quot;foo&quot;], [&quot;bar&quot;], [&quot;foo&quot;]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 推荐的</span><br><span class=\"line\">const compact = arr =&gt; arr.filter(el =&gt; el);</span><br><span class=\"line\">const unique = arr =&gt; [...Set(arr)];</span><br><span class=\"line\">const union = (...arr) =&gt; unique([].concat(...arr));</span><br><span class=\"line\"></span><br><span class=\"line\">compact([&quot;foo&quot;, 0]);</span><br><span class=\"line\">unique([&quot;foo&quot;, &quot;foo&quot;]);</span><br><span class=\"line\">union([&quot;foo&quot;], [&quot;bar&quot;], [&quot;foo&quot;]);</span><br></pre></td></tr></table></figure>"},{"_content":"# this\n\n## 绑定时机\n\n1. 非箭头函数函数\n    声明时\n2. 箭头函数\n    调用时\n\n## 绑定机制\n1. 默认绑定\n    `this`指向全局对象\n2. 隐含绑定：拥有调用者\n    `this`指向调用者\n3. 明确绑定\n    call\n    apply\n4. new 绑定\n\nnew 绑定 > 明确绑定 > 隐含绑定 > 默认绑定","source":"_posts/前端工作随记.md","raw":"# this\n\n## 绑定时机\n\n1. 非箭头函数函数\n    声明时\n2. 箭头函数\n    调用时\n\n## 绑定机制\n1. 默认绑定\n    `this`指向全局对象\n2. 隐含绑定：拥有调用者\n    `this`指向调用者\n3. 明确绑定\n    call\n    apply\n4. new 绑定\n\nnew 绑定 > 明确绑定 > 隐含绑定 > 默认绑定","slug":"前端工作随记","published":1,"date":"2021-12-06T06:07:06.306Z","updated":"2021-12-06T06:07:06.306Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomc0040y4v29gh54uqj","content":"<h1 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h1><h2 id=\"绑定时机\"><a href=\"#绑定时机\" class=\"headerlink\" title=\"绑定时机\"></a>绑定时机</h2><ol>\n<li>非箭头函数函数<br> 声明时</li>\n<li>箭头函数<br> 调用时</li>\n</ol>\n<h2 id=\"绑定机制\"><a href=\"#绑定机制\" class=\"headerlink\" title=\"绑定机制\"></a>绑定机制</h2><ol>\n<li>默认绑定<br> <code>this</code>指向全局对象</li>\n<li>隐含绑定：拥有调用者<br> <code>this</code>指向调用者</li>\n<li>明确绑定<br> call<br> apply</li>\n<li>new 绑定</li>\n</ol>\n<p>new 绑定 &gt; 明确绑定 &gt; 隐含绑定 &gt; 默认绑定</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h1><h2 id=\"绑定时机\"><a href=\"#绑定时机\" class=\"headerlink\" title=\"绑定时机\"></a>绑定时机</h2><ol>\n<li>非箭头函数函数<br> 声明时</li>\n<li>箭头函数<br> 调用时</li>\n</ol>\n<h2 id=\"绑定机制\"><a href=\"#绑定机制\" class=\"headerlink\" title=\"绑定机制\"></a>绑定机制</h2><ol>\n<li>默认绑定<br> <code>this</code>指向全局对象</li>\n<li>隐含绑定：拥有调用者<br> <code>this</code>指向调用者</li>\n<li>明确绑定<br> call<br> apply</li>\n<li>new 绑定</li>\n</ol>\n<p>new 绑定 &gt; 明确绑定 &gt; 隐含绑定 &gt; 默认绑定</p>\n"},{"title":"前端代码指南(二)","date":"2015-12-25T02:05:47.000Z","description":"前端代码指南","_content":"\n[前端代码指南(一)](/2015/12/24/前端代码指南-一/)\n[前端代码指南(二)](/2015/12/25/前端代码指南-二/)\n[前端代码指南(三)](/2015/12/25/前端代码指南-三/)\n\n# CSS\n\n<!-- more -->\n\n### 分号\n\n分号是CSS语句的分离器,请把它放在句尾。\n\n```\n/* 糟糕的 */\ndiv {\n  color: red\n}\n\n/* 推荐的 */\ndiv {\n  color: red;\n}\n```\n\n### 盒模型\n最理想的情况是盒模型在整个文档是一样的。全局设置* { box-sizing:border-box;}是可以的,但最好不要在特定的元素上改变默认的盒模型。\n```\n/* 糟糕的 */\ndiv {\n  width: 100%;\n  padding: 10px;\n  box-sizing: border-box;\n}\n\n/* 推荐的 */\ndiv {\n  padding: 10px;\n}\n```\n\n### 文档流\n 不要改变一个元素的默认样式，尽可能保持元素在自然的文档流中。例如,删除图像下面的空白不应该改变其默认显示:\n```\n/* 糟糕的 */\nimg {\n  display: block;\n}\n\n/* 推荐的 */\nimg {\n  vertical-align: middle;\n}\n```\n同样的，尽可能不要使元素脱离文档流\n```\n/* 糟糕的 */\ndiv {\n  width: 100px;\n  position: absolute;\n  right: 0;\n}\n\n/* 推荐的 */\ndiv {\n  width: 100px;\n  margin-left: auto;\n}\n```\n\n### 定位\ncss有很多方法来定位元素,但是最好不要使用下面的属性/值\n```\ndisplay: block;\ndisplay: flex;\nposition: relative;\nposition: sticky;\nposition: absolute;\nposition: fixed;\n```\n\n### 选择器\n减少选择器与DOM的耦合度。当你的选择器匹配的元素超过3层结构(伪类、后代或兄弟元素)。考虑添加一个类来匹配你想要的元素吧\n```\n/* 糟糕的 */\ndiv:first-of-type :last-child > p ~ *\n\n/* 推荐的 */\ndiv:first-of-type .info\n```\n\n避免过载你的选择器\n```\n/* 糟糕的 */\nimg[src$=svg], ul > li:first-child {\n  opacity: 0;\n}\n\n/* 推荐的 */\n[src$=svg], ul > :first-child {\n  opacity: 0;\n}\n```\n\n### 特性\n\n不要让属性值和选择器难以被覆盖(应该是指优先级不要过高)，减少使用id和!important的使用\n```\n/* 糟糕的 */\n.bar {\n  color: green !important;\n}\n.foo {\n  color: red;\n}\n\n/* 推荐的 */\n.foo.bar {\n  color: green;\n}\n.foo {\n  color: red;\n}\n```\n\n### 覆盖\n覆盖样式会导致选择器和调试变得困难，请尽量避免\n```\n/* 糟糕的 */\nli {\n  visibility: hidden;\n}\nli:first-child {\n  visibility: visible;\n}\n\n/* 推荐的 */\nli + li {\n  visibility: hidden;\n}\n```\n\n### 继承\n不要重复书写可以继承的样式。\n```\n/* 糟糕的 */\ndiv h1, div p {\n  text-shadow: 0 1px 0 #fff;\n}\n\n/* 推荐的 */\ndiv {\n  text-shadow: 0 1px 0 #fff;\n}\n```\n\n### 简洁\n保持你的代码简洁，尽量使用简写属性,避免使用多个属性。\n```\n/* 糟糕的 */\ndiv {\n  transition: all 1s;\n  top: 50%;\n  margin-top: -10px;\n  padding-top: 5px;\n  padding-right: 10px;\n  padding-bottom: 20px;\n  padding-left: 10px;\n}\n\n/* 推荐的 */\ndiv {\n  transition: 1s;\n  top: calc(50% - 10px);\n  padding: 5px 10px 20px;\n}\n```\n\n### 语言\n英文优于数学表达式\n```\n/* 糟糕的 */\n:nth-child(2n + 1) {\n  transform: rotate(360deg);\n}\n\n/* 推荐的 */\n:nth-child(odd) {\n  transform: rotate(1turn);\n}\n```\n\n### 前缀\n积极删除过时的前缀。\n```\n/* 糟糕的 */\ndiv {\n  transform: scale(2);\n  -webkit-transform: scale(2);\n  -moz-transform: scale(2);\n  -ms-transform: scale(2);\n  transition: 1s;\n  -webkit-transition: 1s;\n  -moz-transition: 1s;\n  -ms-transition: 1s;\n}\n\n/* 推荐的 */\ndiv {\n  -webkit-transform: scale(2);\n  transform: scale(2);\n  transition: 1s;\n}\n```\n\n### 动画\n`animations`和`transitions` ，优先选择`transitions` 。除了 `opacity` 和 `transform`属性，其他属性避免使用`animations`。\n\n```\n/* 糟糕的 */\ndiv:hover {\n  animation: move 1s forwards;\n}\n@keyframes move {\n  100% {\n    margin-left: 100px;\n  }\n}\n\n/* 推荐的 */\ndiv:hover {\n  transition: 1s;\n  transform: translateX(100px);\n}\n```\n\n### 单位\n不要对不需要使用单位的值使用单位；如果你要使用相对单位最好使用`rem`；使用秒而不是毫秒\n```\n/* 糟糕的 */\ndiv {\n  margin: 0px;\n  font-size: .9em;\n  line-height: 22px;\n  transition: 500ms;\n}\n\n/* 推荐的 */\ndiv {\n  margin: 0;\n  font-size: .9rem;\n  line-height: 1.5;\n  transition: .5s;\n}\n```\n### 颜色\n如果你需要使用透明度，请使用`rgba`\n```\n/* 糟糕的 */\ndiv {\n  color: hsl(103, 54%, 43%);\n}\n\n/* 推荐的 */\ndiv {\n  color: #5a3;\n}\n```\n\n### 绘制\n如果资源文件可以轻易在css中绘制出来，就避免HTTP请求来加载\n\n```\n/* 糟糕的 */\ndiv::before {\n  content: url(white-circle.svg);\n}\n\n/* 推荐的 */\ndiv::before {\n  content: \"\";\n  display: block;\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background: #fff;\n}\n```\n\n### Hacks\n尽量不要使用Hacks\n```\n/* 糟糕的 */\ndiv {\n  // position: relative;\n  transform: translateZ(0);\n}\n\n/* 推荐的 */\ndiv {\n  /* position: relative; */\n  will-change: transform;\n}\n```\n","source":"_posts/前端代码指南-二.md","raw":"title: 前端代码指南(二)\ndate: 2015-12-25 10:05:47\ntags: [web]\ndescription: 前端代码指南\n\n---\n\n[前端代码指南(一)](/2015/12/24/前端代码指南-一/)\n[前端代码指南(二)](/2015/12/25/前端代码指南-二/)\n[前端代码指南(三)](/2015/12/25/前端代码指南-三/)\n\n# CSS\n\n<!-- more -->\n\n### 分号\n\n分号是CSS语句的分离器,请把它放在句尾。\n\n```\n/* 糟糕的 */\ndiv {\n  color: red\n}\n\n/* 推荐的 */\ndiv {\n  color: red;\n}\n```\n\n### 盒模型\n最理想的情况是盒模型在整个文档是一样的。全局设置* { box-sizing:border-box;}是可以的,但最好不要在特定的元素上改变默认的盒模型。\n```\n/* 糟糕的 */\ndiv {\n  width: 100%;\n  padding: 10px;\n  box-sizing: border-box;\n}\n\n/* 推荐的 */\ndiv {\n  padding: 10px;\n}\n```\n\n### 文档流\n 不要改变一个元素的默认样式，尽可能保持元素在自然的文档流中。例如,删除图像下面的空白不应该改变其默认显示:\n```\n/* 糟糕的 */\nimg {\n  display: block;\n}\n\n/* 推荐的 */\nimg {\n  vertical-align: middle;\n}\n```\n同样的，尽可能不要使元素脱离文档流\n```\n/* 糟糕的 */\ndiv {\n  width: 100px;\n  position: absolute;\n  right: 0;\n}\n\n/* 推荐的 */\ndiv {\n  width: 100px;\n  margin-left: auto;\n}\n```\n\n### 定位\ncss有很多方法来定位元素,但是最好不要使用下面的属性/值\n```\ndisplay: block;\ndisplay: flex;\nposition: relative;\nposition: sticky;\nposition: absolute;\nposition: fixed;\n```\n\n### 选择器\n减少选择器与DOM的耦合度。当你的选择器匹配的元素超过3层结构(伪类、后代或兄弟元素)。考虑添加一个类来匹配你想要的元素吧\n```\n/* 糟糕的 */\ndiv:first-of-type :last-child > p ~ *\n\n/* 推荐的 */\ndiv:first-of-type .info\n```\n\n避免过载你的选择器\n```\n/* 糟糕的 */\nimg[src$=svg], ul > li:first-child {\n  opacity: 0;\n}\n\n/* 推荐的 */\n[src$=svg], ul > :first-child {\n  opacity: 0;\n}\n```\n\n### 特性\n\n不要让属性值和选择器难以被覆盖(应该是指优先级不要过高)，减少使用id和!important的使用\n```\n/* 糟糕的 */\n.bar {\n  color: green !important;\n}\n.foo {\n  color: red;\n}\n\n/* 推荐的 */\n.foo.bar {\n  color: green;\n}\n.foo {\n  color: red;\n}\n```\n\n### 覆盖\n覆盖样式会导致选择器和调试变得困难，请尽量避免\n```\n/* 糟糕的 */\nli {\n  visibility: hidden;\n}\nli:first-child {\n  visibility: visible;\n}\n\n/* 推荐的 */\nli + li {\n  visibility: hidden;\n}\n```\n\n### 继承\n不要重复书写可以继承的样式。\n```\n/* 糟糕的 */\ndiv h1, div p {\n  text-shadow: 0 1px 0 #fff;\n}\n\n/* 推荐的 */\ndiv {\n  text-shadow: 0 1px 0 #fff;\n}\n```\n\n### 简洁\n保持你的代码简洁，尽量使用简写属性,避免使用多个属性。\n```\n/* 糟糕的 */\ndiv {\n  transition: all 1s;\n  top: 50%;\n  margin-top: -10px;\n  padding-top: 5px;\n  padding-right: 10px;\n  padding-bottom: 20px;\n  padding-left: 10px;\n}\n\n/* 推荐的 */\ndiv {\n  transition: 1s;\n  top: calc(50% - 10px);\n  padding: 5px 10px 20px;\n}\n```\n\n### 语言\n英文优于数学表达式\n```\n/* 糟糕的 */\n:nth-child(2n + 1) {\n  transform: rotate(360deg);\n}\n\n/* 推荐的 */\n:nth-child(odd) {\n  transform: rotate(1turn);\n}\n```\n\n### 前缀\n积极删除过时的前缀。\n```\n/* 糟糕的 */\ndiv {\n  transform: scale(2);\n  -webkit-transform: scale(2);\n  -moz-transform: scale(2);\n  -ms-transform: scale(2);\n  transition: 1s;\n  -webkit-transition: 1s;\n  -moz-transition: 1s;\n  -ms-transition: 1s;\n}\n\n/* 推荐的 */\ndiv {\n  -webkit-transform: scale(2);\n  transform: scale(2);\n  transition: 1s;\n}\n```\n\n### 动画\n`animations`和`transitions` ，优先选择`transitions` 。除了 `opacity` 和 `transform`属性，其他属性避免使用`animations`。\n\n```\n/* 糟糕的 */\ndiv:hover {\n  animation: move 1s forwards;\n}\n@keyframes move {\n  100% {\n    margin-left: 100px;\n  }\n}\n\n/* 推荐的 */\ndiv:hover {\n  transition: 1s;\n  transform: translateX(100px);\n}\n```\n\n### 单位\n不要对不需要使用单位的值使用单位；如果你要使用相对单位最好使用`rem`；使用秒而不是毫秒\n```\n/* 糟糕的 */\ndiv {\n  margin: 0px;\n  font-size: .9em;\n  line-height: 22px;\n  transition: 500ms;\n}\n\n/* 推荐的 */\ndiv {\n  margin: 0;\n  font-size: .9rem;\n  line-height: 1.5;\n  transition: .5s;\n}\n```\n### 颜色\n如果你需要使用透明度，请使用`rgba`\n```\n/* 糟糕的 */\ndiv {\n  color: hsl(103, 54%, 43%);\n}\n\n/* 推荐的 */\ndiv {\n  color: #5a3;\n}\n```\n\n### 绘制\n如果资源文件可以轻易在css中绘制出来，就避免HTTP请求来加载\n\n```\n/* 糟糕的 */\ndiv::before {\n  content: url(white-circle.svg);\n}\n\n/* 推荐的 */\ndiv::before {\n  content: \"\";\n  display: block;\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background: #fff;\n}\n```\n\n### Hacks\n尽量不要使用Hacks\n```\n/* 糟糕的 */\ndiv {\n  // position: relative;\n  transform: translateZ(0);\n}\n\n/* 推荐的 */\ndiv {\n  /* position: relative; */\n  will-change: transform;\n}\n```\n","slug":"前端代码指南-二","published":1,"updated":"2021-12-06T06:07:06.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomd0042y4v274gmfh4e","content":"<p><a href=\"/2015/12/24/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%80/\">前端代码指南(一)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%BA%8C/\">前端代码指南(二)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%89/\">前端代码指南(三)</a></p>\n<h1 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h1><span id=\"more\"></span>\n\n<h3 id=\"分号\"><a href=\"#分号\" class=\"headerlink\" title=\"分号\"></a>分号</h3><p>分号是CSS语句的分离器,请把它放在句尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  color: red</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h3><p>最理想的情况是盒模型在整个文档是一样的。全局设置* { box-sizing:border-box;}是可以的,但最好不要在特定的元素上改变默认的盒模型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  padding: 10px;</span><br><span class=\"line\">  box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  padding: 10px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"文档流\"><a href=\"#文档流\" class=\"headerlink\" title=\"文档流\"></a>文档流</h3><p> 不要改变一个元素的默认样式，尽可能保持元素在自然的文档流中。例如,删除图像下面的空白不应该改变其默认显示:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">img &#123;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">img &#123;</span><br><span class=\"line\">  vertical-align: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的，尽可能不要使元素脱离文档流</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  margin-left: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3><p>css有很多方法来定位元素,但是最好不要使用下面的属性/值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: block;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">position: relative;</span><br><span class=\"line\">position: sticky;</span><br><span class=\"line\">position: absolute;</span><br><span class=\"line\">position: fixed;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><p>减少选择器与DOM的耦合度。当你的选择器匹配的元素超过3层结构(伪类、后代或兄弟元素)。考虑添加一个类来匹配你想要的元素吧</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div:first-of-type :last-child &gt; p ~ *</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div:first-of-type .info</span><br></pre></td></tr></table></figure>\n\n<p>避免过载你的选择器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">img[src$=svg], ul &gt; li:first-child &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">[src$=svg], ul &gt; :first-child &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>不要让属性值和选择器难以被覆盖(应该是指优先级不要过高)，减少使用id和!important的使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">.bar &#123;</span><br><span class=\"line\">  color: green !important;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.foo &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">.foo.bar &#123;</span><br><span class=\"line\">  color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.foo &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"覆盖\"><a href=\"#覆盖\" class=\"headerlink\" title=\"覆盖\"></a>覆盖</h3><p>覆盖样式会导致选择器和调试变得困难，请尽量避免</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">li &#123;</span><br><span class=\"line\">  visibility: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">li:first-child &#123;</span><br><span class=\"line\">  visibility: visible;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">li + li &#123;</span><br><span class=\"line\">  visibility: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>不要重复书写可以继承的样式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div h1, div p &#123;</span><br><span class=\"line\">  text-shadow: 0 1px 0 #fff;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  text-shadow: 0 1px 0 #fff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简洁\"><a href=\"#简洁\" class=\"headerlink\" title=\"简洁\"></a>简洁</h3><p>保持你的代码简洁，尽量使用简写属性,避免使用多个属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  transition: all 1s;</span><br><span class=\"line\">  top: 50%;</span><br><span class=\"line\">  margin-top: -10px;</span><br><span class=\"line\">  padding-top: 5px;</span><br><span class=\"line\">  padding-right: 10px;</span><br><span class=\"line\">  padding-bottom: 20px;</span><br><span class=\"line\">  padding-left: 10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  transition: 1s;</span><br><span class=\"line\">  top: calc(50% - 10px);</span><br><span class=\"line\">  padding: 5px 10px 20px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h3><p>英文优于数学表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">:nth-child(2n + 1) &#123;</span><br><span class=\"line\">  transform: rotate(360deg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">:nth-child(odd) &#123;</span><br><span class=\"line\">  transform: rotate(1turn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"前缀\"><a href=\"#前缀\" class=\"headerlink\" title=\"前缀\"></a>前缀</h3><p>积极删除过时的前缀。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  transform: scale(2);</span><br><span class=\"line\">  -webkit-transform: scale(2);</span><br><span class=\"line\">  -moz-transform: scale(2);</span><br><span class=\"line\">  -ms-transform: scale(2);</span><br><span class=\"line\">  transition: 1s;</span><br><span class=\"line\">  -webkit-transition: 1s;</span><br><span class=\"line\">  -moz-transition: 1s;</span><br><span class=\"line\">  -ms-transition: 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  -webkit-transform: scale(2);</span><br><span class=\"line\">  transform: scale(2);</span><br><span class=\"line\">  transition: 1s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h3><p><code>animations</code>和<code>transitions</code> ，优先选择<code>transitions</code> 。除了 <code>opacity</code> 和 <code>transform</code>属性，其他属性避免使用<code>animations</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div:hover &#123;</span><br><span class=\"line\">  animation: move 1s forwards;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@keyframes move &#123;</span><br><span class=\"line\">  100% &#123;</span><br><span class=\"line\">    margin-left: 100px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div:hover &#123;</span><br><span class=\"line\">  transition: 1s;</span><br><span class=\"line\">  transform: translateX(100px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单位\"><a href=\"#单位\" class=\"headerlink\" title=\"单位\"></a>单位</h3><p>不要对不需要使用单位的值使用单位；如果你要使用相对单位最好使用<code>rem</code>；使用秒而不是毫秒</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  margin: 0px;</span><br><span class=\"line\">  font-size: .9em;</span><br><span class=\"line\">  line-height: 22px;</span><br><span class=\"line\">  transition: 500ms;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  margin: 0;</span><br><span class=\"line\">  font-size: .9rem;</span><br><span class=\"line\">  line-height: 1.5;</span><br><span class=\"line\">  transition: .5s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h3><p>如果你需要使用透明度，请使用<code>rgba</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  color: hsl(103, 54%, 43%);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  color: #5a3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h3><p>如果资源文件可以轻易在css中绘制出来，就避免HTTP请求来加载</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div::before &#123;</span><br><span class=\"line\">  content: url(white-circle.svg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div::before &#123;</span><br><span class=\"line\">  content: &quot;&quot;;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">  width: 20px;</span><br><span class=\"line\">  height: 20px;</span><br><span class=\"line\">  border-radius: 50%;</span><br><span class=\"line\">  background: #fff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hacks\"><a href=\"#Hacks\" class=\"headerlink\" title=\"Hacks\"></a>Hacks</h3><p>尽量不要使用Hacks</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  // position: relative;</span><br><span class=\"line\">  transform: translateZ(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  /* position: relative; */</span><br><span class=\"line\">  will-change: transform;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"/2015/12/24/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%80/\">前端代码指南(一)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%BA%8C/\">前端代码指南(二)</a><br><a href=\"/2015/12/25/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%89/\">前端代码指南(三)</a></p>\n<h1 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h1>","more":"<h3 id=\"分号\"><a href=\"#分号\" class=\"headerlink\" title=\"分号\"></a>分号</h3><p>分号是CSS语句的分离器,请把它放在句尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  color: red</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h3><p>最理想的情况是盒模型在整个文档是一样的。全局设置* { box-sizing:border-box;}是可以的,但最好不要在特定的元素上改变默认的盒模型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  padding: 10px;</span><br><span class=\"line\">  box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  padding: 10px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"文档流\"><a href=\"#文档流\" class=\"headerlink\" title=\"文档流\"></a>文档流</h3><p> 不要改变一个元素的默认样式，尽可能保持元素在自然的文档流中。例如,删除图像下面的空白不应该改变其默认显示:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">img &#123;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">img &#123;</span><br><span class=\"line\">  vertical-align: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的，尽可能不要使元素脱离文档流</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  margin-left: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3><p>css有很多方法来定位元素,但是最好不要使用下面的属性/值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: block;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">position: relative;</span><br><span class=\"line\">position: sticky;</span><br><span class=\"line\">position: absolute;</span><br><span class=\"line\">position: fixed;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><p>减少选择器与DOM的耦合度。当你的选择器匹配的元素超过3层结构(伪类、后代或兄弟元素)。考虑添加一个类来匹配你想要的元素吧</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div:first-of-type :last-child &gt; p ~ *</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div:first-of-type .info</span><br></pre></td></tr></table></figure>\n\n<p>避免过载你的选择器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">img[src$=svg], ul &gt; li:first-child &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">[src$=svg], ul &gt; :first-child &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>不要让属性值和选择器难以被覆盖(应该是指优先级不要过高)，减少使用id和!important的使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">.bar &#123;</span><br><span class=\"line\">  color: green !important;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.foo &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">.foo.bar &#123;</span><br><span class=\"line\">  color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.foo &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"覆盖\"><a href=\"#覆盖\" class=\"headerlink\" title=\"覆盖\"></a>覆盖</h3><p>覆盖样式会导致选择器和调试变得困难，请尽量避免</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">li &#123;</span><br><span class=\"line\">  visibility: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">li:first-child &#123;</span><br><span class=\"line\">  visibility: visible;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">li + li &#123;</span><br><span class=\"line\">  visibility: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>不要重复书写可以继承的样式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div h1, div p &#123;</span><br><span class=\"line\">  text-shadow: 0 1px 0 #fff;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  text-shadow: 0 1px 0 #fff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简洁\"><a href=\"#简洁\" class=\"headerlink\" title=\"简洁\"></a>简洁</h3><p>保持你的代码简洁，尽量使用简写属性,避免使用多个属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  transition: all 1s;</span><br><span class=\"line\">  top: 50%;</span><br><span class=\"line\">  margin-top: -10px;</span><br><span class=\"line\">  padding-top: 5px;</span><br><span class=\"line\">  padding-right: 10px;</span><br><span class=\"line\">  padding-bottom: 20px;</span><br><span class=\"line\">  padding-left: 10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  transition: 1s;</span><br><span class=\"line\">  top: calc(50% - 10px);</span><br><span class=\"line\">  padding: 5px 10px 20px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h3><p>英文优于数学表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">:nth-child(2n + 1) &#123;</span><br><span class=\"line\">  transform: rotate(360deg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">:nth-child(odd) &#123;</span><br><span class=\"line\">  transform: rotate(1turn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"前缀\"><a href=\"#前缀\" class=\"headerlink\" title=\"前缀\"></a>前缀</h3><p>积极删除过时的前缀。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  transform: scale(2);</span><br><span class=\"line\">  -webkit-transform: scale(2);</span><br><span class=\"line\">  -moz-transform: scale(2);</span><br><span class=\"line\">  -ms-transform: scale(2);</span><br><span class=\"line\">  transition: 1s;</span><br><span class=\"line\">  -webkit-transition: 1s;</span><br><span class=\"line\">  -moz-transition: 1s;</span><br><span class=\"line\">  -ms-transition: 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  -webkit-transform: scale(2);</span><br><span class=\"line\">  transform: scale(2);</span><br><span class=\"line\">  transition: 1s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h3><p><code>animations</code>和<code>transitions</code> ，优先选择<code>transitions</code> 。除了 <code>opacity</code> 和 <code>transform</code>属性，其他属性避免使用<code>animations</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div:hover &#123;</span><br><span class=\"line\">  animation: move 1s forwards;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@keyframes move &#123;</span><br><span class=\"line\">  100% &#123;</span><br><span class=\"line\">    margin-left: 100px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div:hover &#123;</span><br><span class=\"line\">  transition: 1s;</span><br><span class=\"line\">  transform: translateX(100px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单位\"><a href=\"#单位\" class=\"headerlink\" title=\"单位\"></a>单位</h3><p>不要对不需要使用单位的值使用单位；如果你要使用相对单位最好使用<code>rem</code>；使用秒而不是毫秒</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  margin: 0px;</span><br><span class=\"line\">  font-size: .9em;</span><br><span class=\"line\">  line-height: 22px;</span><br><span class=\"line\">  transition: 500ms;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  margin: 0;</span><br><span class=\"line\">  font-size: .9rem;</span><br><span class=\"line\">  line-height: 1.5;</span><br><span class=\"line\">  transition: .5s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h3><p>如果你需要使用透明度，请使用<code>rgba</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  color: hsl(103, 54%, 43%);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  color: #5a3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h3><p>如果资源文件可以轻易在css中绘制出来，就避免HTTP请求来加载</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div::before &#123;</span><br><span class=\"line\">  content: url(white-circle.svg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div::before &#123;</span><br><span class=\"line\">  content: &quot;&quot;;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">  width: 20px;</span><br><span class=\"line\">  height: 20px;</span><br><span class=\"line\">  border-radius: 50%;</span><br><span class=\"line\">  background: #fff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hacks\"><a href=\"#Hacks\" class=\"headerlink\" title=\"Hacks\"></a>Hacks</h3><p>尽量不要使用Hacks</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 糟糕的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  // position: relative;</span><br><span class=\"line\">  transform: translateZ(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 推荐的 */</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  /* position: relative; */</span><br><span class=\"line\">  will-change: transform;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"在github中创建演示demo","date":"2016-03-30T07:36:40.000Z","description":null,"_content":"\n\n1. 在项目中创建一个新的`gh-pages`分支；\n\n2. 将你想要展示的示例demo上传到改分支，具体操作就看你自己啦，是merge其他分支的过来还是重新写代码都可以。\n\n3. 最后，通过`http://<username>.github.io/<projectname>/url`就可以访问了。\n如果在gh-pages分支的根目录下有个next.html文件，则路径为http://<username>.github.io/<projectname>/next.html\n\n4. 使用git tortoise操作步骤：\n1.git clone,克隆项目文件;\n2.右键-“tortoiseGit”-“create branch”，创建gh-pages分支\n3.右键-“tortoiseGit”-“switch”，切换到gh-pages分支\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n","source":"_posts/在github中创建演示demo.md","raw":"title: 在github中创建演示demo\ntags: [其他]\ndate: 2016-03-30 15:36:40\ndescription:\n---\n\n\n1. 在项目中创建一个新的`gh-pages`分支；\n\n2. 将你想要展示的示例demo上传到改分支，具体操作就看你自己啦，是merge其他分支的过来还是重新写代码都可以。\n\n3. 最后，通过`http://<username>.github.io/<projectname>/url`就可以访问了。\n如果在gh-pages分支的根目录下有个next.html文件，则路径为http://<username>.github.io/<projectname>/next.html\n\n4. 使用git tortoise操作步骤：\n1.git clone,克隆项目文件;\n2.右键-“tortoiseGit”-“create branch”，创建gh-pages分支\n3.右键-“tortoiseGit”-“switch”，切换到gh-pages分支\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n","slug":"在github中创建演示demo","published":1,"updated":"2021-12-06T06:07:06.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomf0043y4v2702c3dgg","content":"<ol>\n<li><p>在项目中创建一个新的<code>gh-pages</code>分支；</p>\n</li>\n<li><p>将你想要展示的示例demo上传到改分支，具体操作就看你自己啦，是merge其他分支的过来还是重新写代码都可以。</p>\n</li>\n<li><p>最后，通过<code>http://&lt;username&gt;.github.io/&lt;projectname&gt;/url</code>就可以访问了。<br>如果在gh-pages分支的根目录下有个next.html文件，则路径为http://<username>.github.io/<projectname>/next.html</p>\n</li>\n<li><p>使用git tortoise操作步骤：</p>\n</li>\n<li><p>git clone,克隆项目文件;</p>\n</li>\n<li><p>右键-“tortoiseGit”-“create branch”，创建gh-pages分支</p>\n</li>\n<li><p>右键-“tortoiseGit”-“switch”，切换到gh-pages分支</p>\n</li>\n</ol>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>在项目中创建一个新的<code>gh-pages</code>分支；</p>\n</li>\n<li><p>将你想要展示的示例demo上传到改分支，具体操作就看你自己啦，是merge其他分支的过来还是重新写代码都可以。</p>\n</li>\n<li><p>最后，通过<code>http://&lt;username&gt;.github.io/&lt;projectname&gt;/url</code>就可以访问了。<br>如果在gh-pages分支的根目录下有个next.html文件，则路径为http://<username>.github.io/<projectname>/next.html</p>\n</li>\n<li><p>使用git tortoise操作步骤：</p>\n</li>\n<li><p>git clone,克隆项目文件;</p>\n</li>\n<li><p>右键-“tortoiseGit”-“create branch”，创建gh-pages分支</p>\n</li>\n<li><p>右键-“tortoiseGit”-“switch”，切换到gh-pages分支</p>\n</li>\n</ol>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n"},{"_content":"# 原生js对IE7/8的兼容性写法 #\n  IE6的退出市场，让我们在浏览器兼容性这一问题上舒了一口气，但是IE7/8的存在，依旧需要我们在书写脚本时谨小慎微，不可大意。本文主要整理了js对现代浏览器与IE7/8浏览器之间所需要做的兼容，水平有限，如果有疏漏或者错误的话，还望指出。\n## event对象 ##\n- IE7/8不支持event对象，只支持window.event对象\n\n\t\tfunction(event){\n\t\t\tvar e = event || window.event\n\t\t}\n\n## 鼠标坐标 ##\n\n- IE7/8 ： event.x   event.y\n\n- 现代浏览器： event.pageX  event.pageY\n\t\n\t\tfunction(event){\n\t\t\tvar e = event || window.event;\n\t\t\tvar pageX = e.pageX || e.x;\n\t\t\tvar pageY = e.pageY || e.y;\n\t\t}\n\n## 目标节点 ##\n\n- IE7/8: event.srcElement\n\n- 现代浏览器: event.target\n\n\t\tfunction(event){\n\t\t\tvar e = event || window.event;\n\t\t\tvar srcTarget = e.target || e.srcElement;\n\t\t}\n\n## 事件绑定 ##\n\n- IE7/8:element.attachEvent(on+event,fn)\n\n- 现代浏览器:element.addEventListener(event,fn,useCapture)\n\n\t\tfunction bind(element, type, handler){\n\t\t  if (element.addEventListener){\n\t\t    element.addEventListener(type, handler, false);\n\t\t  } else if (element.attachEvent){\n\t\t    element.attachEvent(\"on\" + type, handler);\n\t\t  }\n\t\t}\n\n## 取消事件绑定 ##\n\n- IE7/8:element.detachEvent(on+event,fn)\n\n- 现代浏览器:element.removeEventListener(event,fn,useCapture)\n \n\t\tfunction unbind(element, type, handler){\n\t\t\tif (element.removeEventListener){\n\t\t\t\telement.removeEventListener(type, handler, false);\n\t\t\t} else if (element.detachEvent){\n\t\t\t\telement.detachEvent(\"on\" + type, handler);\n\t\t\t}\n\t\t}\n\n\n## 阻止默认事件 ##\n\n- IE7/8: event.preventDefault()\n\n- 现代浏览器: event.returnValue = false\n\n\t\tfunction(event){\n\t\t\tvar e = event || window.event;\n\t\t\tif (event.preventDefault){\n\t\t\t\tevent.preventDefault();\n\t\t\t} else {\n\t\t\t\tevent.returnValue = false;\n\t\t\t}\n\t\t}\n\n\n## 取消事件冒泡/捕获 ##\n\n- IE7/8: 不支持事件捕获，因而只能取消事件冒泡，event.cancelBubble \n\n- 现代浏览器: event.returnValue = false\n\n\t\tfunction(event){\n\t\t\tif (event.stopPropagation){\n\t\t\t\tevent.stopPropagation();\n\t\t\t} else {\n\t\t\t\tevent.cancelBubble = true;\n\t\t\t}\n\t\t}\n","source":"_posts/原生js对IE78的兼容性写法.md","raw":"# 原生js对IE7/8的兼容性写法 #\n  IE6的退出市场，让我们在浏览器兼容性这一问题上舒了一口气，但是IE7/8的存在，依旧需要我们在书写脚本时谨小慎微，不可大意。本文主要整理了js对现代浏览器与IE7/8浏览器之间所需要做的兼容，水平有限，如果有疏漏或者错误的话，还望指出。\n## event对象 ##\n- IE7/8不支持event对象，只支持window.event对象\n\n\t\tfunction(event){\n\t\t\tvar e = event || window.event\n\t\t}\n\n## 鼠标坐标 ##\n\n- IE7/8 ： event.x   event.y\n\n- 现代浏览器： event.pageX  event.pageY\n\t\n\t\tfunction(event){\n\t\t\tvar e = event || window.event;\n\t\t\tvar pageX = e.pageX || e.x;\n\t\t\tvar pageY = e.pageY || e.y;\n\t\t}\n\n## 目标节点 ##\n\n- IE7/8: event.srcElement\n\n- 现代浏览器: event.target\n\n\t\tfunction(event){\n\t\t\tvar e = event || window.event;\n\t\t\tvar srcTarget = e.target || e.srcElement;\n\t\t}\n\n## 事件绑定 ##\n\n- IE7/8:element.attachEvent(on+event,fn)\n\n- 现代浏览器:element.addEventListener(event,fn,useCapture)\n\n\t\tfunction bind(element, type, handler){\n\t\t  if (element.addEventListener){\n\t\t    element.addEventListener(type, handler, false);\n\t\t  } else if (element.attachEvent){\n\t\t    element.attachEvent(\"on\" + type, handler);\n\t\t  }\n\t\t}\n\n## 取消事件绑定 ##\n\n- IE7/8:element.detachEvent(on+event,fn)\n\n- 现代浏览器:element.removeEventListener(event,fn,useCapture)\n \n\t\tfunction unbind(element, type, handler){\n\t\t\tif (element.removeEventListener){\n\t\t\t\telement.removeEventListener(type, handler, false);\n\t\t\t} else if (element.detachEvent){\n\t\t\t\telement.detachEvent(\"on\" + type, handler);\n\t\t\t}\n\t\t}\n\n\n## 阻止默认事件 ##\n\n- IE7/8: event.preventDefault()\n\n- 现代浏览器: event.returnValue = false\n\n\t\tfunction(event){\n\t\t\tvar e = event || window.event;\n\t\t\tif (event.preventDefault){\n\t\t\t\tevent.preventDefault();\n\t\t\t} else {\n\t\t\t\tevent.returnValue = false;\n\t\t\t}\n\t\t}\n\n\n## 取消事件冒泡/捕获 ##\n\n- IE7/8: 不支持事件捕获，因而只能取消事件冒泡，event.cancelBubble \n\n- 现代浏览器: event.returnValue = false\n\n\t\tfunction(event){\n\t\t\tif (event.stopPropagation){\n\t\t\t\tevent.stopPropagation();\n\t\t\t} else {\n\t\t\t\tevent.cancelBubble = true;\n\t\t\t}\n\t\t}\n","slug":"原生js对IE78的兼容性写法","published":1,"date":"2021-12-06T06:07:06.306Z","updated":"2021-12-06T06:07:06.306Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomg0045y4v2fbsq08b9","content":"<h1 id=\"原生js对IE7-8的兼容性写法\"><a href=\"#原生js对IE7-8的兼容性写法\" class=\"headerlink\" title=\"原生js对IE7/8的兼容性写法\"></a>原生js对IE7/8的兼容性写法</h1><p>  IE6的退出市场，让我们在浏览器兼容性这一问题上舒了一口气，但是IE7/8的存在，依旧需要我们在书写脚本时谨小慎微，不可大意。本文主要整理了js对现代浏览器与IE7/8浏览器之间所需要做的兼容，水平有限，如果有疏漏或者错误的话，还望指出。</p>\n<h2 id=\"event对象\"><a href=\"#event对象\" class=\"headerlink\" title=\"event对象\"></a>event对象</h2><ul>\n<li><p>IE7/8不支持event对象，只支持window.event对象</p>\n<pre><code>  function(event)&#123;\n      var e = event || window.event\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"鼠标坐标\"><a href=\"#鼠标坐标\" class=\"headerlink\" title=\"鼠标坐标\"></a>鼠标坐标</h2><ul>\n<li><p>IE7/8 ： event.x   event.y</p>\n</li>\n<li><p>现代浏览器： event.pageX  event.pageY</p>\n<pre><code>  function(event)&#123;\n      var e = event || window.event;\n      var pageX = e.pageX || e.x;\n      var pageY = e.pageY || e.y;\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"目标节点\"><a href=\"#目标节点\" class=\"headerlink\" title=\"目标节点\"></a>目标节点</h2><ul>\n<li><p>IE7/8: event.srcElement</p>\n</li>\n<li><p>现代浏览器: event.target</p>\n<pre><code>  function(event)&#123;\n      var e = event || window.event;\n      var srcTarget = e.target || e.srcElement;\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h2><ul>\n<li><p>IE7/8:element.attachEvent(on+event,fn)</p>\n</li>\n<li><p>现代浏览器:element.addEventListener(event,fn,useCapture)</p>\n<pre><code>  function bind(element, type, handler)&#123;\n    if (element.addEventListener)&#123;\n      element.addEventListener(type, handler, false);\n    &#125; else if (element.attachEvent)&#123;\n      element.attachEvent(&quot;on&quot; + type, handler);\n    &#125;\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"取消事件绑定\"><a href=\"#取消事件绑定\" class=\"headerlink\" title=\"取消事件绑定\"></a>取消事件绑定</h2><ul>\n<li><p>IE7/8:element.detachEvent(on+event,fn)</p>\n</li>\n<li><p>现代浏览器:element.removeEventListener(event,fn,useCapture)</p>\n<pre><code>  function unbind(element, type, handler)&#123;\n      if (element.removeEventListener)&#123;\n          element.removeEventListener(type, handler, false);\n      &#125; else if (element.detachEvent)&#123;\n          element.detachEvent(&quot;on&quot; + type, handler);\n      &#125;\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"阻止默认事件\"><a href=\"#阻止默认事件\" class=\"headerlink\" title=\"阻止默认事件\"></a>阻止默认事件</h2><ul>\n<li><p>IE7/8: event.preventDefault()</p>\n</li>\n<li><p>现代浏览器: event.returnValue = false</p>\n<pre><code>  function(event)&#123;\n      var e = event || window.event;\n      if (event.preventDefault)&#123;\n          event.preventDefault();\n      &#125; else &#123;\n          event.returnValue = false;\n      &#125;\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"取消事件冒泡-捕获\"><a href=\"#取消事件冒泡-捕获\" class=\"headerlink\" title=\"取消事件冒泡/捕获\"></a>取消事件冒泡/捕获</h2><ul>\n<li><p>IE7/8: 不支持事件捕获，因而只能取消事件冒泡，event.cancelBubble </p>\n</li>\n<li><p>现代浏览器: event.returnValue = false</p>\n<pre><code>  function(event)&#123;\n      if (event.stopPropagation)&#123;\n          event.stopPropagation();\n      &#125; else &#123;\n          event.cancelBubble = true;\n      &#125;\n  &#125;\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"原生js对IE7-8的兼容性写法\"><a href=\"#原生js对IE7-8的兼容性写法\" class=\"headerlink\" title=\"原生js对IE7/8的兼容性写法\"></a>原生js对IE7/8的兼容性写法</h1><p>  IE6的退出市场，让我们在浏览器兼容性这一问题上舒了一口气，但是IE7/8的存在，依旧需要我们在书写脚本时谨小慎微，不可大意。本文主要整理了js对现代浏览器与IE7/8浏览器之间所需要做的兼容，水平有限，如果有疏漏或者错误的话，还望指出。</p>\n<h2 id=\"event对象\"><a href=\"#event对象\" class=\"headerlink\" title=\"event对象\"></a>event对象</h2><ul>\n<li><p>IE7/8不支持event对象，只支持window.event对象</p>\n<pre><code>  function(event)&#123;\n      var e = event || window.event\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"鼠标坐标\"><a href=\"#鼠标坐标\" class=\"headerlink\" title=\"鼠标坐标\"></a>鼠标坐标</h2><ul>\n<li><p>IE7/8 ： event.x   event.y</p>\n</li>\n<li><p>现代浏览器： event.pageX  event.pageY</p>\n<pre><code>  function(event)&#123;\n      var e = event || window.event;\n      var pageX = e.pageX || e.x;\n      var pageY = e.pageY || e.y;\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"目标节点\"><a href=\"#目标节点\" class=\"headerlink\" title=\"目标节点\"></a>目标节点</h2><ul>\n<li><p>IE7/8: event.srcElement</p>\n</li>\n<li><p>现代浏览器: event.target</p>\n<pre><code>  function(event)&#123;\n      var e = event || window.event;\n      var srcTarget = e.target || e.srcElement;\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h2><ul>\n<li><p>IE7/8:element.attachEvent(on+event,fn)</p>\n</li>\n<li><p>现代浏览器:element.addEventListener(event,fn,useCapture)</p>\n<pre><code>  function bind(element, type, handler)&#123;\n    if (element.addEventListener)&#123;\n      element.addEventListener(type, handler, false);\n    &#125; else if (element.attachEvent)&#123;\n      element.attachEvent(&quot;on&quot; + type, handler);\n    &#125;\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"取消事件绑定\"><a href=\"#取消事件绑定\" class=\"headerlink\" title=\"取消事件绑定\"></a>取消事件绑定</h2><ul>\n<li><p>IE7/8:element.detachEvent(on+event,fn)</p>\n</li>\n<li><p>现代浏览器:element.removeEventListener(event,fn,useCapture)</p>\n<pre><code>  function unbind(element, type, handler)&#123;\n      if (element.removeEventListener)&#123;\n          element.removeEventListener(type, handler, false);\n      &#125; else if (element.detachEvent)&#123;\n          element.detachEvent(&quot;on&quot; + type, handler);\n      &#125;\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"阻止默认事件\"><a href=\"#阻止默认事件\" class=\"headerlink\" title=\"阻止默认事件\"></a>阻止默认事件</h2><ul>\n<li><p>IE7/8: event.preventDefault()</p>\n</li>\n<li><p>现代浏览器: event.returnValue = false</p>\n<pre><code>  function(event)&#123;\n      var e = event || window.event;\n      if (event.preventDefault)&#123;\n          event.preventDefault();\n      &#125; else &#123;\n          event.returnValue = false;\n      &#125;\n  &#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"取消事件冒泡-捕获\"><a href=\"#取消事件冒泡-捕获\" class=\"headerlink\" title=\"取消事件冒泡/捕获\"></a>取消事件冒泡/捕获</h2><ul>\n<li><p>IE7/8: 不支持事件捕获，因而只能取消事件冒泡，event.cancelBubble </p>\n</li>\n<li><p>现代浏览器: event.returnValue = false</p>\n<pre><code>  function(event)&#123;\n      if (event.stopPropagation)&#123;\n          event.stopPropagation();\n      &#125; else &#123;\n          event.cancelBubble = true;\n      &#125;\n  &#125;\n</code></pre>\n</li>\n</ul>\n"},{"title":"实现弹出框的鼠标拖拽效果","date":"2015-04-27T06:41:01.000Z","description":"鼠标拖拽","_content":"\n\n## 先引入几个与定位有关的概念：\n\n+ javascript:\n\t* clientX/clientY属性：获得事件发生时鼠标指针在视口中的水平和垂直坐标。\n\n\t* screenX/screenY属性：获取鼠标事件发生时鼠标光标相对于整个电脑屏幕的坐标信息。\n\n\t* pageX/pageY属性：可以获得鼠标事件发生时鼠标光标相对于整个文档元素的坐标位置（包含滚动）。在页面没有滚动的情况下，通常pageX/pageY的值与clientX/clientY的值相等。\n\n\t* layerX/layerY属性：他是对于绝对定位元素来说的，相对于当前点击元素的左上角定位的。当页面上的元素时相对定位（position:relative）的时候，通常pageX/pageY和layerX/layerY的值是相同的，但是当元素绝对定位(position:absolute)了的时候，layerX/layerY就将鼠标光标位置相对于本身的左上角定位了。\n\n<!-- more -->\n\n+ jquery:\n\n\t* position()\n\t获取匹配元素相对父元素的偏移。\n\t返回的对象包含两个整型属性：top 和 left。为精确计算结果，请在补白、边框和填充属性上使用像素单位。此方法只对可见元素有效。\n\n\t* offset()\n\t获取匹配元素在当前视口的相对偏移。\n\t返回的对象包含两个整型属性：top 和 left，以像素计。此方法只对可见元素有效。\n\n\t* event.pageX\n\t鼠标相对于文档的左边缘的位置。\n\n\t* event.pageY\n\t鼠标相对于文档的上边缘的位置。\n\n## 实现原理\n1. 鼠标在弹出框上按下时，获取鼠标相对于弹出框的left和top值l、t，这时弹出框状态改为可拖动（mousedown事件）\n\n2. 当弹出框状态为可拖动时：（mousemove事件）\n\n　　①重新定位弹出框的位置；（获取鼠标相对于可视区域的left和top值L、T，并且弹出的坐标移动，它的offsetLeft为L-l；offsetTop为T-t）\n\n　　②限定弹出框的运动范围；\n\n3. 当鼠标按钮弹起时，弹出框不在移动，即状态改为不可拖动；（mouseup）\n\n\n\n## 上代码\nHTML\n\n\t<!DOCTYPE html>\n\t<html>\n\t<head>\n\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n\t<title>鼠标拖拽事件</title>\n\t<style>\n\t*{\n\t    margin:0;\n\t    padding: 0;\n\t}\n\n\t#container{\n\t    width: 380px;\n\t    border: 1px solid #999;\n\t    position: absolute;\n\t    z-index: 5;\n\t}\n\t#mask{\n\t    position: absolute;\n\t    height:100%;\n\t    width: 100%;\n\t    background: black;\n\t    opacity: 0.6;\n\t    /*filter:alpha(opacity=40);*/\n\t    z-index: 1;\n\t    left: 0;\n\t    top:0;\n\t}\n\t#top{\n\t    background: #ccc;\n\t    height: 30px;\n\t    cursor: pointer;\n\t}\n\t#content{\n\t    height: 100px;\n\t    line-height: 20px;\n\t    background: #fff;\n\t    padding: 20px 0 0 0;\n\t}\n\tp{\n\t    text-align: center;\n\t}\n\t</style>\n\t<script src='demo.js'></script>\n\t<body>\n\t    <div id='mask'></div>\n\t    <div id='container'>\n\t        <div id='top'></div>\n\t        <div id='content'>\n\t            <p><label>请输入用户名</label><input type='text' class='ipt'></p>\n\t            <p><label>  请输入密码</label><input  type='password' class='ipt'></p>\n\t        </div>\n\n\t    </div>\n\t</body>\n\t</html>\nJavaScript实现\n\n\twindow.onload=function(){\n\t    var container=document.getElementById('container');\n\t    var top=document.getElementById('top');\n\t    var oMask=document.getElementById('mask')\n\t    console.log(container);\n\t    var startX ;\n\t    var startY;\n\t    var flag=false;\n\t    top.onmousedown=function(e){\n\t        var e= e||window.event;\n\t        startX=e.clientX-container.offsetLeft;           //获取鼠标点与container的相对位置\n\t        startY=e.clientY-container.offsetTop;\n\t        flag=true;\n\t    }\n\n\n    container.onmousemove=function(e){\n        var e= e||window.event;\n        var endX=e.clientX;\n        var endY=e.clientY;\n        var moveX=endX-startX;\n        var moveY=endY-startY;\n        \n        //范围限定\n        var maxW=oMask.offsetWidth-container.offsetWidth;   \n        var maxH=oMask.offsetHeight-container.offsetHeight;\n        moveX=Math.min(maxW,Math.max(0,moveX));             //取得范围在[0,maxW]之间的值\n        moveY=Math.min(maxH,Math.max(0,moveY));\n\n        if(flag==true){\n            container.style.left=moveX+'px';           //鼠标与可视区域的相对位置-鼠标点与container的相对位置=container与可视区域的相对位置\n            container.style.top =moveY+'px';\n        }\n        \n    }\n    document.onmouseup=function(e){\n        flag=false;\n    }\n    \n\t}\n\nJquery实现\n\n\t$(function(){\n\t    var flag=false;\n\t    var mouseLeft;\n\t    var mouseTop;\n\t    $('#top').mousedown(function(event){  \n\t        var downX=event.pageX;       //获取鼠标坐标\n\t        var downY=event.pageY;\n\t        var offsetLeft=$('#container').position().left    //获取弹出框的left值\n\t        var offsetTop =$('#container').position().top\n\t        mouseLeft=downX-offsetLeft;       //计算鼠标在弹出框中的位置\n\t        mouseTop =downY-offsetTop;\n\t        //console.log(mouseLeft)\n\t        flag=true;\n\t    })\n\n\n\n    $(document).mousemove(function(event){  \n        \n        if(flag==true){\n            var moveX=event.pageX;       //获取鼠标坐标\n            var moveY=event.pageY;\n            var moveLeft=moveX-mouseLeft;  //获取移动过程中弹出框的left值\n            var moveTop =moveY-mouseTop;\n            var maxX=$(document).width() -$('#container').outerWidth();\n            var maxY=$(document).height()-$('#container').outerHeight();\n            console.log($('#container').outerWidth())\n            //范围限定\n            moveLeft=Math.min(Math.max(0,moveLeft),maxX);\n            moveTop =Math.min(Math.max(0,moveTop),maxY);\n            //console.log(moveLeft)\n            $('#container').css({'left':moveLeft,'top':moveTop,'backgroud':'red'});\n        }\n        \n    })\n\n\n\n    $(document).mouseup(function(event){  \n        flag=false;\n    })","source":"_posts/实现弹出框的鼠标拖拽效果.md","raw":"title: 实现弹出框的鼠标拖拽效果\ndate: 2015-04-27 14:41:01\ntags: [web,javascript]\ndescription: 鼠标拖拽\n\n---\n\n\n## 先引入几个与定位有关的概念：\n\n+ javascript:\n\t* clientX/clientY属性：获得事件发生时鼠标指针在视口中的水平和垂直坐标。\n\n\t* screenX/screenY属性：获取鼠标事件发生时鼠标光标相对于整个电脑屏幕的坐标信息。\n\n\t* pageX/pageY属性：可以获得鼠标事件发生时鼠标光标相对于整个文档元素的坐标位置（包含滚动）。在页面没有滚动的情况下，通常pageX/pageY的值与clientX/clientY的值相等。\n\n\t* layerX/layerY属性：他是对于绝对定位元素来说的，相对于当前点击元素的左上角定位的。当页面上的元素时相对定位（position:relative）的时候，通常pageX/pageY和layerX/layerY的值是相同的，但是当元素绝对定位(position:absolute)了的时候，layerX/layerY就将鼠标光标位置相对于本身的左上角定位了。\n\n<!-- more -->\n\n+ jquery:\n\n\t* position()\n\t获取匹配元素相对父元素的偏移。\n\t返回的对象包含两个整型属性：top 和 left。为精确计算结果，请在补白、边框和填充属性上使用像素单位。此方法只对可见元素有效。\n\n\t* offset()\n\t获取匹配元素在当前视口的相对偏移。\n\t返回的对象包含两个整型属性：top 和 left，以像素计。此方法只对可见元素有效。\n\n\t* event.pageX\n\t鼠标相对于文档的左边缘的位置。\n\n\t* event.pageY\n\t鼠标相对于文档的上边缘的位置。\n\n## 实现原理\n1. 鼠标在弹出框上按下时，获取鼠标相对于弹出框的left和top值l、t，这时弹出框状态改为可拖动（mousedown事件）\n\n2. 当弹出框状态为可拖动时：（mousemove事件）\n\n　　①重新定位弹出框的位置；（获取鼠标相对于可视区域的left和top值L、T，并且弹出的坐标移动，它的offsetLeft为L-l；offsetTop为T-t）\n\n　　②限定弹出框的运动范围；\n\n3. 当鼠标按钮弹起时，弹出框不在移动，即状态改为不可拖动；（mouseup）\n\n\n\n## 上代码\nHTML\n\n\t<!DOCTYPE html>\n\t<html>\n\t<head>\n\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n\t<title>鼠标拖拽事件</title>\n\t<style>\n\t*{\n\t    margin:0;\n\t    padding: 0;\n\t}\n\n\t#container{\n\t    width: 380px;\n\t    border: 1px solid #999;\n\t    position: absolute;\n\t    z-index: 5;\n\t}\n\t#mask{\n\t    position: absolute;\n\t    height:100%;\n\t    width: 100%;\n\t    background: black;\n\t    opacity: 0.6;\n\t    /*filter:alpha(opacity=40);*/\n\t    z-index: 1;\n\t    left: 0;\n\t    top:0;\n\t}\n\t#top{\n\t    background: #ccc;\n\t    height: 30px;\n\t    cursor: pointer;\n\t}\n\t#content{\n\t    height: 100px;\n\t    line-height: 20px;\n\t    background: #fff;\n\t    padding: 20px 0 0 0;\n\t}\n\tp{\n\t    text-align: center;\n\t}\n\t</style>\n\t<script src='demo.js'></script>\n\t<body>\n\t    <div id='mask'></div>\n\t    <div id='container'>\n\t        <div id='top'></div>\n\t        <div id='content'>\n\t            <p><label>请输入用户名</label><input type='text' class='ipt'></p>\n\t            <p><label>  请输入密码</label><input  type='password' class='ipt'></p>\n\t        </div>\n\n\t    </div>\n\t</body>\n\t</html>\nJavaScript实现\n\n\twindow.onload=function(){\n\t    var container=document.getElementById('container');\n\t    var top=document.getElementById('top');\n\t    var oMask=document.getElementById('mask')\n\t    console.log(container);\n\t    var startX ;\n\t    var startY;\n\t    var flag=false;\n\t    top.onmousedown=function(e){\n\t        var e= e||window.event;\n\t        startX=e.clientX-container.offsetLeft;           //获取鼠标点与container的相对位置\n\t        startY=e.clientY-container.offsetTop;\n\t        flag=true;\n\t    }\n\n\n    container.onmousemove=function(e){\n        var e= e||window.event;\n        var endX=e.clientX;\n        var endY=e.clientY;\n        var moveX=endX-startX;\n        var moveY=endY-startY;\n        \n        //范围限定\n        var maxW=oMask.offsetWidth-container.offsetWidth;   \n        var maxH=oMask.offsetHeight-container.offsetHeight;\n        moveX=Math.min(maxW,Math.max(0,moveX));             //取得范围在[0,maxW]之间的值\n        moveY=Math.min(maxH,Math.max(0,moveY));\n\n        if(flag==true){\n            container.style.left=moveX+'px';           //鼠标与可视区域的相对位置-鼠标点与container的相对位置=container与可视区域的相对位置\n            container.style.top =moveY+'px';\n        }\n        \n    }\n    document.onmouseup=function(e){\n        flag=false;\n    }\n    \n\t}\n\nJquery实现\n\n\t$(function(){\n\t    var flag=false;\n\t    var mouseLeft;\n\t    var mouseTop;\n\t    $('#top').mousedown(function(event){  \n\t        var downX=event.pageX;       //获取鼠标坐标\n\t        var downY=event.pageY;\n\t        var offsetLeft=$('#container').position().left    //获取弹出框的left值\n\t        var offsetTop =$('#container').position().top\n\t        mouseLeft=downX-offsetLeft;       //计算鼠标在弹出框中的位置\n\t        mouseTop =downY-offsetTop;\n\t        //console.log(mouseLeft)\n\t        flag=true;\n\t    })\n\n\n\n    $(document).mousemove(function(event){  \n        \n        if(flag==true){\n            var moveX=event.pageX;       //获取鼠标坐标\n            var moveY=event.pageY;\n            var moveLeft=moveX-mouseLeft;  //获取移动过程中弹出框的left值\n            var moveTop =moveY-mouseTop;\n            var maxX=$(document).width() -$('#container').outerWidth();\n            var maxY=$(document).height()-$('#container').outerHeight();\n            console.log($('#container').outerWidth())\n            //范围限定\n            moveLeft=Math.min(Math.max(0,moveLeft),maxX);\n            moveTop =Math.min(Math.max(0,moveTop),maxY);\n            //console.log(moveLeft)\n            $('#container').css({'left':moveLeft,'top':moveTop,'backgroud':'red'});\n        }\n        \n    })\n\n\n\n    $(document).mouseup(function(event){  \n        flag=false;\n    })","slug":"实现弹出框的鼠标拖拽效果","published":1,"updated":"2021-12-06T06:07:06.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomh0047y4v2binweb2g","content":"<h2 id=\"先引入几个与定位有关的概念：\"><a href=\"#先引入几个与定位有关的概念：\" class=\"headerlink\" title=\"先引入几个与定位有关的概念：\"></a>先引入几个与定位有关的概念：</h2><ul>\n<li><p>javascript:</p>\n<ul>\n<li><p>clientX/clientY属性：获得事件发生时鼠标指针在视口中的水平和垂直坐标。</p>\n</li>\n<li><p>screenX/screenY属性：获取鼠标事件发生时鼠标光标相对于整个电脑屏幕的坐标信息。</p>\n</li>\n<li><p>pageX/pageY属性：可以获得鼠标事件发生时鼠标光标相对于整个文档元素的坐标位置（包含滚动）。在页面没有滚动的情况下，通常pageX/pageY的值与clientX/clientY的值相等。</p>\n</li>\n<li><p>layerX/layerY属性：他是对于绝对定位元素来说的，相对于当前点击元素的左上角定位的。当页面上的元素时相对定位（position:relative）的时候，通常pageX/pageY和layerX/layerY的值是相同的，但是当元素绝对定位(position:absolute)了的时候，layerX/layerY就将鼠标光标位置相对于本身的左上角定位了。</p>\n</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<ul>\n<li><p>jquery:</p>\n<ul>\n<li><p>position()<br>获取匹配元素相对父元素的偏移。<br>返回的对象包含两个整型属性：top 和 left。为精确计算结果，请在补白、边框和填充属性上使用像素单位。此方法只对可见元素有效。</p>\n</li>\n<li><p>offset()<br>获取匹配元素在当前视口的相对偏移。<br>返回的对象包含两个整型属性：top 和 left，以像素计。此方法只对可见元素有效。</p>\n</li>\n<li><p>event.pageX<br>鼠标相对于文档的左边缘的位置。</p>\n</li>\n<li><p>event.pageY<br>鼠标相对于文档的上边缘的位置。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><ol>\n<li><p>鼠标在弹出框上按下时，获取鼠标相对于弹出框的left和top值l、t，这时弹出框状态改为可拖动（mousedown事件）</p>\n</li>\n<li><p>当弹出框状态为可拖动时：（mousemove事件）</p>\n</li>\n</ol>\n<p>　　①重新定位弹出框的位置；（获取鼠标相对于可视区域的left和top值L、T，并且弹出的坐标移动，它的offsetLeft为L-l；offsetTop为T-t）</p>\n<p>　　②限定弹出框的运动范围；</p>\n<ol start=\"3\">\n<li>当鼠标按钮弹起时，弹出框不在移动，即状态改为不可拖动；（mouseup）</li>\n</ol>\n<h2 id=\"上代码\"><a href=\"#上代码\" class=\"headerlink\" title=\"上代码\"></a>上代码</h2><p>HTML</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n&lt;title&gt;鼠标拖拽事件&lt;/title&gt;\n&lt;style&gt;\n*&#123;\n    margin:0;\n    padding: 0;\n&#125;\n\n#container&#123;\n    width: 380px;\n    border: 1px solid #999;\n    position: absolute;\n    z-index: 5;\n&#125;\n#mask&#123;\n    position: absolute;\n    height:100%;\n    width: 100%;\n    background: black;\n    opacity: 0.6;\n    /*filter:alpha(opacity=40);*/\n    z-index: 1;\n    left: 0;\n    top:0;\n&#125;\n#top&#123;\n    background: #ccc;\n    height: 30px;\n    cursor: pointer;\n&#125;\n#content&#123;\n    height: 100px;\n    line-height: 20px;\n    background: #fff;\n    padding: 20px 0 0 0;\n&#125;\np&#123;\n    text-align: center;\n&#125;\n&lt;/style&gt;\n&lt;script src=&#39;demo.js&#39;&gt;&lt;/script&gt;\n&lt;body&gt;\n    &lt;div id=&#39;mask&#39;&gt;&lt;/div&gt;\n    &lt;div id=&#39;container&#39;&gt;\n        &lt;div id=&#39;top&#39;&gt;&lt;/div&gt;\n        &lt;div id=&#39;content&#39;&gt;\n            &lt;p&gt;&lt;label&gt;请输入用户名&lt;/label&gt;&lt;input type=&#39;text&#39; class=&#39;ipt&#39;&gt;&lt;/p&gt;\n            &lt;p&gt;&lt;label&gt;  请输入密码&lt;/label&gt;&lt;input  type=&#39;password&#39; class=&#39;ipt&#39;&gt;&lt;/p&gt;\n        &lt;/div&gt;\n\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>JavaScript实现</p>\n<pre><code>window.onload=function()&#123;\n    var container=document.getElementById(&#39;container&#39;);\n    var top=document.getElementById(&#39;top&#39;);\n    var oMask=document.getElementById(&#39;mask&#39;)\n    console.log(container);\n    var startX ;\n    var startY;\n    var flag=false;\n    top.onmousedown=function(e)&#123;\n        var e= e||window.event;\n        startX=e.clientX-container.offsetLeft;           //获取鼠标点与container的相对位置\n        startY=e.clientY-container.offsetTop;\n        flag=true;\n    &#125;\n\n\ncontainer.onmousemove=function(e)&#123;\n    var e= e||window.event;\n    var endX=e.clientX;\n    var endY=e.clientY;\n    var moveX=endX-startX;\n    var moveY=endY-startY;\n    \n    //范围限定\n    var maxW=oMask.offsetWidth-container.offsetWidth;   \n    var maxH=oMask.offsetHeight-container.offsetHeight;\n    moveX=Math.min(maxW,Math.max(0,moveX));             //取得范围在[0,maxW]之间的值\n    moveY=Math.min(maxH,Math.max(0,moveY));\n\n    if(flag==true)&#123;\n        container.style.left=moveX+&#39;px&#39;;           //鼠标与可视区域的相对位置-鼠标点与container的相对位置=container与可视区域的相对位置\n        container.style.top =moveY+&#39;px&#39;;\n    &#125;\n    \n&#125;\ndocument.onmouseup=function(e)&#123;\n    flag=false;\n&#125;\n\n&#125;\n</code></pre>\n<p>Jquery实现</p>\n<pre><code>$(function()&#123;\n    var flag=false;\n    var mouseLeft;\n    var mouseTop;\n    $(&#39;#top&#39;).mousedown(function(event)&#123;  \n        var downX=event.pageX;       //获取鼠标坐标\n        var downY=event.pageY;\n        var offsetLeft=$(&#39;#container&#39;).position().left    //获取弹出框的left值\n        var offsetTop =$(&#39;#container&#39;).position().top\n        mouseLeft=downX-offsetLeft;       //计算鼠标在弹出框中的位置\n        mouseTop =downY-offsetTop;\n        //console.log(mouseLeft)\n        flag=true;\n    &#125;)\n\n\n\n$(document).mousemove(function(event)&#123;  \n    \n    if(flag==true)&#123;\n        var moveX=event.pageX;       //获取鼠标坐标\n        var moveY=event.pageY;\n        var moveLeft=moveX-mouseLeft;  //获取移动过程中弹出框的left值\n        var moveTop =moveY-mouseTop;\n        var maxX=$(document).width() -$(&#39;#container&#39;).outerWidth();\n        var maxY=$(document).height()-$(&#39;#container&#39;).outerHeight();\n        console.log($(&#39;#container&#39;).outerWidth())\n        //范围限定\n        moveLeft=Math.min(Math.max(0,moveLeft),maxX);\n        moveTop =Math.min(Math.max(0,moveTop),maxY);\n        //console.log(moveLeft)\n        $(&#39;#container&#39;).css(&#123;&#39;left&#39;:moveLeft,&#39;top&#39;:moveTop,&#39;backgroud&#39;:&#39;red&#39;&#125;);\n    &#125;\n    \n&#125;)\n\n\n\n$(document).mouseup(function(event)&#123;  \n    flag=false;\n&#125;)\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"先引入几个与定位有关的概念：\"><a href=\"#先引入几个与定位有关的概念：\" class=\"headerlink\" title=\"先引入几个与定位有关的概念：\"></a>先引入几个与定位有关的概念：</h2><ul>\n<li><p>javascript:</p>\n<ul>\n<li><p>clientX/clientY属性：获得事件发生时鼠标指针在视口中的水平和垂直坐标。</p>\n</li>\n<li><p>screenX/screenY属性：获取鼠标事件发生时鼠标光标相对于整个电脑屏幕的坐标信息。</p>\n</li>\n<li><p>pageX/pageY属性：可以获得鼠标事件发生时鼠标光标相对于整个文档元素的坐标位置（包含滚动）。在页面没有滚动的情况下，通常pageX/pageY的值与clientX/clientY的值相等。</p>\n</li>\n<li><p>layerX/layerY属性：他是对于绝对定位元素来说的，相对于当前点击元素的左上角定位的。当页面上的元素时相对定位（position:relative）的时候，通常pageX/pageY和layerX/layerY的值是相同的，但是当元素绝对定位(position:absolute)了的时候，layerX/layerY就将鼠标光标位置相对于本身的左上角定位了。</p>\n</li>\n</ul>\n</li>\n</ul>","more":"<ul>\n<li><p>jquery:</p>\n<ul>\n<li><p>position()<br>获取匹配元素相对父元素的偏移。<br>返回的对象包含两个整型属性：top 和 left。为精确计算结果，请在补白、边框和填充属性上使用像素单位。此方法只对可见元素有效。</p>\n</li>\n<li><p>offset()<br>获取匹配元素在当前视口的相对偏移。<br>返回的对象包含两个整型属性：top 和 left，以像素计。此方法只对可见元素有效。</p>\n</li>\n<li><p>event.pageX<br>鼠标相对于文档的左边缘的位置。</p>\n</li>\n<li><p>event.pageY<br>鼠标相对于文档的上边缘的位置。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><ol>\n<li><p>鼠标在弹出框上按下时，获取鼠标相对于弹出框的left和top值l、t，这时弹出框状态改为可拖动（mousedown事件）</p>\n</li>\n<li><p>当弹出框状态为可拖动时：（mousemove事件）</p>\n</li>\n</ol>\n<p>　　①重新定位弹出框的位置；（获取鼠标相对于可视区域的left和top值L、T，并且弹出的坐标移动，它的offsetLeft为L-l；offsetTop为T-t）</p>\n<p>　　②限定弹出框的运动范围；</p>\n<ol start=\"3\">\n<li>当鼠标按钮弹起时，弹出框不在移动，即状态改为不可拖动；（mouseup）</li>\n</ol>\n<h2 id=\"上代码\"><a href=\"#上代码\" class=\"headerlink\" title=\"上代码\"></a>上代码</h2><p>HTML</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n&lt;title&gt;鼠标拖拽事件&lt;/title&gt;\n&lt;style&gt;\n*&#123;\n    margin:0;\n    padding: 0;\n&#125;\n\n#container&#123;\n    width: 380px;\n    border: 1px solid #999;\n    position: absolute;\n    z-index: 5;\n&#125;\n#mask&#123;\n    position: absolute;\n    height:100%;\n    width: 100%;\n    background: black;\n    opacity: 0.6;\n    /*filter:alpha(opacity=40);*/\n    z-index: 1;\n    left: 0;\n    top:0;\n&#125;\n#top&#123;\n    background: #ccc;\n    height: 30px;\n    cursor: pointer;\n&#125;\n#content&#123;\n    height: 100px;\n    line-height: 20px;\n    background: #fff;\n    padding: 20px 0 0 0;\n&#125;\np&#123;\n    text-align: center;\n&#125;\n&lt;/style&gt;\n&lt;script src=&#39;demo.js&#39;&gt;&lt;/script&gt;\n&lt;body&gt;\n    &lt;div id=&#39;mask&#39;&gt;&lt;/div&gt;\n    &lt;div id=&#39;container&#39;&gt;\n        &lt;div id=&#39;top&#39;&gt;&lt;/div&gt;\n        &lt;div id=&#39;content&#39;&gt;\n            &lt;p&gt;&lt;label&gt;请输入用户名&lt;/label&gt;&lt;input type=&#39;text&#39; class=&#39;ipt&#39;&gt;&lt;/p&gt;\n            &lt;p&gt;&lt;label&gt;  请输入密码&lt;/label&gt;&lt;input  type=&#39;password&#39; class=&#39;ipt&#39;&gt;&lt;/p&gt;\n        &lt;/div&gt;\n\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>JavaScript实现</p>\n<pre><code>window.onload=function()&#123;\n    var container=document.getElementById(&#39;container&#39;);\n    var top=document.getElementById(&#39;top&#39;);\n    var oMask=document.getElementById(&#39;mask&#39;)\n    console.log(container);\n    var startX ;\n    var startY;\n    var flag=false;\n    top.onmousedown=function(e)&#123;\n        var e= e||window.event;\n        startX=e.clientX-container.offsetLeft;           //获取鼠标点与container的相对位置\n        startY=e.clientY-container.offsetTop;\n        flag=true;\n    &#125;\n\n\ncontainer.onmousemove=function(e)&#123;\n    var e= e||window.event;\n    var endX=e.clientX;\n    var endY=e.clientY;\n    var moveX=endX-startX;\n    var moveY=endY-startY;\n    \n    //范围限定\n    var maxW=oMask.offsetWidth-container.offsetWidth;   \n    var maxH=oMask.offsetHeight-container.offsetHeight;\n    moveX=Math.min(maxW,Math.max(0,moveX));             //取得范围在[0,maxW]之间的值\n    moveY=Math.min(maxH,Math.max(0,moveY));\n\n    if(flag==true)&#123;\n        container.style.left=moveX+&#39;px&#39;;           //鼠标与可视区域的相对位置-鼠标点与container的相对位置=container与可视区域的相对位置\n        container.style.top =moveY+&#39;px&#39;;\n    &#125;\n    \n&#125;\ndocument.onmouseup=function(e)&#123;\n    flag=false;\n&#125;\n\n&#125;\n</code></pre>\n<p>Jquery实现</p>\n<pre><code>$(function()&#123;\n    var flag=false;\n    var mouseLeft;\n    var mouseTop;\n    $(&#39;#top&#39;).mousedown(function(event)&#123;  \n        var downX=event.pageX;       //获取鼠标坐标\n        var downY=event.pageY;\n        var offsetLeft=$(&#39;#container&#39;).position().left    //获取弹出框的left值\n        var offsetTop =$(&#39;#container&#39;).position().top\n        mouseLeft=downX-offsetLeft;       //计算鼠标在弹出框中的位置\n        mouseTop =downY-offsetTop;\n        //console.log(mouseLeft)\n        flag=true;\n    &#125;)\n\n\n\n$(document).mousemove(function(event)&#123;  \n    \n    if(flag==true)&#123;\n        var moveX=event.pageX;       //获取鼠标坐标\n        var moveY=event.pageY;\n        var moveLeft=moveX-mouseLeft;  //获取移动过程中弹出框的left值\n        var moveTop =moveY-mouseTop;\n        var maxX=$(document).width() -$(&#39;#container&#39;).outerWidth();\n        var maxY=$(document).height()-$(&#39;#container&#39;).outerHeight();\n        console.log($(&#39;#container&#39;).outerWidth())\n        //范围限定\n        moveLeft=Math.min(Math.max(0,moveLeft),maxX);\n        moveTop =Math.min(Math.max(0,moveTop),maxY);\n        //console.log(moveLeft)\n        $(&#39;#container&#39;).css(&#123;&#39;left&#39;:moveLeft,&#39;top&#39;:moveTop,&#39;backgroud&#39;:&#39;red&#39;&#125;);\n    &#125;\n    \n&#125;)\n\n\n\n$(document).mouseup(function(event)&#123;  \n    flag=false;\n&#125;)\n</code></pre>"},{"title":"实现跨域","date":"2015-12-23T03:09:54.000Z","description":"跨域","_content":"\n## 从域说起\n>域： 域是WIN2K网络系统的安全性边界。我们知道一个计算机网最基本的单元就是“域”，这一点不是WIN2K所独有的，但活动目录可以贯穿一个或多个域。在独立的计算机上，域即指计算机本身，一个域可以分布在多个物理位置上，同时一个物理位置又可以划分不同网段为不同的域，每个域都有自己的安全策略以及它与其他域的信任关系。当多个域通过信任关系连接起来之后，活动目录可以被多个信任域域共享 \n\n\n>域树：域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域是通过双向可传递信任关系连接在一起。由于这些信任关系是双向的而且是可传递的，因此在域树或树林中新创建的域可以立即与域树或树林中每个其他的域建立信任关系。这些信任关系允许单一登录过程，在域树或树林中的所有域上对用户进行身份验证，但这不一定意味着经过身份验证的用户在域树的所有域中都拥有相同的权利和权限。因为域是安全界限，所以必须在每个域的基础上为用户指派相应的权利和权限。\n\n<!-- more -->\n\n<b style=\"color:#d44950\">域树中的域层次越深级别越低，一个“.”代表一个层次。</b>\n如域`zhidao.baidu.com `(百度知道)就比 `baidu.com`(百度)这个域级别低，因为它有两个层次关系，而`baidu.com`只有一个层次。\n\n\n## 何为跨域\n\n>默认情况下，，XHR 对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。但是，实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。\n\n<b style=\"color:#d44950\">只要协议、域名、端口有任何一个不同，都被当作是不同的域</b>\n\n比如在http://www.a.com/a.js 页面向以下页面发送一个ajax请求，以下是其请求结果及说明\n\n\n| URL       \t\t\t \t|    说明     \t\t   | 是否允许通信  |\n| :-------- \t\t\t \t| \t\t:--:    \t   | :--:          |\n| http://www.a.com/b.js  \t|  同一域名下 \t\t   |  允许         |\n| http://www.a.com:8000/a.js|  同一域名，不同端口  |  不允许       |\n| https://www.a.com/b.js    |  同一域名，不同协议  |  不允许       |\n| http://script.a.com/b.js \t|  主域相同，子域不同  |  不允许       |\n| http://a.com/b.js \t\t|同一域名，不同二级域名|  不允许       |\n| http://www.a.com/b.js     |  不同域名\t\t\t   |  不允许       |\n\n\n<b style=\"color:#d44950\">对于端口和协议的不同，只能通过后台来解决。我们要解决的是域名不同的问题</b>\n\n## 如何跨域\n\n**(一) CORS(Cross-Origin Resource Sharing，跨源资源共享)**\n>1.CORS（Cross-Origin Resource Sharing，跨源资源共享）是W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。\n2.实现此功能非常简单，只需由服务器发送一个响应标头即可。\n\n浏览器支持情况：\n\n+ IE 8+\n+ Firefox 3.5+\n+ Opera 12+\n+ Safari 4+\n+ Chrome 3+\n\n\n假设我们页面或者应用已在 http://www.a.com/ 上了，而我们打算从 http://www.b.com 请求提取数据。一般情况下，如果我们直接使用 AJAX 来请求将会失败，浏览器也会返回错误。\n利用 CORS，http://www.b.com 只需添加一个标头，就可以允许来自 http://www.a.com 的请求。\n下面是用php进行的设置，“*”号表示允许任何域向我们的服务端提交请求：\n\n\theader{\"Access-Control-Allow-Origin: *\"}\n\nCORS的兼容性写法\n```\n\tfunction createCORSRequest(method, url){\n\t\tvar xhr = new XMLHttpRequest();\n\t\t//非IE浏览器\n\t\tif (\"withCredentials\" in xhr){\n\t\t\txhr.open(method, url, true);\n\t\t//IE浏览器\n\t\t} else if (typeof XDomainRequest != \"undefined\"){\n\t\t\tvxhr = new XDomainRequest();\n\t\t\txhr.open(method, url);\n\t\t} else {\n\t\t\txhr = null;\n\t\t}\n\t\treturn xhr;\n\t}\n\tvar request = createCORSRequest(\"get\", \"http://www.somewhere-else.com/page/\");\n\tif (request){\n\t\trequest.onload = function(){\n\t\t\t//对request.responseText 进行处理\n\t\t};\n\t\trequest.send();\n\t}\n```\n\n---\n\n**(二) JSONP(JSON with Padding 填充式JSON 或参数式JSON)**\n\n在js中，我们虽然不能直接用XMLHttpRequest请求不同域上的数据时，但是在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的\n\nJSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。\n\n例如：\n\n\t<script type=\"text/javascript\">\n\t    function dosomething(jsondata){\n\t        //处理获得的json数据\n\t    }\n\t</script>\n\t<script src=\"http://example.com/data.php?callback=dosomething\"></script>\n\n+ 首先第一个`script`便签定义了一个处理数据的函数;\n+ 然后第二个`script`标签载入一个js文件，http://example.com/data.php 是数据所在地址，但是因为是当做js来引入的，所以http://example.com/data.php 返回的必须是一个能执行的js文件;\n+ 最后js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以php应该是这样的\n```\n\t<?php\n\t$callback = $_GET['callback'];//得到回调函数名\n\t$data = array('a','b','c');//要返回的数据\n\techo $callback.'('.json_encode($data).')';//输出\n\t?>\n```\n\n最终，输出结果为：dosomething(['a','b','c']);\n从上面可以看出jsonp是需要服务器端的页面进行相应的配合的。\n\n\nJSONP的优缺点\n优点:\n\n+ 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；\n+ 能够直接访问响应文本，支持在浏览器与服务器之间双向通信\n\n缺点：\n\n+ JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的Web 服务时，一定得保证它安全可靠。\n+ 它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。\n\n---\n\n**(三) window.name**\n\nwindow对象有个`name`属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。\n\n\n这里有三个页面：\n\na.com/app.html：应用页面。\na.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。\nb.com/data.html：应用页面需要获取数据的页面，可称为数据页面。\n\napp.html\n\n\t<iframe src=\"b.com/data.html\" id=\"iframe\"></iframe>\n\t<script>\n\t\tvar iframe = document.getElementById(\"iframe\");\n\t\tiframe.src = \"a.com/proxy.html\";//这是一个与a.com/app.html同源的页面\n\t\tiframe.onload = function(){\n\t\t\tvar data = iframe.contentWindow.name; //取到数据\n\t\t}\n\n\t</script>\n\t\ndata.html\n\n\t<script>\n\t\t// 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右\n        // 数据格式可以自定义，如json、字符串\n\t\twindow.name = \"数据\"\n\t</script>\n\niframe首先的地址是b.com/data.html，所以能取到`window.name`数据;\n但是iframe现在跟app.html并不同源，app.html无法获取到数据，所以又将iframe的链接跳转至a.com/proxy.html这个代理页面，现在app.html跟iframe就同源了。\n\n<b style=\"color:#d44950\">注意：iframe由b.com/data.html跳转到a.com/proxy.html页面，`window.name`的value是不变的</b>\n\n获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n\n\t<script type=\"text/javascript\">\n\t    iframe.contentWindow.document.write('');\n\t    iframe.contentWindow.close();\n\t    document.body.removeChild(iframe);\n\t</script>\n\n\n**(四) document.domain + iframe**\n\n对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。\n具体的做法是可以在http://www.a.com/a.html 和http://script.a.com/b.html 两个文件中分别设置`document.domain = 'a.com'`，然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。\nhttp://www.a.com/a.html页面\n```\n<iframe src=\"http://script.a.com/b.html\" frameborder=\"0\"></iframe>\n<script>\n\tdocument.domain = 'a.com';\n</script>\n```\nhttp://script.a.com/b.html页面\n```\n<script>\n\tdocument.domain = 'a.com';\n</script>\n```\n这样俩个页面就可以通过js相互访问各种属性和对象了。\n<b style=\"color:#d44950\">\ndocument.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的document.domain 可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。</b>\n\n---\n\n**(五) HTML5的window.postMessage**\n\nwindow.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。\nwindow.postMessage允许两个窗口/帧之间跨域发送数据消息。从本质上讲，window.postMessage是一个跨域的无服务器垫片的Ajax。\n\n用法：\notherWindow.postMessage(message, targetOrigin);\n\n+ otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.+open的返回值；通过name或下标从window.frames取到的值。\n+ message: 所要发送的数据，string类型。\n+ targetOrigin: 用于限制otherWindow，“*”表示不作限制\n\n数据发送端\na.com/index.html中的代码：\n```\n<iframe id=\"ifr\" src=\"b.com/index.html\"></iframe>\n<script type=\"text/javascript\">\nwindow.onload = function() {\n    var ifr = document.getElementById('ifr');\n    var targetOrigin = 'http://b.com';  // 若写成'http://b.com/c/proxy.html'效果一样\n                                        // 若写成'http://c.com'就不会执行postMessage了\n    ifr.contentWindow.postMessage('I was there!', targetOrigin);\n};\n</script>\n```\n数据接收端\nb.com/index.html中的代码：\n```\n<script type=\"text/javascript\">\n    window.addEventListener('message', function(event){\n        // 通过origin属性判断消息来源地址\n        if (event.origin == 'http://a.com') {\n            alert(event.data);    // 弹出\"I was there!\"\n            alert(event.source);  // 对a.com、index.html中window对象的引用\n                                  // 但由于同源策略，这里event.source不可以访问window对象\n        }\n    }, false);\n</script>\n```\n参考文章：[JavaScript跨域总结与解决办法](http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html)、[js中几种实用的跨域方法原理详解](http://www.cnblogs.com/2050/p/3191744.html#3322244)\n\n\n脑细胞已经阵亡( ⊙ o ⊙ )","source":"_posts/实现跨域.md","raw":"title: 实现跨域\ndate: 2015-12-23 11:09:54\ntags: [javascript,web]\ndescription: 跨域 \n\n---\n\n## 从域说起\n>域： 域是WIN2K网络系统的安全性边界。我们知道一个计算机网最基本的单元就是“域”，这一点不是WIN2K所独有的，但活动目录可以贯穿一个或多个域。在独立的计算机上，域即指计算机本身，一个域可以分布在多个物理位置上，同时一个物理位置又可以划分不同网段为不同的域，每个域都有自己的安全策略以及它与其他域的信任关系。当多个域通过信任关系连接起来之后，活动目录可以被多个信任域域共享 \n\n\n>域树：域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域是通过双向可传递信任关系连接在一起。由于这些信任关系是双向的而且是可传递的，因此在域树或树林中新创建的域可以立即与域树或树林中每个其他的域建立信任关系。这些信任关系允许单一登录过程，在域树或树林中的所有域上对用户进行身份验证，但这不一定意味着经过身份验证的用户在域树的所有域中都拥有相同的权利和权限。因为域是安全界限，所以必须在每个域的基础上为用户指派相应的权利和权限。\n\n<!-- more -->\n\n<b style=\"color:#d44950\">域树中的域层次越深级别越低，一个“.”代表一个层次。</b>\n如域`zhidao.baidu.com `(百度知道)就比 `baidu.com`(百度)这个域级别低，因为它有两个层次关系，而`baidu.com`只有一个层次。\n\n\n## 何为跨域\n\n>默认情况下，，XHR 对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。但是，实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。\n\n<b style=\"color:#d44950\">只要协议、域名、端口有任何一个不同，都被当作是不同的域</b>\n\n比如在http://www.a.com/a.js 页面向以下页面发送一个ajax请求，以下是其请求结果及说明\n\n\n| URL       \t\t\t \t|    说明     \t\t   | 是否允许通信  |\n| :-------- \t\t\t \t| \t\t:--:    \t   | :--:          |\n| http://www.a.com/b.js  \t|  同一域名下 \t\t   |  允许         |\n| http://www.a.com:8000/a.js|  同一域名，不同端口  |  不允许       |\n| https://www.a.com/b.js    |  同一域名，不同协议  |  不允许       |\n| http://script.a.com/b.js \t|  主域相同，子域不同  |  不允许       |\n| http://a.com/b.js \t\t|同一域名，不同二级域名|  不允许       |\n| http://www.a.com/b.js     |  不同域名\t\t\t   |  不允许       |\n\n\n<b style=\"color:#d44950\">对于端口和协议的不同，只能通过后台来解决。我们要解决的是域名不同的问题</b>\n\n## 如何跨域\n\n**(一) CORS(Cross-Origin Resource Sharing，跨源资源共享)**\n>1.CORS（Cross-Origin Resource Sharing，跨源资源共享）是W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。\n2.实现此功能非常简单，只需由服务器发送一个响应标头即可。\n\n浏览器支持情况：\n\n+ IE 8+\n+ Firefox 3.5+\n+ Opera 12+\n+ Safari 4+\n+ Chrome 3+\n\n\n假设我们页面或者应用已在 http://www.a.com/ 上了，而我们打算从 http://www.b.com 请求提取数据。一般情况下，如果我们直接使用 AJAX 来请求将会失败，浏览器也会返回错误。\n利用 CORS，http://www.b.com 只需添加一个标头，就可以允许来自 http://www.a.com 的请求。\n下面是用php进行的设置，“*”号表示允许任何域向我们的服务端提交请求：\n\n\theader{\"Access-Control-Allow-Origin: *\"}\n\nCORS的兼容性写法\n```\n\tfunction createCORSRequest(method, url){\n\t\tvar xhr = new XMLHttpRequest();\n\t\t//非IE浏览器\n\t\tif (\"withCredentials\" in xhr){\n\t\t\txhr.open(method, url, true);\n\t\t//IE浏览器\n\t\t} else if (typeof XDomainRequest != \"undefined\"){\n\t\t\tvxhr = new XDomainRequest();\n\t\t\txhr.open(method, url);\n\t\t} else {\n\t\t\txhr = null;\n\t\t}\n\t\treturn xhr;\n\t}\n\tvar request = createCORSRequest(\"get\", \"http://www.somewhere-else.com/page/\");\n\tif (request){\n\t\trequest.onload = function(){\n\t\t\t//对request.responseText 进行处理\n\t\t};\n\t\trequest.send();\n\t}\n```\n\n---\n\n**(二) JSONP(JSON with Padding 填充式JSON 或参数式JSON)**\n\n在js中，我们虽然不能直接用XMLHttpRequest请求不同域上的数据时，但是在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的\n\nJSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。\n\n例如：\n\n\t<script type=\"text/javascript\">\n\t    function dosomething(jsondata){\n\t        //处理获得的json数据\n\t    }\n\t</script>\n\t<script src=\"http://example.com/data.php?callback=dosomething\"></script>\n\n+ 首先第一个`script`便签定义了一个处理数据的函数;\n+ 然后第二个`script`标签载入一个js文件，http://example.com/data.php 是数据所在地址，但是因为是当做js来引入的，所以http://example.com/data.php 返回的必须是一个能执行的js文件;\n+ 最后js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以php应该是这样的\n```\n\t<?php\n\t$callback = $_GET['callback'];//得到回调函数名\n\t$data = array('a','b','c');//要返回的数据\n\techo $callback.'('.json_encode($data).')';//输出\n\t?>\n```\n\n最终，输出结果为：dosomething(['a','b','c']);\n从上面可以看出jsonp是需要服务器端的页面进行相应的配合的。\n\n\nJSONP的优缺点\n优点:\n\n+ 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；\n+ 能够直接访问响应文本，支持在浏览器与服务器之间双向通信\n\n缺点：\n\n+ JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的Web 服务时，一定得保证它安全可靠。\n+ 它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。\n\n---\n\n**(三) window.name**\n\nwindow对象有个`name`属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。\n\n\n这里有三个页面：\n\na.com/app.html：应用页面。\na.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。\nb.com/data.html：应用页面需要获取数据的页面，可称为数据页面。\n\napp.html\n\n\t<iframe src=\"b.com/data.html\" id=\"iframe\"></iframe>\n\t<script>\n\t\tvar iframe = document.getElementById(\"iframe\");\n\t\tiframe.src = \"a.com/proxy.html\";//这是一个与a.com/app.html同源的页面\n\t\tiframe.onload = function(){\n\t\t\tvar data = iframe.contentWindow.name; //取到数据\n\t\t}\n\n\t</script>\n\t\ndata.html\n\n\t<script>\n\t\t// 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右\n        // 数据格式可以自定义，如json、字符串\n\t\twindow.name = \"数据\"\n\t</script>\n\niframe首先的地址是b.com/data.html，所以能取到`window.name`数据;\n但是iframe现在跟app.html并不同源，app.html无法获取到数据，所以又将iframe的链接跳转至a.com/proxy.html这个代理页面，现在app.html跟iframe就同源了。\n\n<b style=\"color:#d44950\">注意：iframe由b.com/data.html跳转到a.com/proxy.html页面，`window.name`的value是不变的</b>\n\n获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n\n\t<script type=\"text/javascript\">\n\t    iframe.contentWindow.document.write('');\n\t    iframe.contentWindow.close();\n\t    document.body.removeChild(iframe);\n\t</script>\n\n\n**(四) document.domain + iframe**\n\n对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。\n具体的做法是可以在http://www.a.com/a.html 和http://script.a.com/b.html 两个文件中分别设置`document.domain = 'a.com'`，然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。\nhttp://www.a.com/a.html页面\n```\n<iframe src=\"http://script.a.com/b.html\" frameborder=\"0\"></iframe>\n<script>\n\tdocument.domain = 'a.com';\n</script>\n```\nhttp://script.a.com/b.html页面\n```\n<script>\n\tdocument.domain = 'a.com';\n</script>\n```\n这样俩个页面就可以通过js相互访问各种属性和对象了。\n<b style=\"color:#d44950\">\ndocument.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的document.domain 可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。</b>\n\n---\n\n**(五) HTML5的window.postMessage**\n\nwindow.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。\nwindow.postMessage允许两个窗口/帧之间跨域发送数据消息。从本质上讲，window.postMessage是一个跨域的无服务器垫片的Ajax。\n\n用法：\notherWindow.postMessage(message, targetOrigin);\n\n+ otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.+open的返回值；通过name或下标从window.frames取到的值。\n+ message: 所要发送的数据，string类型。\n+ targetOrigin: 用于限制otherWindow，“*”表示不作限制\n\n数据发送端\na.com/index.html中的代码：\n```\n<iframe id=\"ifr\" src=\"b.com/index.html\"></iframe>\n<script type=\"text/javascript\">\nwindow.onload = function() {\n    var ifr = document.getElementById('ifr');\n    var targetOrigin = 'http://b.com';  // 若写成'http://b.com/c/proxy.html'效果一样\n                                        // 若写成'http://c.com'就不会执行postMessage了\n    ifr.contentWindow.postMessage('I was there!', targetOrigin);\n};\n</script>\n```\n数据接收端\nb.com/index.html中的代码：\n```\n<script type=\"text/javascript\">\n    window.addEventListener('message', function(event){\n        // 通过origin属性判断消息来源地址\n        if (event.origin == 'http://a.com') {\n            alert(event.data);    // 弹出\"I was there!\"\n            alert(event.source);  // 对a.com、index.html中window对象的引用\n                                  // 但由于同源策略，这里event.source不可以访问window对象\n        }\n    }, false);\n</script>\n```\n参考文章：[JavaScript跨域总结与解决办法](http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html)、[js中几种实用的跨域方法原理详解](http://www.cnblogs.com/2050/p/3191744.html#3322244)\n\n\n脑细胞已经阵亡( ⊙ o ⊙ )","slug":"实现跨域","published":1,"updated":"2021-12-06T06:07:06.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomh0048y4v2cx6ybhjj","content":"<h2 id=\"从域说起\"><a href=\"#从域说起\" class=\"headerlink\" title=\"从域说起\"></a>从域说起</h2><blockquote>\n<p>域： 域是WIN2K网络系统的安全性边界。我们知道一个计算机网最基本的单元就是“域”，这一点不是WIN2K所独有的，但活动目录可以贯穿一个或多个域。在独立的计算机上，域即指计算机本身，一个域可以分布在多个物理位置上，同时一个物理位置又可以划分不同网段为不同的域，每个域都有自己的安全策略以及它与其他域的信任关系。当多个域通过信任关系连接起来之后，活动目录可以被多个信任域域共享 </p>\n</blockquote>\n<blockquote>\n<p>域树：域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域是通过双向可传递信任关系连接在一起。由于这些信任关系是双向的而且是可传递的，因此在域树或树林中新创建的域可以立即与域树或树林中每个其他的域建立信任关系。这些信任关系允许单一登录过程，在域树或树林中的所有域上对用户进行身份验证，但这不一定意味着经过身份验证的用户在域树的所有域中都拥有相同的权利和权限。因为域是安全界限，所以必须在每个域的基础上为用户指派相应的权利和权限。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p><b style=\"color:#d44950\">域树中的域层次越深级别越低，一个“.”代表一个层次。</b><br>如域<code>zhidao.baidu.com </code>(百度知道)就比 <code>baidu.com</code>(百度)这个域级别低，因为它有两个层次关系，而<code>baidu.com</code>只有一个层次。</p>\n<h2 id=\"何为跨域\"><a href=\"#何为跨域\" class=\"headerlink\" title=\"何为跨域\"></a>何为跨域</h2><blockquote>\n<p>默认情况下，，XHR 对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。但是，实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。</p>\n</blockquote>\n<p><b style=\"color:#d44950\">只要协议、域名、端口有任何一个不同，都被当作是不同的域</b></p>\n<p>比如在<a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a> 页面向以下页面发送一个ajax请求，以下是其请求结果及说明</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">URL</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">是否允许通信</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td align=\"center\">同一域名下</td>\n<td align=\"center\">允许</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"http://www.a.com:8000/a.js\">http://www.a.com:8000/a.js</a></td>\n<td align=\"center\">同一域名，不同端口</td>\n<td align=\"center\">不允许</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.a.com/b.js\">https://www.a.com/b.js</a></td>\n<td align=\"center\">同一域名，不同协议</td>\n<td align=\"center\">不允许</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"http://script.a.com/b.js\">http://script.a.com/b.js</a></td>\n<td align=\"center\">主域相同，子域不同</td>\n<td align=\"center\">不允许</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"http://a.com/b.js\">http://a.com/b.js</a></td>\n<td align=\"center\">同一域名，不同二级域名</td>\n<td align=\"center\">不允许</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td align=\"center\">不同域名</td>\n<td align=\"center\">不允许</td>\n</tr>\n</tbody></table>\n<p><b style=\"color:#d44950\">对于端口和协议的不同，只能通过后台来解决。我们要解决的是域名不同的问题</b></p>\n<h2 id=\"如何跨域\"><a href=\"#如何跨域\" class=\"headerlink\" title=\"如何跨域\"></a>如何跨域</h2><p><strong>(一) CORS(Cross-Origin Resource Sharing，跨源资源共享)</strong></p>\n<blockquote>\n<p>1.CORS（Cross-Origin Resource Sharing，跨源资源共享）是W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。<br>2.实现此功能非常简单，只需由服务器发送一个响应标头即可。</p>\n</blockquote>\n<p>浏览器支持情况：</p>\n<ul>\n<li>IE 8+</li>\n<li>Firefox 3.5+</li>\n<li>Opera 12+</li>\n<li>Safari 4+</li>\n<li>Chrome 3+</li>\n</ul>\n<p>假设我们页面或者应用已在 <a href=\"http://www.a.com/\">http://www.a.com/</a> 上了，而我们打算从 <a href=\"http://www.b.com/\">http://www.b.com</a> 请求提取数据。一般情况下，如果我们直接使用 AJAX 来请求将会失败，浏览器也会返回错误。<br>利用 CORS，<a href=\"http://www.b.com/\">http://www.b.com</a> 只需添加一个标头，就可以允许来自 <a href=\"http://www.a.com/\">http://www.a.com</a> 的请求。<br>下面是用php进行的设置，“*”号表示允许任何域向我们的服务端提交请求：</p>\n<pre><code>header&#123;&quot;Access-Control-Allow-Origin: *&quot;&#125;\n</code></pre>\n<p>CORS的兼容性写法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createCORSRequest(method, url)&#123;</span><br><span class=\"line\">\tvar xhr = new XMLHttpRequest();</span><br><span class=\"line\">\t//非IE浏览器</span><br><span class=\"line\">\tif (&quot;withCredentials&quot; in xhr)&#123;</span><br><span class=\"line\">\t\txhr.open(method, url, true);</span><br><span class=\"line\">\t//IE浏览器</span><br><span class=\"line\">\t&#125; else if (typeof XDomainRequest != &quot;undefined&quot;)&#123;</span><br><span class=\"line\">\t\tvxhr = new XDomainRequest();</span><br><span class=\"line\">\t\txhr.open(method, url);</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\txhr = null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn xhr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var request = createCORSRequest(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;);</span><br><span class=\"line\">if (request)&#123;</span><br><span class=\"line\">\trequest.onload = function()&#123;</span><br><span class=\"line\">\t\t//对request.responseText 进行处理</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\trequest.send();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>(二) JSONP(JSON with Padding 填充式JSON 或参数式JSON)</strong></p>\n<p>在js中，我们虽然不能直接用XMLHttpRequest请求不同域上的数据时，但是在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的</p>\n<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</p>\n<p>例如：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    function dosomething(jsondata)&#123;\n        //处理获得的json数据\n    &#125;\n&lt;/script&gt;\n&lt;script src=&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;\n</code></pre>\n<ul>\n<li>首先第一个<code>script</code>便签定义了一个处理数据的函数;</li>\n<li>然后第二个<code>script</code>标签载入一个js文件，<a href=\"http://example.com/data.php\">http://example.com/data.php</a> 是数据所在地址，但是因为是当做js来引入的，所以<a href=\"http://example.com/data.php\">http://example.com/data.php</a> 返回的必须是一个能执行的js文件;</li>\n<li>最后js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以php应该是这样的<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">$callback = $_GET[&#x27;callback&#x27;];//得到回调函数名</span><br><span class=\"line\">$data = array(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);//要返回的数据</span><br><span class=\"line\">echo $callback.&#x27;(&#x27;.json_encode($data).&#x27;)&#x27;;//输出</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);<br>从上面可以看出jsonp是需要服务器端的页面进行相应的配合的。</p>\n<p>JSONP的优缺点<br>优点:</p>\n<ul>\n<li>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；</li>\n<li>能够直接访问响应文本，支持在浏览器与服务器之间双向通信</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的Web 服务时，一定得保证它安全可靠。</li>\n<li>它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>\n</ul>\n<hr>\n<p><strong>(三) window.name</strong></p>\n<p>window对象有个<code>name</code>属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>\n<p>这里有三个页面：</p>\n<p>a.com/app.html：应用页面。<br>a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。<br>b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。</p>\n<p>app.html</p>\n<pre><code>&lt;iframe src=&quot;b.com/data.html&quot; id=&quot;iframe&quot;&gt;&lt;/iframe&gt;\n&lt;script&gt;\n    var iframe = document.getElementById(&quot;iframe&quot;);\n    iframe.src = &quot;a.com/proxy.html&quot;;//这是一个与a.com/app.html同源的页面\n    iframe.onload = function()&#123;\n        var data = iframe.contentWindow.name; //取到数据\n    &#125;\n\n&lt;/script&gt;\n</code></pre>\n<p>data.html</p>\n<pre><code>&lt;script&gt;\n    // 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右\n    // 数据格式可以自定义，如json、字符串\n    window.name = &quot;数据&quot;\n&lt;/script&gt;\n</code></pre>\n<p>iframe首先的地址是b.com/data.html，所以能取到<code>window.name</code>数据;<br>但是iframe现在跟app.html并不同源，app.html无法获取到数据，所以又将iframe的链接跳转至a.com/proxy.html这个代理页面，现在app.html跟iframe就同源了。</p>\n<p><b style=\"color:#d44950\">注意：iframe由b.com/data.html跳转到a.com/proxy.html页面，<code>window.name</code>的value是不变的</b></p>\n<p>获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    iframe.contentWindow.document.write(&#39;&#39;);\n    iframe.contentWindow.close();\n    document.body.removeChild(iframe);\n&lt;/script&gt;\n</code></pre>\n<p><strong>(四) document.domain + iframe</strong></p>\n<p>对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。<br>具体的做法是可以在<a href=\"http://www.a.com/a.html\">http://www.a.com/a.html</a> 和<a href=\"http://script.a.com/b.html\">http://script.a.com/b.html</a> 两个文件中分别设置<code>document.domain = &#39;a.com&#39;</code>，然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。<br><a href=\"http://www.a.com/a.html%E9%A1%B5%E9%9D%A2\">http://www.a.com/a.html页面</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;iframe src=&quot;http://script.a.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\tdocument.domain = &#x27;a.com&#x27;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://script.a.com/b.html%E9%A1%B5%E9%9D%A2\">http://script.a.com/b.html页面</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\tdocument.domain = &#x27;a.com&#x27;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这样俩个页面就可以通过js相互访问各种属性和对象了。<br><b style=\"color:#d44950\"><br>document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的document.domain 可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。</b></p>\n<hr>\n<p><strong>(五) HTML5的window.postMessage</strong></p>\n<p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。<br>window.postMessage允许两个窗口/帧之间跨域发送数据消息。从本质上讲，window.postMessage是一个跨域的无服务器垫片的Ajax。</p>\n<p>用法：<br>otherWindow.postMessage(message, targetOrigin);</p>\n<ul>\n<li>otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.+open的返回值；通过name或下标从window.frames取到的值。</li>\n<li>message: 所要发送的数据，string类型。</li>\n<li>targetOrigin: 用于限制otherWindow，“*”表示不作限制</li>\n</ul>\n<p>数据发送端<br>a.com/index.html中的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">window.onload = function() &#123;</span><br><span class=\"line\">    var ifr = document.getElementById(&#x27;ifr&#x27;);</span><br><span class=\"line\">    var targetOrigin = &#x27;http://b.com&#x27;;  // 若写成&#x27;http://b.com/c/proxy.html&#x27;效果一样</span><br><span class=\"line\">                                        // 若写成&#x27;http://c.com&#x27;就不会执行postMessage了</span><br><span class=\"line\">    ifr.contentWindow.postMessage(&#x27;I was there!&#x27;, targetOrigin);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>数据接收端<br>b.com/index.html中的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    window.addEventListener(&#x27;message&#x27;, function(event)&#123;</span><br><span class=\"line\">        // 通过origin属性判断消息来源地址</span><br><span class=\"line\">        if (event.origin == &#x27;http://a.com&#x27;) &#123;</span><br><span class=\"line\">            alert(event.data);    // 弹出&quot;I was there!&quot;</span><br><span class=\"line\">            alert(event.source);  // 对a.com、index.html中window对象的引用</span><br><span class=\"line\">                                  // 但由于同源策略，这里event.source不可以访问window对象</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, false);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>参考文章：<a href=\"http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html\">JavaScript跨域总结与解决办法</a>、<a href=\"http://www.cnblogs.com/2050/p/3191744.html#3322244\">js中几种实用的跨域方法原理详解</a></p>\n<p>脑细胞已经阵亡( ⊙ o ⊙ )</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"从域说起\"><a href=\"#从域说起\" class=\"headerlink\" title=\"从域说起\"></a>从域说起</h2><blockquote>\n<p>域： 域是WIN2K网络系统的安全性边界。我们知道一个计算机网最基本的单元就是“域”，这一点不是WIN2K所独有的，但活动目录可以贯穿一个或多个域。在独立的计算机上，域即指计算机本身，一个域可以分布在多个物理位置上，同时一个物理位置又可以划分不同网段为不同的域，每个域都有自己的安全策略以及它与其他域的信任关系。当多个域通过信任关系连接起来之后，活动目录可以被多个信任域域共享 </p>\n</blockquote>\n<blockquote>\n<p>域树：域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域是通过双向可传递信任关系连接在一起。由于这些信任关系是双向的而且是可传递的，因此在域树或树林中新创建的域可以立即与域树或树林中每个其他的域建立信任关系。这些信任关系允许单一登录过程，在域树或树林中的所有域上对用户进行身份验证，但这不一定意味着经过身份验证的用户在域树的所有域中都拥有相同的权利和权限。因为域是安全界限，所以必须在每个域的基础上为用户指派相应的权利和权限。</p>\n</blockquote>","more":"<p><b style=\"color:#d44950\">域树中的域层次越深级别越低，一个“.”代表一个层次。</b><br>如域<code>zhidao.baidu.com </code>(百度知道)就比 <code>baidu.com</code>(百度)这个域级别低，因为它有两个层次关系，而<code>baidu.com</code>只有一个层次。</p>\n<h2 id=\"何为跨域\"><a href=\"#何为跨域\" class=\"headerlink\" title=\"何为跨域\"></a>何为跨域</h2><blockquote>\n<p>默认情况下，，XHR 对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。但是，实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。</p>\n</blockquote>\n<p><b style=\"color:#d44950\">只要协议、域名、端口有任何一个不同，都被当作是不同的域</b></p>\n<p>比如在<a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a> 页面向以下页面发送一个ajax请求，以下是其请求结果及说明</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">URL</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">是否允许通信</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td align=\"center\">同一域名下</td>\n<td align=\"center\">允许</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"http://www.a.com:8000/a.js\">http://www.a.com:8000/a.js</a></td>\n<td align=\"center\">同一域名，不同端口</td>\n<td align=\"center\">不允许</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.a.com/b.js\">https://www.a.com/b.js</a></td>\n<td align=\"center\">同一域名，不同协议</td>\n<td align=\"center\">不允许</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"http://script.a.com/b.js\">http://script.a.com/b.js</a></td>\n<td align=\"center\">主域相同，子域不同</td>\n<td align=\"center\">不允许</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"http://a.com/b.js\">http://a.com/b.js</a></td>\n<td align=\"center\">同一域名，不同二级域名</td>\n<td align=\"center\">不允许</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td align=\"center\">不同域名</td>\n<td align=\"center\">不允许</td>\n</tr>\n</tbody></table>\n<p><b style=\"color:#d44950\">对于端口和协议的不同，只能通过后台来解决。我们要解决的是域名不同的问题</b></p>\n<h2 id=\"如何跨域\"><a href=\"#如何跨域\" class=\"headerlink\" title=\"如何跨域\"></a>如何跨域</h2><p><strong>(一) CORS(Cross-Origin Resource Sharing，跨源资源共享)</strong></p>\n<blockquote>\n<p>1.CORS（Cross-Origin Resource Sharing，跨源资源共享）是W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。<br>2.实现此功能非常简单，只需由服务器发送一个响应标头即可。</p>\n</blockquote>\n<p>浏览器支持情况：</p>\n<ul>\n<li>IE 8+</li>\n<li>Firefox 3.5+</li>\n<li>Opera 12+</li>\n<li>Safari 4+</li>\n<li>Chrome 3+</li>\n</ul>\n<p>假设我们页面或者应用已在 <a href=\"http://www.a.com/\">http://www.a.com/</a> 上了，而我们打算从 <a href=\"http://www.b.com/\">http://www.b.com</a> 请求提取数据。一般情况下，如果我们直接使用 AJAX 来请求将会失败，浏览器也会返回错误。<br>利用 CORS，<a href=\"http://www.b.com/\">http://www.b.com</a> 只需添加一个标头，就可以允许来自 <a href=\"http://www.a.com/\">http://www.a.com</a> 的请求。<br>下面是用php进行的设置，“*”号表示允许任何域向我们的服务端提交请求：</p>\n<pre><code>header&#123;&quot;Access-Control-Allow-Origin: *&quot;&#125;\n</code></pre>\n<p>CORS的兼容性写法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createCORSRequest(method, url)&#123;</span><br><span class=\"line\">\tvar xhr = new XMLHttpRequest();</span><br><span class=\"line\">\t//非IE浏览器</span><br><span class=\"line\">\tif (&quot;withCredentials&quot; in xhr)&#123;</span><br><span class=\"line\">\t\txhr.open(method, url, true);</span><br><span class=\"line\">\t//IE浏览器</span><br><span class=\"line\">\t&#125; else if (typeof XDomainRequest != &quot;undefined&quot;)&#123;</span><br><span class=\"line\">\t\tvxhr = new XDomainRequest();</span><br><span class=\"line\">\t\txhr.open(method, url);</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\txhr = null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn xhr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var request = createCORSRequest(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;);</span><br><span class=\"line\">if (request)&#123;</span><br><span class=\"line\">\trequest.onload = function()&#123;</span><br><span class=\"line\">\t\t//对request.responseText 进行处理</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\trequest.send();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>(二) JSONP(JSON with Padding 填充式JSON 或参数式JSON)</strong></p>\n<p>在js中，我们虽然不能直接用XMLHttpRequest请求不同域上的数据时，但是在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的</p>\n<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</p>\n<p>例如：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    function dosomething(jsondata)&#123;\n        //处理获得的json数据\n    &#125;\n&lt;/script&gt;\n&lt;script src=&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;\n</code></pre>\n<ul>\n<li>首先第一个<code>script</code>便签定义了一个处理数据的函数;</li>\n<li>然后第二个<code>script</code>标签载入一个js文件，<a href=\"http://example.com/data.php\">http://example.com/data.php</a> 是数据所在地址，但是因为是当做js来引入的，所以<a href=\"http://example.com/data.php\">http://example.com/data.php</a> 返回的必须是一个能执行的js文件;</li>\n<li>最后js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以php应该是这样的<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">$callback = $_GET[&#x27;callback&#x27;];//得到回调函数名</span><br><span class=\"line\">$data = array(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);//要返回的数据</span><br><span class=\"line\">echo $callback.&#x27;(&#x27;.json_encode($data).&#x27;)&#x27;;//输出</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);<br>从上面可以看出jsonp是需要服务器端的页面进行相应的配合的。</p>\n<p>JSONP的优缺点<br>优点:</p>\n<ul>\n<li>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；</li>\n<li>能够直接访问响应文本，支持在浏览器与服务器之间双向通信</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的Web 服务时，一定得保证它安全可靠。</li>\n<li>它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>\n</ul>\n<hr>\n<p><strong>(三) window.name</strong></p>\n<p>window对象有个<code>name</code>属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>\n<p>这里有三个页面：</p>\n<p>a.com/app.html：应用页面。<br>a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。<br>b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。</p>\n<p>app.html</p>\n<pre><code>&lt;iframe src=&quot;b.com/data.html&quot; id=&quot;iframe&quot;&gt;&lt;/iframe&gt;\n&lt;script&gt;\n    var iframe = document.getElementById(&quot;iframe&quot;);\n    iframe.src = &quot;a.com/proxy.html&quot;;//这是一个与a.com/app.html同源的页面\n    iframe.onload = function()&#123;\n        var data = iframe.contentWindow.name; //取到数据\n    &#125;\n\n&lt;/script&gt;\n</code></pre>\n<p>data.html</p>\n<pre><code>&lt;script&gt;\n    // 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右\n    // 数据格式可以自定义，如json、字符串\n    window.name = &quot;数据&quot;\n&lt;/script&gt;\n</code></pre>\n<p>iframe首先的地址是b.com/data.html，所以能取到<code>window.name</code>数据;<br>但是iframe现在跟app.html并不同源，app.html无法获取到数据，所以又将iframe的链接跳转至a.com/proxy.html这个代理页面，现在app.html跟iframe就同源了。</p>\n<p><b style=\"color:#d44950\">注意：iframe由b.com/data.html跳转到a.com/proxy.html页面，<code>window.name</code>的value是不变的</b></p>\n<p>获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    iframe.contentWindow.document.write(&#39;&#39;);\n    iframe.contentWindow.close();\n    document.body.removeChild(iframe);\n&lt;/script&gt;\n</code></pre>\n<p><strong>(四) document.domain + iframe</strong></p>\n<p>对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。<br>具体的做法是可以在<a href=\"http://www.a.com/a.html\">http://www.a.com/a.html</a> 和<a href=\"http://script.a.com/b.html\">http://script.a.com/b.html</a> 两个文件中分别设置<code>document.domain = &#39;a.com&#39;</code>，然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。<br><a href=\"http://www.a.com/a.html%E9%A1%B5%E9%9D%A2\">http://www.a.com/a.html页面</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;iframe src=&quot;http://script.a.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\tdocument.domain = &#x27;a.com&#x27;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://script.a.com/b.html%E9%A1%B5%E9%9D%A2\">http://script.a.com/b.html页面</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\tdocument.domain = &#x27;a.com&#x27;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这样俩个页面就可以通过js相互访问各种属性和对象了。<br><b style=\"color:#d44950\"><br>document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的document.domain 可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。</b></p>\n<hr>\n<p><strong>(五) HTML5的window.postMessage</strong></p>\n<p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。<br>window.postMessage允许两个窗口/帧之间跨域发送数据消息。从本质上讲，window.postMessage是一个跨域的无服务器垫片的Ajax。</p>\n<p>用法：<br>otherWindow.postMessage(message, targetOrigin);</p>\n<ul>\n<li>otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.+open的返回值；通过name或下标从window.frames取到的值。</li>\n<li>message: 所要发送的数据，string类型。</li>\n<li>targetOrigin: 用于限制otherWindow，“*”表示不作限制</li>\n</ul>\n<p>数据发送端<br>a.com/index.html中的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">window.onload = function() &#123;</span><br><span class=\"line\">    var ifr = document.getElementById(&#x27;ifr&#x27;);</span><br><span class=\"line\">    var targetOrigin = &#x27;http://b.com&#x27;;  // 若写成&#x27;http://b.com/c/proxy.html&#x27;效果一样</span><br><span class=\"line\">                                        // 若写成&#x27;http://c.com&#x27;就不会执行postMessage了</span><br><span class=\"line\">    ifr.contentWindow.postMessage(&#x27;I was there!&#x27;, targetOrigin);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>数据接收端<br>b.com/index.html中的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    window.addEventListener(&#x27;message&#x27;, function(event)&#123;</span><br><span class=\"line\">        // 通过origin属性判断消息来源地址</span><br><span class=\"line\">        if (event.origin == &#x27;http://a.com&#x27;) &#123;</span><br><span class=\"line\">            alert(event.data);    // 弹出&quot;I was there!&quot;</span><br><span class=\"line\">            alert(event.source);  // 对a.com、index.html中window对象的引用</span><br><span class=\"line\">                                  // 但由于同源策略，这里event.source不可以访问window对象</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, false);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>参考文章：<a href=\"http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html\">JavaScript跨域总结与解决办法</a>、<a href=\"http://www.cnblogs.com/2050/p/3191744.html#3322244\">js中几种实用的跨域方法原理详解</a></p>\n<p>脑细胞已经阵亡( ⊙ o ⊙ )</p>"},{"title":"对象的创建","date":"2015-09-23T06:27:42.000Z","description":"工厂模式，构造函数，原型模式，创建对象，字面量，new","_content":"\nECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。每个对象都是基于一个引用类型创建的，这个引用类型可以是第5 章讨论的原生类型，也可以是开发人员定义的类型。\n\n<!-- more -->\n\n### 1. 字面量\n\tvar Person={\n\t\t    this.name = name;\n\t\t    this.age = age;\n\t\t    this.job = job;\n\t\t    this.sayName = function(){\n\t\t        alert(this.name);\n\t\t    }\n\t    };\n\n### 2. 通过new创建\n\n\tvar Person = new object();\n\n\t    Person.name = name;\n\t    Person.age = age;\n\t    Person.job = job;\n\t    Person.sayName = function(){\n\t        alert(this.name);\n\t    }\n\t   \n### 3.工厂模式\n工厂模式解决了创建多个相似对象的问题，但存在对象识别的问题。\n\n\tfunction person(name, age, job){\n\t  var o = new Object();\n\t  o.name = name;\n\t  o.age = age;\n\t  o.job = job;\n\t  o.sayName = function(){\n\t    alert(this.name);\n\t  };\n\t  return o;\n\t}\n\tvar person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");\n\n### 4.构造函数\n直接将属性和方法赋给了this 对象；\n构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。\n\n构造函数解决l了对象识别的问题，但它的每个方法都要在每个实例上重新创建一遍。\n\n\tfunction Person(name, age, job){\n\t    this.name = name;\n\t    this.age = age;\n\t    this.job = job;\n\t    this.sayName = function(){\n\t        alert(this.name);\n\t    };\n\t}\n\tvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");  //实例化\n\n### 5.原型模式\n每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。\n\n原型模式实现了共享，但是所有属性都是共享的，牵一发而动全身，一个实例的变化会导致所有实例的变化。\n\n\tfunction Person(){\n\n\t}\n\t \n\tPerson.prototype.name = \"Nicholas\";\n\tPerson.prototype.age = 29;\n\tPerson.prototype.job = \"Software Engineer\";\n\tPerson.prototype.sayName = function(){\n\t\talert(this.name);\n\t};\n\tvar person1 = new Person();\n\tperson1.sayName();\n\n或者\n\n\tfunction Person(){\n\n\t}\n\n\tPerson.prototype = {\n\t　　name : \"Nicholas\",\n\t　　age : 29,\n\t　　job: \"Software Engineer\",\n\t　　sayName : function () {\n\t　　\talert(this.name);\n\t\t}\n\t};\n\n### 6.原型+构造函数\n\n\tfunction Person(name, age, job){\n\t    this.name = name;\n\t    this.age = age;\n\t    this.job = job;\n\t    this.friends = [\"Shelby\", \"Court\"];\n\t}\n\tPerson.prototype = {\n\t    constructor : Person,\n\t    sayName : function(){\n\t    alert(this.name);\n\t    }\n\t}\n\n","source":"_posts/对象的创建.md","raw":"title: 对象的创建\ndate: 2015-09-23 14:27:42\ntags: [web,javascript]\ndescription: 工厂模式，构造函数，原型模式，创建对象，字面量，new\n\n---\n\nECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。每个对象都是基于一个引用类型创建的，这个引用类型可以是第5 章讨论的原生类型，也可以是开发人员定义的类型。\n\n<!-- more -->\n\n### 1. 字面量\n\tvar Person={\n\t\t    this.name = name;\n\t\t    this.age = age;\n\t\t    this.job = job;\n\t\t    this.sayName = function(){\n\t\t        alert(this.name);\n\t\t    }\n\t    };\n\n### 2. 通过new创建\n\n\tvar Person = new object();\n\n\t    Person.name = name;\n\t    Person.age = age;\n\t    Person.job = job;\n\t    Person.sayName = function(){\n\t        alert(this.name);\n\t    }\n\t   \n### 3.工厂模式\n工厂模式解决了创建多个相似对象的问题，但存在对象识别的问题。\n\n\tfunction person(name, age, job){\n\t  var o = new Object();\n\t  o.name = name;\n\t  o.age = age;\n\t  o.job = job;\n\t  o.sayName = function(){\n\t    alert(this.name);\n\t  };\n\t  return o;\n\t}\n\tvar person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");\n\n### 4.构造函数\n直接将属性和方法赋给了this 对象；\n构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。\n\n构造函数解决l了对象识别的问题，但它的每个方法都要在每个实例上重新创建一遍。\n\n\tfunction Person(name, age, job){\n\t    this.name = name;\n\t    this.age = age;\n\t    this.job = job;\n\t    this.sayName = function(){\n\t        alert(this.name);\n\t    };\n\t}\n\tvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");  //实例化\n\n### 5.原型模式\n每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。\n\n原型模式实现了共享，但是所有属性都是共享的，牵一发而动全身，一个实例的变化会导致所有实例的变化。\n\n\tfunction Person(){\n\n\t}\n\t \n\tPerson.prototype.name = \"Nicholas\";\n\tPerson.prototype.age = 29;\n\tPerson.prototype.job = \"Software Engineer\";\n\tPerson.prototype.sayName = function(){\n\t\talert(this.name);\n\t};\n\tvar person1 = new Person();\n\tperson1.sayName();\n\n或者\n\n\tfunction Person(){\n\n\t}\n\n\tPerson.prototype = {\n\t　　name : \"Nicholas\",\n\t　　age : 29,\n\t　　job: \"Software Engineer\",\n\t　　sayName : function () {\n\t　　\talert(this.name);\n\t\t}\n\t};\n\n### 6.原型+构造函数\n\n\tfunction Person(name, age, job){\n\t    this.name = name;\n\t    this.age = age;\n\t    this.job = job;\n\t    this.friends = [\"Shelby\", \"Court\"];\n\t}\n\tPerson.prototype = {\n\t    constructor : Person,\n\t    sayName : function(){\n\t    alert(this.name);\n\t    }\n\t}\n\n","slug":"对象的创建","published":1,"updated":"2021-12-06T06:07:06.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomi004ay4v22qgmequ8","content":"<p>ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。每个对象都是基于一个引用类型创建的，这个引用类型可以是第5 章讨论的原生类型，也可以是开发人员定义的类型。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"1-字面量\"><a href=\"#1-字面量\" class=\"headerlink\" title=\"1. 字面量\"></a>1. 字面量</h3><pre><code>var Person=&#123;\n        this.name = name;\n        this.age = age;\n        this.job = job;\n        this.sayName = function()&#123;\n            alert(this.name);\n        &#125;\n    &#125;;\n</code></pre>\n<h3 id=\"2-通过new创建\"><a href=\"#2-通过new创建\" class=\"headerlink\" title=\"2. 通过new创建\"></a>2. 通过new创建</h3><pre><code>var Person = new object();\n\n    Person.name = name;\n    Person.age = age;\n    Person.job = job;\n    Person.sayName = function()&#123;\n        alert(this.name);\n    &#125;\n   \n</code></pre>\n<h3 id=\"3-工厂模式\"><a href=\"#3-工厂模式\" class=\"headerlink\" title=\"3.工厂模式\"></a>3.工厂模式</h3><p>工厂模式解决了创建多个相似对象的问题，但存在对象识别的问题。</p>\n<pre><code>function person(name, age, job)&#123;\n  var o = new Object();\n  o.name = name;\n  o.age = age;\n  o.job = job;\n  o.sayName = function()&#123;\n    alert(this.name);\n  &#125;;\n  return o;\n&#125;\nvar person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\n</code></pre>\n<h3 id=\"4-构造函数\"><a href=\"#4-构造函数\" class=\"headerlink\" title=\"4.构造函数\"></a>4.构造函数</h3><p>直接将属性和方法赋给了this 对象；<br>构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</p>\n<p>构造函数解决l了对象识别的问题，但它的每个方法都要在每个实例上重新创建一遍。</p>\n<pre><code>function Person(name, age, job)&#123;\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function()&#123;\n        alert(this.name);\n    &#125;;\n&#125;\nvar person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);  //实例化\n</code></pre>\n<h3 id=\"5-原型模式\"><a href=\"#5-原型模式\" class=\"headerlink\" title=\"5.原型模式\"></a>5.原型模式</h3><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>\n<p>原型模式实现了共享，但是所有属性都是共享的，牵一发而动全身，一个实例的变化会导致所有实例的变化。</p>\n<pre><code>function Person()&#123;\n\n&#125;\n \nPerson.prototype.name = &quot;Nicholas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function()&#123;\n    alert(this.name);\n&#125;;\nvar person1 = new Person();\nperson1.sayName();\n</code></pre>\n<p>或者</p>\n<pre><code>function Person()&#123;\n\n&#125;\n\nPerson.prototype = &#123;\n　　name : &quot;Nicholas&quot;,\n　　age : 29,\n　　job: &quot;Software Engineer&quot;,\n　　sayName : function () &#123;\n　　    alert(this.name);\n    &#125;\n&#125;;\n</code></pre>\n<h3 id=\"6-原型-构造函数\"><a href=\"#6-原型-构造函数\" class=\"headerlink\" title=\"6.原型+构造函数\"></a>6.原型+构造函数</h3><pre><code>function Person(name, age, job)&#123;\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];\n&#125;\nPerson.prototype = &#123;\n    constructor : Person,\n    sayName : function()&#123;\n    alert(this.name);\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。每个对象都是基于一个引用类型创建的，这个引用类型可以是第5 章讨论的原生类型，也可以是开发人员定义的类型。</p>","more":"<h3 id=\"1-字面量\"><a href=\"#1-字面量\" class=\"headerlink\" title=\"1. 字面量\"></a>1. 字面量</h3><pre><code>var Person=&#123;\n        this.name = name;\n        this.age = age;\n        this.job = job;\n        this.sayName = function()&#123;\n            alert(this.name);\n        &#125;\n    &#125;;\n</code></pre>\n<h3 id=\"2-通过new创建\"><a href=\"#2-通过new创建\" class=\"headerlink\" title=\"2. 通过new创建\"></a>2. 通过new创建</h3><pre><code>var Person = new object();\n\n    Person.name = name;\n    Person.age = age;\n    Person.job = job;\n    Person.sayName = function()&#123;\n        alert(this.name);\n    &#125;\n   \n</code></pre>\n<h3 id=\"3-工厂模式\"><a href=\"#3-工厂模式\" class=\"headerlink\" title=\"3.工厂模式\"></a>3.工厂模式</h3><p>工厂模式解决了创建多个相似对象的问题，但存在对象识别的问题。</p>\n<pre><code>function person(name, age, job)&#123;\n  var o = new Object();\n  o.name = name;\n  o.age = age;\n  o.job = job;\n  o.sayName = function()&#123;\n    alert(this.name);\n  &#125;;\n  return o;\n&#125;\nvar person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\n</code></pre>\n<h3 id=\"4-构造函数\"><a href=\"#4-构造函数\" class=\"headerlink\" title=\"4.构造函数\"></a>4.构造函数</h3><p>直接将属性和方法赋给了this 对象；<br>构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</p>\n<p>构造函数解决l了对象识别的问题，但它的每个方法都要在每个实例上重新创建一遍。</p>\n<pre><code>function Person(name, age, job)&#123;\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function()&#123;\n        alert(this.name);\n    &#125;;\n&#125;\nvar person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);  //实例化\n</code></pre>\n<h3 id=\"5-原型模式\"><a href=\"#5-原型模式\" class=\"headerlink\" title=\"5.原型模式\"></a>5.原型模式</h3><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>\n<p>原型模式实现了共享，但是所有属性都是共享的，牵一发而动全身，一个实例的变化会导致所有实例的变化。</p>\n<pre><code>function Person()&#123;\n\n&#125;\n \nPerson.prototype.name = &quot;Nicholas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function()&#123;\n    alert(this.name);\n&#125;;\nvar person1 = new Person();\nperson1.sayName();\n</code></pre>\n<p>或者</p>\n<pre><code>function Person()&#123;\n\n&#125;\n\nPerson.prototype = &#123;\n　　name : &quot;Nicholas&quot;,\n　　age : 29,\n　　job: &quot;Software Engineer&quot;,\n　　sayName : function () &#123;\n　　    alert(this.name);\n    &#125;\n&#125;;\n</code></pre>\n<h3 id=\"6-原型-构造函数\"><a href=\"#6-原型-构造函数\" class=\"headerlink\" title=\"6.原型+构造函数\"></a>6.原型+构造函数</h3><pre><code>function Person(name, age, job)&#123;\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];\n&#125;\nPerson.prototype = &#123;\n    constructor : Person,\n    sayName : function()&#123;\n    alert(this.name);\n    &#125;\n&#125;\n</code></pre>"},{"_content":"\n\n# 如何处理输入框的emoji表情\n\n在前端开发中，特别是移动端，我们常常会遇到这个用户输入表情后，数据库无法保存甚至是报错的问题，今天我们就一起来研究一下这个问题的产生以及如何解决它。\n\n## 为什么输入表情后，数据库无法存储？\n\n我先把答案抛出： emoji用到的是4字节的utf-16编码，数据库是采用的utf-8编码，并且最大只允许3字节的字符。\n\n至此，我们的问题变成首先要搞懂UTF-8和UTF-16编码了。\n\n\n\n检测四字节的Unicode\n\n\n\n## Unicode\n\n\n## 编码\n\n\n\n\n\n\nASCII 码\n\nUTF-8\n\n\nUTF-16\n\n\n\n[字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n\n\nweb\n\n使用utf-8\n\n\n所以我们只要检测utf-16\n\n\n\n4字节的utf-16编码范围为U+010000到U+10FFFF\n/[\\u010000-\\u10FFFF]/g\n\n\n\njavascript采用的是是ucs-2编码；所以正则需要再转化为ucs-2","source":"_posts/如何处理输入框的emoji表情.md","raw":"\n\n# 如何处理输入框的emoji表情\n\n在前端开发中，特别是移动端，我们常常会遇到这个用户输入表情后，数据库无法保存甚至是报错的问题，今天我们就一起来研究一下这个问题的产生以及如何解决它。\n\n## 为什么输入表情后，数据库无法存储？\n\n我先把答案抛出： emoji用到的是4字节的utf-16编码，数据库是采用的utf-8编码，并且最大只允许3字节的字符。\n\n至此，我们的问题变成首先要搞懂UTF-8和UTF-16编码了。\n\n\n\n检测四字节的Unicode\n\n\n\n## Unicode\n\n\n## 编码\n\n\n\n\n\n\nASCII 码\n\nUTF-8\n\n\nUTF-16\n\n\n\n[字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n\n\nweb\n\n使用utf-8\n\n\n所以我们只要检测utf-16\n\n\n\n4字节的utf-16编码范围为U+010000到U+10FFFF\n/[\\u010000-\\u10FFFF]/g\n\n\n\njavascript采用的是是ucs-2编码；所以正则需要再转化为ucs-2","slug":"如何处理输入框的emoji表情","published":1,"date":"2021-12-06T06:07:06.318Z","updated":"2021-12-06T06:07:06.318Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomj004cy4v20yj25n83","content":"<h1 id=\"如何处理输入框的emoji表情\"><a href=\"#如何处理输入框的emoji表情\" class=\"headerlink\" title=\"如何处理输入框的emoji表情\"></a>如何处理输入框的emoji表情</h1><p>在前端开发中，特别是移动端，我们常常会遇到这个用户输入表情后，数据库无法保存甚至是报错的问题，今天我们就一起来研究一下这个问题的产生以及如何解决它。</p>\n<h2 id=\"为什么输入表情后，数据库无法存储？\"><a href=\"#为什么输入表情后，数据库无法存储？\" class=\"headerlink\" title=\"为什么输入表情后，数据库无法存储？\"></a>为什么输入表情后，数据库无法存储？</h2><p>我先把答案抛出： emoji用到的是4字节的utf-16编码，数据库是采用的utf-8编码，并且最大只允许3字节的字符。</p>\n<p>至此，我们的问题变成首先要搞懂UTF-8和UTF-16编码了。</p>\n<p>检测四字节的Unicode</p>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>ASCII 码</p>\n<p>UTF-8</p>\n<p>UTF-16</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>\n<p>web</p>\n<p>使用utf-8</p>\n<p>所以我们只要检测utf-16</p>\n<p>4字节的utf-16编码范围为U+010000到U+10FFFF<br>/[\\u010000-\\u10FFFF]/g</p>\n<p>javascript采用的是是ucs-2编码；所以正则需要再转化为ucs-2</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"如何处理输入框的emoji表情\"><a href=\"#如何处理输入框的emoji表情\" class=\"headerlink\" title=\"如何处理输入框的emoji表情\"></a>如何处理输入框的emoji表情</h1><p>在前端开发中，特别是移动端，我们常常会遇到这个用户输入表情后，数据库无法保存甚至是报错的问题，今天我们就一起来研究一下这个问题的产生以及如何解决它。</p>\n<h2 id=\"为什么输入表情后，数据库无法存储？\"><a href=\"#为什么输入表情后，数据库无法存储？\" class=\"headerlink\" title=\"为什么输入表情后，数据库无法存储？\"></a>为什么输入表情后，数据库无法存储？</h2><p>我先把答案抛出： emoji用到的是4字节的utf-16编码，数据库是采用的utf-8编码，并且最大只允许3字节的字符。</p>\n<p>至此，我们的问题变成首先要搞懂UTF-8和UTF-16编码了。</p>\n<p>检测四字节的Unicode</p>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>ASCII 码</p>\n<p>UTF-8</p>\n<p>UTF-16</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>\n<p>web</p>\n<p>使用utf-8</p>\n<p>所以我们只要检测utf-16</p>\n<p>4字节的utf-16编码范围为U+010000到U+10FFFF<br>/[\\u010000-\\u10FFFF]/g</p>\n<p>javascript采用的是是ucs-2编码；所以正则需要再转化为ucs-2</p>\n"},{"_content":"webupload\n\n\njplaery\n\n\nartTemplate\n\n\nunveil","source":"_posts/常用插件整理.md","raw":"webupload\n\n\njplaery\n\n\nartTemplate\n\n\nunveil","slug":"常用插件整理","published":1,"date":"2021-12-06T06:07:06.337Z","updated":"2021-12-06T06:07:06.337Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomj004ey4v26ny4hgrj","content":"<p>webupload</p>\n<p>jplaery</p>\n<p>artTemplate</p>\n<p>unveil</p>\n","site":{"data":{}},"excerpt":"","more":"<p>webupload</p>\n<p>jplaery</p>\n<p>artTemplate</p>\n<p>unveil</p>\n"},{"_content":"# 常用正则表达式函数\n\n```js\nfunction reg(intLen,decimalLen){\n    return new RegExp(`^(-)?\\\\d{1,${intLen}}(\\\\.\\\\d{1,${decimalLen}})?$`)\n}\n```","source":"_posts/常用正则表达式函数.md","raw":"# 常用正则表达式函数\n\n```js\nfunction reg(intLen,decimalLen){\n    return new RegExp(`^(-)?\\\\d{1,${intLen}}(\\\\.\\\\d{1,${decimalLen}})?$`)\n}\n```","slug":"常用正则表达式函数","published":1,"date":"2021-12-06T05:35:02.631Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomk004gy4v2h62bf63g","content":"<h1 id=\"常用正则表达式函数\"><a href=\"#常用正则表达式函数\" class=\"headerlink\" title=\"常用正则表达式函数\"></a>常用正则表达式函数</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reg</span>(<span class=\"params\">intLen,decimalLen</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`^(-)?\\\\d&#123;1,<span class=\"subst\">$&#123;intLen&#125;</span>&#125;(\\\\.\\\\d&#123;1,<span class=\"subst\">$&#123;decimalLen&#125;</span>&#125;)?$`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常用正则表达式函数\"><a href=\"#常用正则表达式函数\" class=\"headerlink\" title=\"常用正则表达式函数\"></a>常用正则表达式函数</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reg</span>(<span class=\"params\">intLen,decimalLen</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`^(-)?\\\\d&#123;1,<span class=\"subst\">$&#123;intLen&#125;</span>&#125;(\\\\.\\\\d&#123;1,<span class=\"subst\">$&#123;decimalLen&#125;</span>&#125;)?$`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Flexbox布局","date":"2016-01-12T07:40:43.000Z","description":"弹性盒模型, Flexbox","_content":"\nFlexbox布局（ Flexible Box 或CSS3 弹性布局），是CSS3中的一种新的布局模式，是可以自动调整子元素的高和宽，来很好的填充任何不同屏幕大小的显示设备中的可用显示空间，收缩内容防止内容溢出，确保元素拥有恰当的行为的布局方式。使用Flexbox来布局更容易，可以使用更少的代码，更简单的方式实现更复杂的布局。它可以实现：\n\n<!-- more -->\n\n + 如果元素容器没有足够的空间，我们无需计算每个元素的宽度，就可以设置他们在同一行；\n + 可以快速让他们布局在一列；\n + 可以方便让他们对齐容器的左、右、中间等；\n + 无需修改结构就可以改变他们的显示顺序；\n + 如果元素容器设置百分比和视窗大小改变，不用提心未指定元素的确切宽度而破坏布局，因为容器中的每个子元素都可以自动分配容器的宽度或高度的比例。\n\n## 浏览器兼容性\n![](/images/201601/flexbox1.png)\n\n红色代表不支持，绿色代表支持，暗绿色代表部分支持，其中IE10、IE11目前使用中出现了大量的bug，Android4.3只支持老的flexbox规范。\n可以发现该属性在移动端的使用还是可能的，不过要加上老的规范写法。\n\n## 容器属性（父元素属性）\n`主轴` ：项目排列方向的轴（可以是水平或者垂直），每一行（列）项目代表一条轴\n`交叉轴`： 与主轴垂直的轴（可以是水平或者垂直）；\n可以通过访问[flexBox](http://www.htmllion.com/css-flexbox.html)测试以下属性\n### 1. display\n\n取值：\n\n + flex          将对象作为弹性容器显示\n + inline-flex      将对象作为内联块级弹性容器显示。\n\n<span style=\"color:red\">注：</span>以下是旧版本的属性值：\nbox：将对象作为弹性容器显示。（最老版本）\ninline-box：将对象作为内联块级弹性容器显示。（最老版本）\nflexbox：将对象作为弹性容器显示。（过渡版本）\ninline-flexbox：将对象作为内联块级弹性容器显示。（过渡版本）\n### 2. flex-direction  决定主轴的方向（即项目的排列方向）。\n\n取值：\n\n + row  主轴为水平方向，起点在左端。\n + row-reverse  主轴为水平方向，起点在右端。\n + column  主轴为垂直方向，起点在上沿。\n + column-reverse  主轴为垂直方向，起点在下沿。\n\n### 3. flex-wrap  设置容器内的项目排列不下时是否换行\n\n取值：\n\n + wrap  换行\n + no-wrap  一行显示，不换行\n + wrap-reverse  倒序换行，将各行的顺序倒序排列\n\n### 4. justify-content   定义了项目在主轴上（依据设置的主轴方向而定）的对齐方式。\n\n取值：\n\n + flex-start  左对齐\n + flex-end   右对齐\n + center   居中对齐\n + space-between   俩端对齐\n + space-around  项目间隔相同对齐\n\n### 5.align-items  定义项目在交叉轴上的对齐方式。\n+ flex-start 起点对齐\n+ flex-end 终点对齐\n+ center 居中对齐\n+ baseline 项目的第一行文字的基线对齐。\n+ stretch 如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n### 6. align-content  当项目有多列（行）时，该属性定义各轴的对齐方式\n\n取值：\n\n + flex-start  起点对齐\n + flex-end  终点对齐\n + center  居中对齐\n + space-between  项目间隔相同对齐\n + space-around 每行（列）的间隔俩侧相等对齐\n + stretch 项目布满容器对齐\n\n\n\n\n##  项目属性（子元素属性）\n\n### 1. order  定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n### 2. flex 定义了项目的大小，是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto\n(1) flex-grow  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大\n(2) flex-shrink  定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小\n(3) flex-basis 定义项目占据的空间,然后再分配多余空间。\n\n### 3. align-self  属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的\n\n## 测试用例\n\n这几天在项目中小范围试用了下（移动端），结果UC和微信浏览器不支持，当时就蒙逼了好吗。后来查了下，发现加上老版本的写法和前缀即可。至少借的几个手机测试是通过了。\n<div class=\"flexbox\">\n\t<div>1</div>\n\t<div>2</div>\n\t<div>3</div>\n\t<div>4</div>\n\t<div>5</div>\n</div>\n\n<style>\n\t.flexbox{\n\t    display: -webkit-flex;\n\t    display: flex;\n\t    display: -webkit-box;\n\t    -webkit-align-items: center;\n\t    align-items: center;\n\t    -webkit-box-align: center;\n\t\tborder:1px solid #000;\n\t\tmin-height:200px;\n\t}\n\t.flexbox>div{\n\t\tflex: 1;\n\t\t-webkit-flex: 1;\n\t\t-webkit-box-flex: 1;\n\t\t-moz-box-flex: 1;\n\t\t-ms-flex: 1;\n\t\tbackground-color: #258fb8;\n\t\tborder:1px solid blue;\n\t}\n</style>\n\n代码：\n``` html\n<div class=\"flexbox\">\n\t<div>1</div>\n\t<div>2</div>\n\t<div>3</div>\n\t<div>4</div>\n\t<div>5</div>\n</div>\n\n<style>\n\t .flexbox{\n\t\tdisplay: -webkit-flex;\n\t\tdisplay: flex;\n\t\t/*兼容老版本*/\n\t\tdisplay: -webkit-box;\n\t\t-webkit-align-items: center;\n\t\talign-items: center;\n\t\t/*兼容老版本*/\n\t\t-webkit-box-align: center;\n\t\tborder:1px solid #000;\n\t\tmin-height:200px;\n\t}\n\t.flexbox>div{\n\t\tflex: 1;\n\t\t-webkit-flex: 1;\n\t\t-webkit-box-flex: 1;\n\t\t-moz-box-flex: 1;\n\t\t-ms-flex: 1;\n\t\tbackground-color: green;\n\t\tborder:1px solid blue;\n\t}\n</style>\n```","source":"_posts/弹性盒模型.md","raw":"---\ntitle: Flexbox布局\ndate: 2016-01-12 15:40:43\ntags: [css]\ndescription: 弹性盒模型, Flexbox\n---\n\nFlexbox布局（ Flexible Box 或CSS3 弹性布局），是CSS3中的一种新的布局模式，是可以自动调整子元素的高和宽，来很好的填充任何不同屏幕大小的显示设备中的可用显示空间，收缩内容防止内容溢出，确保元素拥有恰当的行为的布局方式。使用Flexbox来布局更容易，可以使用更少的代码，更简单的方式实现更复杂的布局。它可以实现：\n\n<!-- more -->\n\n + 如果元素容器没有足够的空间，我们无需计算每个元素的宽度，就可以设置他们在同一行；\n + 可以快速让他们布局在一列；\n + 可以方便让他们对齐容器的左、右、中间等；\n + 无需修改结构就可以改变他们的显示顺序；\n + 如果元素容器设置百分比和视窗大小改变，不用提心未指定元素的确切宽度而破坏布局，因为容器中的每个子元素都可以自动分配容器的宽度或高度的比例。\n\n## 浏览器兼容性\n![](/images/201601/flexbox1.png)\n\n红色代表不支持，绿色代表支持，暗绿色代表部分支持，其中IE10、IE11目前使用中出现了大量的bug，Android4.3只支持老的flexbox规范。\n可以发现该属性在移动端的使用还是可能的，不过要加上老的规范写法。\n\n## 容器属性（父元素属性）\n`主轴` ：项目排列方向的轴（可以是水平或者垂直），每一行（列）项目代表一条轴\n`交叉轴`： 与主轴垂直的轴（可以是水平或者垂直）；\n可以通过访问[flexBox](http://www.htmllion.com/css-flexbox.html)测试以下属性\n### 1. display\n\n取值：\n\n + flex          将对象作为弹性容器显示\n + inline-flex      将对象作为内联块级弹性容器显示。\n\n<span style=\"color:red\">注：</span>以下是旧版本的属性值：\nbox：将对象作为弹性容器显示。（最老版本）\ninline-box：将对象作为内联块级弹性容器显示。（最老版本）\nflexbox：将对象作为弹性容器显示。（过渡版本）\ninline-flexbox：将对象作为内联块级弹性容器显示。（过渡版本）\n### 2. flex-direction  决定主轴的方向（即项目的排列方向）。\n\n取值：\n\n + row  主轴为水平方向，起点在左端。\n + row-reverse  主轴为水平方向，起点在右端。\n + column  主轴为垂直方向，起点在上沿。\n + column-reverse  主轴为垂直方向，起点在下沿。\n\n### 3. flex-wrap  设置容器内的项目排列不下时是否换行\n\n取值：\n\n + wrap  换行\n + no-wrap  一行显示，不换行\n + wrap-reverse  倒序换行，将各行的顺序倒序排列\n\n### 4. justify-content   定义了项目在主轴上（依据设置的主轴方向而定）的对齐方式。\n\n取值：\n\n + flex-start  左对齐\n + flex-end   右对齐\n + center   居中对齐\n + space-between   俩端对齐\n + space-around  项目间隔相同对齐\n\n### 5.align-items  定义项目在交叉轴上的对齐方式。\n+ flex-start 起点对齐\n+ flex-end 终点对齐\n+ center 居中对齐\n+ baseline 项目的第一行文字的基线对齐。\n+ stretch 如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n### 6. align-content  当项目有多列（行）时，该属性定义各轴的对齐方式\n\n取值：\n\n + flex-start  起点对齐\n + flex-end  终点对齐\n + center  居中对齐\n + space-between  项目间隔相同对齐\n + space-around 每行（列）的间隔俩侧相等对齐\n + stretch 项目布满容器对齐\n\n\n\n\n##  项目属性（子元素属性）\n\n### 1. order  定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n### 2. flex 定义了项目的大小，是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto\n(1) flex-grow  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大\n(2) flex-shrink  定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小\n(3) flex-basis 定义项目占据的空间,然后再分配多余空间。\n\n### 3. align-self  属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的\n\n## 测试用例\n\n这几天在项目中小范围试用了下（移动端），结果UC和微信浏览器不支持，当时就蒙逼了好吗。后来查了下，发现加上老版本的写法和前缀即可。至少借的几个手机测试是通过了。\n<div class=\"flexbox\">\n\t<div>1</div>\n\t<div>2</div>\n\t<div>3</div>\n\t<div>4</div>\n\t<div>5</div>\n</div>\n\n<style>\n\t.flexbox{\n\t    display: -webkit-flex;\n\t    display: flex;\n\t    display: -webkit-box;\n\t    -webkit-align-items: center;\n\t    align-items: center;\n\t    -webkit-box-align: center;\n\t\tborder:1px solid #000;\n\t\tmin-height:200px;\n\t}\n\t.flexbox>div{\n\t\tflex: 1;\n\t\t-webkit-flex: 1;\n\t\t-webkit-box-flex: 1;\n\t\t-moz-box-flex: 1;\n\t\t-ms-flex: 1;\n\t\tbackground-color: #258fb8;\n\t\tborder:1px solid blue;\n\t}\n</style>\n\n代码：\n``` html\n<div class=\"flexbox\">\n\t<div>1</div>\n\t<div>2</div>\n\t<div>3</div>\n\t<div>4</div>\n\t<div>5</div>\n</div>\n\n<style>\n\t .flexbox{\n\t\tdisplay: -webkit-flex;\n\t\tdisplay: flex;\n\t\t/*兼容老版本*/\n\t\tdisplay: -webkit-box;\n\t\t-webkit-align-items: center;\n\t\talign-items: center;\n\t\t/*兼容老版本*/\n\t\t-webkit-box-align: center;\n\t\tborder:1px solid #000;\n\t\tmin-height:200px;\n\t}\n\t.flexbox>div{\n\t\tflex: 1;\n\t\t-webkit-flex: 1;\n\t\t-webkit-box-flex: 1;\n\t\t-moz-box-flex: 1;\n\t\t-ms-flex: 1;\n\t\tbackground-color: green;\n\t\tborder:1px solid blue;\n\t}\n</style>\n```","slug":"弹性盒模型","published":1,"updated":"2021-12-06T06:59:32.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomk004iy4v2hv41f6v3","content":"<p>Flexbox布局（ Flexible Box 或CSS3 弹性布局），是CSS3中的一种新的布局模式，是可以自动调整子元素的高和宽，来很好的填充任何不同屏幕大小的显示设备中的可用显示空间，收缩内容防止内容溢出，确保元素拥有恰当的行为的布局方式。使用Flexbox来布局更容易，可以使用更少的代码，更简单的方式实现更复杂的布局。它可以实现：</p>\n<span id=\"more\"></span>\n\n<ul>\n<li>如果元素容器没有足够的空间，我们无需计算每个元素的宽度，就可以设置他们在同一行；</li>\n<li>可以快速让他们布局在一列；</li>\n<li>可以方便让他们对齐容器的左、右、中间等；</li>\n<li>无需修改结构就可以改变他们的显示顺序；</li>\n<li>如果元素容器设置百分比和视窗大小改变，不用提心未指定元素的确切宽度而破坏布局，因为容器中的每个子元素都可以自动分配容器的宽度或高度的比例。</li>\n</ul>\n<h2 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h2><p><img src=\"/images/201601/flexbox1.png\"></p>\n<p>红色代表不支持，绿色代表支持，暗绿色代表部分支持，其中IE10、IE11目前使用中出现了大量的bug，Android4.3只支持老的flexbox规范。<br>可以发现该属性在移动端的使用还是可能的，不过要加上老的规范写法。</p>\n<h2 id=\"容器属性（父元素属性）\"><a href=\"#容器属性（父元素属性）\" class=\"headerlink\" title=\"容器属性（父元素属性）\"></a>容器属性（父元素属性）</h2><p><code>主轴</code> ：项目排列方向的轴（可以是水平或者垂直），每一行（列）项目代表一条轴<br><code>交叉轴</code>： 与主轴垂直的轴（可以是水平或者垂直）；<br>可以通过访问<a href=\"http://www.htmllion.com/css-flexbox.html\">flexBox</a>测试以下属性</p>\n<h3 id=\"1-display\"><a href=\"#1-display\" class=\"headerlink\" title=\"1. display\"></a>1. display</h3><p>取值：</p>\n<ul>\n<li>flex          将对象作为弹性容器显示</li>\n<li>inline-flex      将对象作为内联块级弹性容器显示。</li>\n</ul>\n<p><span style=\"color:red\">注：</span>以下是旧版本的属性值：<br>box：将对象作为弹性容器显示。（最老版本）<br>inline-box：将对象作为内联块级弹性容器显示。（最老版本）<br>flexbox：将对象作为弹性容器显示。（过渡版本）<br>inline-flexbox：将对象作为内联块级弹性容器显示。（过渡版本）</p>\n<h3 id=\"2-flex-direction-决定主轴的方向（即项目的排列方向）。\"><a href=\"#2-flex-direction-决定主轴的方向（即项目的排列方向）。\" class=\"headerlink\" title=\"2. flex-direction  决定主轴的方向（即项目的排列方向）。\"></a>2. flex-direction  决定主轴的方向（即项目的排列方向）。</h3><p>取值：</p>\n<ul>\n<li>row  主轴为水平方向，起点在左端。</li>\n<li>row-reverse  主轴为水平方向，起点在右端。</li>\n<li>column  主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse  主轴为垂直方向，起点在下沿。</li>\n</ul>\n<h3 id=\"3-flex-wrap-设置容器内的项目排列不下时是否换行\"><a href=\"#3-flex-wrap-设置容器内的项目排列不下时是否换行\" class=\"headerlink\" title=\"3. flex-wrap  设置容器内的项目排列不下时是否换行\"></a>3. flex-wrap  设置容器内的项目排列不下时是否换行</h3><p>取值：</p>\n<ul>\n<li>wrap  换行</li>\n<li>no-wrap  一行显示，不换行</li>\n<li>wrap-reverse  倒序换行，将各行的顺序倒序排列</li>\n</ul>\n<h3 id=\"4-justify-content-定义了项目在主轴上（依据设置的主轴方向而定）的对齐方式。\"><a href=\"#4-justify-content-定义了项目在主轴上（依据设置的主轴方向而定）的对齐方式。\" class=\"headerlink\" title=\"4. justify-content   定义了项目在主轴上（依据设置的主轴方向而定）的对齐方式。\"></a>4. justify-content   定义了项目在主轴上（依据设置的主轴方向而定）的对齐方式。</h3><p>取值：</p>\n<ul>\n<li>flex-start  左对齐</li>\n<li>flex-end   右对齐</li>\n<li>center   居中对齐</li>\n<li>space-between   俩端对齐</li>\n<li>space-around  项目间隔相同对齐</li>\n</ul>\n<h3 id=\"5-align-items-定义项目在交叉轴上的对齐方式。\"><a href=\"#5-align-items-定义项目在交叉轴上的对齐方式。\" class=\"headerlink\" title=\"5.align-items  定义项目在交叉轴上的对齐方式。\"></a>5.align-items  定义项目在交叉轴上的对齐方式。</h3><ul>\n<li>flex-start 起点对齐</li>\n<li>flex-end 终点对齐</li>\n<li>center 居中对齐</li>\n<li>baseline 项目的第一行文字的基线对齐。</li>\n<li>stretch 如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<h3 id=\"6-align-content-当项目有多列（行）时，该属性定义各轴的对齐方式\"><a href=\"#6-align-content-当项目有多列（行）时，该属性定义各轴的对齐方式\" class=\"headerlink\" title=\"6. align-content  当项目有多列（行）时，该属性定义各轴的对齐方式\"></a>6. align-content  当项目有多列（行）时，该属性定义各轴的对齐方式</h3><p>取值：</p>\n<ul>\n<li>flex-start  起点对齐</li>\n<li>flex-end  终点对齐</li>\n<li>center  居中对齐</li>\n<li>space-between  项目间隔相同对齐</li>\n<li>space-around 每行（列）的间隔俩侧相等对齐</li>\n<li>stretch 项目布满容器对齐</li>\n</ul>\n<h2 id=\"项目属性（子元素属性）\"><a href=\"#项目属性（子元素属性）\" class=\"headerlink\" title=\"项目属性（子元素属性）\"></a>项目属性（子元素属性）</h2><h3 id=\"1-order-定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"><a href=\"#1-order-定义项目的排列顺序。数值越小，排列越靠前，默认为0。\" class=\"headerlink\" title=\"1. order  定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"></a>1. order  定义项目的排列顺序。数值越小，排列越靠前，默认为0。</h3><h3 id=\"2-flex-定义了项目的大小，是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto\"><a href=\"#2-flex-定义了项目的大小，是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto\" class=\"headerlink\" title=\"2. flex 定义了项目的大小，是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto\"></a>2. flex 定义了项目的大小，是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto</h3><p>(1) flex-grow  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大<br>(2) flex-shrink  定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小<br>(3) flex-basis 定义项目占据的空间,然后再分配多余空间。</p>\n<h3 id=\"3-align-self-属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的\"><a href=\"#3-align-self-属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的\" class=\"headerlink\" title=\"3. align-self  属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的\"></a>3. align-self  属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的</h3><h2 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h2><p>这几天在项目中小范围试用了下（移动端），结果UC和微信浏览器不支持，当时就蒙逼了好吗。后来查了下，发现加上老版本的写法和前缀即可。至少借的几个手机测试是通过了。</p>\n<div class=\"flexbox\">\n    <div>1</div>\n    <div>2</div>\n    <div>3</div>\n    <div>4</div>\n    <div>5</div>\n</div>\n\n<style>\n    .flexbox{\n        display: -webkit-flex;\n        display: flex;\n        display: -webkit-box;\n        -webkit-align-items: center;\n        align-items: center;\n        -webkit-box-align: center;\n        border:1px solid #000;\n        min-height:200px;\n    }\n    .flexbox>div{\n        flex: 1;\n        -webkit-flex: 1;\n        -webkit-box-flex: 1;\n        -moz-box-flex: 1;\n        -ms-flex: 1;\n        background-color: #258fb8;\n        border:1px solid blue;\n    }\n</style>\n\n<p>代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;flexbox&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>5<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span></span><br><span class=\"line\"><span class=\"css\">\t <span class=\"selector-class\">.flexbox</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">display</span>: -webkit-flex;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">display</span>: flex;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"comment\">/*兼容老版本*/</span></span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">display</span>: -webkit-box;</span></span><br><span class=\"line\"><span class=\"css\">\t\t-webkit-<span class=\"attribute\">align-items</span>: center;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">align-items</span>: center;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"comment\">/*兼容老版本*/</span></span></span><br><span class=\"line\"><span class=\"css\">\t\t-webkit-box-align: center;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">min-height</span>:<span class=\"number\">200px</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t&#125;</span></span><br><span class=\"line\"><span class=\"css\">\t<span class=\"selector-class\">.flexbox</span>&gt;<span class=\"selector-tag\">div</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t-webkit-<span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t-webkit-box-<span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t-moz-box-<span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t-ms-<span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">background-color</span>: green;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid blue;</span></span><br><span class=\"line\"><span class=\"css\">\t&#125;</span></span><br><span class=\"line\"><span class=\"css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Flexbox布局（ Flexible Box 或CSS3 弹性布局），是CSS3中的一种新的布局模式，是可以自动调整子元素的高和宽，来很好的填充任何不同屏幕大小的显示设备中的可用显示空间，收缩内容防止内容溢出，确保元素拥有恰当的行为的布局方式。使用Flexbox来布局更容易，可以使用更少的代码，更简单的方式实现更复杂的布局。它可以实现：</p>","more":"<ul>\n<li>如果元素容器没有足够的空间，我们无需计算每个元素的宽度，就可以设置他们在同一行；</li>\n<li>可以快速让他们布局在一列；</li>\n<li>可以方便让他们对齐容器的左、右、中间等；</li>\n<li>无需修改结构就可以改变他们的显示顺序；</li>\n<li>如果元素容器设置百分比和视窗大小改变，不用提心未指定元素的确切宽度而破坏布局，因为容器中的每个子元素都可以自动分配容器的宽度或高度的比例。</li>\n</ul>\n<h2 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h2><p><img src=\"/images/201601/flexbox1.png\"></p>\n<p>红色代表不支持，绿色代表支持，暗绿色代表部分支持，其中IE10、IE11目前使用中出现了大量的bug，Android4.3只支持老的flexbox规范。<br>可以发现该属性在移动端的使用还是可能的，不过要加上老的规范写法。</p>\n<h2 id=\"容器属性（父元素属性）\"><a href=\"#容器属性（父元素属性）\" class=\"headerlink\" title=\"容器属性（父元素属性）\"></a>容器属性（父元素属性）</h2><p><code>主轴</code> ：项目排列方向的轴（可以是水平或者垂直），每一行（列）项目代表一条轴<br><code>交叉轴</code>： 与主轴垂直的轴（可以是水平或者垂直）；<br>可以通过访问<a href=\"http://www.htmllion.com/css-flexbox.html\">flexBox</a>测试以下属性</p>\n<h3 id=\"1-display\"><a href=\"#1-display\" class=\"headerlink\" title=\"1. display\"></a>1. display</h3><p>取值：</p>\n<ul>\n<li>flex          将对象作为弹性容器显示</li>\n<li>inline-flex      将对象作为内联块级弹性容器显示。</li>\n</ul>\n<p><span style=\"color:red\">注：</span>以下是旧版本的属性值：<br>box：将对象作为弹性容器显示。（最老版本）<br>inline-box：将对象作为内联块级弹性容器显示。（最老版本）<br>flexbox：将对象作为弹性容器显示。（过渡版本）<br>inline-flexbox：将对象作为内联块级弹性容器显示。（过渡版本）</p>\n<h3 id=\"2-flex-direction-决定主轴的方向（即项目的排列方向）。\"><a href=\"#2-flex-direction-决定主轴的方向（即项目的排列方向）。\" class=\"headerlink\" title=\"2. flex-direction  决定主轴的方向（即项目的排列方向）。\"></a>2. flex-direction  决定主轴的方向（即项目的排列方向）。</h3><p>取值：</p>\n<ul>\n<li>row  主轴为水平方向，起点在左端。</li>\n<li>row-reverse  主轴为水平方向，起点在右端。</li>\n<li>column  主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse  主轴为垂直方向，起点在下沿。</li>\n</ul>\n<h3 id=\"3-flex-wrap-设置容器内的项目排列不下时是否换行\"><a href=\"#3-flex-wrap-设置容器内的项目排列不下时是否换行\" class=\"headerlink\" title=\"3. flex-wrap  设置容器内的项目排列不下时是否换行\"></a>3. flex-wrap  设置容器内的项目排列不下时是否换行</h3><p>取值：</p>\n<ul>\n<li>wrap  换行</li>\n<li>no-wrap  一行显示，不换行</li>\n<li>wrap-reverse  倒序换行，将各行的顺序倒序排列</li>\n</ul>\n<h3 id=\"4-justify-content-定义了项目在主轴上（依据设置的主轴方向而定）的对齐方式。\"><a href=\"#4-justify-content-定义了项目在主轴上（依据设置的主轴方向而定）的对齐方式。\" class=\"headerlink\" title=\"4. justify-content   定义了项目在主轴上（依据设置的主轴方向而定）的对齐方式。\"></a>4. justify-content   定义了项目在主轴上（依据设置的主轴方向而定）的对齐方式。</h3><p>取值：</p>\n<ul>\n<li>flex-start  左对齐</li>\n<li>flex-end   右对齐</li>\n<li>center   居中对齐</li>\n<li>space-between   俩端对齐</li>\n<li>space-around  项目间隔相同对齐</li>\n</ul>\n<h3 id=\"5-align-items-定义项目在交叉轴上的对齐方式。\"><a href=\"#5-align-items-定义项目在交叉轴上的对齐方式。\" class=\"headerlink\" title=\"5.align-items  定义项目在交叉轴上的对齐方式。\"></a>5.align-items  定义项目在交叉轴上的对齐方式。</h3><ul>\n<li>flex-start 起点对齐</li>\n<li>flex-end 终点对齐</li>\n<li>center 居中对齐</li>\n<li>baseline 项目的第一行文字的基线对齐。</li>\n<li>stretch 如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<h3 id=\"6-align-content-当项目有多列（行）时，该属性定义各轴的对齐方式\"><a href=\"#6-align-content-当项目有多列（行）时，该属性定义各轴的对齐方式\" class=\"headerlink\" title=\"6. align-content  当项目有多列（行）时，该属性定义各轴的对齐方式\"></a>6. align-content  当项目有多列（行）时，该属性定义各轴的对齐方式</h3><p>取值：</p>\n<ul>\n<li>flex-start  起点对齐</li>\n<li>flex-end  终点对齐</li>\n<li>center  居中对齐</li>\n<li>space-between  项目间隔相同对齐</li>\n<li>space-around 每行（列）的间隔俩侧相等对齐</li>\n<li>stretch 项目布满容器对齐</li>\n</ul>\n<h2 id=\"项目属性（子元素属性）\"><a href=\"#项目属性（子元素属性）\" class=\"headerlink\" title=\"项目属性（子元素属性）\"></a>项目属性（子元素属性）</h2><h3 id=\"1-order-定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"><a href=\"#1-order-定义项目的排列顺序。数值越小，排列越靠前，默认为0。\" class=\"headerlink\" title=\"1. order  定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"></a>1. order  定义项目的排列顺序。数值越小，排列越靠前，默认为0。</h3><h3 id=\"2-flex-定义了项目的大小，是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto\"><a href=\"#2-flex-定义了项目的大小，是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto\" class=\"headerlink\" title=\"2. flex 定义了项目的大小，是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto\"></a>2. flex 定义了项目的大小，是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto</h3><p>(1) flex-grow  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大<br>(2) flex-shrink  定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小<br>(3) flex-basis 定义项目占据的空间,然后再分配多余空间。</p>\n<h3 id=\"3-align-self-属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的\"><a href=\"#3-align-self-属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的\" class=\"headerlink\" title=\"3. align-self  属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的\"></a>3. align-self  属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的</h3><h2 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h2><p>这几天在项目中小范围试用了下（移动端），结果UC和微信浏览器不支持，当时就蒙逼了好吗。后来查了下，发现加上老版本的写法和前缀即可。至少借的几个手机测试是通过了。</p>\n<div class=\"flexbox\">\n    <div>1</div>\n    <div>2</div>\n    <div>3</div>\n    <div>4</div>\n    <div>5</div>\n</div>\n\n<style>\n    .flexbox{\n        display: -webkit-flex;\n        display: flex;\n        display: -webkit-box;\n        -webkit-align-items: center;\n        align-items: center;\n        -webkit-box-align: center;\n        border:1px solid #000;\n        min-height:200px;\n    }\n    .flexbox>div{\n        flex: 1;\n        -webkit-flex: 1;\n        -webkit-box-flex: 1;\n        -moz-box-flex: 1;\n        -ms-flex: 1;\n        background-color: #258fb8;\n        border:1px solid blue;\n    }\n</style>\n\n<p>代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;flexbox&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>5<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span></span><br><span class=\"line\"><span class=\"css\">\t <span class=\"selector-class\">.flexbox</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">display</span>: -webkit-flex;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">display</span>: flex;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"comment\">/*兼容老版本*/</span></span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">display</span>: -webkit-box;</span></span><br><span class=\"line\"><span class=\"css\">\t\t-webkit-<span class=\"attribute\">align-items</span>: center;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">align-items</span>: center;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"comment\">/*兼容老版本*/</span></span></span><br><span class=\"line\"><span class=\"css\">\t\t-webkit-box-align: center;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">min-height</span>:<span class=\"number\">200px</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t&#125;</span></span><br><span class=\"line\"><span class=\"css\">\t<span class=\"selector-class\">.flexbox</span>&gt;<span class=\"selector-tag\">div</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t-webkit-<span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t-webkit-box-<span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t-moz-box-<span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t-ms-<span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">background-color</span>: green;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid blue;</span></span><br><span class=\"line\"><span class=\"css\">\t&#125;</span></span><br><span class=\"line\"><span class=\"css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"_content":"# 快速排序\n\n快速排序（Quicksort）是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn)次比较。在最坏状况下则需要 Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。\n\n快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。\n\n## 算法步骤\n\n1. 从数列中挑出一个元素，称为 “基准”（pivot）\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。\n3. **递归**地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\n\n![images](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/Sorting_quicksort_anim.gif)\n\n## 代码实现\n\n```js\nArray.prototype.quickSort = function() {\n    var len = this.length;\n    if (len <= 1) {\n        return this.slice(0);\n    }\n    var left = [];\n    var right = [];\n    var mid = [this[0]];\n    // 排除掉基准\n    for (var i = 1; i < len; i++) { // n\n        if (this[i] < mid[0]) {\n            left.push(this[i]); // n*n/2\n        } else {\n            right.push(this[i]); // n*n/2\n        }\n    }\n\n    return left.quickSort().concat(mid, right.quickSort());\n};\n```\n\n<!-- 次数 = n + n^2-->\n\n\n\n[wiki](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)\n","source":"_posts/快速排序.md","raw":"# 快速排序\n\n快速排序（Quicksort）是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn)次比较。在最坏状况下则需要 Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。\n\n快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。\n\n## 算法步骤\n\n1. 从数列中挑出一个元素，称为 “基准”（pivot）\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。\n3. **递归**地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\n\n![images](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/Sorting_quicksort_anim.gif)\n\n## 代码实现\n\n```js\nArray.prototype.quickSort = function() {\n    var len = this.length;\n    if (len <= 1) {\n        return this.slice(0);\n    }\n    var left = [];\n    var right = [];\n    var mid = [this[0]];\n    // 排除掉基准\n    for (var i = 1; i < len; i++) { // n\n        if (this[i] < mid[0]) {\n            left.push(this[i]); // n*n/2\n        } else {\n            right.push(this[i]); // n*n/2\n        }\n    }\n\n    return left.quickSort().concat(mid, right.quickSort());\n};\n```\n\n<!-- 次数 = n + n^2-->\n\n\n\n[wiki](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)\n","slug":"快速排序","published":1,"date":"2021-12-06T06:07:06.072Z","updated":"2021-12-06T06:07:06.072Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoml004ky4v2bxk09m1c","content":"<h1 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h1><p>快速排序（Quicksort）是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn)次比较。在最坏状况下则需要 Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>\n<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p>\n<h2 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h2><ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>\n<li><strong>递归</strong>地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ol>\n<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/Sorting_quicksort_anim.gif\" alt=\"images\"></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.quickSort = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = <span class=\"built_in\">this</span>.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mid = [<span class=\"built_in\">this</span>[<span class=\"number\">0</span>]];</span><br><span class=\"line\">    <span class=\"comment\">// 排除掉基准</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123; <span class=\"comment\">// n</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>[i] &lt; mid[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">            left.push(<span class=\"built_in\">this</span>[i]); <span class=\"comment\">// n*n/2</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right.push(<span class=\"built_in\">this</span>[i]); <span class=\"comment\">// n*n/2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> left.quickSort().concat(mid, right.quickSort());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<!-- 次数 = n + n^2-->\n\n\n\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">wiki</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h1><p>快速排序（Quicksort）是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn)次比较。在最坏状况下则需要 Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>\n<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p>\n<h2 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h2><ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>\n<li><strong>递归</strong>地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ol>\n<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/Sorting_quicksort_anim.gif\" alt=\"images\"></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.quickSort = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = <span class=\"built_in\">this</span>.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mid = [<span class=\"built_in\">this</span>[<span class=\"number\">0</span>]];</span><br><span class=\"line\">    <span class=\"comment\">// 排除掉基准</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123; <span class=\"comment\">// n</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>[i] &lt; mid[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">            left.push(<span class=\"built_in\">this</span>[i]); <span class=\"comment\">// n*n/2</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right.push(<span class=\"built_in\">this</span>[i]); <span class=\"comment\">// n*n/2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> left.quickSort().concat(mid, right.quickSort());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<!-- 次数 = n + n^2-->\n\n\n\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">wiki</a></p>\n"},{"_content":"# 搜索算法\n\n这篇文章主要介绍广度优先搜索（BFS）和 深度优先搜索（DFS）算法，它们是图／树常见的俩种遍历算法。\n\n## 广度优先搜索（BFS）\n\n广度优先搜索算法（英语：Breadth-First-Search，缩写为 BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS 是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。\n\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/bfs.png)\n\n\n1. 首先将根节点放入队列中。\n2. 从队列中取出第一个节点，并检验它是否为目标。\n3. 如果找到目标，则结束搜寻并回传结果。\n4. 否则将它所有尚未检验过的直接子节点加入队列中。\n5. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。\n6. 重复步骤2。\n\nbfs ＝队列，入队列，出队列\n\n利用队列。\n\n```js\n//  伪代码\n\nfuntion BFS(){\n    将根节点V加入队列S\n    while(队列S不为空){\n        从队列中取出第一个节点W，并检验它是否满足搜索条件。\n        if(当前节点W满足搜索条件){\n            return W\n        }else{\n            For(遍历W的相邻的未访问过的节点){\n                将其加入队列\n            }\n        }\n    }\n\n    return '未搜索到结果'\n}\n```\n\n## 深度优先搜索（DFS）\n\n深度优先搜索算法（Depth-First-Search，简称 DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\n\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/dfs.png)\n\n> 主要思想：不撞南墙不回头。\n\n实现步骤：\n\n1. 首先将根节点放入队列中。\n\n2. 从队列中取出第一个节点，并检验它是否为目标。\n\n    如果找到目标，则结束搜寻并回传结果。\n\n    否则将它某一个尚未检验过的直接子节点加入队列中。\n\n3. 重复步骤 2。\n\n4. 如果不存在未检测过的直接子节点。\n\n    将上一级节点加入队列中。\n\n    重复步骤 2。\n\n5. 重复步骤 4。\n\n6. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。\n\n利用栈。dfs=栈，压栈，出栈。\n\n```js\n// 伪代码\n\n// 栈实现\nfunction DFS(){\n    将初始节点压栈。\n\n    While(栈非空) {\n\n        取出栈顶节点W,并暂存。\n        将栈顶元素出站。\n        if(节点W满足搜索条件){\n            return W\n        }else{\n            For(遍历W的相邻的未访问过的节点){\n                将其入栈。\n            }\n        }\n    }\n\n    return '未搜索到结果'\n}\n\n// 递归实现\nfunction DFS(节点，搜索条件){\n\n    if(节点是否满足条件){\n        return 节点\n    }else{\n        // 判断是否到达终点，即是否还存在未遍历的相邻节点\n        if() {\n            return;\n        }\n        // 尝试每一个可走方向（右下左上）\n        for(遍历节点的所有相邻节点){\n            // 判断是否可走,可走调用递归尝试下一步，不可走则尝试该点的其他方向\n            if (可走) {\n                // 继续下一步\n                DFS();\n            }\n        }\n    }\n\n}\n```\n\n## Js 实现\n\n### 树结构数据\n\n```js\nvar tree = {\n    name: \"中国\",\n    children: [\n        {\n            name: \"北京\",\n            children: [\n                {\n                    name: \"朝阳群众\"\n                },\n                {\n                    name: \"海淀区\"\n                },\n                {\n                    name: \"昌平区\"\n                }\n            ]\n        },\n        {\n            name: \"浙江省\",\n            children: [\n                {\n                    name: \"杭州市\",\n                    code: 0571\n                },\n                {\n                    name: \"嘉兴市\"\n                },\n                {\n                    name: \"绍兴市\"\n                },\n                {\n                    name: \"宁波市\"\n                }\n            ]\n        }\n    ]\n};\n```\n\n### DFS 实现\n\n```js\n// 算法实现\nfunction dfs(tree, name) {\n    var stack = [];\n    stack.push(tree);\n    while (stack.length !== 0) {\n        var current = stack[stack.length - 1];\n        stack.pop();\n        if (current.name === name) {\n            return current;\n        } else {\n            current.children &&\n                current.children.forEach(node => {\n                    stack.push(node);\n                });\n        }\n    }\n    return null;\n}\n\n// 使用递归\nfunction dfs(tree, name) {\n    var result;\n    if (tree.name === name) {\n        result = tree;\n    } else {\n        var children = tree.children;\n        if (children && children.length) {\n            children.forEach(node => {\n                result = dfs(node, name);\n            });\n        } else {\n            result = null;\n        }\n    }\n    return result;\n}\n```\n\n### BFS 实现\n\n```js\n// 算法实现\nfunction bfs(tree, name) {\n    var queue = [];\n    queue.push(tree);\n    while (queue.length !== 0) {\n        var current = queue[0];\n        queue.shift();\n        if (current.name === name) {\n            return current;\n        } else {\n            current.children &&\n                current.children.forEach((node, index) => {\n                    queue.push(node);\n                });\n        }\n    }\n\n    return null;\n}\n```\n","source":"_posts/搜索算法.md","raw":"# 搜索算法\n\n这篇文章主要介绍广度优先搜索（BFS）和 深度优先搜索（DFS）算法，它们是图／树常见的俩种遍历算法。\n\n## 广度优先搜索（BFS）\n\n广度优先搜索算法（英语：Breadth-First-Search，缩写为 BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS 是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。\n\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/bfs.png)\n\n\n1. 首先将根节点放入队列中。\n2. 从队列中取出第一个节点，并检验它是否为目标。\n3. 如果找到目标，则结束搜寻并回传结果。\n4. 否则将它所有尚未检验过的直接子节点加入队列中。\n5. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。\n6. 重复步骤2。\n\nbfs ＝队列，入队列，出队列\n\n利用队列。\n\n```js\n//  伪代码\n\nfuntion BFS(){\n    将根节点V加入队列S\n    while(队列S不为空){\n        从队列中取出第一个节点W，并检验它是否满足搜索条件。\n        if(当前节点W满足搜索条件){\n            return W\n        }else{\n            For(遍历W的相邻的未访问过的节点){\n                将其加入队列\n            }\n        }\n    }\n\n    return '未搜索到结果'\n}\n```\n\n## 深度优先搜索（DFS）\n\n深度优先搜索算法（Depth-First-Search，简称 DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\n\n![image](https://raw.githubusercontent.com/bigdots/blog/master/images/201801/dfs.png)\n\n> 主要思想：不撞南墙不回头。\n\n实现步骤：\n\n1. 首先将根节点放入队列中。\n\n2. 从队列中取出第一个节点，并检验它是否为目标。\n\n    如果找到目标，则结束搜寻并回传结果。\n\n    否则将它某一个尚未检验过的直接子节点加入队列中。\n\n3. 重复步骤 2。\n\n4. 如果不存在未检测过的直接子节点。\n\n    将上一级节点加入队列中。\n\n    重复步骤 2。\n\n5. 重复步骤 4。\n\n6. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。\n\n利用栈。dfs=栈，压栈，出栈。\n\n```js\n// 伪代码\n\n// 栈实现\nfunction DFS(){\n    将初始节点压栈。\n\n    While(栈非空) {\n\n        取出栈顶节点W,并暂存。\n        将栈顶元素出站。\n        if(节点W满足搜索条件){\n            return W\n        }else{\n            For(遍历W的相邻的未访问过的节点){\n                将其入栈。\n            }\n        }\n    }\n\n    return '未搜索到结果'\n}\n\n// 递归实现\nfunction DFS(节点，搜索条件){\n\n    if(节点是否满足条件){\n        return 节点\n    }else{\n        // 判断是否到达终点，即是否还存在未遍历的相邻节点\n        if() {\n            return;\n        }\n        // 尝试每一个可走方向（右下左上）\n        for(遍历节点的所有相邻节点){\n            // 判断是否可走,可走调用递归尝试下一步，不可走则尝试该点的其他方向\n            if (可走) {\n                // 继续下一步\n                DFS();\n            }\n        }\n    }\n\n}\n```\n\n## Js 实现\n\n### 树结构数据\n\n```js\nvar tree = {\n    name: \"中国\",\n    children: [\n        {\n            name: \"北京\",\n            children: [\n                {\n                    name: \"朝阳群众\"\n                },\n                {\n                    name: \"海淀区\"\n                },\n                {\n                    name: \"昌平区\"\n                }\n            ]\n        },\n        {\n            name: \"浙江省\",\n            children: [\n                {\n                    name: \"杭州市\",\n                    code: 0571\n                },\n                {\n                    name: \"嘉兴市\"\n                },\n                {\n                    name: \"绍兴市\"\n                },\n                {\n                    name: \"宁波市\"\n                }\n            ]\n        }\n    ]\n};\n```\n\n### DFS 实现\n\n```js\n// 算法实现\nfunction dfs(tree, name) {\n    var stack = [];\n    stack.push(tree);\n    while (stack.length !== 0) {\n        var current = stack[stack.length - 1];\n        stack.pop();\n        if (current.name === name) {\n            return current;\n        } else {\n            current.children &&\n                current.children.forEach(node => {\n                    stack.push(node);\n                });\n        }\n    }\n    return null;\n}\n\n// 使用递归\nfunction dfs(tree, name) {\n    var result;\n    if (tree.name === name) {\n        result = tree;\n    } else {\n        var children = tree.children;\n        if (children && children.length) {\n            children.forEach(node => {\n                result = dfs(node, name);\n            });\n        } else {\n            result = null;\n        }\n    }\n    return result;\n}\n```\n\n### BFS 实现\n\n```js\n// 算法实现\nfunction bfs(tree, name) {\n    var queue = [];\n    queue.push(tree);\n    while (queue.length !== 0) {\n        var current = queue[0];\n        queue.shift();\n        if (current.name === name) {\n            return current;\n        } else {\n            current.children &&\n                current.children.forEach((node, index) => {\n                    queue.push(node);\n                });\n        }\n    }\n\n    return null;\n}\n```\n","slug":"搜索算法","published":1,"date":"2021-12-06T06:07:06.072Z","updated":"2021-12-06T06:07:06.072Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomm004my4v2ezlccw3q","content":"<h1 id=\"搜索算法\"><a href=\"#搜索算法\" class=\"headerlink\" title=\"搜索算法\"></a>搜索算法</h1><p>这篇文章主要介绍广度优先搜索（BFS）和 深度优先搜索（DFS）算法，它们是图／树常见的俩种遍历算法。</p>\n<h2 id=\"广度优先搜索（BFS）\"><a href=\"#广度优先搜索（BFS）\" class=\"headerlink\" title=\"广度优先搜索（BFS）\"></a>广度优先搜索（BFS）</h2><p>广度优先搜索算法（英语：Breadth-First-Search，缩写为 BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS 是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。</p>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/bfs.png\" alt=\"image\"></p>\n<ol>\n<li>首先将根节点放入队列中。</li>\n<li>从队列中取出第一个节点，并检验它是否为目标。</li>\n<li>如果找到目标，则结束搜寻并回传结果。</li>\n<li>否则将它所有尚未检验过的直接子节点加入队列中。</li>\n<li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</li>\n<li>重复步骤2。</li>\n</ol>\n<p>bfs ＝队列，入队列，出队列</p>\n<p>利用队列。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  伪代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">funtion <span class=\"function\"><span class=\"title\">BFS</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    将根节点V加入队列S</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(队列S不为空)&#123;</span><br><span class=\"line\">        从队列中取出第一个节点W，并检验它是否满足搜索条件。</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(当前节点W满足搜索条件)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> W</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">For</span>(<span class=\"params\">遍历W的相邻的未访问过的节点</span>)</span>&#123;</span><br><span class=\"line\">                将其加入队列</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;未搜索到结果&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"深度优先搜索（DFS）\"><a href=\"#深度优先搜索（DFS）\" class=\"headerlink\" title=\"深度优先搜索（DFS）\"></a>深度优先搜索（DFS）</h2><p>深度优先搜索算法（Depth-First-Search，简称 DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。</p>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/dfs.png\" alt=\"image\"></p>\n<blockquote>\n<p>主要思想：不撞南墙不回头。</p>\n</blockquote>\n<p>实现步骤：</p>\n<ol>\n<li><p>首先将根节点放入队列中。</p>\n</li>\n<li><p>从队列中取出第一个节点，并检验它是否为目标。</p>\n<p> 如果找到目标，则结束搜寻并回传结果。</p>\n<p> 否则将它某一个尚未检验过的直接子节点加入队列中。</p>\n</li>\n<li><p>重复步骤 2。</p>\n</li>\n<li><p>如果不存在未检测过的直接子节点。</p>\n<p> 将上一级节点加入队列中。</p>\n<p> 重复步骤 2。</p>\n</li>\n<li><p>重复步骤 4。</p>\n</li>\n<li><p>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</p>\n</li>\n</ol>\n<p>利用栈。dfs=栈，压栈，出栈。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 栈实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DFS</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    将初始节点压栈。</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">While</span>(<span class=\"params\">栈非空</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        取出栈顶节点W,并暂存。</span><br><span class=\"line\">        将栈顶元素出站。</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(节点W满足搜索条件)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> W</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">For</span>(<span class=\"params\">遍历W的相邻的未访问过的节点</span>)</span>&#123;</span><br><span class=\"line\">                将其入栈。</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;未搜索到结果&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DFS</span>(<span class=\"params\">节点，搜索条件</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(节点是否满足条件)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> 节点</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否到达终点，即是否还存在未遍历的相邻节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试每一个可走方向（右下左上）</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(遍历节点的所有相邻节点)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否可走,可走调用递归尝试下一步，不可走则尝试该点的其他方向</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (可走) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 继续下一步</span></span><br><span class=\"line\">                DFS();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Js-实现\"><a href=\"#Js-实现\" class=\"headerlink\" title=\"Js 实现\"></a>Js 实现</h2><h3 id=\"树结构数据\"><a href=\"#树结构数据\" class=\"headerlink\" title=\"树结构数据\"></a>树结构数据</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tree = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;中国&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">name</span>: <span class=\"string\">&quot;北京&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">children</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;朝阳群众&quot;</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;海淀区&quot;</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;昌平区&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">name</span>: <span class=\"string\">&quot;浙江省&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">children</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;杭州市&quot;</span>,</span><br><span class=\"line\">                    <span class=\"attr\">code</span>: <span class=\"number\">0571</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;嘉兴市&quot;</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;绍兴市&quot;</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;宁波市&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DFS-实现\"><a href=\"#DFS-实现\" class=\"headerlink\" title=\"DFS 实现\"></a>DFS 实现</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 算法实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dfs</span>(<span class=\"params\">tree, name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack = [];</span><br><span class=\"line\">    stack.push(tree);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (stack.length !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> current = stack[stack.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        stack.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.name === name) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            current.children &amp;&amp;</span><br><span class=\"line\">                current.children.forEach(<span class=\"function\"><span class=\"params\">node</span> =&gt;</span> &#123;</span><br><span class=\"line\">                    stack.push(node);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dfs</span>(<span class=\"params\">tree, name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tree.name === name) &#123;</span><br><span class=\"line\">        result = tree;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> children = tree.children;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (children &amp;&amp; children.length) &#123;</span><br><span class=\"line\">            children.forEach(<span class=\"function\"><span class=\"params\">node</span> =&gt;</span> &#123;</span><br><span class=\"line\">                result = dfs(node, name);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BFS-实现\"><a href=\"#BFS-实现\" class=\"headerlink\" title=\"BFS 实现\"></a>BFS 实现</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 算法实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bfs</span>(<span class=\"params\">tree, name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> queue = [];</span><br><span class=\"line\">    queue.push(tree);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.length !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> current = queue[<span class=\"number\">0</span>];</span><br><span class=\"line\">        queue.shift();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.name === name) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            current.children &amp;&amp;</span><br><span class=\"line\">                current.children.forEach(<span class=\"function\">(<span class=\"params\">node, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    queue.push(node);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"搜索算法\"><a href=\"#搜索算法\" class=\"headerlink\" title=\"搜索算法\"></a>搜索算法</h1><p>这篇文章主要介绍广度优先搜索（BFS）和 深度优先搜索（DFS）算法，它们是图／树常见的俩种遍历算法。</p>\n<h2 id=\"广度优先搜索（BFS）\"><a href=\"#广度优先搜索（BFS）\" class=\"headerlink\" title=\"广度优先搜索（BFS）\"></a>广度优先搜索（BFS）</h2><p>广度优先搜索算法（英语：Breadth-First-Search，缩写为 BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS 是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。</p>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/bfs.png\" alt=\"image\"></p>\n<ol>\n<li>首先将根节点放入队列中。</li>\n<li>从队列中取出第一个节点，并检验它是否为目标。</li>\n<li>如果找到目标，则结束搜寻并回传结果。</li>\n<li>否则将它所有尚未检验过的直接子节点加入队列中。</li>\n<li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</li>\n<li>重复步骤2。</li>\n</ol>\n<p>bfs ＝队列，入队列，出队列</p>\n<p>利用队列。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  伪代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">funtion <span class=\"function\"><span class=\"title\">BFS</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    将根节点V加入队列S</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(队列S不为空)&#123;</span><br><span class=\"line\">        从队列中取出第一个节点W，并检验它是否满足搜索条件。</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(当前节点W满足搜索条件)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> W</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">For</span>(<span class=\"params\">遍历W的相邻的未访问过的节点</span>)</span>&#123;</span><br><span class=\"line\">                将其加入队列</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;未搜索到结果&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"深度优先搜索（DFS）\"><a href=\"#深度优先搜索（DFS）\" class=\"headerlink\" title=\"深度优先搜索（DFS）\"></a>深度优先搜索（DFS）</h2><p>深度优先搜索算法（Depth-First-Search，简称 DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。</p>\n<p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201801/dfs.png\" alt=\"image\"></p>\n<blockquote>\n<p>主要思想：不撞南墙不回头。</p>\n</blockquote>\n<p>实现步骤：</p>\n<ol>\n<li><p>首先将根节点放入队列中。</p>\n</li>\n<li><p>从队列中取出第一个节点，并检验它是否为目标。</p>\n<p> 如果找到目标，则结束搜寻并回传结果。</p>\n<p> 否则将它某一个尚未检验过的直接子节点加入队列中。</p>\n</li>\n<li><p>重复步骤 2。</p>\n</li>\n<li><p>如果不存在未检测过的直接子节点。</p>\n<p> 将上一级节点加入队列中。</p>\n<p> 重复步骤 2。</p>\n</li>\n<li><p>重复步骤 4。</p>\n</li>\n<li><p>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</p>\n</li>\n</ol>\n<p>利用栈。dfs=栈，压栈，出栈。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 栈实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DFS</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    将初始节点压栈。</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">While</span>(<span class=\"params\">栈非空</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        取出栈顶节点W,并暂存。</span><br><span class=\"line\">        将栈顶元素出站。</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(节点W满足搜索条件)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> W</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">For</span>(<span class=\"params\">遍历W的相邻的未访问过的节点</span>)</span>&#123;</span><br><span class=\"line\">                将其入栈。</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;未搜索到结果&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DFS</span>(<span class=\"params\">节点，搜索条件</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(节点是否满足条件)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> 节点</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否到达终点，即是否还存在未遍历的相邻节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试每一个可走方向（右下左上）</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(遍历节点的所有相邻节点)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否可走,可走调用递归尝试下一步，不可走则尝试该点的其他方向</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (可走) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 继续下一步</span></span><br><span class=\"line\">                DFS();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Js-实现\"><a href=\"#Js-实现\" class=\"headerlink\" title=\"Js 实现\"></a>Js 实现</h2><h3 id=\"树结构数据\"><a href=\"#树结构数据\" class=\"headerlink\" title=\"树结构数据\"></a>树结构数据</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tree = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;中国&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">name</span>: <span class=\"string\">&quot;北京&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">children</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;朝阳群众&quot;</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;海淀区&quot;</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;昌平区&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">name</span>: <span class=\"string\">&quot;浙江省&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">children</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;杭州市&quot;</span>,</span><br><span class=\"line\">                    <span class=\"attr\">code</span>: <span class=\"number\">0571</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;嘉兴市&quot;</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;绍兴市&quot;</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">name</span>: <span class=\"string\">&quot;宁波市&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DFS-实现\"><a href=\"#DFS-实现\" class=\"headerlink\" title=\"DFS 实现\"></a>DFS 实现</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 算法实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dfs</span>(<span class=\"params\">tree, name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack = [];</span><br><span class=\"line\">    stack.push(tree);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (stack.length !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> current = stack[stack.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        stack.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.name === name) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            current.children &amp;&amp;</span><br><span class=\"line\">                current.children.forEach(<span class=\"function\"><span class=\"params\">node</span> =&gt;</span> &#123;</span><br><span class=\"line\">                    stack.push(node);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dfs</span>(<span class=\"params\">tree, name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tree.name === name) &#123;</span><br><span class=\"line\">        result = tree;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> children = tree.children;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (children &amp;&amp; children.length) &#123;</span><br><span class=\"line\">            children.forEach(<span class=\"function\"><span class=\"params\">node</span> =&gt;</span> &#123;</span><br><span class=\"line\">                result = dfs(node, name);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BFS-实现\"><a href=\"#BFS-实现\" class=\"headerlink\" title=\"BFS 实现\"></a>BFS 实现</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 算法实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bfs</span>(<span class=\"params\">tree, name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> queue = [];</span><br><span class=\"line\">    queue.push(tree);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.length !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> current = queue[<span class=\"number\">0</span>];</span><br><span class=\"line\">        queue.shift();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.name === name) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            current.children &amp;&amp;</span><br><span class=\"line\">                current.children.forEach(<span class=\"function\">(<span class=\"params\">node, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    queue.push(node);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"探究TCP","date":"2016-03-16T03:00:52.000Z","description":"TCP","_content":"\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n## OSI\n> OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。\n\n<!-- more -->\n\n![](/images/201601/osi.jpg)\n\n其中TCP处理transport层，主要是用来建立可靠的连接。 而建立连接的基础\n\n\n## TCP\n>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议\n\n应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。\n\n![](/images/201601/TCP.jpg)\n\n+ Source Port / Destination Port:这个就是客户端口(源端口)和服务器端口(目的端口).端口就是用来区别主机中的不同进程，通过结合源IP和目的IP结合，得出唯一的TCP连接。\n\n+ Sequence Number(seqNumber): 一般由客户端发送，用来表示报文段中第一个数据字节在数据流中的序号，主要用来解决网络包乱序的问题。\n\n+ Acknowledgment Number(ACK): 即就是用来存放客户端发来的seqNumber的下一个信号(seqNumber+1). 只有当TCP flags中的ACK为1时才有效. 主要是用来解决不丢包的问题。\n\n+ TCP flags: TCP中有6个首部，用来控制TCP连接的状态.取值为0,1.这6个有:URG，ACK，PSH，RST，SYN，FIN.\n\n    + URG 当为1时，用来保证TCP连接不被中断, 并且将该次TCP内容数据的紧急程度提升(就是告诉电脑，你丫赶快把这个给resolve了)\n\n    + ACK 通常是服务器端返回的。 用来表示应答是否有效。 1为有效，0为无效\n\n    + PSH 表示，当数据包得到后，立马给应用程序使用(PUSH到最顶端)\n\n    + RST 用来确保TCP连接的安全。 该flag用来表示 一个连接复位的请求。如果发生错误连接，则reset一次，重新连。当然也可以用来拒绝非法数据包。\n\n    + SYN 同步的意思,通常是由客户端发送，用来建立连接的。第一次握手时: SYN:1 , ACK:0. 第二次握手时: SYN:1 ACK:1\n\n    + FIN 用来表示是否结束该次TCP连接。 通常当你的数据发送完后，会自动带上FIN 然后断开连接\n\n## TCP三次握手——建立链接\n\n![](/images/201601/tcp_3.jpg)\n\n(图中flag说明:SYN包表示标志位syn=1,ACK包表示标志位ack=1,SYN+ACK包表示标志位syn=1,ack=1)\n\n现在，我们来正式进入3次握手环节。\n\n+ 第一次握手. 客户端向服务器发送一个SYN包，并且添加上seqNumber(假设为x),然后进入SYN_SEND状态，并且等待服务器的确认。\n\n+ 第二次握手: 服务器接受SYN包，并且进行确认，如果该请求有效，则将TCP flags中的ACK 标志位置1，然后将AckNumber置为(seqNumber+1)，并且再添加上自己的seqNumber(y),完成后，返回给客户端.服务器进入SYN_RECV状态.(这里服务端是发送SYN+ACK包)\n\n+ 第三次握手 客户端接受ACK+SYN报文后，获取到服务器发送AckNumber(y), 并且将新头部的AckNumber变为(y+1).然后发送给服务器，完成TCP3次连接。此时服务器和客户端都进入ESTABLISHED状态.\n\n## 为什么只有3次握手，而不是4次，或者2次?\n\n假如是2次的话， 可能会出现这样一个情况。\n\n当客户端发送一次请求A后，但是A在网络延迟了很久， 接着客户端又发送了一次B，但是此时A已经无效了。接着服务器相应了B，并返回TCP连接头，建立连接(这里就2次哈)。 然后，A 历经千山万水终于到服务器了，服务器一看有请求来了，则接受，由于一开始A带着的TCP格式都是正确的，那么服务器，理所应当的也返回成功连接的flag，但是，此时客户端已经判断该次请求无效，废弃了。然后服务器，就这么一直挂着(浪费资源)，造成的一个问题是，md, 这个锅是谁的?所以，为了保险起见，再补充一次连接就可以了。所以3次是最合适的。在Chinese中，以3为起称为多，如果你用4，5，6，7，8...次的话，这不更浪费吗?\n\n## TCP四次握手——关闭链接\n由于TCP连 接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。\n\n+ TCP客 户端发送一个FIN，用来关闭客户到服务器的数据传送。\n+ 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。\n+ 服务器关闭客户端的连接，发送一个FIN给客户端。\n+ 客户段发回ACK报文确认，并将确认序号设置为收到序号加1。\n\n参考文章：[《让你升级的网络知识》](http://mp.weixin.qq.com/s?__biz=MjM5OTkwOTA5Mw==&mid=409908127&idx=1&sn=56a1110d6c22571c04ce13e889aeac87&scene=0#wechat_redirect)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/探究TCP.md","raw":"title: 探究TCP\ntags: [计算机网络]\ndate: 2016-03-16 11:00:52\ndescription: TCP\n\n---\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n## OSI\n> OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。\n\n<!-- more -->\n\n![](/images/201601/osi.jpg)\n\n其中TCP处理transport层，主要是用来建立可靠的连接。 而建立连接的基础\n\n\n## TCP\n>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议\n\n应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。\n\n![](/images/201601/TCP.jpg)\n\n+ Source Port / Destination Port:这个就是客户端口(源端口)和服务器端口(目的端口).端口就是用来区别主机中的不同进程，通过结合源IP和目的IP结合，得出唯一的TCP连接。\n\n+ Sequence Number(seqNumber): 一般由客户端发送，用来表示报文段中第一个数据字节在数据流中的序号，主要用来解决网络包乱序的问题。\n\n+ Acknowledgment Number(ACK): 即就是用来存放客户端发来的seqNumber的下一个信号(seqNumber+1). 只有当TCP flags中的ACK为1时才有效. 主要是用来解决不丢包的问题。\n\n+ TCP flags: TCP中有6个首部，用来控制TCP连接的状态.取值为0,1.这6个有:URG，ACK，PSH，RST，SYN，FIN.\n\n    + URG 当为1时，用来保证TCP连接不被中断, 并且将该次TCP内容数据的紧急程度提升(就是告诉电脑，你丫赶快把这个给resolve了)\n\n    + ACK 通常是服务器端返回的。 用来表示应答是否有效。 1为有效，0为无效\n\n    + PSH 表示，当数据包得到后，立马给应用程序使用(PUSH到最顶端)\n\n    + RST 用来确保TCP连接的安全。 该flag用来表示 一个连接复位的请求。如果发生错误连接，则reset一次，重新连。当然也可以用来拒绝非法数据包。\n\n    + SYN 同步的意思,通常是由客户端发送，用来建立连接的。第一次握手时: SYN:1 , ACK:0. 第二次握手时: SYN:1 ACK:1\n\n    + FIN 用来表示是否结束该次TCP连接。 通常当你的数据发送完后，会自动带上FIN 然后断开连接\n\n## TCP三次握手——建立链接\n\n![](/images/201601/tcp_3.jpg)\n\n(图中flag说明:SYN包表示标志位syn=1,ACK包表示标志位ack=1,SYN+ACK包表示标志位syn=1,ack=1)\n\n现在，我们来正式进入3次握手环节。\n\n+ 第一次握手. 客户端向服务器发送一个SYN包，并且添加上seqNumber(假设为x),然后进入SYN_SEND状态，并且等待服务器的确认。\n\n+ 第二次握手: 服务器接受SYN包，并且进行确认，如果该请求有效，则将TCP flags中的ACK 标志位置1，然后将AckNumber置为(seqNumber+1)，并且再添加上自己的seqNumber(y),完成后，返回给客户端.服务器进入SYN_RECV状态.(这里服务端是发送SYN+ACK包)\n\n+ 第三次握手 客户端接受ACK+SYN报文后，获取到服务器发送AckNumber(y), 并且将新头部的AckNumber变为(y+1).然后发送给服务器，完成TCP3次连接。此时服务器和客户端都进入ESTABLISHED状态.\n\n## 为什么只有3次握手，而不是4次，或者2次?\n\n假如是2次的话， 可能会出现这样一个情况。\n\n当客户端发送一次请求A后，但是A在网络延迟了很久， 接着客户端又发送了一次B，但是此时A已经无效了。接着服务器相应了B，并返回TCP连接头，建立连接(这里就2次哈)。 然后，A 历经千山万水终于到服务器了，服务器一看有请求来了，则接受，由于一开始A带着的TCP格式都是正确的，那么服务器，理所应当的也返回成功连接的flag，但是，此时客户端已经判断该次请求无效，废弃了。然后服务器，就这么一直挂着(浪费资源)，造成的一个问题是，md, 这个锅是谁的?所以，为了保险起见，再补充一次连接就可以了。所以3次是最合适的。在Chinese中，以3为起称为多，如果你用4，5，6，7，8...次的话，这不更浪费吗?\n\n## TCP四次握手——关闭链接\n由于TCP连 接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。\n\n+ TCP客 户端发送一个FIN，用来关闭客户到服务器的数据传送。\n+ 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。\n+ 服务器关闭客户端的连接，发送一个FIN给客户端。\n+ 客户段发回ACK报文确认，并将确认序号设置为收到序号加1。\n\n参考文章：[《让你升级的网络知识》](http://mp.weixin.qq.com/s?__biz=MjM5OTkwOTA5Mw==&mid=409908127&idx=1&sn=56a1110d6c22571c04ce13e889aeac87&scene=0#wechat_redirect)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"探究TCP","published":1,"updated":"2021-12-06T06:07:06.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomm004ny4v2d4u8gqgw","content":"<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<h2 id=\"OSI\"><a href=\"#OSI\" class=\"headerlink\" title=\"OSI\"></a>OSI</h2><blockquote>\n<p>OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p><img src=\"/images/201601/osi.jpg\"></p>\n<p>其中TCP处理transport层，主要是用来建立可靠的连接。 而建立连接的基础</p>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><blockquote>\n<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>\n</blockquote>\n<p>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</p>\n<p><img src=\"/images/201601/TCP.jpg\"></p>\n<ul>\n<li><p>Source Port / Destination Port:这个就是客户端口(源端口)和服务器端口(目的端口).端口就是用来区别主机中的不同进程，通过结合源IP和目的IP结合，得出唯一的TCP连接。</p>\n</li>\n<li><p>Sequence Number(seqNumber): 一般由客户端发送，用来表示报文段中第一个数据字节在数据流中的序号，主要用来解决网络包乱序的问题。</p>\n</li>\n<li><p>Acknowledgment Number(ACK): 即就是用来存放客户端发来的seqNumber的下一个信号(seqNumber+1). 只有当TCP flags中的ACK为1时才有效. 主要是用来解决不丢包的问题。</p>\n</li>\n<li><p>TCP flags: TCP中有6个首部，用来控制TCP连接的状态.取值为0,1.这6个有:URG，ACK，PSH，RST，SYN，FIN.</p>\n<ul>\n<li><p>URG 当为1时，用来保证TCP连接不被中断, 并且将该次TCP内容数据的紧急程度提升(就是告诉电脑，你丫赶快把这个给resolve了)</p>\n</li>\n<li><p>ACK 通常是服务器端返回的。 用来表示应答是否有效。 1为有效，0为无效</p>\n</li>\n<li><p>PSH 表示，当数据包得到后，立马给应用程序使用(PUSH到最顶端)</p>\n</li>\n<li><p>RST 用来确保TCP连接的安全。 该flag用来表示 一个连接复位的请求。如果发生错误连接，则reset一次，重新连。当然也可以用来拒绝非法数据包。</p>\n</li>\n<li><p>SYN 同步的意思,通常是由客户端发送，用来建立连接的。第一次握手时: SYN:1 , ACK:0. 第二次握手时: SYN:1 ACK:1</p>\n</li>\n<li><p>FIN 用来表示是否结束该次TCP连接。 通常当你的数据发送完后，会自动带上FIN 然后断开连接</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP三次握手——建立链接\"><a href=\"#TCP三次握手——建立链接\" class=\"headerlink\" title=\"TCP三次握手——建立链接\"></a>TCP三次握手——建立链接</h2><p><img src=\"/images/201601/tcp_3.jpg\"></p>\n<p>(图中flag说明:SYN包表示标志位syn=1,ACK包表示标志位ack=1,SYN+ACK包表示标志位syn=1,ack=1)</p>\n<p>现在，我们来正式进入3次握手环节。</p>\n<ul>\n<li><p>第一次握手. 客户端向服务器发送一个SYN包，并且添加上seqNumber(假设为x),然后进入SYN_SEND状态，并且等待服务器的确认。</p>\n</li>\n<li><p>第二次握手: 服务器接受SYN包，并且进行确认，如果该请求有效，则将TCP flags中的ACK 标志位置1，然后将AckNumber置为(seqNumber+1)，并且再添加上自己的seqNumber(y),完成后，返回给客户端.服务器进入SYN_RECV状态.(这里服务端是发送SYN+ACK包)</p>\n</li>\n<li><p>第三次握手 客户端接受ACK+SYN报文后，获取到服务器发送AckNumber(y), 并且将新头部的AckNumber变为(y+1).然后发送给服务器，完成TCP3次连接。此时服务器和客户端都进入ESTABLISHED状态.</p>\n</li>\n</ul>\n<h2 id=\"为什么只有3次握手，而不是4次，或者2次\"><a href=\"#为什么只有3次握手，而不是4次，或者2次\" class=\"headerlink\" title=\"为什么只有3次握手，而不是4次，或者2次?\"></a>为什么只有3次握手，而不是4次，或者2次?</h2><p>假如是2次的话， 可能会出现这样一个情况。</p>\n<p>当客户端发送一次请求A后，但是A在网络延迟了很久， 接着客户端又发送了一次B，但是此时A已经无效了。接着服务器相应了B，并返回TCP连接头，建立连接(这里就2次哈)。 然后，A 历经千山万水终于到服务器了，服务器一看有请求来了，则接受，由于一开始A带着的TCP格式都是正确的，那么服务器，理所应当的也返回成功连接的flag，但是，此时客户端已经判断该次请求无效，废弃了。然后服务器，就这么一直挂着(浪费资源)，造成的一个问题是，md, 这个锅是谁的?所以，为了保险起见，再补充一次连接就可以了。所以3次是最合适的。在Chinese中，以3为起称为多，如果你用4，5，6，7，8…次的话，这不更浪费吗?</p>\n<h2 id=\"TCP四次握手——关闭链接\"><a href=\"#TCP四次握手——关闭链接\" class=\"headerlink\" title=\"TCP四次握手——关闭链接\"></a>TCP四次握手——关闭链接</h2><p>由于TCP连 接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>\n<ul>\n<li>TCP客 户端发送一个FIN，用来关闭客户到服务器的数据传送。</li>\n<li>服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li>\n<li>服务器关闭客户端的连接，发送一个FIN给客户端。</li>\n<li>客户段发回ACK报文确认，并将确认序号设置为收到序号加1。</li>\n</ul>\n<p>参考文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5OTkwOTA5Mw==&mid=409908127&idx=1&sn=56a1110d6c22571c04ce13e889aeac87&scene=0#wechat_redirect\">《让你升级的网络知识》</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<h2 id=\"OSI\"><a href=\"#OSI\" class=\"headerlink\" title=\"OSI\"></a>OSI</h2><blockquote>\n<p>OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>\n</blockquote>","more":"<p><img src=\"/images/201601/osi.jpg\"></p>\n<p>其中TCP处理transport层，主要是用来建立可靠的连接。 而建立连接的基础</p>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><blockquote>\n<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>\n</blockquote>\n<p>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</p>\n<p><img src=\"/images/201601/TCP.jpg\"></p>\n<ul>\n<li><p>Source Port / Destination Port:这个就是客户端口(源端口)和服务器端口(目的端口).端口就是用来区别主机中的不同进程，通过结合源IP和目的IP结合，得出唯一的TCP连接。</p>\n</li>\n<li><p>Sequence Number(seqNumber): 一般由客户端发送，用来表示报文段中第一个数据字节在数据流中的序号，主要用来解决网络包乱序的问题。</p>\n</li>\n<li><p>Acknowledgment Number(ACK): 即就是用来存放客户端发来的seqNumber的下一个信号(seqNumber+1). 只有当TCP flags中的ACK为1时才有效. 主要是用来解决不丢包的问题。</p>\n</li>\n<li><p>TCP flags: TCP中有6个首部，用来控制TCP连接的状态.取值为0,1.这6个有:URG，ACK，PSH，RST，SYN，FIN.</p>\n<ul>\n<li><p>URG 当为1时，用来保证TCP连接不被中断, 并且将该次TCP内容数据的紧急程度提升(就是告诉电脑，你丫赶快把这个给resolve了)</p>\n</li>\n<li><p>ACK 通常是服务器端返回的。 用来表示应答是否有效。 1为有效，0为无效</p>\n</li>\n<li><p>PSH 表示，当数据包得到后，立马给应用程序使用(PUSH到最顶端)</p>\n</li>\n<li><p>RST 用来确保TCP连接的安全。 该flag用来表示 一个连接复位的请求。如果发生错误连接，则reset一次，重新连。当然也可以用来拒绝非法数据包。</p>\n</li>\n<li><p>SYN 同步的意思,通常是由客户端发送，用来建立连接的。第一次握手时: SYN:1 , ACK:0. 第二次握手时: SYN:1 ACK:1</p>\n</li>\n<li><p>FIN 用来表示是否结束该次TCP连接。 通常当你的数据发送完后，会自动带上FIN 然后断开连接</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP三次握手——建立链接\"><a href=\"#TCP三次握手——建立链接\" class=\"headerlink\" title=\"TCP三次握手——建立链接\"></a>TCP三次握手——建立链接</h2><p><img src=\"/images/201601/tcp_3.jpg\"></p>\n<p>(图中flag说明:SYN包表示标志位syn=1,ACK包表示标志位ack=1,SYN+ACK包表示标志位syn=1,ack=1)</p>\n<p>现在，我们来正式进入3次握手环节。</p>\n<ul>\n<li><p>第一次握手. 客户端向服务器发送一个SYN包，并且添加上seqNumber(假设为x),然后进入SYN_SEND状态，并且等待服务器的确认。</p>\n</li>\n<li><p>第二次握手: 服务器接受SYN包，并且进行确认，如果该请求有效，则将TCP flags中的ACK 标志位置1，然后将AckNumber置为(seqNumber+1)，并且再添加上自己的seqNumber(y),完成后，返回给客户端.服务器进入SYN_RECV状态.(这里服务端是发送SYN+ACK包)</p>\n</li>\n<li><p>第三次握手 客户端接受ACK+SYN报文后，获取到服务器发送AckNumber(y), 并且将新头部的AckNumber变为(y+1).然后发送给服务器，完成TCP3次连接。此时服务器和客户端都进入ESTABLISHED状态.</p>\n</li>\n</ul>\n<h2 id=\"为什么只有3次握手，而不是4次，或者2次\"><a href=\"#为什么只有3次握手，而不是4次，或者2次\" class=\"headerlink\" title=\"为什么只有3次握手，而不是4次，或者2次?\"></a>为什么只有3次握手，而不是4次，或者2次?</h2><p>假如是2次的话， 可能会出现这样一个情况。</p>\n<p>当客户端发送一次请求A后，但是A在网络延迟了很久， 接着客户端又发送了一次B，但是此时A已经无效了。接着服务器相应了B，并返回TCP连接头，建立连接(这里就2次哈)。 然后，A 历经千山万水终于到服务器了，服务器一看有请求来了，则接受，由于一开始A带着的TCP格式都是正确的，那么服务器，理所应当的也返回成功连接的flag，但是，此时客户端已经判断该次请求无效，废弃了。然后服务器，就这么一直挂着(浪费资源)，造成的一个问题是，md, 这个锅是谁的?所以，为了保险起见，再补充一次连接就可以了。所以3次是最合适的。在Chinese中，以3为起称为多，如果你用4，5，6，7，8…次的话，这不更浪费吗?</p>\n<h2 id=\"TCP四次握手——关闭链接\"><a href=\"#TCP四次握手——关闭链接\" class=\"headerlink\" title=\"TCP四次握手——关闭链接\"></a>TCP四次握手——关闭链接</h2><p>由于TCP连 接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>\n<ul>\n<li>TCP客 户端发送一个FIN，用来关闭客户到服务器的数据传送。</li>\n<li>服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li>\n<li>服务器关闭客户端的连接，发送一个FIN给客户端。</li>\n<li>客户段发回ACK报文确认，并将确认序号设置为收到序号加1。</li>\n</ul>\n<p>参考文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5OTkwOTA5Mw==&mid=409908127&idx=1&sn=56a1110d6c22571c04ce13e889aeac87&scene=0#wechat_redirect\">《让你升级的网络知识》</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"放大镜效果的基本实现","date":"2015-04-21T04:32:04.000Z","description":"放大镜效果","_content":"\n\n\n话不多说，先上图(没图说JB)：\n![](/images/201511/1.gif)\n\n<!-- more -->\n\n<i>此图为良心原创</i>\n---\nA:放大镜   \nB：小图片   \nC：大图片可视区域   \nD：大图片\n\n## 原理：\n鼠标的位置应该在放大镜的中央，所以鼠标位置为：clientX=A.offsetLeft()+B.offsetLeft+1/2*A.offsetWidth;\n\n　　　　　　　　　　　　　　　　　　　　　　　clientY=A.offsetTop()+B.offsetTop+1/2*A.offsetHeight;\n\n鼠标移动过程中:放大镜A和大图D是一起随鼠标成比例运动的，因为当放大镜A的右边框移动到与小图B的右边框重合时，大图D也应该移动到了右边框与C的右边框重合的地方。所以，他们的移动比例是：(D.offsetWidth-C.offsetWidth)/(B.offsetWidth-A.offsetWidth)=b/a\n\n---\n#### HTML代码\n\t<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\t<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n\t<head>\n\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n\t<title>放大镜效果</title>\n\n\n\t<style>\n\n\t*{\n\tmargin:0;\n\tpadding:0; \n\t}\n\n\t#demo{\n\tposition: relative;\n\tmargin:30px 50px;\n\twidth: 1000px;\n\theight: 600px;\n\tborder: 1px solid #000;\n\t}\n\n\t#zhezhao{\n\tposition: absolute;\n\tz-index:2;\n\tbackground:red;\n\twidth:402px;\n\theight:402px;\n\tleft: 20px;\n\ttop:20px;\n\topacity: 0;\n\t}\n\n\t#small{\n\tposition: absolute;\n\twidth:402px;\n\theight:402px;\n\tleft: 20px;\n\ttop:20px;\n\tborder: 1px solid #000;\n\tz-index: 1;\n\t}\n\n\n\t#small img{\n\tposition: absolute;\n\n\t}\n\n\n\t#big{\n\tposition: relative;\n\ttop: 20px;\n\tleft: 460px;\n\twidth:500px;\n\theight:500px;\n\tborder: 1px solid #000;\n\toverflow: hidden;\n\tdisplay: none;\n\tz-index: 1;\n\t}\n\n\n\t#big img{\n\tposition: absolute;\n\n\t}\n\n\n\t#glass{\n\tposition: absolute;\n\twidth:100px;\n\theight: 100px;\n\topacity: 0.3;\n\tbackground:orange;\n\tdisplay: none;\n\t}\n\n\t</style>\n\n\n\t</head>\n\n\n\t<body>\n\t<div id='demo'>\n\t<div id='zhezhao'> </div> \n\t<!-- 在ie浏览器中，当鼠标在放大镜上是，浏览器并不认为鼠标同样在小图的div上，所以加个遮罩层 兼容ie-->\n\n\n\t<div id='small'> \n\t<img src='images/small.png' alt=''>\n\t<div id='glass'></div>\n\t</div>\n\t<div id='big'>\n\t<img src='images/big.jpg' alt='' >\n\n\t</div>\n\n\t</div>\n\n\n\n\t</body>\n\n\t</html>\n\n#### JS代码\n\t<script>\n\n\twindow.onload=function(){\n\tvar demo =document.getElementById('demo');\n\tvar small =document.getElementById('small');\n\tvar big =document.getElementById('big');\n\tvar glass =document.getElementById('glass')\n\tvar image =document.getElementById('big').getElementsByTagName('img')[0];\n\tvar zhezhao=document.getElementById('zhezhao');\n\n\tzhezhao.onmouseover=function(){\n\tglass.style.display='block'\n\tbig.style.display='block'\n\t}\n\tzhezhao.onmouseout=function(){\n\tglass.style.display='none'\n\tbig.style.display='none'\n\t}\n\n\t//弄清楚clientX，offsetLeft，left的关系，注意区分\n\tzhezhao.onmousemove=function(ev){\n\tvar event=ev\n\tvar left=event.clientX-demo.offsetLeft-small.offsetLeft-glass.offsetWidth/2;\n\tvar top =event.clientY-demo.offsetTop -small.offsetTop -glass.offsetHeight/2;\n\tif(left<0){\n\tleft=0;\n\t}else if(left>(small.offsetWidth-glass.offsetWidth)){\n\tleft=small.offsetWidth-glass.offsetWidth\n\t}\n\n\tif(top<0){\n\ttop=0;\n\t}else if(top>(small.offsetHeight- glass.offsetHeight)){\n\ttop=small.offsetHeight- glass.offsetHeight\n\t}\n\tglass.style.left =left+'px';\n\tglass.style.top =top+'px';\n\n\n\n\tvar percent=(image.offsetWidth-big.offsetWidth)/(small.offsetWidth-glass.offsetWidth)\n\n\timage.style.left=-percent*left+'px'\n\timage.style.top =-percent*top+'px'\n\n\n\n\t}\n\t}\n\n\t</script>","source":"_posts/放大镜效果的基本实现.md","raw":"title: 放大镜效果的基本实现\ndate: 2015-04-21 12:32:04\ntags: [web,javascript]\ndescription: 放大镜效果\n---\n\n\n\n话不多说，先上图(没图说JB)：\n![](/images/201511/1.gif)\n\n<!-- more -->\n\n<i>此图为良心原创</i>\n---\nA:放大镜   \nB：小图片   \nC：大图片可视区域   \nD：大图片\n\n## 原理：\n鼠标的位置应该在放大镜的中央，所以鼠标位置为：clientX=A.offsetLeft()+B.offsetLeft+1/2*A.offsetWidth;\n\n　　　　　　　　　　　　　　　　　　　　　　　clientY=A.offsetTop()+B.offsetTop+1/2*A.offsetHeight;\n\n鼠标移动过程中:放大镜A和大图D是一起随鼠标成比例运动的，因为当放大镜A的右边框移动到与小图B的右边框重合时，大图D也应该移动到了右边框与C的右边框重合的地方。所以，他们的移动比例是：(D.offsetWidth-C.offsetWidth)/(B.offsetWidth-A.offsetWidth)=b/a\n\n---\n#### HTML代码\n\t<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\t<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n\t<head>\n\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n\t<title>放大镜效果</title>\n\n\n\t<style>\n\n\t*{\n\tmargin:0;\n\tpadding:0; \n\t}\n\n\t#demo{\n\tposition: relative;\n\tmargin:30px 50px;\n\twidth: 1000px;\n\theight: 600px;\n\tborder: 1px solid #000;\n\t}\n\n\t#zhezhao{\n\tposition: absolute;\n\tz-index:2;\n\tbackground:red;\n\twidth:402px;\n\theight:402px;\n\tleft: 20px;\n\ttop:20px;\n\topacity: 0;\n\t}\n\n\t#small{\n\tposition: absolute;\n\twidth:402px;\n\theight:402px;\n\tleft: 20px;\n\ttop:20px;\n\tborder: 1px solid #000;\n\tz-index: 1;\n\t}\n\n\n\t#small img{\n\tposition: absolute;\n\n\t}\n\n\n\t#big{\n\tposition: relative;\n\ttop: 20px;\n\tleft: 460px;\n\twidth:500px;\n\theight:500px;\n\tborder: 1px solid #000;\n\toverflow: hidden;\n\tdisplay: none;\n\tz-index: 1;\n\t}\n\n\n\t#big img{\n\tposition: absolute;\n\n\t}\n\n\n\t#glass{\n\tposition: absolute;\n\twidth:100px;\n\theight: 100px;\n\topacity: 0.3;\n\tbackground:orange;\n\tdisplay: none;\n\t}\n\n\t</style>\n\n\n\t</head>\n\n\n\t<body>\n\t<div id='demo'>\n\t<div id='zhezhao'> </div> \n\t<!-- 在ie浏览器中，当鼠标在放大镜上是，浏览器并不认为鼠标同样在小图的div上，所以加个遮罩层 兼容ie-->\n\n\n\t<div id='small'> \n\t<img src='images/small.png' alt=''>\n\t<div id='glass'></div>\n\t</div>\n\t<div id='big'>\n\t<img src='images/big.jpg' alt='' >\n\n\t</div>\n\n\t</div>\n\n\n\n\t</body>\n\n\t</html>\n\n#### JS代码\n\t<script>\n\n\twindow.onload=function(){\n\tvar demo =document.getElementById('demo');\n\tvar small =document.getElementById('small');\n\tvar big =document.getElementById('big');\n\tvar glass =document.getElementById('glass')\n\tvar image =document.getElementById('big').getElementsByTagName('img')[0];\n\tvar zhezhao=document.getElementById('zhezhao');\n\n\tzhezhao.onmouseover=function(){\n\tglass.style.display='block'\n\tbig.style.display='block'\n\t}\n\tzhezhao.onmouseout=function(){\n\tglass.style.display='none'\n\tbig.style.display='none'\n\t}\n\n\t//弄清楚clientX，offsetLeft，left的关系，注意区分\n\tzhezhao.onmousemove=function(ev){\n\tvar event=ev\n\tvar left=event.clientX-demo.offsetLeft-small.offsetLeft-glass.offsetWidth/2;\n\tvar top =event.clientY-demo.offsetTop -small.offsetTop -glass.offsetHeight/2;\n\tif(left<0){\n\tleft=0;\n\t}else if(left>(small.offsetWidth-glass.offsetWidth)){\n\tleft=small.offsetWidth-glass.offsetWidth\n\t}\n\n\tif(top<0){\n\ttop=0;\n\t}else if(top>(small.offsetHeight- glass.offsetHeight)){\n\ttop=small.offsetHeight- glass.offsetHeight\n\t}\n\tglass.style.left =left+'px';\n\tglass.style.top =top+'px';\n\n\n\n\tvar percent=(image.offsetWidth-big.offsetWidth)/(small.offsetWidth-glass.offsetWidth)\n\n\timage.style.left=-percent*left+'px'\n\timage.style.top =-percent*top+'px'\n\n\n\n\t}\n\t}\n\n\t</script>","slug":"放大镜效果的基本实现","published":1,"updated":"2021-12-06T06:07:06.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomn004oy4v28nvtfbvn","content":"<p>话不多说，先上图(没图说JB)：<br><img src=\"/images/201511/1.gif\"></p>\n<span id=\"more\"></span>\n\n<h2 id=\"此图为良心原创\"><a href=\"#此图为良心原创\" class=\"headerlink\" title=\"此图为良心原创\"></a><i>此图为良心原创</i></h2><p>A:放大镜<br>B：小图片<br>C：大图片可视区域<br>D：大图片</p>\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><p>鼠标的位置应该在放大镜的中央，所以鼠标位置为：clientX=A.offsetLeft()+B.offsetLeft+1/2*A.offsetWidth;</p>\n<p>　　　　　　　　　　　　　　　　　　　　　　　clientY=A.offsetTop()+B.offsetTop+1/2*A.offsetHeight;</p>\n<p>鼠标移动过程中:放大镜A和大图D是一起随鼠标成比例运动的，因为当放大镜A的右边框移动到与小图B的右边框重合时，大图D也应该移动到了右边框与C的右边框重合的地方。所以，他们的移动比例是：(D.offsetWidth-C.offsetWidth)/(B.offsetWidth-A.offsetWidth)=b/a</p>\n<hr>\n<h4 id=\"HTML代码\"><a href=\"#HTML代码\" class=\"headerlink\" title=\"HTML代码\"></a>HTML代码</h4><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\n\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;\n&lt;title&gt;放大镜效果&lt;/title&gt;\n\n\n&lt;style&gt;\n\n*&#123;\nmargin:0;\npadding:0; \n&#125;\n\n#demo&#123;\nposition: relative;\nmargin:30px 50px;\nwidth: 1000px;\nheight: 600px;\nborder: 1px solid #000;\n&#125;\n\n#zhezhao&#123;\nposition: absolute;\nz-index:2;\nbackground:red;\nwidth:402px;\nheight:402px;\nleft: 20px;\ntop:20px;\nopacity: 0;\n&#125;\n\n#small&#123;\nposition: absolute;\nwidth:402px;\nheight:402px;\nleft: 20px;\ntop:20px;\nborder: 1px solid #000;\nz-index: 1;\n&#125;\n\n\n#small img&#123;\nposition: absolute;\n\n&#125;\n\n\n#big&#123;\nposition: relative;\ntop: 20px;\nleft: 460px;\nwidth:500px;\nheight:500px;\nborder: 1px solid #000;\noverflow: hidden;\ndisplay: none;\nz-index: 1;\n&#125;\n\n\n#big img&#123;\nposition: absolute;\n\n&#125;\n\n\n#glass&#123;\nposition: absolute;\nwidth:100px;\nheight: 100px;\nopacity: 0.3;\nbackground:orange;\ndisplay: none;\n&#125;\n\n&lt;/style&gt;\n\n\n&lt;/head&gt;\n\n\n&lt;body&gt;\n&lt;div id=&#39;demo&#39;&gt;\n&lt;div id=&#39;zhezhao&#39;&gt; &lt;/div&gt; \n&lt;!-- 在ie浏览器中，当鼠标在放大镜上是，浏览器并不认为鼠标同样在小图的div上，所以加个遮罩层 兼容ie--&gt;\n\n\n&lt;div id=&#39;small&#39;&gt; \n&lt;img src=&#39;images/small.png&#39; alt=&#39;&#39;&gt;\n&lt;div id=&#39;glass&#39;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=&#39;big&#39;&gt;\n&lt;img src=&#39;images/big.jpg&#39; alt=&#39;&#39; &gt;\n\n&lt;/div&gt;\n\n&lt;/div&gt;\n\n\n\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"JS代码\"><a href=\"#JS代码\" class=\"headerlink\" title=\"JS代码\"></a>JS代码</h4><pre><code>&lt;script&gt;\n\nwindow.onload=function()&#123;\nvar demo =document.getElementById(&#39;demo&#39;);\nvar small =document.getElementById(&#39;small&#39;);\nvar big =document.getElementById(&#39;big&#39;);\nvar glass =document.getElementById(&#39;glass&#39;)\nvar image =document.getElementById(&#39;big&#39;).getElementsByTagName(&#39;img&#39;)[0];\nvar zhezhao=document.getElementById(&#39;zhezhao&#39;);\n\nzhezhao.onmouseover=function()&#123;\nglass.style.display=&#39;block&#39;\nbig.style.display=&#39;block&#39;\n&#125;\nzhezhao.onmouseout=function()&#123;\nglass.style.display=&#39;none&#39;\nbig.style.display=&#39;none&#39;\n&#125;\n\n//弄清楚clientX，offsetLeft，left的关系，注意区分\nzhezhao.onmousemove=function(ev)&#123;\nvar event=ev\nvar left=event.clientX-demo.offsetLeft-small.offsetLeft-glass.offsetWidth/2;\nvar top =event.clientY-demo.offsetTop -small.offsetTop -glass.offsetHeight/2;\nif(left&lt;0)&#123;\nleft=0;\n&#125;else if(left&gt;(small.offsetWidth-glass.offsetWidth))&#123;\nleft=small.offsetWidth-glass.offsetWidth\n&#125;\n\nif(top&lt;0)&#123;\ntop=0;\n&#125;else if(top&gt;(small.offsetHeight- glass.offsetHeight))&#123;\ntop=small.offsetHeight- glass.offsetHeight\n&#125;\nglass.style.left =left+&#39;px&#39;;\nglass.style.top =top+&#39;px&#39;;\n\n\n\nvar percent=(image.offsetWidth-big.offsetWidth)/(small.offsetWidth-glass.offsetWidth)\n\nimage.style.left=-percent*left+&#39;px&#39;\nimage.style.top =-percent*top+&#39;px&#39;\n\n\n\n&#125;\n&#125;\n\n&lt;/script&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>话不多说，先上图(没图说JB)：<br><img src=\"/images/201511/1.gif\"></p>","more":"<h2 id=\"此图为良心原创\"><a href=\"#此图为良心原创\" class=\"headerlink\" title=\"此图为良心原创\"></a><i>此图为良心原创</i></h2><p>A:放大镜<br>B：小图片<br>C：大图片可视区域<br>D：大图片</p>\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><p>鼠标的位置应该在放大镜的中央，所以鼠标位置为：clientX=A.offsetLeft()+B.offsetLeft+1/2*A.offsetWidth;</p>\n<p>　　　　　　　　　　　　　　　　　　　　　　　clientY=A.offsetTop()+B.offsetTop+1/2*A.offsetHeight;</p>\n<p>鼠标移动过程中:放大镜A和大图D是一起随鼠标成比例运动的，因为当放大镜A的右边框移动到与小图B的右边框重合时，大图D也应该移动到了右边框与C的右边框重合的地方。所以，他们的移动比例是：(D.offsetWidth-C.offsetWidth)/(B.offsetWidth-A.offsetWidth)=b/a</p>\n<hr>\n<h4 id=\"HTML代码\"><a href=\"#HTML代码\" class=\"headerlink\" title=\"HTML代码\"></a>HTML代码</h4><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\n\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;\n&lt;title&gt;放大镜效果&lt;/title&gt;\n\n\n&lt;style&gt;\n\n*&#123;\nmargin:0;\npadding:0; \n&#125;\n\n#demo&#123;\nposition: relative;\nmargin:30px 50px;\nwidth: 1000px;\nheight: 600px;\nborder: 1px solid #000;\n&#125;\n\n#zhezhao&#123;\nposition: absolute;\nz-index:2;\nbackground:red;\nwidth:402px;\nheight:402px;\nleft: 20px;\ntop:20px;\nopacity: 0;\n&#125;\n\n#small&#123;\nposition: absolute;\nwidth:402px;\nheight:402px;\nleft: 20px;\ntop:20px;\nborder: 1px solid #000;\nz-index: 1;\n&#125;\n\n\n#small img&#123;\nposition: absolute;\n\n&#125;\n\n\n#big&#123;\nposition: relative;\ntop: 20px;\nleft: 460px;\nwidth:500px;\nheight:500px;\nborder: 1px solid #000;\noverflow: hidden;\ndisplay: none;\nz-index: 1;\n&#125;\n\n\n#big img&#123;\nposition: absolute;\n\n&#125;\n\n\n#glass&#123;\nposition: absolute;\nwidth:100px;\nheight: 100px;\nopacity: 0.3;\nbackground:orange;\ndisplay: none;\n&#125;\n\n&lt;/style&gt;\n\n\n&lt;/head&gt;\n\n\n&lt;body&gt;\n&lt;div id=&#39;demo&#39;&gt;\n&lt;div id=&#39;zhezhao&#39;&gt; &lt;/div&gt; \n&lt;!-- 在ie浏览器中，当鼠标在放大镜上是，浏览器并不认为鼠标同样在小图的div上，所以加个遮罩层 兼容ie--&gt;\n\n\n&lt;div id=&#39;small&#39;&gt; \n&lt;img src=&#39;images/small.png&#39; alt=&#39;&#39;&gt;\n&lt;div id=&#39;glass&#39;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=&#39;big&#39;&gt;\n&lt;img src=&#39;images/big.jpg&#39; alt=&#39;&#39; &gt;\n\n&lt;/div&gt;\n\n&lt;/div&gt;\n\n\n\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"JS代码\"><a href=\"#JS代码\" class=\"headerlink\" title=\"JS代码\"></a>JS代码</h4><pre><code>&lt;script&gt;\n\nwindow.onload=function()&#123;\nvar demo =document.getElementById(&#39;demo&#39;);\nvar small =document.getElementById(&#39;small&#39;);\nvar big =document.getElementById(&#39;big&#39;);\nvar glass =document.getElementById(&#39;glass&#39;)\nvar image =document.getElementById(&#39;big&#39;).getElementsByTagName(&#39;img&#39;)[0];\nvar zhezhao=document.getElementById(&#39;zhezhao&#39;);\n\nzhezhao.onmouseover=function()&#123;\nglass.style.display=&#39;block&#39;\nbig.style.display=&#39;block&#39;\n&#125;\nzhezhao.onmouseout=function()&#123;\nglass.style.display=&#39;none&#39;\nbig.style.display=&#39;none&#39;\n&#125;\n\n//弄清楚clientX，offsetLeft，left的关系，注意区分\nzhezhao.onmousemove=function(ev)&#123;\nvar event=ev\nvar left=event.clientX-demo.offsetLeft-small.offsetLeft-glass.offsetWidth/2;\nvar top =event.clientY-demo.offsetTop -small.offsetTop -glass.offsetHeight/2;\nif(left&lt;0)&#123;\nleft=0;\n&#125;else if(left&gt;(small.offsetWidth-glass.offsetWidth))&#123;\nleft=small.offsetWidth-glass.offsetWidth\n&#125;\n\nif(top&lt;0)&#123;\ntop=0;\n&#125;else if(top&gt;(small.offsetHeight- glass.offsetHeight))&#123;\ntop=small.offsetHeight- glass.offsetHeight\n&#125;\nglass.style.left =left+&#39;px&#39;;\nglass.style.top =top+&#39;px&#39;;\n\n\n\nvar percent=(image.offsetWidth-big.offsetWidth)/(small.offsetWidth-glass.offsetWidth)\n\nimage.style.left=-percent*left+&#39;px&#39;\nimage.style.top =-percent*top+&#39;px&#39;\n\n\n\n&#125;\n&#125;\n\n&lt;/script&gt;\n</code></pre>"},{"title":"搭建Java开发环境","date":"2016-03-28T03:25:02.000Z","description":"搭建Java开发环境","_content":"Java 开发环境的搭建相对其他语言可能有些复杂，因为Java 本身提供了很多机制，从而方便学习。Java的开发环境可以用JDK 来代表，本章主要记录如何下载、安装和配置JDK。\n<!-- more -->\n## 安装配置JDK\n1. 下载JDK\nJDK是java的SDK（软件开发工具包Software Development Kit）。它是Sun 公司提供的一种免费的Java 软件开发工具包，里面包含了很多用于Java 程序开发的工具，最常用的是编译和运行工具。可以在[JDK官网](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)下载。\n\n2. 安装JDK\n下载JDK 后，双击下载的EXE 文件，即可开始安装JDK。首先是弹出许可证协议窗口，其中给出了Sun 公司的一些开发协议，单击其中的“接受”按钮。在窗口中可以选择要安装的Java 组件和JDK 文件的安装路径。Java的所有组件默认安装在C盘，也可以自定义安装路径。 。一直单击“下一步”按钮即可，稍后，单击窗口中的“完成”按钮就正式完成了JDK 的安装。\n\n3. 配置JDK\n这里才是重头戏，下载和安装JDK 只是完成Java 开发环境搭建的前半部分。配置JDK 的目的是能够在命令提示符中运行JDK 中的命令，例如编译和运行。\n配置步骤：\n + 在“计算机”桌面图标上，单击鼠标右键，在弹出菜单中选择“属性”→“高级系统设置”→“环境变量”命令，弹出“环境变量”窗口，在该窗口中就可以进行环境变量的设置\n + 单击“系统变量”选项组中的“新建”按钮，新建环境变量，变量名为JAVA_HOME，变量值为JDK安装路径,默认为C:\\Program Files (x86)\\Java\\jdk1.8.0_77;\n + PATH中新添%JAVA_HOME%\\bin;\n\n在完成了上诉环境配置后，打开cmd命令行，输入java -version,不报错则表示成功。\n\n## 安装intelli idea\n1. 下载安装intelli idea\n官网下载:[http://www.jetbrains.com/idea/]((http://www.jetbrains.com/idea/)\n\n2. 注册intelli idea\n打开已经安装好的intelli idea，通过它提供的License server进行注册，选择License server方式后，在文本框内输入“http://www.iteblog.com/idea/key.php”点击“OK”即可。\n\n\n## hello world\n\n1. 新建工程文件，打开intelli idea，选择菜单栏中“file”→“new”→“project”命令，新建一个project,在project SDK中导入前面安装的JDK，然后一直next，最后命名完成即可。\n\n2. 新建类，在工程文件下的src上右击，选择“new”→“javaclass”,输入类名，在类文件中输入：\n```java\npublic static void main(String[ ] args) {\n    System.out.println(\"Hello World\");\n}\n```\n快捷键`ctrl`+`shift`+`F10`，或者点击工具栏的run和debug按钮，即可编译运行代码。\n\n\n如果运行结果为“hello world”，则说明运行成功。\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/搭建Java开发环境.md","raw":"title: 搭建Java开发环境\ntags: [java基础]\ndate: 2016-03-28 11:25:02\ndescription: 搭建Java开发环境\n---\nJava 开发环境的搭建相对其他语言可能有些复杂，因为Java 本身提供了很多机制，从而方便学习。Java的开发环境可以用JDK 来代表，本章主要记录如何下载、安装和配置JDK。\n<!-- more -->\n## 安装配置JDK\n1. 下载JDK\nJDK是java的SDK（软件开发工具包Software Development Kit）。它是Sun 公司提供的一种免费的Java 软件开发工具包，里面包含了很多用于Java 程序开发的工具，最常用的是编译和运行工具。可以在[JDK官网](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)下载。\n\n2. 安装JDK\n下载JDK 后，双击下载的EXE 文件，即可开始安装JDK。首先是弹出许可证协议窗口，其中给出了Sun 公司的一些开发协议，单击其中的“接受”按钮。在窗口中可以选择要安装的Java 组件和JDK 文件的安装路径。Java的所有组件默认安装在C盘，也可以自定义安装路径。 。一直单击“下一步”按钮即可，稍后，单击窗口中的“完成”按钮就正式完成了JDK 的安装。\n\n3. 配置JDK\n这里才是重头戏，下载和安装JDK 只是完成Java 开发环境搭建的前半部分。配置JDK 的目的是能够在命令提示符中运行JDK 中的命令，例如编译和运行。\n配置步骤：\n + 在“计算机”桌面图标上，单击鼠标右键，在弹出菜单中选择“属性”→“高级系统设置”→“环境变量”命令，弹出“环境变量”窗口，在该窗口中就可以进行环境变量的设置\n + 单击“系统变量”选项组中的“新建”按钮，新建环境变量，变量名为JAVA_HOME，变量值为JDK安装路径,默认为C:\\Program Files (x86)\\Java\\jdk1.8.0_77;\n + PATH中新添%JAVA_HOME%\\bin;\n\n在完成了上诉环境配置后，打开cmd命令行，输入java -version,不报错则表示成功。\n\n## 安装intelli idea\n1. 下载安装intelli idea\n官网下载:[http://www.jetbrains.com/idea/]((http://www.jetbrains.com/idea/)\n\n2. 注册intelli idea\n打开已经安装好的intelli idea，通过它提供的License server进行注册，选择License server方式后，在文本框内输入“http://www.iteblog.com/idea/key.php”点击“OK”即可。\n\n\n## hello world\n\n1. 新建工程文件，打开intelli idea，选择菜单栏中“file”→“new”→“project”命令，新建一个project,在project SDK中导入前面安装的JDK，然后一直next，最后命名完成即可。\n\n2. 新建类，在工程文件下的src上右击，选择“new”→“javaclass”,输入类名，在类文件中输入：\n```java\npublic static void main(String[ ] args) {\n    System.out.println(\"Hello World\");\n}\n```\n快捷键`ctrl`+`shift`+`F10`，或者点击工具栏的run和debug按钮，即可编译运行代码。\n\n\n如果运行结果为“hello world”，则说明运行成功。\n\n\n\n\n\n\n\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"搭建Java开发环境","published":1,"updated":"2018-03-16T08:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomo004qy4v200q9aqi1","content":"<p>Java 开发环境的搭建相对其他语言可能有些复杂，因为Java 本身提供了很多机制，从而方便学习。Java的开发环境可以用JDK 来代表，本章主要记录如何下载、安装和配置JDK。</p>\n<span id=\"more\"></span>\n<h2 id=\"安装配置JDK\"><a href=\"#安装配置JDK\" class=\"headerlink\" title=\"安装配置JDK\"></a>安装配置JDK</h2><ol>\n<li><p>下载JDK<br>JDK是java的SDK（软件开发工具包Software Development Kit）。它是Sun 公司提供的一种免费的Java 软件开发工具包，里面包含了很多用于Java 程序开发的工具，最常用的是编译和运行工具。可以在<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\">JDK官网</a>下载。</p>\n</li>\n<li><p>安装JDK<br>下载JDK 后，双击下载的EXE 文件，即可开始安装JDK。首先是弹出许可证协议窗口，其中给出了Sun 公司的一些开发协议，单击其中的“接受”按钮。在窗口中可以选择要安装的Java 组件和JDK 文件的安装路径。Java的所有组件默认安装在C盘，也可以自定义安装路径。 。一直单击“下一步”按钮即可，稍后，单击窗口中的“完成”按钮就正式完成了JDK 的安装。</p>\n</li>\n<li><p>配置JDK<br>这里才是重头戏，下载和安装JDK 只是完成Java 开发环境搭建的前半部分。配置JDK 的目的是能够在命令提示符中运行JDK 中的命令，例如编译和运行。<br>配置步骤：</p>\n</li>\n</ol>\n<ul>\n<li>在“计算机”桌面图标上，单击鼠标右键，在弹出菜单中选择“属性”→“高级系统设置”→“环境变量”命令，弹出“环境变量”窗口，在该窗口中就可以进行环境变量的设置</li>\n<li>单击“系统变量”选项组中的“新建”按钮，新建环境变量，变量名为JAVA_HOME，变量值为JDK安装路径,默认为C:\\Program Files (x86)\\Java\\jdk1.8.0_77;</li>\n<li>PATH中新添%JAVA_HOME%\\bin;</li>\n</ul>\n<p>在完成了上诉环境配置后，打开cmd命令行，输入java -version,不报错则表示成功。</p>\n<h2 id=\"安装intelli-idea\"><a href=\"#安装intelli-idea\" class=\"headerlink\" title=\"安装intelli idea\"></a>安装intelli idea</h2><ol>\n<li><p>下载安装intelli idea<br>官网下载:<a href=\"(http://www.jetbrains.com/idea/\">http://www.jetbrains.com/idea/</a></p>\n</li>\n<li><p>注册intelli idea<br>打开已经安装好的intelli idea，通过它提供的License server进行注册，选择License server方式后，在文本框内输入“<a href=\"http://www.iteblog.com/idea/key.php%E2%80%9D%E7%82%B9%E5%87%BB%E2%80%9COK%E2%80%9D%E5%8D%B3%E5%8F%AF%E3%80%82\">http://www.iteblog.com/idea/key.php”点击“OK”即可。</a></p>\n</li>\n</ol>\n<h2 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h2><ol>\n<li><p>新建工程文件，打开intelli idea，选择菜单栏中“file”→“new”→“project”命令，新建一个project,在project SDK中导入前面安装的JDK，然后一直next，最后命名完成即可。</p>\n</li>\n<li><p>新建类，在工程文件下的src上右击，选择“new”→“javaclass”,输入类名，在类文件中输入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[ ] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>快捷键<code>ctrl</code>+<code>shift</code>+<code>F10</code>，或者点击工具栏的run和debug按钮，即可编译运行代码。</p>\n</li>\n</ol>\n<p>如果运行结果为“hello world”，则说明运行成功。</p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>Java 开发环境的搭建相对其他语言可能有些复杂，因为Java 本身提供了很多机制，从而方便学习。Java的开发环境可以用JDK 来代表，本章主要记录如何下载、安装和配置JDK。</p>","more":"<h2 id=\"安装配置JDK\"><a href=\"#安装配置JDK\" class=\"headerlink\" title=\"安装配置JDK\"></a>安装配置JDK</h2><ol>\n<li><p>下载JDK<br>JDK是java的SDK（软件开发工具包Software Development Kit）。它是Sun 公司提供的一种免费的Java 软件开发工具包，里面包含了很多用于Java 程序开发的工具，最常用的是编译和运行工具。可以在<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\">JDK官网</a>下载。</p>\n</li>\n<li><p>安装JDK<br>下载JDK 后，双击下载的EXE 文件，即可开始安装JDK。首先是弹出许可证协议窗口，其中给出了Sun 公司的一些开发协议，单击其中的“接受”按钮。在窗口中可以选择要安装的Java 组件和JDK 文件的安装路径。Java的所有组件默认安装在C盘，也可以自定义安装路径。 。一直单击“下一步”按钮即可，稍后，单击窗口中的“完成”按钮就正式完成了JDK 的安装。</p>\n</li>\n<li><p>配置JDK<br>这里才是重头戏，下载和安装JDK 只是完成Java 开发环境搭建的前半部分。配置JDK 的目的是能够在命令提示符中运行JDK 中的命令，例如编译和运行。<br>配置步骤：</p>\n</li>\n</ol>\n<ul>\n<li>在“计算机”桌面图标上，单击鼠标右键，在弹出菜单中选择“属性”→“高级系统设置”→“环境变量”命令，弹出“环境变量”窗口，在该窗口中就可以进行环境变量的设置</li>\n<li>单击“系统变量”选项组中的“新建”按钮，新建环境变量，变量名为JAVA_HOME，变量值为JDK安装路径,默认为C:\\Program Files (x86)\\Java\\jdk1.8.0_77;</li>\n<li>PATH中新添%JAVA_HOME%\\bin;</li>\n</ul>\n<p>在完成了上诉环境配置后，打开cmd命令行，输入java -version,不报错则表示成功。</p>\n<h2 id=\"安装intelli-idea\"><a href=\"#安装intelli-idea\" class=\"headerlink\" title=\"安装intelli idea\"></a>安装intelli idea</h2><ol>\n<li><p>下载安装intelli idea<br>官网下载:<a href=\"(http://www.jetbrains.com/idea/\">http://www.jetbrains.com/idea/</a></p>\n</li>\n<li><p>注册intelli idea<br>打开已经安装好的intelli idea，通过它提供的License server进行注册，选择License server方式后，在文本框内输入“<a href=\"http://www.iteblog.com/idea/key.php%E2%80%9D%E7%82%B9%E5%87%BB%E2%80%9COK%E2%80%9D%E5%8D%B3%E5%8F%AF%E3%80%82\">http://www.iteblog.com/idea/key.php”点击“OK”即可。</a></p>\n</li>\n</ol>\n<h2 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h2><ol>\n<li><p>新建工程文件，打开intelli idea，选择菜单栏中“file”→“new”→“project”命令，新建一个project,在project SDK中导入前面安装的JDK，然后一直next，最后命名完成即可。</p>\n</li>\n<li><p>新建类，在工程文件下的src上右击，选择“new”→“javaclass”,输入类名，在类文件中输入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[ ] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>快捷键<code>ctrl</code>+<code>shift</code>+<code>F10</code>，或者点击工具栏的run和debug按钮，即可编译运行代码。</p>\n</li>\n</ol>\n<p>如果运行结果为“hello world”，则说明运行成功。</p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"_content":"\n```js\nfunction setFixedInterval(fn, timeout) {\n    var startTime = new Date().getTime();\n    var count = 0;\n    var timer = null;\n    // 每次根据标准时间进行矫正\n    // 递归调用setTimeout， 使用修正后的延迟时间\n    function fixed() {\n        var now = +new Date();\n        count++;\n        var offset = new Date().getTime() - (startTime + count * 1000);\n        var nextTime = 1000 - offset;\n        if (nextTime < 0) nextTime = 0;\n        fn();\n        timer && clearTimeout(timer);\n        timer = setTimeout(fixed, nextTime);\n    }\n\n    timer = setTimeout(fixed, timeout);\n}\n```\n\n","source":"_posts/校准定时器.md","raw":"\n```js\nfunction setFixedInterval(fn, timeout) {\n    var startTime = new Date().getTime();\n    var count = 0;\n    var timer = null;\n    // 每次根据标准时间进行矫正\n    // 递归调用setTimeout， 使用修正后的延迟时间\n    function fixed() {\n        var now = +new Date();\n        count++;\n        var offset = new Date().getTime() - (startTime + count * 1000);\n        var nextTime = 1000 - offset;\n        if (nextTime < 0) nextTime = 0;\n        fn();\n        timer && clearTimeout(timer);\n        timer = setTimeout(fixed, nextTime);\n    }\n\n    timer = setTimeout(fixed, timeout);\n}\n```\n\n","slug":"校准定时器","published":1,"date":"2021-12-06T05:35:02.631Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomo004sy4v25fws3zen","content":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setFixedInterval</span>(<span class=\"params\">fn, timeout</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 每次根据标准时间进行矫正</span></span><br><span class=\"line\">    <span class=\"comment\">// 递归调用setTimeout， 使用修正后的延迟时间</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fixed</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> offset = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime() - (startTime + count * <span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> nextTime = <span class=\"number\">1000</span> - offset;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTime &lt; <span class=\"number\">0</span>) nextTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">        fn();</span><br><span class=\"line\">        timer &amp;&amp; <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>(fixed, nextTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    timer = <span class=\"built_in\">setTimeout</span>(fixed, timeout);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setFixedInterval</span>(<span class=\"params\">fn, timeout</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 每次根据标准时间进行矫正</span></span><br><span class=\"line\">    <span class=\"comment\">// 递归调用setTimeout， 使用修正后的延迟时间</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fixed</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> offset = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime() - (startTime + count * <span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> nextTime = <span class=\"number\">1000</span> - offset;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTime &lt; <span class=\"number\">0</span>) nextTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">        fn();</span><br><span class=\"line\">        timer &amp;&amp; <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>(fixed, nextTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    timer = <span class=\"built_in\">setTimeout</span>(fixed, timeout);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"# 数组去重\n\nES6 简单写法\n\n```js\nArray.prototype.uniq = function() {\n    return [...new Set(this)];\n};\n```\n\nES5 写法\n\n```js\nArray.prototype.uniq = function() {\n    var hash = {};\n    return this.reduce((result, current) => {\n        if (!hash[current]) {\n            hash[current] = true;\n            result.push(current);\n        }\n        return result;\n    }, []);\n}\n```\n\n```js\nArray.prototype.uniq = function() {\n    // 长度只有1，直接返回当前的拷贝\n    if (this.length <= 1) {\n        return this.slice(0);\n    }\n    var buf = [];\n    for (var i = 0, l = this.length; i < l; i++) {\n        if (!_isExist(buf, this[i])) {\n            buf.push(this[i]);\n        }\n    }\n    return buf; // 判断是否重复\n    function _isExist(bufArray, target) {\n        if (bufArray.length === 0) {\n            return false;\n        }\n        var bufItem;\n        for (var i = 0, l = bufArray.length; i < l; i++) {\n            bufItem = bufArray[i];\n            if (bufItem === target) {\n                return true;\n                break;\n            }\n            // NaN 需要特殊处理\n            if (\n                typeof target === \"number\" &&\n                typeof bufItem === \"number\" &&\n                isNaN(bufItem) &&\n                isNaN(target)\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n","source":"_posts/数组去重.md","raw":"# 数组去重\n\nES6 简单写法\n\n```js\nArray.prototype.uniq = function() {\n    return [...new Set(this)];\n};\n```\n\nES5 写法\n\n```js\nArray.prototype.uniq = function() {\n    var hash = {};\n    return this.reduce((result, current) => {\n        if (!hash[current]) {\n            hash[current] = true;\n            result.push(current);\n        }\n        return result;\n    }, []);\n}\n```\n\n```js\nArray.prototype.uniq = function() {\n    // 长度只有1，直接返回当前的拷贝\n    if (this.length <= 1) {\n        return this.slice(0);\n    }\n    var buf = [];\n    for (var i = 0, l = this.length; i < l; i++) {\n        if (!_isExist(buf, this[i])) {\n            buf.push(this[i]);\n        }\n    }\n    return buf; // 判断是否重复\n    function _isExist(bufArray, target) {\n        if (bufArray.length === 0) {\n            return false;\n        }\n        var bufItem;\n        for (var i = 0, l = bufArray.length; i < l; i++) {\n            bufItem = bufArray[i];\n            if (bufItem === target) {\n                return true;\n                break;\n            }\n            // NaN 需要特殊处理\n            if (\n                typeof target === \"number\" &&\n                typeof bufItem === \"number\" &&\n                isNaN(bufItem) &&\n                isNaN(target)\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n","slug":"数组去重","published":1,"date":"2021-12-06T05:35:02.631Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomp004uy4v23el652md","content":"<h1 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h1><p>ES6 简单写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.uniq = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [...new <span class=\"built_in\">Set</span>(<span class=\"built_in\">this</span>)];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>ES5 写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.uniq = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hash = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.reduce(<span class=\"function\">(<span class=\"params\">result, current</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!hash[current]) &#123;</span><br><span class=\"line\">            hash[current] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            result.push(current);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.uniq = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 长度只有1，直接返回当前的拷贝</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = <span class=\"built_in\">this</span>.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!_isExist(buf, <span class=\"built_in\">this</span>[i])) &#123;</span><br><span class=\"line\">            buf.push(<span class=\"built_in\">this</span>[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf; <span class=\"comment\">// 判断是否重复</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_isExist</span>(<span class=\"params\">bufArray, target</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bufArray.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bufItem;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = bufArray.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">            bufItem = bufArray[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bufItem === target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// NaN 需要特殊处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                <span class=\"keyword\">typeof</span> target === <span class=\"string\">&quot;number&quot;</span> &amp;&amp;</span><br><span class=\"line\">                <span class=\"keyword\">typeof</span> bufItem === <span class=\"string\">&quot;number&quot;</span> &amp;&amp;</span><br><span class=\"line\">                <span class=\"built_in\">isNaN</span>(bufItem) &amp;&amp;</span><br><span class=\"line\">                <span class=\"built_in\">isNaN</span>(target)</span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h1><p>ES6 简单写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.uniq = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [...new <span class=\"built_in\">Set</span>(<span class=\"built_in\">this</span>)];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>ES5 写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.uniq = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hash = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.reduce(<span class=\"function\">(<span class=\"params\">result, current</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!hash[current]) &#123;</span><br><span class=\"line\">            hash[current] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            result.push(current);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.uniq = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 长度只有1，直接返回当前的拷贝</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = <span class=\"built_in\">this</span>.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!_isExist(buf, <span class=\"built_in\">this</span>[i])) &#123;</span><br><span class=\"line\">            buf.push(<span class=\"built_in\">this</span>[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf; <span class=\"comment\">// 判断是否重复</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_isExist</span>(<span class=\"params\">bufArray, target</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bufArray.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bufItem;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = bufArray.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">            bufItem = bufArray[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bufItem === target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// NaN 需要特殊处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                <span class=\"keyword\">typeof</span> target === <span class=\"string\">&quot;number&quot;</span> &amp;&amp;</span><br><span class=\"line\">                <span class=\"keyword\">typeof</span> bufItem === <span class=\"string\">&quot;number&quot;</span> &amp;&amp;</span><br><span class=\"line\">                <span class=\"built_in\">isNaN</span>(bufItem) &amp;&amp;</span><br><span class=\"line\">                <span class=\"built_in\">isNaN</span>(target)</span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"chrome developer tool—— 断点调试篇","date":"2016-06-12T05:05:32.000Z","description":"chrome developer tool 断点","_content":"\n> 断点，调试器的功能之一，可以让程序中断在需要的地方，从而方便其分析。也可以在一次调试中设置断点，下一次只需让程序自动运行到设置断点位置，便可在上次设置断点的位置中断下来，极大的方便了操作，同时节省了时间。 ——百度百科\n\n简单地说，断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。\n\n<!-- more -->\n\n## Sources面板\nSources面板是chrome developer tool中的断点调试面板。我们打开Sources面板后其实会在界面中看到如下内容，我们跟着逐一看看都是什么意思：\n\n![](/images/201601/sourcesPanel.png)\n\n**1.左上蓝色模块 **\n网站文件目录树。\n\n**2.右上黄色模块 **\n左侧所选文件的具体内容展示区\n\n**3.右下绿色模块 **\n这一模块有俩个可切换区域：\n+ scope ：显示当前断点的作用域\n+ watch ：点击+号可添加你所需要监控的变量或者表达式\n\n**4.左下红色模块 **\n主要核心功能区\n+ Call Stack 显示当前断点的环境调用栈\n+ Breakpoints 当前js断点列表，添加的每个断点都会出现在此处，点击列表中断点就会定位到内容区的断点上\n+ DOM Breakpoints 当前DOM断点列表列表\n+ XHR Breakpoints 当前xhr断点列表，可点击右侧`+`添加断点\n+ Event Listener Breakpoints 事件监听器断点设置处\n+ Event Listeners 当前事件监听断点列表\n\n\n## 设置断点\n断点调试的首要条件当然是添加断点，js断点添加的方式有俩种:\n\n**1.JS断点**\n+ Sources断点\nSources断点添加的流程是“F12（Ctrl + Shift + I）打开开发工具”——“点击Sources菜单”——“左侧树中找到相应文件”——“点击行号列”即完成在当前行添加/删除断点操作。当断点添加完毕后，刷新页面JS执行到断点位置停住，在Sources界面会看到当前作用域中所有变量和值，只需对每个值进行验证即可完成我们题设验证要求。\n - 条件断点\n    在Sources里还可以设置条件断点，在断点位置的右键菜单中选择“Edit Breakpoint...”可以设置触发断点的条件，就是写一个表达式，表达式为 true 时才触发断点。\n\n+ Debugger断点\nDebugger断点的添加就是通过在代码中添加\"debugger;\"语句，当代码执行到该语句的时候就会自动断点。\n\n**2.DOM断点**\nDOM断点，顾名思义就是在DOM元素上添加断点，进而达到调试的目的。而在实际使用中断点的效果最终还是落地到JS逻辑之内。\nDOM断点的添加流程为：打开Elements面板——定位到相关DOM节点——单机鼠标右键，弹出侧边栏——鼠标移动到`Break on...`上，选择相应选项`subtree modifications`/`attributes modifications`/`node removal`即可。\n![](/images/201601/domBreak.png)\n\n+ 子节点变化断点 (subtree modifications)\n主要针对子节点增加、删除以及交换顺序等操作，但子节点进行属性修改和内容修改并不会触发断点。\n\n+ 节点属性断点 (attributes modifications)\n\n+ 节点移除断点 (node removal)\n\n**3.XHR断点（XHR Breakpoints）**\n我们可以通过“XHR Breakpoints”右侧的“+”号为异步断点添加断点条件，当异步请求触发时的URL满足此条件，JS逻辑则会自动产生断点。\n![](/images/201601/xhrdebug.gif)\n\n**4.事件监听器断点（Event Listener Breakpoints）**\n事件监听器断点，即根据事件名称进行断点设置。当事件被触发时，断点到事件绑定的位置。事件监听器断点，列出了所有页面及脚本事件，包括：鼠标、键盘、动画、定时器、XHR等等。\n![](/images/201601/eventdebug.gif)\n\n## 断点调试\n断点调试主要用到以下功能键，从左到右依次为：\n![](/images/201601/debuger.png)\n+ Pause/Resume script execution：暂停/恢复脚本执行（程序执行到下一断点停止）。\n+ Step over next function call：执行到下一步的函数调用（跳到下一行）。\n+ Step into next function call：进入当前函数。\n+ Step out of current function：跳出当前执行函数。\n+ Deactive/Active all breakpoints：关闭/开启所有断点（不会取消）。\n+ Pause on exceptions：异常情况自动断点设置。\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/断点调试篇.md","raw":"title: chrome developer tool—— 断点调试篇\ntags:\n  - 工具\ndate: 2016-06-12 13:05:32\ndescription: chrome developer tool 断点\n---\n\n> 断点，调试器的功能之一，可以让程序中断在需要的地方，从而方便其分析。也可以在一次调试中设置断点，下一次只需让程序自动运行到设置断点位置，便可在上次设置断点的位置中断下来，极大的方便了操作，同时节省了时间。 ——百度百科\n\n简单地说，断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。\n\n<!-- more -->\n\n## Sources面板\nSources面板是chrome developer tool中的断点调试面板。我们打开Sources面板后其实会在界面中看到如下内容，我们跟着逐一看看都是什么意思：\n\n![](/images/201601/sourcesPanel.png)\n\n**1.左上蓝色模块 **\n网站文件目录树。\n\n**2.右上黄色模块 **\n左侧所选文件的具体内容展示区\n\n**3.右下绿色模块 **\n这一模块有俩个可切换区域：\n+ scope ：显示当前断点的作用域\n+ watch ：点击+号可添加你所需要监控的变量或者表达式\n\n**4.左下红色模块 **\n主要核心功能区\n+ Call Stack 显示当前断点的环境调用栈\n+ Breakpoints 当前js断点列表，添加的每个断点都会出现在此处，点击列表中断点就会定位到内容区的断点上\n+ DOM Breakpoints 当前DOM断点列表列表\n+ XHR Breakpoints 当前xhr断点列表，可点击右侧`+`添加断点\n+ Event Listener Breakpoints 事件监听器断点设置处\n+ Event Listeners 当前事件监听断点列表\n\n\n## 设置断点\n断点调试的首要条件当然是添加断点，js断点添加的方式有俩种:\n\n**1.JS断点**\n+ Sources断点\nSources断点添加的流程是“F12（Ctrl + Shift + I）打开开发工具”——“点击Sources菜单”——“左侧树中找到相应文件”——“点击行号列”即完成在当前行添加/删除断点操作。当断点添加完毕后，刷新页面JS执行到断点位置停住，在Sources界面会看到当前作用域中所有变量和值，只需对每个值进行验证即可完成我们题设验证要求。\n - 条件断点\n    在Sources里还可以设置条件断点，在断点位置的右键菜单中选择“Edit Breakpoint...”可以设置触发断点的条件，就是写一个表达式，表达式为 true 时才触发断点。\n\n+ Debugger断点\nDebugger断点的添加就是通过在代码中添加\"debugger;\"语句，当代码执行到该语句的时候就会自动断点。\n\n**2.DOM断点**\nDOM断点，顾名思义就是在DOM元素上添加断点，进而达到调试的目的。而在实际使用中断点的效果最终还是落地到JS逻辑之内。\nDOM断点的添加流程为：打开Elements面板——定位到相关DOM节点——单机鼠标右键，弹出侧边栏——鼠标移动到`Break on...`上，选择相应选项`subtree modifications`/`attributes modifications`/`node removal`即可。\n![](/images/201601/domBreak.png)\n\n+ 子节点变化断点 (subtree modifications)\n主要针对子节点增加、删除以及交换顺序等操作，但子节点进行属性修改和内容修改并不会触发断点。\n\n+ 节点属性断点 (attributes modifications)\n\n+ 节点移除断点 (node removal)\n\n**3.XHR断点（XHR Breakpoints）**\n我们可以通过“XHR Breakpoints”右侧的“+”号为异步断点添加断点条件，当异步请求触发时的URL满足此条件，JS逻辑则会自动产生断点。\n![](/images/201601/xhrdebug.gif)\n\n**4.事件监听器断点（Event Listener Breakpoints）**\n事件监听器断点，即根据事件名称进行断点设置。当事件被触发时，断点到事件绑定的位置。事件监听器断点，列出了所有页面及脚本事件，包括：鼠标、键盘、动画、定时器、XHR等等。\n![](/images/201601/eventdebug.gif)\n\n## 断点调试\n断点调试主要用到以下功能键，从左到右依次为：\n![](/images/201601/debuger.png)\n+ Pause/Resume script execution：暂停/恢复脚本执行（程序执行到下一断点停止）。\n+ Step over next function call：执行到下一步的函数调用（跳到下一行）。\n+ Step into next function call：进入当前函数。\n+ Step out of current function：跳出当前执行函数。\n+ Deactive/Active all breakpoints：关闭/开启所有断点（不会取消）。\n+ Pause on exceptions：异常情况自动断点设置。\n\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"断点调试篇","published":1,"updated":"2021-12-06T06:07:06.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomr004wy4v2aoake1so","content":"<blockquote>\n<p>断点，调试器的功能之一，可以让程序中断在需要的地方，从而方便其分析。也可以在一次调试中设置断点，下一次只需让程序自动运行到设置断点位置，便可在上次设置断点的位置中断下来，极大的方便了操作，同时节省了时间。 ——百度百科</p>\n</blockquote>\n<p>简单地说，断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Sources面板\"><a href=\"#Sources面板\" class=\"headerlink\" title=\"Sources面板\"></a>Sources面板</h2><p>Sources面板是chrome developer tool中的断点调试面板。我们打开Sources面板后其实会在界面中看到如下内容，我们跟着逐一看看都是什么意思：</p>\n<p><img src=\"/images/201601/sourcesPanel.png\"></p>\n<p>**1.左上蓝色模块 **<br>网站文件目录树。</p>\n<p>**2.右上黄色模块 **<br>左侧所选文件的具体内容展示区</p>\n<p>**3.右下绿色模块 **<br>这一模块有俩个可切换区域：</p>\n<ul>\n<li>scope ：显示当前断点的作用域</li>\n<li>watch ：点击+号可添加你所需要监控的变量或者表达式</li>\n</ul>\n<p>**4.左下红色模块 **<br>主要核心功能区</p>\n<ul>\n<li>Call Stack 显示当前断点的环境调用栈</li>\n<li>Breakpoints 当前js断点列表，添加的每个断点都会出现在此处，点击列表中断点就会定位到内容区的断点上</li>\n<li>DOM Breakpoints 当前DOM断点列表列表</li>\n<li>XHR Breakpoints 当前xhr断点列表，可点击右侧<code>+</code>添加断点</li>\n<li>Event Listener Breakpoints 事件监听器断点设置处</li>\n<li>Event Listeners 当前事件监听断点列表</li>\n</ul>\n<h2 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h2><p>断点调试的首要条件当然是添加断点，js断点添加的方式有俩种:</p>\n<p><strong>1.JS断点</strong></p>\n<ul>\n<li>Sources断点<br>Sources断点添加的流程是“F12（Ctrl + Shift + I）打开开发工具”——“点击Sources菜单”——“左侧树中找到相应文件”——“点击行号列”即完成在当前行添加/删除断点操作。当断点添加完毕后，刷新页面JS执行到断点位置停住，在Sources界面会看到当前作用域中所有变量和值，只需对每个值进行验证即可完成我们题设验证要求。</li>\n</ul>\n<ul>\n<li>条件断点<br> 在Sources里还可以设置条件断点，在断点位置的右键菜单中选择“Edit Breakpoint…”可以设置触发断点的条件，就是写一个表达式，表达式为 true 时才触发断点。</li>\n</ul>\n<ul>\n<li>Debugger断点<br>Debugger断点的添加就是通过在代码中添加”debugger;”语句，当代码执行到该语句的时候就会自动断点。</li>\n</ul>\n<p><strong>2.DOM断点</strong><br>DOM断点，顾名思义就是在DOM元素上添加断点，进而达到调试的目的。而在实际使用中断点的效果最终还是落地到JS逻辑之内。<br>DOM断点的添加流程为：打开Elements面板——定位到相关DOM节点——单机鼠标右键，弹出侧边栏——鼠标移动到<code>Break on...</code>上，选择相应选项<code>subtree modifications</code>/<code>attributes modifications</code>/<code>node removal</code>即可。<br><img src=\"/images/201601/domBreak.png\"></p>\n<ul>\n<li><p>子节点变化断点 (subtree modifications)<br>主要针对子节点增加、删除以及交换顺序等操作，但子节点进行属性修改和内容修改并不会触发断点。</p>\n</li>\n<li><p>节点属性断点 (attributes modifications)</p>\n</li>\n<li><p>节点移除断点 (node removal)</p>\n</li>\n</ul>\n<p><strong>3.XHR断点（XHR Breakpoints）</strong><br>我们可以通过“XHR Breakpoints”右侧的“+”号为异步断点添加断点条件，当异步请求触发时的URL满足此条件，JS逻辑则会自动产生断点。<br><img src=\"/images/201601/xhrdebug.gif\"></p>\n<p><strong>4.事件监听器断点（Event Listener Breakpoints）</strong><br>事件监听器断点，即根据事件名称进行断点设置。当事件被触发时，断点到事件绑定的位置。事件监听器断点，列出了所有页面及脚本事件，包括：鼠标、键盘、动画、定时器、XHR等等。<br><img src=\"/images/201601/eventdebug.gif\"></p>\n<h2 id=\"断点调试\"><a href=\"#断点调试\" class=\"headerlink\" title=\"断点调试\"></a>断点调试</h2><p>断点调试主要用到以下功能键，从左到右依次为：<br><img src=\"/images/201601/debuger.png\"></p>\n<ul>\n<li>Pause/Resume script execution：暂停/恢复脚本执行（程序执行到下一断点停止）。</li>\n<li>Step over next function call：执行到下一步的函数调用（跳到下一行）。</li>\n<li>Step into next function call：进入当前函数。</li>\n<li>Step out of current function：跳出当前执行函数。</li>\n<li>Deactive/Active all breakpoints：关闭/开启所有断点（不会取消）。</li>\n<li>Pause on exceptions：异常情况自动断点设置。</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>断点，调试器的功能之一，可以让程序中断在需要的地方，从而方便其分析。也可以在一次调试中设置断点，下一次只需让程序自动运行到设置断点位置，便可在上次设置断点的位置中断下来，极大的方便了操作，同时节省了时间。 ——百度百科</p>\n</blockquote>\n<p>简单地说，断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。</p>","more":"<h2 id=\"Sources面板\"><a href=\"#Sources面板\" class=\"headerlink\" title=\"Sources面板\"></a>Sources面板</h2><p>Sources面板是chrome developer tool中的断点调试面板。我们打开Sources面板后其实会在界面中看到如下内容，我们跟着逐一看看都是什么意思：</p>\n<p><img src=\"/images/201601/sourcesPanel.png\"></p>\n<p>**1.左上蓝色模块 **<br>网站文件目录树。</p>\n<p>**2.右上黄色模块 **<br>左侧所选文件的具体内容展示区</p>\n<p>**3.右下绿色模块 **<br>这一模块有俩个可切换区域：</p>\n<ul>\n<li>scope ：显示当前断点的作用域</li>\n<li>watch ：点击+号可添加你所需要监控的变量或者表达式</li>\n</ul>\n<p>**4.左下红色模块 **<br>主要核心功能区</p>\n<ul>\n<li>Call Stack 显示当前断点的环境调用栈</li>\n<li>Breakpoints 当前js断点列表，添加的每个断点都会出现在此处，点击列表中断点就会定位到内容区的断点上</li>\n<li>DOM Breakpoints 当前DOM断点列表列表</li>\n<li>XHR Breakpoints 当前xhr断点列表，可点击右侧<code>+</code>添加断点</li>\n<li>Event Listener Breakpoints 事件监听器断点设置处</li>\n<li>Event Listeners 当前事件监听断点列表</li>\n</ul>\n<h2 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h2><p>断点调试的首要条件当然是添加断点，js断点添加的方式有俩种:</p>\n<p><strong>1.JS断点</strong></p>\n<ul>\n<li>Sources断点<br>Sources断点添加的流程是“F12（Ctrl + Shift + I）打开开发工具”——“点击Sources菜单”——“左侧树中找到相应文件”——“点击行号列”即完成在当前行添加/删除断点操作。当断点添加完毕后，刷新页面JS执行到断点位置停住，在Sources界面会看到当前作用域中所有变量和值，只需对每个值进行验证即可完成我们题设验证要求。</li>\n</ul>\n<ul>\n<li>条件断点<br> 在Sources里还可以设置条件断点，在断点位置的右键菜单中选择“Edit Breakpoint…”可以设置触发断点的条件，就是写一个表达式，表达式为 true 时才触发断点。</li>\n</ul>\n<ul>\n<li>Debugger断点<br>Debugger断点的添加就是通过在代码中添加”debugger;”语句，当代码执行到该语句的时候就会自动断点。</li>\n</ul>\n<p><strong>2.DOM断点</strong><br>DOM断点，顾名思义就是在DOM元素上添加断点，进而达到调试的目的。而在实际使用中断点的效果最终还是落地到JS逻辑之内。<br>DOM断点的添加流程为：打开Elements面板——定位到相关DOM节点——单机鼠标右键，弹出侧边栏——鼠标移动到<code>Break on...</code>上，选择相应选项<code>subtree modifications</code>/<code>attributes modifications</code>/<code>node removal</code>即可。<br><img src=\"/images/201601/domBreak.png\"></p>\n<ul>\n<li><p>子节点变化断点 (subtree modifications)<br>主要针对子节点增加、删除以及交换顺序等操作，但子节点进行属性修改和内容修改并不会触发断点。</p>\n</li>\n<li><p>节点属性断点 (attributes modifications)</p>\n</li>\n<li><p>节点移除断点 (node removal)</p>\n</li>\n</ul>\n<p><strong>3.XHR断点（XHR Breakpoints）</strong><br>我们可以通过“XHR Breakpoints”右侧的“+”号为异步断点添加断点条件，当异步请求触发时的URL满足此条件，JS逻辑则会自动产生断点。<br><img src=\"/images/201601/xhrdebug.gif\"></p>\n<p><strong>4.事件监听器断点（Event Listener Breakpoints）</strong><br>事件监听器断点，即根据事件名称进行断点设置。当事件被触发时，断点到事件绑定的位置。事件监听器断点，列出了所有页面及脚本事件，包括：鼠标、键盘、动画、定时器、XHR等等。<br><img src=\"/images/201601/eventdebug.gif\"></p>\n<h2 id=\"断点调试\"><a href=\"#断点调试\" class=\"headerlink\" title=\"断点调试\"></a>断点调试</h2><p>断点调试主要用到以下功能键，从左到右依次为：<br><img src=\"/images/201601/debuger.png\"></p>\n<ul>\n<li>Pause/Resume script execution：暂停/恢复脚本执行（程序执行到下一断点停止）。</li>\n<li>Step over next function call：执行到下一步的函数调用（跳到下一行）。</li>\n<li>Step into next function call：进入当前函数。</li>\n<li>Step out of current function：跳出当前执行函数。</li>\n<li>Deactive/Active all breakpoints：关闭/开启所有断点（不会取消）。</li>\n<li>Pause on exceptions：异常情况自动断点设置。</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"_content":"# 模块\n\n## require 函数\n\n```javascript\nfunction require(/* ... */) {\n  const module = { exports: {} };\n  ((module, exports) => {\n    //所require的模块的代码\n    function someFunc() {}\n    exports = someFunc;\n    // 在这里，exports = module.exports, 它是一个引用，直接赋值给它，只是让这个变量等于另外一个引用，并不会修改到module对象\n\n    module.exports = someFunc;\n    //在这里，通过 module.exports 才能真正修改到 exports 本身，此时\b才会导出someFunc\n  })(module, module.exports);\n  return module.exports;\n}\n```\n\n这个函数传递一个字符串，返回一个对象（module.exports）；\n\n\n**问题：**\n1. module.exports 和 exports 的区别\n    exports 只是 module.exports 的一个引用\n    \n2. 如果 a.js require 了 b.js, 那么在 b 中定义全局变量 t = 111 能否在 a 中直接打印出来?\n\n    答：每个 `.js` 能独立一个环境只是因为 node 帮你在外层包了一圈自执行, 所以你使用 t = 111 定义全局变量在其他地方当然能拿到. 情况如下:\n\n3. a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?\n\n    答： 不会, 先执行的导出空对象, 模块导出的只是 `var module = { exports: {} };` 中的 exports, 以从 a.js 启动为例, a.js 还没执行完 exports 就是 {} 在 b.js 的开头拿到的就是 {} 而已.","source":"_posts/模块.md","raw":"# 模块\n\n## require 函数\n\n```javascript\nfunction require(/* ... */) {\n  const module = { exports: {} };\n  ((module, exports) => {\n    //所require的模块的代码\n    function someFunc() {}\n    exports = someFunc;\n    // 在这里，exports = module.exports, 它是一个引用，直接赋值给它，只是让这个变量等于另外一个引用，并不会修改到module对象\n\n    module.exports = someFunc;\n    //在这里，通过 module.exports 才能真正修改到 exports 本身，此时\b才会导出someFunc\n  })(module, module.exports);\n  return module.exports;\n}\n```\n\n这个函数传递一个字符串，返回一个对象（module.exports）；\n\n\n**问题：**\n1. module.exports 和 exports 的区别\n    exports 只是 module.exports 的一个引用\n    \n2. 如果 a.js require 了 b.js, 那么在 b 中定义全局变量 t = 111 能否在 a 中直接打印出来?\n\n    答：每个 `.js` 能独立一个环境只是因为 node 帮你在外层包了一圈自执行, 所以你使用 t = 111 定义全局变量在其他地方当然能拿到. 情况如下:\n\n3. a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?\n\n    答： 不会, 先执行的导出空对象, 模块导出的只是 `var module = { exports: {} };` 中的 exports, 以从 a.js 启动为例, a.js 还没执行完 exports 就是 {} 在 b.js 的开头拿到的就是 {} 而已.","slug":"模块","published":1,"date":"2021-12-06T05:35:02.621Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwoms004yy4v25fpc1c1c","content":"<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><h2 id=\"require-函数\"><a href=\"#require-函数\" class=\"headerlink\" title=\"require 函数\"></a>require 函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">require</span>(<span class=\"params\"><span class=\"comment\">/* ... */</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">module</span> = &#123; <span class=\"attr\">exports</span>: &#123;&#125; &#125;;</span><br><span class=\"line\">  (<span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span>, <span class=\"built_in\">exports</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//所require的模块的代码</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someFunc</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">exports</span> = someFunc;</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，exports = module.exports, 它是一个引用，直接赋值给它，只是让这个变量等于另外一个引用，并不会修改到module对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = someFunc;</span><br><span class=\"line\">    <span class=\"comment\">//在这里，通过 module.exports 才能真正修改到 exports 本身，此时\b才会导出someFunc</span></span><br><span class=\"line\">  &#125;)(<span class=\"built_in\">module</span>, <span class=\"built_in\">module</span>.exports);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数传递一个字符串，返回一个对象（module.exports）；</p>\n<p><strong>问题：</strong></p>\n<ol>\n<li><p>module.exports 和 exports 的区别<br> exports 只是 module.exports 的一个引用</p>\n</li>\n<li><p>如果 a.js require 了 b.js, 那么在 b 中定义全局变量 t = 111 能否在 a 中直接打印出来?</p>\n<p> 答：每个 <code>.js</code> 能独立一个环境只是因为 node 帮你在外层包了一圈自执行, 所以你使用 t = 111 定义全局变量在其他地方当然能拿到. 情况如下:</p>\n</li>\n<li><p>a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?</p>\n<p> 答： 不会, 先执行的导出空对象, 模块导出的只是 <code>var module = &#123; exports: &#123;&#125; &#125;;</code> 中的 exports, 以从 a.js 启动为例, a.js 还没执行完 exports 就是 {} 在 b.js 的开头拿到的就是 {} 而已.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><h2 id=\"require-函数\"><a href=\"#require-函数\" class=\"headerlink\" title=\"require 函数\"></a>require 函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">require</span>(<span class=\"params\"><span class=\"comment\">/* ... */</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">module</span> = &#123; <span class=\"attr\">exports</span>: &#123;&#125; &#125;;</span><br><span class=\"line\">  (<span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span>, <span class=\"built_in\">exports</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//所require的模块的代码</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someFunc</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">exports</span> = someFunc;</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，exports = module.exports, 它是一个引用，直接赋值给它，只是让这个变量等于另外一个引用，并不会修改到module对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = someFunc;</span><br><span class=\"line\">    <span class=\"comment\">//在这里，通过 module.exports 才能真正修改到 exports 本身，此时\b才会导出someFunc</span></span><br><span class=\"line\">  &#125;)(<span class=\"built_in\">module</span>, <span class=\"built_in\">module</span>.exports);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数传递一个字符串，返回一个对象（module.exports）；</p>\n<p><strong>问题：</strong></p>\n<ol>\n<li><p>module.exports 和 exports 的区别<br> exports 只是 module.exports 的一个引用</p>\n</li>\n<li><p>如果 a.js require 了 b.js, 那么在 b 中定义全局变量 t = 111 能否在 a 中直接打印出来?</p>\n<p> 答：每个 <code>.js</code> 能独立一个环境只是因为 node 帮你在外层包了一圈自执行, 所以你使用 t = 111 定义全局变量在其他地方当然能拿到. 情况如下:</p>\n</li>\n<li><p>a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?</p>\n<p> 答： 不会, 先执行的导出空对象, 模块导出的只是 <code>var module = &#123; exports: &#123;&#125; &#125;;</code> 中的 exports, 以从 a.js 启动为例, a.js 还没执行完 exports 就是 {} 在 b.js 的开头拿到的就是 {} 而已.</p>\n</li>\n</ol>\n"},{"_content":"# 深拷贝\n\n\n```js\n/**\n * deepCopy\n * @param {*} data 要拷贝的数据\n */\nfunction deepCopy(data) {\n    var buf;\n    if (data instanceof Array) {\n        buf = []; // 创建一个空的数组\n        var i = data.length;\n        while (i--) {\n            buf[i] = deepCopy(data[i]);\n        }\n        return buf;\n    } else if (data instanceof Object) {\n        buf = {}; // 创建一个空对象\n        for (var k in data) {\n            // 为这个对象添加新的属性\n            buf[k] = deepCopy(data[k]);\n        }\n        return buf;\n    } else {\n        return data;\n    }\n}\n```\n\ntips：`for in` 遍历数组会遍历 Array.prototype 上的可枚举属性。可以使用 `hasOwnProperty` 解决。","source":"_posts/深拷贝.md","raw":"# 深拷贝\n\n\n```js\n/**\n * deepCopy\n * @param {*} data 要拷贝的数据\n */\nfunction deepCopy(data) {\n    var buf;\n    if (data instanceof Array) {\n        buf = []; // 创建一个空的数组\n        var i = data.length;\n        while (i--) {\n            buf[i] = deepCopy(data[i]);\n        }\n        return buf;\n    } else if (data instanceof Object) {\n        buf = {}; // 创建一个空对象\n        for (var k in data) {\n            // 为这个对象添加新的属性\n            buf[k] = deepCopy(data[k]);\n        }\n        return buf;\n    } else {\n        return data;\n    }\n}\n```\n\ntips：`for in` 遍历数组会遍历 Array.prototype 上的可枚举属性。可以使用 `hasOwnProperty` 解决。","slug":"深拷贝","published":1,"date":"2021-12-06T05:35:02.631Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomt0050y4v2e4oh1nrp","content":"<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * deepCopy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>data 要拷贝的数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;</span><br><span class=\"line\">        buf = []; <span class=\"comment\">// 创建一个空的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = data.length;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">            buf[i] = deepCopy(data[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) &#123;</span><br><span class=\"line\">        buf = &#123;&#125;; <span class=\"comment\">// 创建一个空对象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 为这个对象添加新的属性</span></span><br><span class=\"line\">            buf[k] = deepCopy(data[k]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>tips：<code>for in</code> 遍历数组会遍历 Array.prototype 上的可枚举属性。可以使用 <code>hasOwnProperty</code> 解决。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * deepCopy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>data 要拷贝的数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;</span><br><span class=\"line\">        buf = []; <span class=\"comment\">// 创建一个空的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = data.length;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">            buf[i] = deepCopy(data[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) &#123;</span><br><span class=\"line\">        buf = &#123;&#125;; <span class=\"comment\">// 创建一个空对象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 为这个对象添加新的属性</span></span><br><span class=\"line\">            buf[k] = deepCopy(data[k]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>tips：<code>for in</code> 遍历数组会遍历 Array.prototype 上的可枚举属性。可以使用 <code>hasOwnProperty</code> 解决。</p>\n"},{"title":"浏览器客户端的数据存储","date":"2016-03-23T08:51:58.000Z","description":"数据存储","_content":"\n属于某个特定用户的信息应该存在该用户的机器上,无论是登录信息、偏好设定或其他数据,这是一个很重要的用户体验，它避免了用户重复多次的简单操作。\n\n## 一、Cookie\n\ncookie 是原来的网景公司创造的。一份题为“Persistent Client State: HTTP Cookes”（持久客户端状态： HTTP Cookies ） 的标准中对cookie 机制进行了阐述。\n<!-- more -->\n\n> cookie标准要求服务器对任意HTTP 请求发送Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息\n\n**过程：**\n1.设置cookie，发送至服务器端；\n2.服务器对该请求发送带有`Set-Cookie` 的HTTP响应给浏览器；\n3.浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP 头将信息发送回服务器\n\n**cookie的限制**\n + 域限制：浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP 头将信息发送回服务器\n + 大小限制：大多数浏览器都有大约4096B（加减1）的长度限制。为了最佳的浏览器兼容性，最好将整个cookie 长度限制在4095B（含4095）以内\n + 个数限制：每个域的cookie 总数是有限的，不过浏览器之间各有不同：\n\n\n 浏览器      | 个数\n------------ | ---\nIE7+         | 50\nFirefox      | 50\nOpera        | 30\n Safari 和Chrome    | 没有硬性规定\n\n\n**cookie的构成**\n比如：\n```\nSet-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com;secure\n```\n+ `name = value` [必须参数]; 名值对，不区分大小写，必须是URL 编码\n+ `domain`  设定cookie的有效域，所有向该域发送的请求中都会包含这个cookie 信息\n+ `path`  指定cookie在有效域中的有效路径，即使请求都是来自同一个域的，不是该键制定的路径，也不会发送cookie\n+ `expires`  表示cookie 何时应该被删除的时间戳（这个值是个GMT 格式的日期），默认情况下，浏览器会话结束时即将所有cookie 删除\n+ `secure`  指定后，cookie 只有在使用SSL 连接的时候才发送到服务器\n\n\n**js处理cookie**\n`document.cookie` 返回当前页面可用的所有cookie的字符串，一系列由分号隔开的名值对儿。\ncookie的操作无非是获取、设置和删除，我们把这三种方法封装在一个`var CookieUtil = {}`对象中。分别对应其get，set，unset属性。\n\n> cookie的name和value都是经过URL 编码的，所以必须使用encodeURIComponent，decodeURIComponent()来编解码。\n\n1.**get**\n\n```js\n    get: function (name){\n        var cookieName = encodeURIComponent(name) + \"=\",\n        cookieStart = document.cookie.indexOf(cookieName),\n        cookieValue = null;\n        if (cookieStart > -1){\n            var cookieEnd = document.cookie.indexOf(\";\", cookieStart);\n            if (cookieEnd == -1){\n                cookieEnd = document.cookie.length;\n            }\n            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));\n        }\n        return cookieValue;\n    }\n\n```\n2.**set**\n```\n    set: function (name, value, expires, path, domain, secure) {\n        var cookieText = encodeURIComponent(name) + \"=\" +\n        encodeURIComponent(value);\n        if (expires instanceof Date) {\n            cookieText += \"; expires=\" + expires.toGMTString();\n        }\n        if (path) {\n            cookieText += \"; path=\" + path;\n        }\n        if (domain) {\n            cookieText += \"; domain=\" + domain;\n        }\n        if (secure) {\n            cookieText += \"; secure\";\n        }\n        document.cookie = cookieText;\n    }\n```\n3.**unset**\n```\n    unset: function (name, path, domain, secure){\n        this.set(name, \"\", new Date(0), path, domain, secure);\n    }\n```\n\n\n**子cookie**\n> 子cookie可以绕开浏览器的单域名下的cookie 数限制。子cookie 是存放在单个cookie 中的更小段的数据。也就是使用cookie 值来存储多个名称值对，如：name=name1=value1&name2=value2&name3=value3&name4=value4&name5=value5\n\n\n**所有的cookie 都会由浏览器作为请求头发送，所以在cookie 中存储大量信息会影响到特定域的请求性能。cookie 信息越大，完成对服务器请求的时间也就越长。尽管浏览器对cookie 进行了大小限制，不过最好还是尽可能在cookie 中少存储信息，以避免影响性能**\n\n## 二、IE用户数据\n\n在IE5.0 中，微软通过一个自定义行为引入了持久化用户数据的概念。用户数据允许每个文档最多\n128KB 数据，每个域名最多1MB 数据。\n\n**使用**：\n+ 使用CSS 在某个元素上指定userData 行为：\n```css\n<div style=\"behavior:url(#default#userData)\" id=\"dataStore\"></div>\n```\n+ 使用setAttribute()方法在上面保存数据\n```js\ndataStore.setAttribute(\"name\", \"Nicholas\");\n```\n+ 调用save()方法保存数据，参数为数据空间名字，数据空间名字可以完全任意，仅用于区分不同的数据集\n```js\ndataStore.save(\"BookInfo\");\n```\n+ 使用load()方法来获取数据，参数为数据空间名字\n```js\ndataStore.load(\"BookInfo\");\n```\n+ 使用removeAttribute()删除数据，并使用save()保存修改\n```js\ndataStore.removeAttribute(\"name\");\ndataStore.save(\"BookInfo\");\n```\n\n**限制**\n+ 同cookie，需要同域名，同路径，并使用与进行存储的脚本同样的协议；\n+ 无法将用户数据访问限制扩展到更多的客户\n\n**用户数据默认是可以跨越会话持久存在的，不会过期；数据需要通过removeAttribute()方法专门进行删除以释放空间。**\n\n## 三、web存储机制——Web Storage\n\nWeb Storage 的目的是克服由cookie 带来的一些限制，提供一种存储大量可以跨会话的在cookie 之外的存储会话数据的途径。\n\n**Storage对象（以windows 对象属性的形式存在）**\n+ sessionStorage对象\n存储特定于某个会话的数据，该数据只保持到浏览器关闭\n\n+ globalStorage对象\n这个对象可以跨越会话存储数据，但有特定的访问限制。要使用globalStorage，首先要指定哪些域可以访问该数据。可以通过方括号标记使用属性来实现。如果不使用removeItem() 或者delete 删除该对象， 或者用户未清除浏览器缓存， 存储在globalStorage 属性中的数据会一直保留在磁盘上。这让globalStorage 非常适合在客户端存储文档或者长期保存用户偏好设置。\n\n+ localStorage对象\n该对象在修订过的HTML 5 规范中作为持久保存客户端数据的方案取代了globalStorage。与globalStorage 不同，不能给localStorage 指定任何访问规则；规则事先就设定好了。要访问同一个localStorage 对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。这相当于globalStorage[location.host]。\n同globalStorage对象一样，localStorage对象数据保留到通过JavaScript 删除或者是用户清除浏览器缓存。\n\n**浏览器支持：**\nIE8+、Firefox 3.5+、Chrome 4+和Opera 10.5+\n\n**Storage对象方法：**\n+ clear()： 删除所有值；Firefox 中没有实现 。\n+ getItem(name)：根据指定的名字name 获取对应的值。\n+ key(index)：获得index 位置处的值的名字。\n+ removeItem(name)：删除由name 指定的名值对儿。\n+ setItem(name, value)：为指定的name 设置一个对应的值。\n\n> Storage 类型只能存储字符串。非字符串的数据在存储之前会被转换成字符串。\n\n**Storage对象事件**\n对Storage 对象进行任何修改，都会在文档上触发storage 事件。这个事件的event 对象有以下属性：\n+ domain：发生变化的存储空间的域名。\n+ key：设置或者删除的键名。\n+ newValue：如果是设置值，则是新值；如果是删除键，则是null。\n+ oldValue：键被更改之前的值。\n\n**数据操作**\n存储数据：\n```\n    //使用属性存储数据\n    sessionStorage/globalStorage[\"www.wrox.com\"]/localStorage.name = \"brand\";\n    //使用方法存储数据\n    sessionStorage/globalStorage[\"www.wrox.com\"]/localStorage.setItem(\"name\",\"brand\");\n```\n读取数据：\n```\n    //使用属性存储数据\n    var name = sessionStorage/globalStorage[\"www.wrox.com\"]/localStorage.name;\n    //使用方法存储数据\n    var name = sessionStorage/globalStorage[\"www.wrox.com\"]/localStorage.getItem((\"name\",\"brand\");\n```\n删除数据：\n```\n    sessionStorage/globalStorage[\"www.wrox.com\"]/localStorage.removeItem(\"name\")\n```\n**限制**\n每个来源都有固定大小的空间用于保存自己的数据，一般限制在2.5M—5M左右。\n\n\n参考书籍：[《javascript高级程序设计》](#)\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/浏览器客户端的数据存储.md","raw":"title: 浏览器客户端的数据存储\ntags: [javascript]\ndate: 2016-03-23 16:51:58\ndescription: 数据存储\n\n---\n\n属于某个特定用户的信息应该存在该用户的机器上,无论是登录信息、偏好设定或其他数据,这是一个很重要的用户体验，它避免了用户重复多次的简单操作。\n\n## 一、Cookie\n\ncookie 是原来的网景公司创造的。一份题为“Persistent Client State: HTTP Cookes”（持久客户端状态： HTTP Cookies ） 的标准中对cookie 机制进行了阐述。\n<!-- more -->\n\n> cookie标准要求服务器对任意HTTP 请求发送Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息\n\n**过程：**\n1.设置cookie，发送至服务器端；\n2.服务器对该请求发送带有`Set-Cookie` 的HTTP响应给浏览器；\n3.浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP 头将信息发送回服务器\n\n**cookie的限制**\n + 域限制：浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP 头将信息发送回服务器\n + 大小限制：大多数浏览器都有大约4096B（加减1）的长度限制。为了最佳的浏览器兼容性，最好将整个cookie 长度限制在4095B（含4095）以内\n + 个数限制：每个域的cookie 总数是有限的，不过浏览器之间各有不同：\n\n\n 浏览器      | 个数\n------------ | ---\nIE7+         | 50\nFirefox      | 50\nOpera        | 30\n Safari 和Chrome    | 没有硬性规定\n\n\n**cookie的构成**\n比如：\n```\nSet-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com;secure\n```\n+ `name = value` [必须参数]; 名值对，不区分大小写，必须是URL 编码\n+ `domain`  设定cookie的有效域，所有向该域发送的请求中都会包含这个cookie 信息\n+ `path`  指定cookie在有效域中的有效路径，即使请求都是来自同一个域的，不是该键制定的路径，也不会发送cookie\n+ `expires`  表示cookie 何时应该被删除的时间戳（这个值是个GMT 格式的日期），默认情况下，浏览器会话结束时即将所有cookie 删除\n+ `secure`  指定后，cookie 只有在使用SSL 连接的时候才发送到服务器\n\n\n**js处理cookie**\n`document.cookie` 返回当前页面可用的所有cookie的字符串，一系列由分号隔开的名值对儿。\ncookie的操作无非是获取、设置和删除，我们把这三种方法封装在一个`var CookieUtil = {}`对象中。分别对应其get，set，unset属性。\n\n> cookie的name和value都是经过URL 编码的，所以必须使用encodeURIComponent，decodeURIComponent()来编解码。\n\n1.**get**\n\n```js\n    get: function (name){\n        var cookieName = encodeURIComponent(name) + \"=\",\n        cookieStart = document.cookie.indexOf(cookieName),\n        cookieValue = null;\n        if (cookieStart > -1){\n            var cookieEnd = document.cookie.indexOf(\";\", cookieStart);\n            if (cookieEnd == -1){\n                cookieEnd = document.cookie.length;\n            }\n            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));\n        }\n        return cookieValue;\n    }\n\n```\n2.**set**\n```\n    set: function (name, value, expires, path, domain, secure) {\n        var cookieText = encodeURIComponent(name) + \"=\" +\n        encodeURIComponent(value);\n        if (expires instanceof Date) {\n            cookieText += \"; expires=\" + expires.toGMTString();\n        }\n        if (path) {\n            cookieText += \"; path=\" + path;\n        }\n        if (domain) {\n            cookieText += \"; domain=\" + domain;\n        }\n        if (secure) {\n            cookieText += \"; secure\";\n        }\n        document.cookie = cookieText;\n    }\n```\n3.**unset**\n```\n    unset: function (name, path, domain, secure){\n        this.set(name, \"\", new Date(0), path, domain, secure);\n    }\n```\n\n\n**子cookie**\n> 子cookie可以绕开浏览器的单域名下的cookie 数限制。子cookie 是存放在单个cookie 中的更小段的数据。也就是使用cookie 值来存储多个名称值对，如：name=name1=value1&name2=value2&name3=value3&name4=value4&name5=value5\n\n\n**所有的cookie 都会由浏览器作为请求头发送，所以在cookie 中存储大量信息会影响到特定域的请求性能。cookie 信息越大，完成对服务器请求的时间也就越长。尽管浏览器对cookie 进行了大小限制，不过最好还是尽可能在cookie 中少存储信息，以避免影响性能**\n\n## 二、IE用户数据\n\n在IE5.0 中，微软通过一个自定义行为引入了持久化用户数据的概念。用户数据允许每个文档最多\n128KB 数据，每个域名最多1MB 数据。\n\n**使用**：\n+ 使用CSS 在某个元素上指定userData 行为：\n```css\n<div style=\"behavior:url(#default#userData)\" id=\"dataStore\"></div>\n```\n+ 使用setAttribute()方法在上面保存数据\n```js\ndataStore.setAttribute(\"name\", \"Nicholas\");\n```\n+ 调用save()方法保存数据，参数为数据空间名字，数据空间名字可以完全任意，仅用于区分不同的数据集\n```js\ndataStore.save(\"BookInfo\");\n```\n+ 使用load()方法来获取数据，参数为数据空间名字\n```js\ndataStore.load(\"BookInfo\");\n```\n+ 使用removeAttribute()删除数据，并使用save()保存修改\n```js\ndataStore.removeAttribute(\"name\");\ndataStore.save(\"BookInfo\");\n```\n\n**限制**\n+ 同cookie，需要同域名，同路径，并使用与进行存储的脚本同样的协议；\n+ 无法将用户数据访问限制扩展到更多的客户\n\n**用户数据默认是可以跨越会话持久存在的，不会过期；数据需要通过removeAttribute()方法专门进行删除以释放空间。**\n\n## 三、web存储机制——Web Storage\n\nWeb Storage 的目的是克服由cookie 带来的一些限制，提供一种存储大量可以跨会话的在cookie 之外的存储会话数据的途径。\n\n**Storage对象（以windows 对象属性的形式存在）**\n+ sessionStorage对象\n存储特定于某个会话的数据，该数据只保持到浏览器关闭\n\n+ globalStorage对象\n这个对象可以跨越会话存储数据，但有特定的访问限制。要使用globalStorage，首先要指定哪些域可以访问该数据。可以通过方括号标记使用属性来实现。如果不使用removeItem() 或者delete 删除该对象， 或者用户未清除浏览器缓存， 存储在globalStorage 属性中的数据会一直保留在磁盘上。这让globalStorage 非常适合在客户端存储文档或者长期保存用户偏好设置。\n\n+ localStorage对象\n该对象在修订过的HTML 5 规范中作为持久保存客户端数据的方案取代了globalStorage。与globalStorage 不同，不能给localStorage 指定任何访问规则；规则事先就设定好了。要访问同一个localStorage 对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。这相当于globalStorage[location.host]。\n同globalStorage对象一样，localStorage对象数据保留到通过JavaScript 删除或者是用户清除浏览器缓存。\n\n**浏览器支持：**\nIE8+、Firefox 3.5+、Chrome 4+和Opera 10.5+\n\n**Storage对象方法：**\n+ clear()： 删除所有值；Firefox 中没有实现 。\n+ getItem(name)：根据指定的名字name 获取对应的值。\n+ key(index)：获得index 位置处的值的名字。\n+ removeItem(name)：删除由name 指定的名值对儿。\n+ setItem(name, value)：为指定的name 设置一个对应的值。\n\n> Storage 类型只能存储字符串。非字符串的数据在存储之前会被转换成字符串。\n\n**Storage对象事件**\n对Storage 对象进行任何修改，都会在文档上触发storage 事件。这个事件的event 对象有以下属性：\n+ domain：发生变化的存储空间的域名。\n+ key：设置或者删除的键名。\n+ newValue：如果是设置值，则是新值；如果是删除键，则是null。\n+ oldValue：键被更改之前的值。\n\n**数据操作**\n存储数据：\n```\n    //使用属性存储数据\n    sessionStorage/globalStorage[\"www.wrox.com\"]/localStorage.name = \"brand\";\n    //使用方法存储数据\n    sessionStorage/globalStorage[\"www.wrox.com\"]/localStorage.setItem(\"name\",\"brand\");\n```\n读取数据：\n```\n    //使用属性存储数据\n    var name = sessionStorage/globalStorage[\"www.wrox.com\"]/localStorage.name;\n    //使用方法存储数据\n    var name = sessionStorage/globalStorage[\"www.wrox.com\"]/localStorage.getItem((\"name\",\"brand\");\n```\n删除数据：\n```\n    sessionStorage/globalStorage[\"www.wrox.com\"]/localStorage.removeItem(\"name\")\n```\n**限制**\n每个来源都有固定大小的空间用于保存自己的数据，一般限制在2.5M—5M左右。\n\n\n参考书籍：[《javascript高级程序设计》](#)\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"浏览器客户端的数据存储","published":1,"updated":"2021-12-06T06:07:06.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomt0051y4v2ellx0hh2","content":"<p>属于某个特定用户的信息应该存在该用户的机器上,无论是登录信息、偏好设定或其他数据,这是一个很重要的用户体验，它避免了用户重复多次的简单操作。</p>\n<h2 id=\"一、Cookie\"><a href=\"#一、Cookie\" class=\"headerlink\" title=\"一、Cookie\"></a>一、Cookie</h2><p>cookie 是原来的网景公司创造的。一份题为“Persistent Client State: HTTP Cookes”（持久客户端状态： HTTP Cookies ） 的标准中对cookie 机制进行了阐述。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>cookie标准要求服务器对任意HTTP 请求发送Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息</p>\n</blockquote>\n<p><strong>过程：</strong><br>1.设置cookie，发送至服务器端；<br>2.服务器对该请求发送带有<code>Set-Cookie</code> 的HTTP响应给浏览器；<br>3.浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP 头将信息发送回服务器</p>\n<p><strong>cookie的限制</strong></p>\n<ul>\n<li>域限制：浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP 头将信息发送回服务器</li>\n<li>大小限制：大多数浏览器都有大约4096B（加减1）的长度限制。为了最佳的浏览器兼容性，最好将整个cookie 长度限制在4095B（含4095）以内</li>\n<li>个数限制：每个域的cookie 总数是有限的，不过浏览器之间各有不同：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>浏览器</th>\n<th>个数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IE7+</td>\n<td>50</td>\n</tr>\n<tr>\n<td>Firefox</td>\n<td>50</td>\n</tr>\n<tr>\n<td>Opera</td>\n<td>30</td>\n</tr>\n<tr>\n<td>Safari 和Chrome</td>\n<td>没有硬性规定</td>\n</tr>\n</tbody></table>\n<p><strong>cookie的构成</strong><br>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com;secure</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>name = value</code> [必须参数]; 名值对，不区分大小写，必须是URL 编码</li>\n<li><code>domain</code>  设定cookie的有效域，所有向该域发送的请求中都会包含这个cookie 信息</li>\n<li><code>path</code>  指定cookie在有效域中的有效路径，即使请求都是来自同一个域的，不是该键制定的路径，也不会发送cookie</li>\n<li><code>expires</code>  表示cookie 何时应该被删除的时间戳（这个值是个GMT 格式的日期），默认情况下，浏览器会话结束时即将所有cookie 删除</li>\n<li><code>secure</code>  指定后，cookie 只有在使用SSL 连接的时候才发送到服务器</li>\n</ul>\n<p><strong>js处理cookie</strong><br><code>document.cookie</code> 返回当前页面可用的所有cookie的字符串，一系列由分号隔开的名值对儿。<br>cookie的操作无非是获取、设置和删除，我们把这三种方法封装在一个<code>var CookieUtil = &#123;&#125;</code>对象中。分别对应其get，set，unset属性。</p>\n<blockquote>\n<p>cookie的name和value都是经过URL 编码的，所以必须使用encodeURIComponent，decodeURIComponent()来编解码。</p>\n</blockquote>\n<p>1.<strong>get</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cookieName = <span class=\"built_in\">encodeURIComponent</span>(name) + <span class=\"string\">&quot;=&quot;</span>,</span><br><span class=\"line\">    cookieStart = <span class=\"built_in\">document</span>.cookie.indexOf(cookieName),</span><br><span class=\"line\">    cookieValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cookieStart &gt; -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> cookieEnd = <span class=\"built_in\">document</span>.cookie.indexOf(<span class=\"string\">&quot;;&quot;</span>, cookieStart);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cookieEnd == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cookieEnd = <span class=\"built_in\">document</span>.cookie.length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cookieValue = <span class=\"built_in\">decodeURIComponent</span>(<span class=\"built_in\">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cookieValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2.<strong>set</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set: function (name, value, expires, path, domain, secure) &#123;</span><br><span class=\"line\">    var cookieText = encodeURIComponent(name) + &quot;=&quot; +</span><br><span class=\"line\">    encodeURIComponent(value);</span><br><span class=\"line\">    if (expires instanceof Date) &#123;</span><br><span class=\"line\">        cookieText += &quot;; expires=&quot; + expires.toGMTString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (path) &#123;</span><br><span class=\"line\">        cookieText += &quot;; path=&quot; + path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (domain) &#123;</span><br><span class=\"line\">        cookieText += &quot;; domain=&quot; + domain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (secure) &#123;</span><br><span class=\"line\">        cookieText += &quot;; secure&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    document.cookie = cookieText;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.<strong>unset</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unset: function (name, path, domain, secure)&#123;</span><br><span class=\"line\">    this.set(name, &quot;&quot;, new Date(0), path, domain, secure);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>子cookie</strong></p>\n<blockquote>\n<p>子cookie可以绕开浏览器的单域名下的cookie 数限制。子cookie 是存放在单个cookie 中的更小段的数据。也就是使用cookie 值来存储多个名称值对，如：name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5</p>\n</blockquote>\n<p><strong>所有的cookie 都会由浏览器作为请求头发送，所以在cookie 中存储大量信息会影响到特定域的请求性能。cookie 信息越大，完成对服务器请求的时间也就越长。尽管浏览器对cookie 进行了大小限制，不过最好还是尽可能在cookie 中少存储信息，以避免影响性能</strong></p>\n<h2 id=\"二、IE用户数据\"><a href=\"#二、IE用户数据\" class=\"headerlink\" title=\"二、IE用户数据\"></a>二、IE用户数据</h2><p>在IE5.0 中，微软通过一个自定义行为引入了持久化用户数据的概念。用户数据允许每个文档最多<br>128KB 数据，每个域名最多1MB 数据。</p>\n<p><strong>使用</strong>：</p>\n<ul>\n<li>使用CSS 在某个元素上指定userData 行为：<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> style=&quot;behavior:<span class=\"built_in\">url</span>(<span class=\"string\">#default#userData</span>)<span class=\"string\">&quot; id=&quot;</span>dataStore<span class=\"string\">&quot;&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>使用setAttribute()方法在上面保存数据<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataStore.setAttribute(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Nicholas&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n<li>调用save()方法保存数据，参数为数据空间名字，数据空间名字可以完全任意，仅用于区分不同的数据集<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataStore.save(<span class=\"string\">&quot;BookInfo&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n<li>使用load()方法来获取数据，参数为数据空间名字<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataStore.load(<span class=\"string\">&quot;BookInfo&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n<li>使用removeAttribute()删除数据，并使用save()保存修改<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataStore.removeAttribute(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">dataStore.save(<span class=\"string\">&quot;BookInfo&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>限制</strong></p>\n<ul>\n<li>同cookie，需要同域名，同路径，并使用与进行存储的脚本同样的协议；</li>\n<li>无法将用户数据访问限制扩展到更多的客户</li>\n</ul>\n<p><strong>用户数据默认是可以跨越会话持久存在的，不会过期；数据需要通过removeAttribute()方法专门进行删除以释放空间。</strong></p>\n<h2 id=\"三、web存储机制——Web-Storage\"><a href=\"#三、web存储机制——Web-Storage\" class=\"headerlink\" title=\"三、web存储机制——Web Storage\"></a>三、web存储机制——Web Storage</h2><p>Web Storage 的目的是克服由cookie 带来的一些限制，提供一种存储大量可以跨会话的在cookie 之外的存储会话数据的途径。</p>\n<p><strong>Storage对象（以windows 对象属性的形式存在）</strong></p>\n<ul>\n<li><p>sessionStorage对象<br>存储特定于某个会话的数据，该数据只保持到浏览器关闭</p>\n</li>\n<li><p>globalStorage对象<br>这个对象可以跨越会话存储数据，但有特定的访问限制。要使用globalStorage，首先要指定哪些域可以访问该数据。可以通过方括号标记使用属性来实现。如果不使用removeItem() 或者delete 删除该对象， 或者用户未清除浏览器缓存， 存储在globalStorage 属性中的数据会一直保留在磁盘上。这让globalStorage 非常适合在客户端存储文档或者长期保存用户偏好设置。</p>\n</li>\n<li><p>localStorage对象<br>该对象在修订过的HTML 5 规范中作为持久保存客户端数据的方案取代了globalStorage。与globalStorage 不同，不能给localStorage 指定任何访问规则；规则事先就设定好了。要访问同一个localStorage 对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。这相当于globalStorage[location.host]。<br>同globalStorage对象一样，localStorage对象数据保留到通过JavaScript 删除或者是用户清除浏览器缓存。</p>\n</li>\n</ul>\n<p><strong>浏览器支持：</strong><br>IE8+、Firefox 3.5+、Chrome 4+和Opera 10.5+</p>\n<p><strong>Storage对象方法：</strong></p>\n<ul>\n<li>clear()： 删除所有值；Firefox 中没有实现 。</li>\n<li>getItem(name)：根据指定的名字name 获取对应的值。</li>\n<li>key(index)：获得index 位置处的值的名字。</li>\n<li>removeItem(name)：删除由name 指定的名值对儿。</li>\n<li>setItem(name, value)：为指定的name 设置一个对应的值。</li>\n</ul>\n<blockquote>\n<p>Storage 类型只能存储字符串。非字符串的数据在存储之前会被转换成字符串。</p>\n</blockquote>\n<p><strong>Storage对象事件</strong><br>对Storage 对象进行任何修改，都会在文档上触发storage 事件。这个事件的event 对象有以下属性：</p>\n<ul>\n<li>domain：发生变化的存储空间的域名。</li>\n<li>key：设置或者删除的键名。</li>\n<li>newValue：如果是设置值，则是新值；如果是删除键，则是null。</li>\n<li>oldValue：键被更改之前的值。</li>\n</ul>\n<p><strong>数据操作</strong><br>存储数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用属性存储数据</span><br><span class=\"line\">sessionStorage/globalStorage[&quot;www.wrox.com&quot;]/localStorage.name = &quot;brand&quot;;</span><br><span class=\"line\">//使用方法存储数据</span><br><span class=\"line\">sessionStorage/globalStorage[&quot;www.wrox.com&quot;]/localStorage.setItem(&quot;name&quot;,&quot;brand&quot;);</span><br></pre></td></tr></table></figure>\n<p>读取数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用属性存储数据</span><br><span class=\"line\">var name = sessionStorage/globalStorage[&quot;www.wrox.com&quot;]/localStorage.name;</span><br><span class=\"line\">//使用方法存储数据</span><br><span class=\"line\">var name = sessionStorage/globalStorage[&quot;www.wrox.com&quot;]/localStorage.getItem((&quot;name&quot;,&quot;brand&quot;);</span><br></pre></td></tr></table></figure>\n<p>删除数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage/globalStorage[&quot;www.wrox.com&quot;]/localStorage.removeItem(&quot;name&quot;)</span><br></pre></td></tr></table></figure>\n<p><strong>限制</strong><br>每个来源都有固定大小的空间用于保存自己的数据，一般限制在2.5M—5M左右。</p>\n<p>参考书籍：<a href=\"#\">《javascript高级程序设计》</a></p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>属于某个特定用户的信息应该存在该用户的机器上,无论是登录信息、偏好设定或其他数据,这是一个很重要的用户体验，它避免了用户重复多次的简单操作。</p>\n<h2 id=\"一、Cookie\"><a href=\"#一、Cookie\" class=\"headerlink\" title=\"一、Cookie\"></a>一、Cookie</h2><p>cookie 是原来的网景公司创造的。一份题为“Persistent Client State: HTTP Cookes”（持久客户端状态： HTTP Cookies ） 的标准中对cookie 机制进行了阐述。</p>","more":"<blockquote>\n<p>cookie标准要求服务器对任意HTTP 请求发送Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息</p>\n</blockquote>\n<p><strong>过程：</strong><br>1.设置cookie，发送至服务器端；<br>2.服务器对该请求发送带有<code>Set-Cookie</code> 的HTTP响应给浏览器；<br>3.浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP 头将信息发送回服务器</p>\n<p><strong>cookie的限制</strong></p>\n<ul>\n<li>域限制：浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP 头将信息发送回服务器</li>\n<li>大小限制：大多数浏览器都有大约4096B（加减1）的长度限制。为了最佳的浏览器兼容性，最好将整个cookie 长度限制在4095B（含4095）以内</li>\n<li>个数限制：每个域的cookie 总数是有限的，不过浏览器之间各有不同：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>浏览器</th>\n<th>个数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IE7+</td>\n<td>50</td>\n</tr>\n<tr>\n<td>Firefox</td>\n<td>50</td>\n</tr>\n<tr>\n<td>Opera</td>\n<td>30</td>\n</tr>\n<tr>\n<td>Safari 和Chrome</td>\n<td>没有硬性规定</td>\n</tr>\n</tbody></table>\n<p><strong>cookie的构成</strong><br>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com;secure</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>name = value</code> [必须参数]; 名值对，不区分大小写，必须是URL 编码</li>\n<li><code>domain</code>  设定cookie的有效域，所有向该域发送的请求中都会包含这个cookie 信息</li>\n<li><code>path</code>  指定cookie在有效域中的有效路径，即使请求都是来自同一个域的，不是该键制定的路径，也不会发送cookie</li>\n<li><code>expires</code>  表示cookie 何时应该被删除的时间戳（这个值是个GMT 格式的日期），默认情况下，浏览器会话结束时即将所有cookie 删除</li>\n<li><code>secure</code>  指定后，cookie 只有在使用SSL 连接的时候才发送到服务器</li>\n</ul>\n<p><strong>js处理cookie</strong><br><code>document.cookie</code> 返回当前页面可用的所有cookie的字符串，一系列由分号隔开的名值对儿。<br>cookie的操作无非是获取、设置和删除，我们把这三种方法封装在一个<code>var CookieUtil = &#123;&#125;</code>对象中。分别对应其get，set，unset属性。</p>\n<blockquote>\n<p>cookie的name和value都是经过URL 编码的，所以必须使用encodeURIComponent，decodeURIComponent()来编解码。</p>\n</blockquote>\n<p>1.<strong>get</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cookieName = <span class=\"built_in\">encodeURIComponent</span>(name) + <span class=\"string\">&quot;=&quot;</span>,</span><br><span class=\"line\">    cookieStart = <span class=\"built_in\">document</span>.cookie.indexOf(cookieName),</span><br><span class=\"line\">    cookieValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cookieStart &gt; -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> cookieEnd = <span class=\"built_in\">document</span>.cookie.indexOf(<span class=\"string\">&quot;;&quot;</span>, cookieStart);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cookieEnd == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cookieEnd = <span class=\"built_in\">document</span>.cookie.length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cookieValue = <span class=\"built_in\">decodeURIComponent</span>(<span class=\"built_in\">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cookieValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2.<strong>set</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set: function (name, value, expires, path, domain, secure) &#123;</span><br><span class=\"line\">    var cookieText = encodeURIComponent(name) + &quot;=&quot; +</span><br><span class=\"line\">    encodeURIComponent(value);</span><br><span class=\"line\">    if (expires instanceof Date) &#123;</span><br><span class=\"line\">        cookieText += &quot;; expires=&quot; + expires.toGMTString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (path) &#123;</span><br><span class=\"line\">        cookieText += &quot;; path=&quot; + path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (domain) &#123;</span><br><span class=\"line\">        cookieText += &quot;; domain=&quot; + domain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (secure) &#123;</span><br><span class=\"line\">        cookieText += &quot;; secure&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    document.cookie = cookieText;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.<strong>unset</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unset: function (name, path, domain, secure)&#123;</span><br><span class=\"line\">    this.set(name, &quot;&quot;, new Date(0), path, domain, secure);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>子cookie</strong></p>\n<blockquote>\n<p>子cookie可以绕开浏览器的单域名下的cookie 数限制。子cookie 是存放在单个cookie 中的更小段的数据。也就是使用cookie 值来存储多个名称值对，如：name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5</p>\n</blockquote>\n<p><strong>所有的cookie 都会由浏览器作为请求头发送，所以在cookie 中存储大量信息会影响到特定域的请求性能。cookie 信息越大，完成对服务器请求的时间也就越长。尽管浏览器对cookie 进行了大小限制，不过最好还是尽可能在cookie 中少存储信息，以避免影响性能</strong></p>\n<h2 id=\"二、IE用户数据\"><a href=\"#二、IE用户数据\" class=\"headerlink\" title=\"二、IE用户数据\"></a>二、IE用户数据</h2><p>在IE5.0 中，微软通过一个自定义行为引入了持久化用户数据的概念。用户数据允许每个文档最多<br>128KB 数据，每个域名最多1MB 数据。</p>\n<p><strong>使用</strong>：</p>\n<ul>\n<li>使用CSS 在某个元素上指定userData 行为：<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> style=&quot;behavior:<span class=\"built_in\">url</span>(<span class=\"string\">#default#userData</span>)<span class=\"string\">&quot; id=&quot;</span>dataStore<span class=\"string\">&quot;&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>使用setAttribute()方法在上面保存数据<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataStore.setAttribute(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Nicholas&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n<li>调用save()方法保存数据，参数为数据空间名字，数据空间名字可以完全任意，仅用于区分不同的数据集<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataStore.save(<span class=\"string\">&quot;BookInfo&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n<li>使用load()方法来获取数据，参数为数据空间名字<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataStore.load(<span class=\"string\">&quot;BookInfo&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n<li>使用removeAttribute()删除数据，并使用save()保存修改<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataStore.removeAttribute(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">dataStore.save(<span class=\"string\">&quot;BookInfo&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>限制</strong></p>\n<ul>\n<li>同cookie，需要同域名，同路径，并使用与进行存储的脚本同样的协议；</li>\n<li>无法将用户数据访问限制扩展到更多的客户</li>\n</ul>\n<p><strong>用户数据默认是可以跨越会话持久存在的，不会过期；数据需要通过removeAttribute()方法专门进行删除以释放空间。</strong></p>\n<h2 id=\"三、web存储机制——Web-Storage\"><a href=\"#三、web存储机制——Web-Storage\" class=\"headerlink\" title=\"三、web存储机制——Web Storage\"></a>三、web存储机制——Web Storage</h2><p>Web Storage 的目的是克服由cookie 带来的一些限制，提供一种存储大量可以跨会话的在cookie 之外的存储会话数据的途径。</p>\n<p><strong>Storage对象（以windows 对象属性的形式存在）</strong></p>\n<ul>\n<li><p>sessionStorage对象<br>存储特定于某个会话的数据，该数据只保持到浏览器关闭</p>\n</li>\n<li><p>globalStorage对象<br>这个对象可以跨越会话存储数据，但有特定的访问限制。要使用globalStorage，首先要指定哪些域可以访问该数据。可以通过方括号标记使用属性来实现。如果不使用removeItem() 或者delete 删除该对象， 或者用户未清除浏览器缓存， 存储在globalStorage 属性中的数据会一直保留在磁盘上。这让globalStorage 非常适合在客户端存储文档或者长期保存用户偏好设置。</p>\n</li>\n<li><p>localStorage对象<br>该对象在修订过的HTML 5 规范中作为持久保存客户端数据的方案取代了globalStorage。与globalStorage 不同，不能给localStorage 指定任何访问规则；规则事先就设定好了。要访问同一个localStorage 对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。这相当于globalStorage[location.host]。<br>同globalStorage对象一样，localStorage对象数据保留到通过JavaScript 删除或者是用户清除浏览器缓存。</p>\n</li>\n</ul>\n<p><strong>浏览器支持：</strong><br>IE8+、Firefox 3.5+、Chrome 4+和Opera 10.5+</p>\n<p><strong>Storage对象方法：</strong></p>\n<ul>\n<li>clear()： 删除所有值；Firefox 中没有实现 。</li>\n<li>getItem(name)：根据指定的名字name 获取对应的值。</li>\n<li>key(index)：获得index 位置处的值的名字。</li>\n<li>removeItem(name)：删除由name 指定的名值对儿。</li>\n<li>setItem(name, value)：为指定的name 设置一个对应的值。</li>\n</ul>\n<blockquote>\n<p>Storage 类型只能存储字符串。非字符串的数据在存储之前会被转换成字符串。</p>\n</blockquote>\n<p><strong>Storage对象事件</strong><br>对Storage 对象进行任何修改，都会在文档上触发storage 事件。这个事件的event 对象有以下属性：</p>\n<ul>\n<li>domain：发生变化的存储空间的域名。</li>\n<li>key：设置或者删除的键名。</li>\n<li>newValue：如果是设置值，则是新值；如果是删除键，则是null。</li>\n<li>oldValue：键被更改之前的值。</li>\n</ul>\n<p><strong>数据操作</strong><br>存储数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用属性存储数据</span><br><span class=\"line\">sessionStorage/globalStorage[&quot;www.wrox.com&quot;]/localStorage.name = &quot;brand&quot;;</span><br><span class=\"line\">//使用方法存储数据</span><br><span class=\"line\">sessionStorage/globalStorage[&quot;www.wrox.com&quot;]/localStorage.setItem(&quot;name&quot;,&quot;brand&quot;);</span><br></pre></td></tr></table></figure>\n<p>读取数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用属性存储数据</span><br><span class=\"line\">var name = sessionStorage/globalStorage[&quot;www.wrox.com&quot;]/localStorage.name;</span><br><span class=\"line\">//使用方法存储数据</span><br><span class=\"line\">var name = sessionStorage/globalStorage[&quot;www.wrox.com&quot;]/localStorage.getItem((&quot;name&quot;,&quot;brand&quot;);</span><br></pre></td></tr></table></figure>\n<p>删除数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage/globalStorage[&quot;www.wrox.com&quot;]/localStorage.removeItem(&quot;name&quot;)</span><br></pre></td></tr></table></figure>\n<p><strong>限制</strong><br>每个来源都有固定大小的空间用于保存自己的数据，一般限制在2.5M—5M左右。</p>\n<p>参考书籍：<a href=\"#\">《javascript高级程序设计》</a></p>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"title":"移动端调试工具-Debuggap","date":"2016-03-16T06:06:17.000Z","description":"移动端调试工具,Debuggap","_content":"\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n随着移动互联网的迅速崛起，开发移动应用程序越来越多，但如果在移动端开发应用程序需要调试时，额… 仿佛又回到了IE时代，最方便也只能到处 alert 来调试。目前已经有一款产品可以做到这一点，比如phonegap，但是phonegap的调试问题非常麻烦，不能真正做到有效提高效率。下面将介绍debug工具。这是一款神器，它简单易用的同时又不影响它的强大，它能够：\n\n<!-- more -->\n\n+ 不需要安装即可运行在Windows、Linux和Mac平台上\n+ 支持各种平台(Android,IOS,WebOS,BlackBerry,Firefox OS,Windows Phone等等)\n+ 支持所有HTML5框架(比如phonegap)和浏览器\n+ 支持快速查看元素节点树\n+ 可以同一时间调试多个设备\n+ 支持Android设备单步调试,观察变量等等\n\n\n话不多说，动起来的吧。\n\n### 1.下载解压\n首先到[官网](http://www.debuggap.com/)根据自己的色板平台下载相应Debuggap,下载完毕后解压即可，无需安装。解压后，目录结构是这样的，其中DebugGap.exe是运行程序，双击即可运行；而client文件夹下存放的是DebugGap.js。\n```bash\n2016/01/25  15:50    <DIR>          .\n2016/01/25  15:50    <DIR>          ..\n2015/05/26  22:04    <DIR>          client\n2015/04/01  22:05        39,340,032 DebugGap.exe\n2015/03/29  15:39           860,672 ffmpegsumo.dll\n2015/03/29  15:39         9,956,864 icudt.dll\n2015/03/29  15:39           102,400 libEGL.dll\n2015/03/29  15:39           873,984 libGLESv2.dll\n2015/03/29  15:39         4,001,552 nw.pak\n2015/03/29  15:39         4,207,616 nwsnapshot.exe\n2015/05/26  22:02               231 package.json\n2015/03/29  15:39               463 readme.txt\n2016/01/26  13:48    <DIR>          source\n               9 个文件     59,343,814 字节\n               4 个目录 288,704,741,376 可用字节\n```\n### 2.使用\n使用分为三部分：\n+ 在项目中引入client文件夹下的DebugGap.js文件\n+ 配置客户端\n+ 启动debuggap程序\n\n全过程示范：\n第一步：新建一个测试页面。为了使我们手机能访问到，我们将测试页面放入xamp搭建的本地服务器中，并在页面中通过`<script src=\"debuggap.js\" type=\"text/javascript\"></script>`引入debuggap.js。（为了引用方便我已将debuggap.js拷到与测试页面同一个文件夹下）\n第二步：使用手机访问页面，会发现页面上多了个蓝色按钮，点击后进入 config，配置地址为电脑ip地址和自定义的端口（出于偷懒，下面所有的图都是从[think2011](https://cnodejs.org/topic/54ff176fc1749396754897e5)拷的）\n![](http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132105209-1710430782.gif)\n\n\n第三步：在电脑上运行 DebugGap.app，接着输入本机IP地址 和 自定义的端口。\n![](http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132130818-29108219.png)\n\n\n点击链接，即可看到以下界面\n![](http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132144834-1036741627.png)\n\n\n\n点击其中一个进入即可调试\n![](http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132210037-1723401607.png)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n\n","source":"_posts/移动端调试工具-Debuggap.md","raw":"title: 移动端调试工具-Debuggap\ntags: [工具]\ndate: 2016-03-16 14:06:17\ndescription: 移动端调试工具,Debuggap\n\n---\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n随着移动互联网的迅速崛起，开发移动应用程序越来越多，但如果在移动端开发应用程序需要调试时，额… 仿佛又回到了IE时代，最方便也只能到处 alert 来调试。目前已经有一款产品可以做到这一点，比如phonegap，但是phonegap的调试问题非常麻烦，不能真正做到有效提高效率。下面将介绍debug工具。这是一款神器，它简单易用的同时又不影响它的强大，它能够：\n\n<!-- more -->\n\n+ 不需要安装即可运行在Windows、Linux和Mac平台上\n+ 支持各种平台(Android,IOS,WebOS,BlackBerry,Firefox OS,Windows Phone等等)\n+ 支持所有HTML5框架(比如phonegap)和浏览器\n+ 支持快速查看元素节点树\n+ 可以同一时间调试多个设备\n+ 支持Android设备单步调试,观察变量等等\n\n\n话不多说，动起来的吧。\n\n### 1.下载解压\n首先到[官网](http://www.debuggap.com/)根据自己的色板平台下载相应Debuggap,下载完毕后解压即可，无需安装。解压后，目录结构是这样的，其中DebugGap.exe是运行程序，双击即可运行；而client文件夹下存放的是DebugGap.js。\n```bash\n2016/01/25  15:50    <DIR>          .\n2016/01/25  15:50    <DIR>          ..\n2015/05/26  22:04    <DIR>          client\n2015/04/01  22:05        39,340,032 DebugGap.exe\n2015/03/29  15:39           860,672 ffmpegsumo.dll\n2015/03/29  15:39         9,956,864 icudt.dll\n2015/03/29  15:39           102,400 libEGL.dll\n2015/03/29  15:39           873,984 libGLESv2.dll\n2015/03/29  15:39         4,001,552 nw.pak\n2015/03/29  15:39         4,207,616 nwsnapshot.exe\n2015/05/26  22:02               231 package.json\n2015/03/29  15:39               463 readme.txt\n2016/01/26  13:48    <DIR>          source\n               9 个文件     59,343,814 字节\n               4 个目录 288,704,741,376 可用字节\n```\n### 2.使用\n使用分为三部分：\n+ 在项目中引入client文件夹下的DebugGap.js文件\n+ 配置客户端\n+ 启动debuggap程序\n\n全过程示范：\n第一步：新建一个测试页面。为了使我们手机能访问到，我们将测试页面放入xamp搭建的本地服务器中，并在页面中通过`<script src=\"debuggap.js\" type=\"text/javascript\"></script>`引入debuggap.js。（为了引用方便我已将debuggap.js拷到与测试页面同一个文件夹下）\n第二步：使用手机访问页面，会发现页面上多了个蓝色按钮，点击后进入 config，配置地址为电脑ip地址和自定义的端口（出于偷懒，下面所有的图都是从[think2011](https://cnodejs.org/topic/54ff176fc1749396754897e5)拷的）\n![](http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132105209-1710430782.gif)\n\n\n第三步：在电脑上运行 DebugGap.app，接着输入本机IP地址 和 自定义的端口。\n![](http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132130818-29108219.png)\n\n\n点击链接，即可看到以下界面\n![](http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132144834-1036741627.png)\n\n\n\n点击其中一个进入即可调试\n![](http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132210037-1723401607.png)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n\n","slug":"移动端调试工具-Debuggap","published":1,"updated":"2021-12-06T06:07:06.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomu0052y4v26w4t144p","content":"<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>随着移动互联网的迅速崛起，开发移动应用程序越来越多，但如果在移动端开发应用程序需要调试时，额… 仿佛又回到了IE时代，最方便也只能到处 alert 来调试。目前已经有一款产品可以做到这一点，比如phonegap，但是phonegap的调试问题非常麻烦，不能真正做到有效提高效率。下面将介绍debug工具。这是一款神器，它简单易用的同时又不影响它的强大，它能够：</p>\n<span id=\"more\"></span>\n\n<ul>\n<li>不需要安装即可运行在Windows、Linux和Mac平台上</li>\n<li>支持各种平台(Android,IOS,WebOS,BlackBerry,Firefox OS,Windows Phone等等)</li>\n<li>支持所有HTML5框架(比如phonegap)和浏览器</li>\n<li>支持快速查看元素节点树</li>\n<li>可以同一时间调试多个设备</li>\n<li>支持Android设备单步调试,观察变量等等</li>\n</ul>\n<p>话不多说，动起来的吧。</p>\n<h3 id=\"1-下载解压\"><a href=\"#1-下载解压\" class=\"headerlink\" title=\"1.下载解压\"></a>1.下载解压</h3><p>首先到<a href=\"http://www.debuggap.com/\">官网</a>根据自己的色板平台下载相应Debuggap,下载完毕后解压即可，无需安装。解压后，目录结构是这样的，其中DebugGap.exe是运行程序，双击即可运行；而client文件夹下存放的是DebugGap.js。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016/01/25  15:50    &lt;DIR&gt;          .</span><br><span class=\"line\">2016/01/25  15:50    &lt;DIR&gt;          ..</span><br><span class=\"line\">2015/05/26  22:04    &lt;DIR&gt;          client</span><br><span class=\"line\">2015/04/01  22:05        39,340,032 DebugGap.exe</span><br><span class=\"line\">2015/03/29  15:39           860,672 ffmpegsumo.dll</span><br><span class=\"line\">2015/03/29  15:39         9,956,864 icudt.dll</span><br><span class=\"line\">2015/03/29  15:39           102,400 libEGL.dll</span><br><span class=\"line\">2015/03/29  15:39           873,984 libGLESv2.dll</span><br><span class=\"line\">2015/03/29  15:39         4,001,552 nw.pak</span><br><span class=\"line\">2015/03/29  15:39         4,207,616 nwsnapshot.exe</span><br><span class=\"line\">2015/05/26  22:02               231 package.json</span><br><span class=\"line\">2015/03/29  15:39               463 readme.txt</span><br><span class=\"line\">2016/01/26  13:48    &lt;DIR&gt;          <span class=\"built_in\">source</span></span><br><span class=\"line\">               9 个文件     59,343,814 字节</span><br><span class=\"line\">               4 个目录 288,704,741,376 可用字节</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h3><p>使用分为三部分：</p>\n<ul>\n<li>在项目中引入client文件夹下的DebugGap.js文件</li>\n<li>配置客户端</li>\n<li>启动debuggap程序</li>\n</ul>\n<p>全过程示范：<br>第一步：新建一个测试页面。为了使我们手机能访问到，我们将测试页面放入xamp搭建的本地服务器中，并在页面中通过<code>&lt;script src=&quot;debuggap.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code>引入debuggap.js。（为了引用方便我已将debuggap.js拷到与测试页面同一个文件夹下）<br>第二步：使用手机访问页面，会发现页面上多了个蓝色按钮，点击后进入 config，配置地址为电脑ip地址和自定义的端口（出于偷懒，下面所有的图都是从<a href=\"https://cnodejs.org/topic/54ff176fc1749396754897e5\">think2011</a>拷的）<br><img src=\"http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132105209-1710430782.gif\"></p>\n<p>第三步：在电脑上运行 DebugGap.app，接着输入本机IP地址 和 自定义的端口。<br><img src=\"http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132130818-29108219.png\"></p>\n<p>点击链接，即可看到以下界面<br><img src=\"http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132144834-1036741627.png\"></p>\n<p>点击其中一个进入即可调试<br><img src=\"http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132210037-1723401607.png\"></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>随着移动互联网的迅速崛起，开发移动应用程序越来越多，但如果在移动端开发应用程序需要调试时，额… 仿佛又回到了IE时代，最方便也只能到处 alert 来调试。目前已经有一款产品可以做到这一点，比如phonegap，但是phonegap的调试问题非常麻烦，不能真正做到有效提高效率。下面将介绍debug工具。这是一款神器，它简单易用的同时又不影响它的强大，它能够：</p>","more":"<ul>\n<li>不需要安装即可运行在Windows、Linux和Mac平台上</li>\n<li>支持各种平台(Android,IOS,WebOS,BlackBerry,Firefox OS,Windows Phone等等)</li>\n<li>支持所有HTML5框架(比如phonegap)和浏览器</li>\n<li>支持快速查看元素节点树</li>\n<li>可以同一时间调试多个设备</li>\n<li>支持Android设备单步调试,观察变量等等</li>\n</ul>\n<p>话不多说，动起来的吧。</p>\n<h3 id=\"1-下载解压\"><a href=\"#1-下载解压\" class=\"headerlink\" title=\"1.下载解压\"></a>1.下载解压</h3><p>首先到<a href=\"http://www.debuggap.com/\">官网</a>根据自己的色板平台下载相应Debuggap,下载完毕后解压即可，无需安装。解压后，目录结构是这样的，其中DebugGap.exe是运行程序，双击即可运行；而client文件夹下存放的是DebugGap.js。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016/01/25  15:50    &lt;DIR&gt;          .</span><br><span class=\"line\">2016/01/25  15:50    &lt;DIR&gt;          ..</span><br><span class=\"line\">2015/05/26  22:04    &lt;DIR&gt;          client</span><br><span class=\"line\">2015/04/01  22:05        39,340,032 DebugGap.exe</span><br><span class=\"line\">2015/03/29  15:39           860,672 ffmpegsumo.dll</span><br><span class=\"line\">2015/03/29  15:39         9,956,864 icudt.dll</span><br><span class=\"line\">2015/03/29  15:39           102,400 libEGL.dll</span><br><span class=\"line\">2015/03/29  15:39           873,984 libGLESv2.dll</span><br><span class=\"line\">2015/03/29  15:39         4,001,552 nw.pak</span><br><span class=\"line\">2015/03/29  15:39         4,207,616 nwsnapshot.exe</span><br><span class=\"line\">2015/05/26  22:02               231 package.json</span><br><span class=\"line\">2015/03/29  15:39               463 readme.txt</span><br><span class=\"line\">2016/01/26  13:48    &lt;DIR&gt;          <span class=\"built_in\">source</span></span><br><span class=\"line\">               9 个文件     59,343,814 字节</span><br><span class=\"line\">               4 个目录 288,704,741,376 可用字节</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h3><p>使用分为三部分：</p>\n<ul>\n<li>在项目中引入client文件夹下的DebugGap.js文件</li>\n<li>配置客户端</li>\n<li>启动debuggap程序</li>\n</ul>\n<p>全过程示范：<br>第一步：新建一个测试页面。为了使我们手机能访问到，我们将测试页面放入xamp搭建的本地服务器中，并在页面中通过<code>&lt;script src=&quot;debuggap.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code>引入debuggap.js。（为了引用方便我已将debuggap.js拷到与测试页面同一个文件夹下）<br>第二步：使用手机访问页面，会发现页面上多了个蓝色按钮，点击后进入 config，配置地址为电脑ip地址和自定义的端口（出于偷懒，下面所有的图都是从<a href=\"https://cnodejs.org/topic/54ff176fc1749396754897e5\">think2011</a>拷的）<br><img src=\"http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132105209-1710430782.gif\"></p>\n<p>第三步：在电脑上运行 DebugGap.app，接着输入本机IP地址 和 自定义的端口。<br><img src=\"http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132130818-29108219.png\"></p>\n<p>点击链接，即可看到以下界面<br><img src=\"http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132144834-1036741627.png\"></p>\n<p>点击其中一个进入即可调试<br><img src=\"http://images2015.cnblogs.com/blog/733894/201603/733894-20160316132210037-1723401607.png\"></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"_content":"# 第一次react-native项目实践要点总结\n\n今天完成了我的第一个react-native项目的封包，当然其间各种环境各种坑，同时，成就感也是满满的。这里总结一下使用react-native的一些入门级重要点（不涉及环境）。**注意：阅读需要语法基础： ES6 、react 、JSX**\n\n我对react-native的理解简而言之就是 ：**react的语法** ＋ **native的组件**\n\n## 组件的创建声明\n```\nclass HelloWorldApp extends Component {\n  constructor(props) {\n  \tsuper(props);\n    this.state = {\n  \n    };\n  }\n  render() {\n    return (\n      <Text>Hello world!</Text>\n    );\n  }\n}\n```\n上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。当你在其他的组件中调用这个组件时，就会实例化这个“类”（即组件）。\n\n**注意：组件名需要大写**\n\n## 组件的导出、引用与注册\n在ES6中，新增了import和export俩个关键字来导入导出模块。react－native的组件也是采用的这俩个关键字。\n\n俩种方式：\n\n第一种：\n\n```\n导出：\nexport default class HelloWorldApp extends Component{\n\trender() {\n    return (\n      <Text>Hello world!</Text>\n    );\n  }\n｝\n\n导入：\nimport HelloWorldApp from \"../..\"\n```\n\n第二种：\n\n```\n导出：\nclass HelloWorldApp extends Component {\n  render() {\n    return (\n      <Text>Hello world!</Text>\n    );\n  }\n}\n\nexport {HelloWorldApp}\n\n导入：\nimport ｛ HelloWorldApp ｝ from \"../..\"\n\n```\n\n1. 后缀名自动获取（文件会获取拥有与之相应后缀名的文件）\n\n\t在组件模块的导入过程中，如果这个模块是分设备的，也就有俩个文件：xxx.android.js和xxx.ios.js，这些后缀（android和ios）是不需要的，在不同的设备环境中，它自动获取相应后缀名的文件，即ios包会自动获取xxx.ios，android包会自动获取xxx.android。\n\n2. 后缀名自动忽略（文件会自动忽略拥有与之不相应后缀名的文件）\n\n\t一个ios和android的公共模块文件，即共用代码模块文件，命名不能加ios和android后缀，否则，ios包取不到有androis后缀的文件，android取不到有ios后缀的文件。\n\n\n实例解释上述：\n现在有以下五个文件：\n\nindex.ios.js \n \nindex.android.js\n\nsay.android.js\n\nsay.ios.js\n\nHelloWorldApp.android.js   \n\n我们想要分别在index.ios.js 和 index.android.js引入其他三个模块。我们只要在index.ios.js 和 index.android.js文件中如下写法就行：\n\n```\n//这里，index.ios.js会自动获取say.ios.js的模块；index.android.js会自动获取say.android.js的模块\n\nimport 模块名 from \"./say\";\n\n//这里，HelloWorldApp.android.js 是一个公共模块，index.android.js能成功获取到./HelloWorldApp；但是index.ios.js则无法获取到HelloWorldApp模块，因为index.ios.js会忽略android后缀名的模块文件\n\nimport 模块名 from \"./HelloWorldApp\"\n```\n\n\n## react组件的生命周期\n\n![](https://raw.githubusercontent.com/bigdots/blog/master/images/201601/react-component.jpg)\n\n项目中使用组件的时候，纠结于componentWillMount,componentDidMount...，直到看到这张图豁然开朗(so，图是盗的)。需要注意的是，这张图应该比较老了，其中的getDefaultProps和\ngetInitialState这俩个函数是ES5的写法了，ES6语法中，constructor方法中代替了getDefaultProps／getInitialState，我们可以在其内直接初始化props和state。\n\n生命周期：\n\n1. 实例化（初始化）\n\t- constructor\n\n\t\t设置默认的props->设置默认的state\n\t- componentWillMount\n\t\t\n\t\t完成渲染之前执行，此时可以设置state\n\t\t\n\t- render\n\n\t\t创建虚拟DOM，此时不能修改state\n\t\t\n\t- componentDidMount\n\n\t\t真实的DOM渲染完毕，此时可以更改组件props及state\n\n2. 存在期：(这个时候的主要行为是状态的改变导致组件更新)\n\t- componentWillReceiveProps\n\n\t\t组件接收到新的props,此时可以更改组件props及state\n\t\t\n\t- shouldComponentUpdate\n\n\t\t操作组件是否应当渲染新的props或state，返回布尔值，首次渲染该方法不会被调用。\n\t\t\n\t- componentWillUpdate\n\n\t\t接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。\n\t\t\n\t- render\n\n\t\t创建（更新）虚拟DOM\n\t\t\n\t- componentDidUpdate\n\t 组件真实的DOM更新完成\n\t \n3. 销毁期：\n\t- componentWillUnmount\n\t组件被移除之前，主要用于做一些清理工作，比如事件监听\n\n\n## react 的 props 和 state\n\n1. props（属性）\n\n\t当我们调用这些组件时，我们如果为每一个组件传递了不同的属性，这个属性就是props。比如下例中，我们调用了HelloWorldApp组件，并为其设置了一个date属性，则我们可以在HelloWorldApp的组件里，通过this.props.date来获取这一属性值。\n\t```\n\t<HelloWorldApp date = {2016}>\n\t```\n\n2. state（状态）\n\n\t**state需要在constructor中初始化，然后通过调用setState方法修改。**\n\t通过上面的组件生命周期图，我们可以看出，state是一个状态机，state的改变会引起shouldcomponentupdate、componentwillupdate、rendner...一系列方法的执行，**视图会重新渲染**。所以，如果需要动态地改变组件的数据或试图，请操作state。\n\n\n## react组件之间的通信  \n\n1. 子组件接收父组件的改变信号\n\n\t简单：当父组件改变时，直接向子组件传递props\n\t\n2. 父组件接收子组件的改变信号\n\t在父组件中定义一个方法，并通过props传递给子组件，子组件改变时，通过调用这个父组件传递过来的方法，从而实现在父组件中执行该方法。\n\t\n3. 非父子关系组件之间的通信\n\n\t`RCTDeviceEventEmitter`模块：它有俩个方法：emit和addListener，一个发送，一个接收。\n\t\n\tRCTDeviceEventEmitter.emit(notifName,param);\n\t\n\tRCTDeviceEventEmitter.addListener(notifName,callback)\n\t\n\n## native 事件对象\n\n在项目中，遇到一个控制scrollview组件滚动的需求，需要获取当前滚动的坐标，当时找了好久的文档，没找到解决方案，后来发现可以通过这样来传入一个事件对象\n\n```\n<ScrollView ref='scrollView' onScroll = {(e) => {this.scrollhShow(e);}}>\n```\n\n然后在函数中读取：\n\n```\nscrollhShow(e) {\n\tconsole.log(e.nativeEvent)\n}\n```\n当当当当，我要的滚动视图的坐标值就在里面了。\n","source":"_posts/第一次react-native项目实践要点总结.md","raw":"# 第一次react-native项目实践要点总结\n\n今天完成了我的第一个react-native项目的封包，当然其间各种环境各种坑，同时，成就感也是满满的。这里总结一下使用react-native的一些入门级重要点（不涉及环境）。**注意：阅读需要语法基础： ES6 、react 、JSX**\n\n我对react-native的理解简而言之就是 ：**react的语法** ＋ **native的组件**\n\n## 组件的创建声明\n```\nclass HelloWorldApp extends Component {\n  constructor(props) {\n  \tsuper(props);\n    this.state = {\n  \n    };\n  }\n  render() {\n    return (\n      <Text>Hello world!</Text>\n    );\n  }\n}\n```\n上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。当你在其他的组件中调用这个组件时，就会实例化这个“类”（即组件）。\n\n**注意：组件名需要大写**\n\n## 组件的导出、引用与注册\n在ES6中，新增了import和export俩个关键字来导入导出模块。react－native的组件也是采用的这俩个关键字。\n\n俩种方式：\n\n第一种：\n\n```\n导出：\nexport default class HelloWorldApp extends Component{\n\trender() {\n    return (\n      <Text>Hello world!</Text>\n    );\n  }\n｝\n\n导入：\nimport HelloWorldApp from \"../..\"\n```\n\n第二种：\n\n```\n导出：\nclass HelloWorldApp extends Component {\n  render() {\n    return (\n      <Text>Hello world!</Text>\n    );\n  }\n}\n\nexport {HelloWorldApp}\n\n导入：\nimport ｛ HelloWorldApp ｝ from \"../..\"\n\n```\n\n1. 后缀名自动获取（文件会获取拥有与之相应后缀名的文件）\n\n\t在组件模块的导入过程中，如果这个模块是分设备的，也就有俩个文件：xxx.android.js和xxx.ios.js，这些后缀（android和ios）是不需要的，在不同的设备环境中，它自动获取相应后缀名的文件，即ios包会自动获取xxx.ios，android包会自动获取xxx.android。\n\n2. 后缀名自动忽略（文件会自动忽略拥有与之不相应后缀名的文件）\n\n\t一个ios和android的公共模块文件，即共用代码模块文件，命名不能加ios和android后缀，否则，ios包取不到有androis后缀的文件，android取不到有ios后缀的文件。\n\n\n实例解释上述：\n现在有以下五个文件：\n\nindex.ios.js \n \nindex.android.js\n\nsay.android.js\n\nsay.ios.js\n\nHelloWorldApp.android.js   \n\n我们想要分别在index.ios.js 和 index.android.js引入其他三个模块。我们只要在index.ios.js 和 index.android.js文件中如下写法就行：\n\n```\n//这里，index.ios.js会自动获取say.ios.js的模块；index.android.js会自动获取say.android.js的模块\n\nimport 模块名 from \"./say\";\n\n//这里，HelloWorldApp.android.js 是一个公共模块，index.android.js能成功获取到./HelloWorldApp；但是index.ios.js则无法获取到HelloWorldApp模块，因为index.ios.js会忽略android后缀名的模块文件\n\nimport 模块名 from \"./HelloWorldApp\"\n```\n\n\n## react组件的生命周期\n\n![](https://raw.githubusercontent.com/bigdots/blog/master/images/201601/react-component.jpg)\n\n项目中使用组件的时候，纠结于componentWillMount,componentDidMount...，直到看到这张图豁然开朗(so，图是盗的)。需要注意的是，这张图应该比较老了，其中的getDefaultProps和\ngetInitialState这俩个函数是ES5的写法了，ES6语法中，constructor方法中代替了getDefaultProps／getInitialState，我们可以在其内直接初始化props和state。\n\n生命周期：\n\n1. 实例化（初始化）\n\t- constructor\n\n\t\t设置默认的props->设置默认的state\n\t- componentWillMount\n\t\t\n\t\t完成渲染之前执行，此时可以设置state\n\t\t\n\t- render\n\n\t\t创建虚拟DOM，此时不能修改state\n\t\t\n\t- componentDidMount\n\n\t\t真实的DOM渲染完毕，此时可以更改组件props及state\n\n2. 存在期：(这个时候的主要行为是状态的改变导致组件更新)\n\t- componentWillReceiveProps\n\n\t\t组件接收到新的props,此时可以更改组件props及state\n\t\t\n\t- shouldComponentUpdate\n\n\t\t操作组件是否应当渲染新的props或state，返回布尔值，首次渲染该方法不会被调用。\n\t\t\n\t- componentWillUpdate\n\n\t\t接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。\n\t\t\n\t- render\n\n\t\t创建（更新）虚拟DOM\n\t\t\n\t- componentDidUpdate\n\t 组件真实的DOM更新完成\n\t \n3. 销毁期：\n\t- componentWillUnmount\n\t组件被移除之前，主要用于做一些清理工作，比如事件监听\n\n\n## react 的 props 和 state\n\n1. props（属性）\n\n\t当我们调用这些组件时，我们如果为每一个组件传递了不同的属性，这个属性就是props。比如下例中，我们调用了HelloWorldApp组件，并为其设置了一个date属性，则我们可以在HelloWorldApp的组件里，通过this.props.date来获取这一属性值。\n\t```\n\t<HelloWorldApp date = {2016}>\n\t```\n\n2. state（状态）\n\n\t**state需要在constructor中初始化，然后通过调用setState方法修改。**\n\t通过上面的组件生命周期图，我们可以看出，state是一个状态机，state的改变会引起shouldcomponentupdate、componentwillupdate、rendner...一系列方法的执行，**视图会重新渲染**。所以，如果需要动态地改变组件的数据或试图，请操作state。\n\n\n## react组件之间的通信  \n\n1. 子组件接收父组件的改变信号\n\n\t简单：当父组件改变时，直接向子组件传递props\n\t\n2. 父组件接收子组件的改变信号\n\t在父组件中定义一个方法，并通过props传递给子组件，子组件改变时，通过调用这个父组件传递过来的方法，从而实现在父组件中执行该方法。\n\t\n3. 非父子关系组件之间的通信\n\n\t`RCTDeviceEventEmitter`模块：它有俩个方法：emit和addListener，一个发送，一个接收。\n\t\n\tRCTDeviceEventEmitter.emit(notifName,param);\n\t\n\tRCTDeviceEventEmitter.addListener(notifName,callback)\n\t\n\n## native 事件对象\n\n在项目中，遇到一个控制scrollview组件滚动的需求，需要获取当前滚动的坐标，当时找了好久的文档，没找到解决方案，后来发现可以通过这样来传入一个事件对象\n\n```\n<ScrollView ref='scrollView' onScroll = {(e) => {this.scrollhShow(e);}}>\n```\n\n然后在函数中读取：\n\n```\nscrollhShow(e) {\n\tconsole.log(e.nativeEvent)\n}\n```\n当当当当，我要的滚动视图的坐标值就在里面了。\n","slug":"第一次react-native项目实践要点总结","published":1,"date":"2021-12-06T06:07:06.369Z","updated":"2021-12-06T06:07:06.370Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomu0054y4v26x8rbnz7","content":"<h1 id=\"第一次react-native项目实践要点总结\"><a href=\"#第一次react-native项目实践要点总结\" class=\"headerlink\" title=\"第一次react-native项目实践要点总结\"></a>第一次react-native项目实践要点总结</h1><p>今天完成了我的第一个react-native项目的封包，当然其间各种环境各种坑，同时，成就感也是满满的。这里总结一下使用react-native的一些入门级重要点（不涉及环境）。<strong>注意：阅读需要语法基础： ES6 、react 、JSX</strong></p>\n<p>我对react-native的理解简而言之就是 ：<strong>react的语法</strong> ＋ <strong>native的组件</strong></p>\n<h2 id=\"组件的创建声明\"><a href=\"#组件的创建声明\" class=\"headerlink\" title=\"组件的创建声明\"></a>组件的创建声明</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class HelloWorldApp extends Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">  \tsuper(props);</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Text&gt;Hello world!&lt;/Text&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。当你在其他的组件中调用这个组件时，就会实例化这个“类”（即组件）。</p>\n<p><strong>注意：组件名需要大写</strong></p>\n<h2 id=\"组件的导出、引用与注册\"><a href=\"#组件的导出、引用与注册\" class=\"headerlink\" title=\"组件的导出、引用与注册\"></a>组件的导出、引用与注册</h2><p>在ES6中，新增了import和export俩个关键字来导入导出模块。react－native的组件也是采用的这俩个关键字。</p>\n<p>俩种方式：</p>\n<p>第一种：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">导出：</span><br><span class=\"line\">export default class HelloWorldApp extends Component&#123;</span><br><span class=\"line\">\trender() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Text&gt;Hello world!&lt;/Text&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">｝</span><br><span class=\"line\"></span><br><span class=\"line\">导入：</span><br><span class=\"line\">import HelloWorldApp from &quot;../..&quot;</span><br></pre></td></tr></table></figure>\n\n<p>第二种：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">导出：</span><br><span class=\"line\">class HelloWorldApp extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Text&gt;Hello world!&lt;/Text&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;HelloWorldApp&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">导入：</span><br><span class=\"line\">import ｛ HelloWorldApp ｝ from &quot;../..&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>后缀名自动获取（文件会获取拥有与之相应后缀名的文件）</p>\n<p> 在组件模块的导入过程中，如果这个模块是分设备的，也就有俩个文件：xxx.android.js和xxx.ios.js，这些后缀（android和ios）是不需要的，在不同的设备环境中，它自动获取相应后缀名的文件，即ios包会自动获取xxx.ios，android包会自动获取xxx.android。</p>\n</li>\n<li><p>后缀名自动忽略（文件会自动忽略拥有与之不相应后缀名的文件）</p>\n<p> 一个ios和android的公共模块文件，即共用代码模块文件，命名不能加ios和android后缀，否则，ios包取不到有androis后缀的文件，android取不到有ios后缀的文件。</p>\n</li>\n</ol>\n<p>实例解释上述：<br>现在有以下五个文件：</p>\n<p>index.ios.js </p>\n<p>index.android.js</p>\n<p>say.android.js</p>\n<p>say.ios.js</p>\n<p>HelloWorldApp.android.js   </p>\n<p>我们想要分别在index.ios.js 和 index.android.js引入其他三个模块。我们只要在index.ios.js 和 index.android.js文件中如下写法就行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这里，index.ios.js会自动获取say.ios.js的模块；index.android.js会自动获取say.android.js的模块</span><br><span class=\"line\"></span><br><span class=\"line\">import 模块名 from &quot;./say&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">//这里，HelloWorldApp.android.js 是一个公共模块，index.android.js能成功获取到./HelloWorldApp；但是index.ios.js则无法获取到HelloWorldApp模块，因为index.ios.js会忽略android后缀名的模块文件</span><br><span class=\"line\"></span><br><span class=\"line\">import 模块名 from &quot;./HelloWorldApp&quot;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"react组件的生命周期\"><a href=\"#react组件的生命周期\" class=\"headerlink\" title=\"react组件的生命周期\"></a>react组件的生命周期</h2><p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201601/react-component.jpg\"></p>\n<p>项目中使用组件的时候，纠结于componentWillMount,componentDidMount…，直到看到这张图豁然开朗(so，图是盗的)。需要注意的是，这张图应该比较老了，其中的getDefaultProps和<br>getInitialState这俩个函数是ES5的写法了，ES6语法中，constructor方法中代替了getDefaultProps／getInitialState，我们可以在其内直接初始化props和state。</p>\n<p>生命周期：</p>\n<ol>\n<li><p>实例化（初始化）</p>\n<ul>\n<li><p>constructor</p>\n<p>  设置默认的props-&gt;设置默认的state</p>\n</li>\n<li><p>componentWillMount</p>\n<p>  完成渲染之前执行，此时可以设置state</p>\n</li>\n<li><p>render</p>\n<p>  创建虚拟DOM，此时不能修改state</p>\n</li>\n<li><p>componentDidMount</p>\n<p>  真实的DOM渲染完毕，此时可以更改组件props及state</p>\n</li>\n</ul>\n</li>\n<li><p>存在期：(这个时候的主要行为是状态的改变导致组件更新)</p>\n<ul>\n<li><p>componentWillReceiveProps</p>\n<p>  组件接收到新的props,此时可以更改组件props及state</p>\n</li>\n<li><p>shouldComponentUpdate</p>\n<p>  操作组件是否应当渲染新的props或state，返回布尔值，首次渲染该方法不会被调用。</p>\n</li>\n<li><p>componentWillUpdate</p>\n<p>  接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。</p>\n</li>\n<li><p>render</p>\n<p>  创建（更新）虚拟DOM</p>\n</li>\n<li><p>componentDidUpdate<br>组件真实的DOM更新完成</p>\n</li>\n</ul>\n</li>\n<li><p>销毁期：</p>\n<ul>\n<li>componentWillUnmount<br>组件被移除之前，主要用于做一些清理工作，比如事件监听</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"react-的-props-和-state\"><a href=\"#react-的-props-和-state\" class=\"headerlink\" title=\"react 的 props 和 state\"></a>react 的 props 和 state</h2><ol>\n<li><p>props（属性）</p>\n<p> 当我们调用这些组件时，我们如果为每一个组件传递了不同的属性，这个属性就是props。比如下例中，我们调用了HelloWorldApp组件，并为其设置了一个date属性，则我们可以在HelloWorldApp的组件里，通过this.props.date来获取这一属性值。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;HelloWorldApp date = &#123;2016&#125;&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>state（状态）</p>\n<p> <strong>state需要在constructor中初始化，然后通过调用setState方法修改。</strong><br> 通过上面的组件生命周期图，我们可以看出，state是一个状态机，state的改变会引起shouldcomponentupdate、componentwillupdate、rendner…一系列方法的执行，<strong>视图会重新渲染</strong>。所以，如果需要动态地改变组件的数据或试图，请操作state。</p>\n</li>\n</ol>\n<h2 id=\"react组件之间的通信\"><a href=\"#react组件之间的通信\" class=\"headerlink\" title=\"react组件之间的通信\"></a>react组件之间的通信</h2><ol>\n<li><p>子组件接收父组件的改变信号</p>\n<p> 简单：当父组件改变时，直接向子组件传递props</p>\n</li>\n<li><p>父组件接收子组件的改变信号<br> 在父组件中定义一个方法，并通过props传递给子组件，子组件改变时，通过调用这个父组件传递过来的方法，从而实现在父组件中执行该方法。</p>\n</li>\n<li><p>非父子关系组件之间的通信</p>\n<p> <code>RCTDeviceEventEmitter</code>模块：它有俩个方法：emit和addListener，一个发送，一个接收。</p>\n<p> RCTDeviceEventEmitter.emit(notifName,param);</p>\n<p> RCTDeviceEventEmitter.addListener(notifName,callback)</p>\n</li>\n</ol>\n<h2 id=\"native-事件对象\"><a href=\"#native-事件对象\" class=\"headerlink\" title=\"native 事件对象\"></a>native 事件对象</h2><p>在项目中，遇到一个控制scrollview组件滚动的需求，需要获取当前滚动的坐标，当时找了好久的文档，没找到解决方案，后来发现可以通过这样来传入一个事件对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ScrollView ref=&#x27;scrollView&#x27; onScroll = &#123;(e) =&gt; &#123;this.scrollhShow(e);&#125;&#125;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后在函数中读取：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollhShow(e) &#123;</span><br><span class=\"line\">\tconsole.log(e.nativeEvent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当当当当，我要的滚动视图的坐标值就在里面了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第一次react-native项目实践要点总结\"><a href=\"#第一次react-native项目实践要点总结\" class=\"headerlink\" title=\"第一次react-native项目实践要点总结\"></a>第一次react-native项目实践要点总结</h1><p>今天完成了我的第一个react-native项目的封包，当然其间各种环境各种坑，同时，成就感也是满满的。这里总结一下使用react-native的一些入门级重要点（不涉及环境）。<strong>注意：阅读需要语法基础： ES6 、react 、JSX</strong></p>\n<p>我对react-native的理解简而言之就是 ：<strong>react的语法</strong> ＋ <strong>native的组件</strong></p>\n<h2 id=\"组件的创建声明\"><a href=\"#组件的创建声明\" class=\"headerlink\" title=\"组件的创建声明\"></a>组件的创建声明</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class HelloWorldApp extends Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">  \tsuper(props);</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Text&gt;Hello world!&lt;/Text&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。当你在其他的组件中调用这个组件时，就会实例化这个“类”（即组件）。</p>\n<p><strong>注意：组件名需要大写</strong></p>\n<h2 id=\"组件的导出、引用与注册\"><a href=\"#组件的导出、引用与注册\" class=\"headerlink\" title=\"组件的导出、引用与注册\"></a>组件的导出、引用与注册</h2><p>在ES6中，新增了import和export俩个关键字来导入导出模块。react－native的组件也是采用的这俩个关键字。</p>\n<p>俩种方式：</p>\n<p>第一种：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">导出：</span><br><span class=\"line\">export default class HelloWorldApp extends Component&#123;</span><br><span class=\"line\">\trender() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Text&gt;Hello world!&lt;/Text&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">｝</span><br><span class=\"line\"></span><br><span class=\"line\">导入：</span><br><span class=\"line\">import HelloWorldApp from &quot;../..&quot;</span><br></pre></td></tr></table></figure>\n\n<p>第二种：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">导出：</span><br><span class=\"line\">class HelloWorldApp extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Text&gt;Hello world!&lt;/Text&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;HelloWorldApp&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">导入：</span><br><span class=\"line\">import ｛ HelloWorldApp ｝ from &quot;../..&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>后缀名自动获取（文件会获取拥有与之相应后缀名的文件）</p>\n<p> 在组件模块的导入过程中，如果这个模块是分设备的，也就有俩个文件：xxx.android.js和xxx.ios.js，这些后缀（android和ios）是不需要的，在不同的设备环境中，它自动获取相应后缀名的文件，即ios包会自动获取xxx.ios，android包会自动获取xxx.android。</p>\n</li>\n<li><p>后缀名自动忽略（文件会自动忽略拥有与之不相应后缀名的文件）</p>\n<p> 一个ios和android的公共模块文件，即共用代码模块文件，命名不能加ios和android后缀，否则，ios包取不到有androis后缀的文件，android取不到有ios后缀的文件。</p>\n</li>\n</ol>\n<p>实例解释上述：<br>现在有以下五个文件：</p>\n<p>index.ios.js </p>\n<p>index.android.js</p>\n<p>say.android.js</p>\n<p>say.ios.js</p>\n<p>HelloWorldApp.android.js   </p>\n<p>我们想要分别在index.ios.js 和 index.android.js引入其他三个模块。我们只要在index.ios.js 和 index.android.js文件中如下写法就行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这里，index.ios.js会自动获取say.ios.js的模块；index.android.js会自动获取say.android.js的模块</span><br><span class=\"line\"></span><br><span class=\"line\">import 模块名 from &quot;./say&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">//这里，HelloWorldApp.android.js 是一个公共模块，index.android.js能成功获取到./HelloWorldApp；但是index.ios.js则无法获取到HelloWorldApp模块，因为index.ios.js会忽略android后缀名的模块文件</span><br><span class=\"line\"></span><br><span class=\"line\">import 模块名 from &quot;./HelloWorldApp&quot;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"react组件的生命周期\"><a href=\"#react组件的生命周期\" class=\"headerlink\" title=\"react组件的生命周期\"></a>react组件的生命周期</h2><p><img src=\"https://raw.githubusercontent.com/bigdots/blog/master/images/201601/react-component.jpg\"></p>\n<p>项目中使用组件的时候，纠结于componentWillMount,componentDidMount…，直到看到这张图豁然开朗(so，图是盗的)。需要注意的是，这张图应该比较老了，其中的getDefaultProps和<br>getInitialState这俩个函数是ES5的写法了，ES6语法中，constructor方法中代替了getDefaultProps／getInitialState，我们可以在其内直接初始化props和state。</p>\n<p>生命周期：</p>\n<ol>\n<li><p>实例化（初始化）</p>\n<ul>\n<li><p>constructor</p>\n<p>  设置默认的props-&gt;设置默认的state</p>\n</li>\n<li><p>componentWillMount</p>\n<p>  完成渲染之前执行，此时可以设置state</p>\n</li>\n<li><p>render</p>\n<p>  创建虚拟DOM，此时不能修改state</p>\n</li>\n<li><p>componentDidMount</p>\n<p>  真实的DOM渲染完毕，此时可以更改组件props及state</p>\n</li>\n</ul>\n</li>\n<li><p>存在期：(这个时候的主要行为是状态的改变导致组件更新)</p>\n<ul>\n<li><p>componentWillReceiveProps</p>\n<p>  组件接收到新的props,此时可以更改组件props及state</p>\n</li>\n<li><p>shouldComponentUpdate</p>\n<p>  操作组件是否应当渲染新的props或state，返回布尔值，首次渲染该方法不会被调用。</p>\n</li>\n<li><p>componentWillUpdate</p>\n<p>  接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。</p>\n</li>\n<li><p>render</p>\n<p>  创建（更新）虚拟DOM</p>\n</li>\n<li><p>componentDidUpdate<br>组件真实的DOM更新完成</p>\n</li>\n</ul>\n</li>\n<li><p>销毁期：</p>\n<ul>\n<li>componentWillUnmount<br>组件被移除之前，主要用于做一些清理工作，比如事件监听</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"react-的-props-和-state\"><a href=\"#react-的-props-和-state\" class=\"headerlink\" title=\"react 的 props 和 state\"></a>react 的 props 和 state</h2><ol>\n<li><p>props（属性）</p>\n<p> 当我们调用这些组件时，我们如果为每一个组件传递了不同的属性，这个属性就是props。比如下例中，我们调用了HelloWorldApp组件，并为其设置了一个date属性，则我们可以在HelloWorldApp的组件里，通过this.props.date来获取这一属性值。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;HelloWorldApp date = &#123;2016&#125;&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>state（状态）</p>\n<p> <strong>state需要在constructor中初始化，然后通过调用setState方法修改。</strong><br> 通过上面的组件生命周期图，我们可以看出，state是一个状态机，state的改变会引起shouldcomponentupdate、componentwillupdate、rendner…一系列方法的执行，<strong>视图会重新渲染</strong>。所以，如果需要动态地改变组件的数据或试图，请操作state。</p>\n</li>\n</ol>\n<h2 id=\"react组件之间的通信\"><a href=\"#react组件之间的通信\" class=\"headerlink\" title=\"react组件之间的通信\"></a>react组件之间的通信</h2><ol>\n<li><p>子组件接收父组件的改变信号</p>\n<p> 简单：当父组件改变时，直接向子组件传递props</p>\n</li>\n<li><p>父组件接收子组件的改变信号<br> 在父组件中定义一个方法，并通过props传递给子组件，子组件改变时，通过调用这个父组件传递过来的方法，从而实现在父组件中执行该方法。</p>\n</li>\n<li><p>非父子关系组件之间的通信</p>\n<p> <code>RCTDeviceEventEmitter</code>模块：它有俩个方法：emit和addListener，一个发送，一个接收。</p>\n<p> RCTDeviceEventEmitter.emit(notifName,param);</p>\n<p> RCTDeviceEventEmitter.addListener(notifName,callback)</p>\n</li>\n</ol>\n<h2 id=\"native-事件对象\"><a href=\"#native-事件对象\" class=\"headerlink\" title=\"native 事件对象\"></a>native 事件对象</h2><p>在项目中，遇到一个控制scrollview组件滚动的需求，需要获取当前滚动的坐标，当时找了好久的文档，没找到解决方案，后来发现可以通过这样来传入一个事件对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ScrollView ref=&#x27;scrollView&#x27; onScroll = &#123;(e) =&gt; &#123;this.scrollhShow(e);&#125;&#125;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后在函数中读取：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollhShow(e) &#123;</span><br><span class=\"line\">\tconsole.log(e.nativeEvent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当当当当，我要的滚动视图的坐标值就在里面了。</p>\n"},{"_content":"[十大经典排序算法总结（JavaScript描述）](https://juejin.im/post/57dcd394a22b9d00610c5ec8)","source":"_posts/算法复杂度.md","raw":"[十大经典排序算法总结（JavaScript描述）](https://juejin.im/post/57dcd394a22b9d00610c5ec8)","slug":"算法复杂度","published":1,"date":"2021-12-06T06:07:06.081Z","updated":"2021-12-06T06:07:06.081Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomv0056y4v2eumr37fj","content":"<p><a href=\"https://juejin.im/post/57dcd394a22b9d00610c5ec8\">十大经典排序算法总结（JavaScript描述）</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://juejin.im/post/57dcd394a22b9d00610c5ec8\">十大经典排序算法总结（JavaScript描述）</a></p>\n"},{"_content":"# git常用操作命令\n\n### 新建本地仓库（俩种方式）\n1. 本地新建文件夹，然后初始化\n\n ``` \n git init\n ```\n \n2. 直接创建并初始化文件夹\n\n ```\n   git init <reponName> \n ```  \n\n### 添加新文件\n```\ngit add <filename>\n```\n\n### 更新本地代码\n\n```\ngit pull\n```\n\n### 比较代码\n\n```\ngit diff <source> <target>\n```\n\n### 合并代码\n```\ngit merge <target>\n```\n\n### 提交版本\n```\ngit commit -m \" commit info \"\n```\n\n### 推送到远程仓库\n```\ngit push origin master\n```\n\n\n\n\n\n \n \n\n","source":"_posts/简易git操作命令.md","raw":"# git常用操作命令\n\n### 新建本地仓库（俩种方式）\n1. 本地新建文件夹，然后初始化\n\n ``` \n git init\n ```\n \n2. 直接创建并初始化文件夹\n\n ```\n   git init <reponName> \n ```  \n\n### 添加新文件\n```\ngit add <filename>\n```\n\n### 更新本地代码\n\n```\ngit pull\n```\n\n### 比较代码\n\n```\ngit diff <source> <target>\n```\n\n### 合并代码\n```\ngit merge <target>\n```\n\n### 提交版本\n```\ngit commit -m \" commit info \"\n```\n\n### 推送到远程仓库\n```\ngit push origin master\n```\n\n\n\n\n\n \n \n\n","slug":"简易git操作命令","published":1,"date":"2021-12-06T06:07:06.374Z","updated":"2021-12-06T06:07:06.374Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomw0057y4v2308fa0o7","content":"<h1 id=\"git常用操作命令\"><a href=\"#git常用操作命令\" class=\"headerlink\" title=\"git常用操作命令\"></a>git常用操作命令</h1><h3 id=\"新建本地仓库（俩种方式）\"><a href=\"#新建本地仓库（俩种方式）\" class=\"headerlink\" title=\"新建本地仓库（俩种方式）\"></a>新建本地仓库（俩种方式）</h3><ol>\n<li>本地新建文件夹，然后初始化</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>直接创建并初始化文件夹</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   git init &lt;reponName&gt; </span><br><span class=\"line\"> ```  </span><br><span class=\"line\"></span><br><span class=\"line\">### 添加新文件</span><br></pre></td></tr></table></figure>\n<p>git add <filename></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 更新本地代码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>git pull</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 比较代码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>git diff <source> <target></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 合并代码</span><br></pre></td></tr></table></figure>\n<p>git merge <target></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 提交版本</span><br></pre></td></tr></table></figure>\n<p>git commit -m “ commit info “</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 推送到远程仓库</span><br></pre></td></tr></table></figure>\n<p>git push origin master</p>\n<pre><code>\n\n\n\n\n \n \n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"git常用操作命令\"><a href=\"#git常用操作命令\" class=\"headerlink\" title=\"git常用操作命令\"></a>git常用操作命令</h1><h3 id=\"新建本地仓库（俩种方式）\"><a href=\"#新建本地仓库（俩种方式）\" class=\"headerlink\" title=\"新建本地仓库（俩种方式）\"></a>新建本地仓库（俩种方式）</h3><ol>\n<li>本地新建文件夹，然后初始化</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>直接创建并初始化文件夹</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   git init &lt;reponName&gt; </span><br><span class=\"line\"> ```  </span><br><span class=\"line\"></span><br><span class=\"line\">### 添加新文件</span><br></pre></td></tr></table></figure>\n<p>git add <filename></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 更新本地代码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>git pull</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 比较代码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>git diff <source> <target></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 合并代码</span><br></pre></td></tr></table></figure>\n<p>git merge <target></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 提交版本</span><br></pre></td></tr></table></figure>\n<p>git commit -m “ commit info “</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 推送到远程仓库</span><br></pre></td></tr></table></figure>\n<p>git push origin master</p>\n<pre><code>\n\n\n\n\n \n \n</code></pre>\n"},{"_content":"\n# 计算机字符编码\n\n在计算机内部，所有信息都是使用0和1进行表示的，它们最终都是一个二进制值。\n\n二进制数的每一个位表示一个计算机位（bit，简称位），每一个二进制位（bit）有0和1两种状态。\n\n8个位组成一个字节(byte)，那么一个字节可以组合出256（2^8）种状态（从0000000到11111111）。\n\n虽然机器是基于二进制的，但对人类来说，二进制数实在是太长了，需要做精简。因此需要将其转换成其它进制，比如八进制、十进制、十六进制（hexadecimal，简称hex）等。\n\n\n## 编码\n\n人们为了使用方便，将字符与不同的二进制值相对应，于是产生了编码。\n\n### ASCII 码\n\n上个世纪60年代，美国制定的一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这套编码被称为 ASCII 码，一直沿用至今。\n\nASCII 码一共规定了128个字符的编码。比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。\n\n\n\n### GB2312、GBK等其他编码的产生\n\nASCII 码只有128个字符，而世界上有几千种语言，ASCII码是难以应付的，于是各个国家组织制定了各种适应本国的计算机编码。\n\n一个国家／组织的字符集可能远远超过256个，比如汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如：简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。\n\n但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。\n\n### Unicode\n\n由于各自琳琅满目的编码，往往在计算机领域出现各种乱码问题。于是产生了Unicode。\n\nUnicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。\n\nUnicode又统一码、万国码、单一码，它包括字符集、编码方案等。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。\n\n\n### 码点\n它从0开始，为每个符号指定一个编号，这叫做\"码点\"（code point）。目前最新版本是7.0版，一共收入了109449个符号。\n\n这么多符号，Unicode不是一次性定义的，而是分区定义。每个区可以存放65536个（2^16）字符，称为一个平面（plane）。目前，一共有17个（2^5）平面，也就是说，整个Unicode字符集的大小现在是221。\n\n\nUnicode最前面的65536个字符位，称为基本平面（缩写BMP），它的码点范围是从0一直到216-1，写成16进制就是从U+0000到U+FFFF。所有最常见的字符都放在这个平面，这是Unicode最先定义和公布的一个平面。\n\n剩下的字符都放在辅助平面（缩写SMP），码点范围从U+010000一直到U+10FFFF。\n\n\n### 编码方案\n\nUnicode除了规定了每个字符的码点，还规定了到底用什么样的字节序表示这个码点，这就涉及到编码方法。\n\nUnicode编码方法并不唯一，现有UTF-32、UTF-8、UTF-16等多种编码方式。\n\n1. UTF-32\n\n    这是最直观的编码方法，每个码点使用四个字节表示，字节内容一一对应码点。比如字母a为0x00000061\n\n    它的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比ASCII编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5标准就明文规定，网页不得编码成UTF-32。\n\n2. UTF-8\n\n    它是一种变长的编码方法，字符长度从1个字节到4个字节不等。越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同。\n\n3. UTF-16\n\n    它介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。\n\n    它的编码规则很简单：f。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。\n\n\n\n\n\n\n","source":"_posts/计算机字符编码.md","raw":"\n# 计算机字符编码\n\n在计算机内部，所有信息都是使用0和1进行表示的，它们最终都是一个二进制值。\n\n二进制数的每一个位表示一个计算机位（bit，简称位），每一个二进制位（bit）有0和1两种状态。\n\n8个位组成一个字节(byte)，那么一个字节可以组合出256（2^8）种状态（从0000000到11111111）。\n\n虽然机器是基于二进制的，但对人类来说，二进制数实在是太长了，需要做精简。因此需要将其转换成其它进制，比如八进制、十进制、十六进制（hexadecimal，简称hex）等。\n\n\n## 编码\n\n人们为了使用方便，将字符与不同的二进制值相对应，于是产生了编码。\n\n### ASCII 码\n\n上个世纪60年代，美国制定的一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这套编码被称为 ASCII 码，一直沿用至今。\n\nASCII 码一共规定了128个字符的编码。比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。\n\n\n\n### GB2312、GBK等其他编码的产生\n\nASCII 码只有128个字符，而世界上有几千种语言，ASCII码是难以应付的，于是各个国家组织制定了各种适应本国的计算机编码。\n\n一个国家／组织的字符集可能远远超过256个，比如汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如：简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。\n\n但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。\n\n### Unicode\n\n由于各自琳琅满目的编码，往往在计算机领域出现各种乱码问题。于是产生了Unicode。\n\nUnicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。\n\nUnicode又统一码、万国码、单一码，它包括字符集、编码方案等。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。\n\n\n### 码点\n它从0开始，为每个符号指定一个编号，这叫做\"码点\"（code point）。目前最新版本是7.0版，一共收入了109449个符号。\n\n这么多符号，Unicode不是一次性定义的，而是分区定义。每个区可以存放65536个（2^16）字符，称为一个平面（plane）。目前，一共有17个（2^5）平面，也就是说，整个Unicode字符集的大小现在是221。\n\n\nUnicode最前面的65536个字符位，称为基本平面（缩写BMP），它的码点范围是从0一直到216-1，写成16进制就是从U+0000到U+FFFF。所有最常见的字符都放在这个平面，这是Unicode最先定义和公布的一个平面。\n\n剩下的字符都放在辅助平面（缩写SMP），码点范围从U+010000一直到U+10FFFF。\n\n\n### 编码方案\n\nUnicode除了规定了每个字符的码点，还规定了到底用什么样的字节序表示这个码点，这就涉及到编码方法。\n\nUnicode编码方法并不唯一，现有UTF-32、UTF-8、UTF-16等多种编码方式。\n\n1. UTF-32\n\n    这是最直观的编码方法，每个码点使用四个字节表示，字节内容一一对应码点。比如字母a为0x00000061\n\n    它的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比ASCII编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5标准就明文规定，网页不得编码成UTF-32。\n\n2. UTF-8\n\n    它是一种变长的编码方法，字符长度从1个字节到4个字节不等。越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同。\n\n3. UTF-16\n\n    它介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。\n\n    它的编码规则很简单：f。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。\n\n\n\n\n\n\n","slug":"计算机字符编码","published":1,"date":"2021-12-06T06:07:06.382Z","updated":"2021-12-06T06:07:06.382Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomw0058y4v29frr5a6k","content":"<h1 id=\"计算机字符编码\"><a href=\"#计算机字符编码\" class=\"headerlink\" title=\"计算机字符编码\"></a>计算机字符编码</h1><p>在计算机内部，所有信息都是使用0和1进行表示的，它们最终都是一个二进制值。</p>\n<p>二进制数的每一个位表示一个计算机位（bit，简称位），每一个二进制位（bit）有0和1两种状态。</p>\n<p>8个位组成一个字节(byte)，那么一个字节可以组合出256（2^8）种状态（从0000000到11111111）。</p>\n<p>虽然机器是基于二进制的，但对人类来说，二进制数实在是太长了，需要做精简。因此需要将其转换成其它进制，比如八进制、十进制、十六进制（hexadecimal，简称hex）等。</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>人们为了使用方便，将字符与不同的二进制值相对应，于是产生了编码。</p>\n<h3 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h3><p>上个世纪60年代，美国制定的一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这套编码被称为 ASCII 码，一直沿用至今。</p>\n<p>ASCII 码一共规定了128个字符的编码。比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。</p>\n<h3 id=\"GB2312、GBK等其他编码的产生\"><a href=\"#GB2312、GBK等其他编码的产生\" class=\"headerlink\" title=\"GB2312、GBK等其他编码的产生\"></a>GB2312、GBK等其他编码的产生</h3><p>ASCII 码只有128个字符，而世界上有几千种语言，ASCII码是难以应付的，于是各个国家组织制定了各种适应本国的计算机编码。</p>\n<p>一个国家／组织的字符集可能远远超过256个，比如汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如：简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p>\n<p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。</p>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>由于各自琳琅满目的编码，往往在计算机领域出现各种乱码问题。于是产生了Unicode。</p>\n<p>Unicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。</p>\n<p>Unicode又统一码、万国码、单一码，它包括字符集、编码方案等。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p>\n<h3 id=\"码点\"><a href=\"#码点\" class=\"headerlink\" title=\"码点\"></a>码点</h3><p>它从0开始，为每个符号指定一个编号，这叫做”码点”（code point）。目前最新版本是7.0版，一共收入了109449个符号。</p>\n<p>这么多符号，Unicode不是一次性定义的，而是分区定义。每个区可以存放65536个（2^16）字符，称为一个平面（plane）。目前，一共有17个（2^5）平面，也就是说，整个Unicode字符集的大小现在是221。</p>\n<p>Unicode最前面的65536个字符位，称为基本平面（缩写BMP），它的码点范围是从0一直到216-1，写成16进制就是从U+0000到U+FFFF。所有最常见的字符都放在这个平面，这是Unicode最先定义和公布的一个平面。</p>\n<p>剩下的字符都放在辅助平面（缩写SMP），码点范围从U+010000一直到U+10FFFF。</p>\n<h3 id=\"编码方案\"><a href=\"#编码方案\" class=\"headerlink\" title=\"编码方案\"></a>编码方案</h3><p>Unicode除了规定了每个字符的码点，还规定了到底用什么样的字节序表示这个码点，这就涉及到编码方法。</p>\n<p>Unicode编码方法并不唯一，现有UTF-32、UTF-8、UTF-16等多种编码方式。</p>\n<ol>\n<li><p>UTF-32</p>\n<p> 这是最直观的编码方法，每个码点使用四个字节表示，字节内容一一对应码点。比如字母a为0x00000061</p>\n<p> 它的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比ASCII编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5标准就明文规定，网页不得编码成UTF-32。</p>\n</li>\n<li><p>UTF-8</p>\n<p> 它是一种变长的编码方法，字符长度从1个字节到4个字节不等。越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同。</p>\n</li>\n<li><p>UTF-16</p>\n<p> 它介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。</p>\n<p> 它的编码规则很简单：f。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"计算机字符编码\"><a href=\"#计算机字符编码\" class=\"headerlink\" title=\"计算机字符编码\"></a>计算机字符编码</h1><p>在计算机内部，所有信息都是使用0和1进行表示的，它们最终都是一个二进制值。</p>\n<p>二进制数的每一个位表示一个计算机位（bit，简称位），每一个二进制位（bit）有0和1两种状态。</p>\n<p>8个位组成一个字节(byte)，那么一个字节可以组合出256（2^8）种状态（从0000000到11111111）。</p>\n<p>虽然机器是基于二进制的，但对人类来说，二进制数实在是太长了，需要做精简。因此需要将其转换成其它进制，比如八进制、十进制、十六进制（hexadecimal，简称hex）等。</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>人们为了使用方便，将字符与不同的二进制值相对应，于是产生了编码。</p>\n<h3 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h3><p>上个世纪60年代，美国制定的一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这套编码被称为 ASCII 码，一直沿用至今。</p>\n<p>ASCII 码一共规定了128个字符的编码。比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。</p>\n<h3 id=\"GB2312、GBK等其他编码的产生\"><a href=\"#GB2312、GBK等其他编码的产生\" class=\"headerlink\" title=\"GB2312、GBK等其他编码的产生\"></a>GB2312、GBK等其他编码的产生</h3><p>ASCII 码只有128个字符，而世界上有几千种语言，ASCII码是难以应付的，于是各个国家组织制定了各种适应本国的计算机编码。</p>\n<p>一个国家／组织的字符集可能远远超过256个，比如汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如：简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p>\n<p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。</p>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>由于各自琳琅满目的编码，往往在计算机领域出现各种乱码问题。于是产生了Unicode。</p>\n<p>Unicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。</p>\n<p>Unicode又统一码、万国码、单一码，它包括字符集、编码方案等。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p>\n<h3 id=\"码点\"><a href=\"#码点\" class=\"headerlink\" title=\"码点\"></a>码点</h3><p>它从0开始，为每个符号指定一个编号，这叫做”码点”（code point）。目前最新版本是7.0版，一共收入了109449个符号。</p>\n<p>这么多符号，Unicode不是一次性定义的，而是分区定义。每个区可以存放65536个（2^16）字符，称为一个平面（plane）。目前，一共有17个（2^5）平面，也就是说，整个Unicode字符集的大小现在是221。</p>\n<p>Unicode最前面的65536个字符位，称为基本平面（缩写BMP），它的码点范围是从0一直到216-1，写成16进制就是从U+0000到U+FFFF。所有最常见的字符都放在这个平面，这是Unicode最先定义和公布的一个平面。</p>\n<p>剩下的字符都放在辅助平面（缩写SMP），码点范围从U+010000一直到U+10FFFF。</p>\n<h3 id=\"编码方案\"><a href=\"#编码方案\" class=\"headerlink\" title=\"编码方案\"></a>编码方案</h3><p>Unicode除了规定了每个字符的码点，还规定了到底用什么样的字节序表示这个码点，这就涉及到编码方法。</p>\n<p>Unicode编码方法并不唯一，现有UTF-32、UTF-8、UTF-16等多种编码方式。</p>\n<ol>\n<li><p>UTF-32</p>\n<p> 这是最直观的编码方法，每个码点使用四个字节表示，字节内容一一对应码点。比如字母a为0x00000061</p>\n<p> 它的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比ASCII编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5标准就明文规定，网页不得编码成UTF-32。</p>\n</li>\n<li><p>UTF-8</p>\n<p> 它是一种变长的编码方法，字符长度从1个字节到4个字节不等。越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同。</p>\n</li>\n<li><p>UTF-16</p>\n<p> 它介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。</p>\n<p> 它的编码规则很简单：f。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。</p>\n</li>\n</ol>\n"},{"title":"网页内嵌媒体的完美实现","date":"2016-03-16T06:06:47.000Z","description":"插入视频,插入音乐，背景音乐","_content":"\n项目中经常需要用到视频和音频的插入与控制。但在使用中发现要使浏览器完美地呈现视频和音频并不是那么一件简单的事。各个浏览器不同的解析方式导致这一行为实施起来十分地困难。摸了一大堆石头，发现以下方式是可行的。（我所测试的视频格式swf格式，音频是是mp3格式）\n\n<!-- more -->\n\n## flash视频播放\n\n1. `<video>`标签定义视频，比如电影片段或其他视频流。\n这样就解决问题了吗，不，它不支持IE8及以下。\n![](/images/201601/videoSuport.png)\n**提示：可以在开始标签和结束标签之间放置文本内容，这样老的浏览器不支持的情况下会显示内部文本。**\n\n2. `<embed>`标签定义嵌入的内容，比如插件。\n现在行了吗？还是不行。因为**windows平台的IE利用Activex控件来播放flash而其它的浏览器则 使用Netscape插件技术来播放flash。**\n而`<embed>`标签是用于Netscape Navigator2.0及以后的浏览器或其它支持Netscape插件的浏览器。\n\n3. `<object>`标签标签用于包含对象，比如图像、音频、视频、Java applets、ActiveX、PDF 以及 Flash。\n浏览器的对象支持有赖于对象类型。不幸的是，主流浏览器都使用不同的代码来加载相同的对象类型。\n而幸运的是，object 对象提供了解决方案。**如果未显示 object 元素，就会执行位于 `<object>` 和 `</object>` 之间的代码。**通过这种方式，我们能够嵌套多个 object 元素（每个对应一个浏览器）。\n**注释：<param> 标签定义用于对象的 run-time 设置。**\n\n最后综合一下就行了：\n\n```\n<object id=\"\" classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n        codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0\"\n        WIDTH=\"740\" HEIGHT=\"420\" id=\"myMovieName\">\n            <!-- src -->\n            <param name=movie value=\"http://www.mafengwo.cn/swf/videoPlayer.swf\">\n            <param name=quality value=\"high\">\n            <param name=bgcolor value=\"#000\">\n            <param name=allowfullscreen value=\"true\">\n            <param name=wmode value=\"transparent\">\n            <param name=allowscriptaccess value=\"always\">\n            <!-- important -->\n            <param name=flashvars value=\"userid=06232AA4161AAAB6&amp;videoid=E9A575F51098D4C19C33DC5901307461&amp;mode=api&amp;autostart=false&amp;jscontrol=false\">\n            <embed src=\"http://www.mafengwo.cn/swf/videoPlayer.swf\" quality=\"high\" bgcolor=\"#000\" width=\"740\" height=\"420\"\n                        name=\"myMovieName\" align=\"\" type=\"application/x-shockwave-flash\"\n                        pluginspage=\"http://www.macromedia.com/go/getflashplayer\" allowfullscreen=\"true\" allowscriptaccess=\"always\" wmode=\"transparent\" flashvars=\"userid=06232AA4161AAAB6&amp;videoid=E9A575F51098D4C19C33DC5901307461&amp;mode=api&amp;autostart=false&amp;jscontrol=false\">\n            </embed>\n</object>\n```\n\n+ “classid”和“codebase”属性必须要精确地按上例所示的写法写，它们告诉浏览器自动下载flash player的地址。如果你没有安装过flash player 那么IE3.0以后的浏览器会跳出一个提示框访问是否要自动安装flash player。\n+ “pluginspage”属性告诉浏览器下载flash player的地址，如果还没有安装flash player的话，用户安装完后需要重启浏览器才能正常使用。\n\n\n\n## 音频的播放与控制\n\n1. `<audio>` 标签定义声音，比如音乐或其他音频流。\n**提示：可以在开始标签和结束标签之间放置文本内容，这样老的浏览器不支持的情况下会显示内部文本。**\n它与`<video>`是相似的，它也同样不支持IE8及以下浏览器。\n\n2. `<audio>`+`<embed>`\n```\n<audio autoplay=\"autoplay\" id=\"audio\">\n  <source src={{audioSrc}} type=\"audio/mp3\" />\n  <embed id=\"embed\" height=\"0\" type=\"audio/mp3\" src={{audioSrc}} name=\"sound\" MASTERSOUND />\n</audio>\n```\n 经检测火狐无法播放，其他浏览器可以完美呈现。\n\n3. `<object>`\n火狐可以完美播放：\n```html\n<object data={{audioSrc}} type=\"application/x-mplayer2\" width=\"0\" height=\"0\" id=\"object\">\n    <param name=\"src\" value={{audioSrc}}>\n    <param name=\"autostart\" value=\"1\">\n    <param name=\"playcount\" value=\"infinite\">\n</object>\n```\n 现在，我们可以通过浏览器检测的方式，对不同浏览器采用不同的方法。\n```javascript\nif(navigator.userAgent.indexOf(\"Firefox\")!=-1){\n    //火狐\n}else{\n    //其他浏览器\n}\n```\n\n4. `<audio>`、`<embed>`和`<object>`的js控制播放和暂停\n + `<audio>` : audio.pause() / audio.play();\n + `<embed>` : embed.stop() / embed.play();\n + `<object>` : obj.controls.stop() / obj.controls.play();\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","source":"_posts/网页内嵌媒体的完美实现.md","raw":"title: 网页内嵌媒体的完美实现\ntags: [web]\ndate: 2016-03-16 14:06:47\ndescription: 插入视频,插入音乐，背景音乐\n\n---\n\n项目中经常需要用到视频和音频的插入与控制。但在使用中发现要使浏览器完美地呈现视频和音频并不是那么一件简单的事。各个浏览器不同的解析方式导致这一行为实施起来十分地困难。摸了一大堆石头，发现以下方式是可行的。（我所测试的视频格式swf格式，音频是是mp3格式）\n\n<!-- more -->\n\n## flash视频播放\n\n1. `<video>`标签定义视频，比如电影片段或其他视频流。\n这样就解决问题了吗，不，它不支持IE8及以下。\n![](/images/201601/videoSuport.png)\n**提示：可以在开始标签和结束标签之间放置文本内容，这样老的浏览器不支持的情况下会显示内部文本。**\n\n2. `<embed>`标签定义嵌入的内容，比如插件。\n现在行了吗？还是不行。因为**windows平台的IE利用Activex控件来播放flash而其它的浏览器则 使用Netscape插件技术来播放flash。**\n而`<embed>`标签是用于Netscape Navigator2.0及以后的浏览器或其它支持Netscape插件的浏览器。\n\n3. `<object>`标签标签用于包含对象，比如图像、音频、视频、Java applets、ActiveX、PDF 以及 Flash。\n浏览器的对象支持有赖于对象类型。不幸的是，主流浏览器都使用不同的代码来加载相同的对象类型。\n而幸运的是，object 对象提供了解决方案。**如果未显示 object 元素，就会执行位于 `<object>` 和 `</object>` 之间的代码。**通过这种方式，我们能够嵌套多个 object 元素（每个对应一个浏览器）。\n**注释：<param> 标签定义用于对象的 run-time 设置。**\n\n最后综合一下就行了：\n\n```\n<object id=\"\" classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n        codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0\"\n        WIDTH=\"740\" HEIGHT=\"420\" id=\"myMovieName\">\n            <!-- src -->\n            <param name=movie value=\"http://www.mafengwo.cn/swf/videoPlayer.swf\">\n            <param name=quality value=\"high\">\n            <param name=bgcolor value=\"#000\">\n            <param name=allowfullscreen value=\"true\">\n            <param name=wmode value=\"transparent\">\n            <param name=allowscriptaccess value=\"always\">\n            <!-- important -->\n            <param name=flashvars value=\"userid=06232AA4161AAAB6&amp;videoid=E9A575F51098D4C19C33DC5901307461&amp;mode=api&amp;autostart=false&amp;jscontrol=false\">\n            <embed src=\"http://www.mafengwo.cn/swf/videoPlayer.swf\" quality=\"high\" bgcolor=\"#000\" width=\"740\" height=\"420\"\n                        name=\"myMovieName\" align=\"\" type=\"application/x-shockwave-flash\"\n                        pluginspage=\"http://www.macromedia.com/go/getflashplayer\" allowfullscreen=\"true\" allowscriptaccess=\"always\" wmode=\"transparent\" flashvars=\"userid=06232AA4161AAAB6&amp;videoid=E9A575F51098D4C19C33DC5901307461&amp;mode=api&amp;autostart=false&amp;jscontrol=false\">\n            </embed>\n</object>\n```\n\n+ “classid”和“codebase”属性必须要精确地按上例所示的写法写，它们告诉浏览器自动下载flash player的地址。如果你没有安装过flash player 那么IE3.0以后的浏览器会跳出一个提示框访问是否要自动安装flash player。\n+ “pluginspage”属性告诉浏览器下载flash player的地址，如果还没有安装flash player的话，用户安装完后需要重启浏览器才能正常使用。\n\n\n\n## 音频的播放与控制\n\n1. `<audio>` 标签定义声音，比如音乐或其他音频流。\n**提示：可以在开始标签和结束标签之间放置文本内容，这样老的浏览器不支持的情况下会显示内部文本。**\n它与`<video>`是相似的，它也同样不支持IE8及以下浏览器。\n\n2. `<audio>`+`<embed>`\n```\n<audio autoplay=\"autoplay\" id=\"audio\">\n  <source src={{audioSrc}} type=\"audio/mp3\" />\n  <embed id=\"embed\" height=\"0\" type=\"audio/mp3\" src={{audioSrc}} name=\"sound\" MASTERSOUND />\n</audio>\n```\n 经检测火狐无法播放，其他浏览器可以完美呈现。\n\n3. `<object>`\n火狐可以完美播放：\n```html\n<object data={{audioSrc}} type=\"application/x-mplayer2\" width=\"0\" height=\"0\" id=\"object\">\n    <param name=\"src\" value={{audioSrc}}>\n    <param name=\"autostart\" value=\"1\">\n    <param name=\"playcount\" value=\"infinite\">\n</object>\n```\n 现在，我们可以通过浏览器检测的方式，对不同浏览器采用不同的方法。\n```javascript\nif(navigator.userAgent.indexOf(\"Firefox\")!=-1){\n    //火狐\n}else{\n    //其他浏览器\n}\n```\n\n4. `<audio>`、`<embed>`和`<object>`的js控制播放和暂停\n + `<audio>` : audio.pause() / audio.play();\n + `<embed>` : embed.stop() / embed.play();\n + `<object>` : obj.controls.stop() / obj.controls.play();\n\n我的博客:[http://bigdots.github.io](http://bigdots.github.io)、[http://www.cnblogs.com/yzg1/](http://www.cnblogs.com/yzg1/)\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！\n","slug":"网页内嵌媒体的完美实现","published":1,"updated":"2021-12-06T06:07:06.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomx0059y4v29vu32442","content":"<p>项目中经常需要用到视频和音频的插入与控制。但在使用中发现要使浏览器完美地呈现视频和音频并不是那么一件简单的事。各个浏览器不同的解析方式导致这一行为实施起来十分地困难。摸了一大堆石头，发现以下方式是可行的。（我所测试的视频格式swf格式，音频是是mp3格式）</p>\n<span id=\"more\"></span>\n\n<h2 id=\"flash视频播放\"><a href=\"#flash视频播放\" class=\"headerlink\" title=\"flash视频播放\"></a>flash视频播放</h2><ol>\n<li><code>&lt;video&gt;</code>标签定义视频，比如电影片段或其他视频流。<br>这样就解决问题了吗，不，它不支持IE8及以下。<br><img src=\"/images/201601/videoSuport.png\"></li>\n</ol>\n<p><strong>提示：可以在开始标签和结束标签之间放置文本内容，这样老的浏览器不支持的情况下会显示内部文本。</strong></p>\n<ol start=\"2\">\n<li><p><code>&lt;embed&gt;</code>标签定义嵌入的内容，比如插件。<br>现在行了吗？还是不行。因为<strong>windows平台的IE利用Activex控件来播放flash而其它的浏览器则 使用Netscape插件技术来播放flash。</strong><br>而<code>&lt;embed&gt;</code>标签是用于Netscape Navigator2.0及以后的浏览器或其它支持Netscape插件的浏览器。</p>\n</li>\n<li><p><code>&lt;object&gt;</code>标签标签用于包含对象，比如图像、音频、视频、Java applets、ActiveX、PDF 以及 Flash。<br>浏览器的对象支持有赖于对象类型。不幸的是，主流浏览器都使用不同的代码来加载相同的对象类型。<br>而幸运的是，object 对象提供了解决方案。<strong>如果未显示 object 元素，就会执行位于 <code>&lt;object&gt;</code> 和 <code>&lt;/object&gt;</code> 之间的代码。</strong>通过这种方式，我们能够嵌套多个 object 元素（每个对应一个浏览器）。</p>\n</li>\n</ol>\n<p><strong>注释：<param> 标签定义用于对象的 run-time 设置。</strong></p>\n<p>最后综合一下就行了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object id=&quot;&quot; classid=&quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;</span><br><span class=\"line\">        codebase=&quot;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0&quot;</span><br><span class=\"line\">        WIDTH=&quot;740&quot; HEIGHT=&quot;420&quot; id=&quot;myMovieName&quot;&gt;</span><br><span class=\"line\">            &lt;!-- src --&gt;</span><br><span class=\"line\">            &lt;param name=movie value=&quot;http://www.mafengwo.cn/swf/videoPlayer.swf&quot;&gt;</span><br><span class=\"line\">            &lt;param name=quality value=&quot;high&quot;&gt;</span><br><span class=\"line\">            &lt;param name=bgcolor value=&quot;#000&quot;&gt;</span><br><span class=\"line\">            &lt;param name=allowfullscreen value=&quot;true&quot;&gt;</span><br><span class=\"line\">            &lt;param name=wmode value=&quot;transparent&quot;&gt;</span><br><span class=\"line\">            &lt;param name=allowscriptaccess value=&quot;always&quot;&gt;</span><br><span class=\"line\">            &lt;!-- important --&gt;</span><br><span class=\"line\">            &lt;param name=flashvars value=&quot;userid=06232AA4161AAAB6&amp;amp;videoid=E9A575F51098D4C19C33DC5901307461&amp;amp;mode=api&amp;amp;autostart=false&amp;amp;jscontrol=false&quot;&gt;</span><br><span class=\"line\">            &lt;embed src=&quot;http://www.mafengwo.cn/swf/videoPlayer.swf&quot; quality=&quot;high&quot; bgcolor=&quot;#000&quot; width=&quot;740&quot; height=&quot;420&quot;</span><br><span class=\"line\">                        name=&quot;myMovieName&quot; align=&quot;&quot; type=&quot;application/x-shockwave-flash&quot;</span><br><span class=\"line\">                        pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot; allowfullscreen=&quot;true&quot; allowscriptaccess=&quot;always&quot; wmode=&quot;transparent&quot; flashvars=&quot;userid=06232AA4161AAAB6&amp;amp;videoid=E9A575F51098D4C19C33DC5901307461&amp;amp;mode=api&amp;amp;autostart=false&amp;amp;jscontrol=false&quot;&gt;</span><br><span class=\"line\">            &lt;/embed&gt;</span><br><span class=\"line\">&lt;/object&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>“classid”和“codebase”属性必须要精确地按上例所示的写法写，它们告诉浏览器自动下载flash player的地址。如果你没有安装过flash player 那么IE3.0以后的浏览器会跳出一个提示框访问是否要自动安装flash player。</li>\n<li>“pluginspage”属性告诉浏览器下载flash player的地址，如果还没有安装flash player的话，用户安装完后需要重启浏览器才能正常使用。</li>\n</ul>\n<h2 id=\"音频的播放与控制\"><a href=\"#音频的播放与控制\" class=\"headerlink\" title=\"音频的播放与控制\"></a>音频的播放与控制</h2><ol>\n<li><code>&lt;audio&gt;</code> 标签定义声音，比如音乐或其他音频流。</li>\n</ol>\n<p><strong>提示：可以在开始标签和结束标签之间放置文本内容，这样老的浏览器不支持的情况下会显示内部文本。</strong><br>它与<code>&lt;video&gt;</code>是相似的，它也同样不支持IE8及以下浏览器。</p>\n<ol start=\"2\">\n<li><p><code>&lt;audio&gt;</code>+<code>&lt;embed&gt;</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;audio autoplay=&quot;autoplay&quot; id=&quot;audio&quot;&gt;</span><br><span class=\"line\">  &lt;source src=&#123;&#123;audioSrc&#125;&#125; type=&quot;audio/mp3&quot; /&gt;</span><br><span class=\"line\">  &lt;embed id=&quot;embed&quot; height=&quot;0&quot; type=&quot;audio/mp3&quot; src=&#123;&#123;audioSrc&#125;&#125; name=&quot;sound&quot; MASTERSOUND /&gt;</span><br><span class=\"line\">&lt;/audio&gt;</span><br></pre></td></tr></table></figure>\n<p>经检测火狐无法播放，其他浏览器可以完美呈现。</p>\n</li>\n<li><p><code>&lt;object&gt;</code><br>火狐可以完美播放：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">object</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;&#123;audioSrc&#125;&#125;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;application/x-mplayer2&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;object&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;src&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;audioSrc&#125;&#125;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;autostart&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;playcount&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;infinite&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">object</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>现在，我们可以通过浏览器检测的方式，对不同浏览器采用不同的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(navigator.userAgent.indexOf(<span class=\"string\">&quot;Firefox&quot;</span>)!=-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//火狐</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//其他浏览器</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>&lt;audio&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;object&gt;</code>的js控制播放和暂停</p>\n</li>\n</ol>\n<ul>\n<li><code>&lt;audio&gt;</code> : audio.pause() / audio.play();</li>\n<li><code>&lt;embed&gt;</code> : embed.stop() / embed.play();</li>\n<li><code>&lt;object&gt;</code> : obj.controls.stop() / obj.controls.play();</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>项目中经常需要用到视频和音频的插入与控制。但在使用中发现要使浏览器完美地呈现视频和音频并不是那么一件简单的事。各个浏览器不同的解析方式导致这一行为实施起来十分地困难。摸了一大堆石头，发现以下方式是可行的。（我所测试的视频格式swf格式，音频是是mp3格式）</p>","more":"<h2 id=\"flash视频播放\"><a href=\"#flash视频播放\" class=\"headerlink\" title=\"flash视频播放\"></a>flash视频播放</h2><ol>\n<li><code>&lt;video&gt;</code>标签定义视频，比如电影片段或其他视频流。<br>这样就解决问题了吗，不，它不支持IE8及以下。<br><img src=\"/images/201601/videoSuport.png\"></li>\n</ol>\n<p><strong>提示：可以在开始标签和结束标签之间放置文本内容，这样老的浏览器不支持的情况下会显示内部文本。</strong></p>\n<ol start=\"2\">\n<li><p><code>&lt;embed&gt;</code>标签定义嵌入的内容，比如插件。<br>现在行了吗？还是不行。因为<strong>windows平台的IE利用Activex控件来播放flash而其它的浏览器则 使用Netscape插件技术来播放flash。</strong><br>而<code>&lt;embed&gt;</code>标签是用于Netscape Navigator2.0及以后的浏览器或其它支持Netscape插件的浏览器。</p>\n</li>\n<li><p><code>&lt;object&gt;</code>标签标签用于包含对象，比如图像、音频、视频、Java applets、ActiveX、PDF 以及 Flash。<br>浏览器的对象支持有赖于对象类型。不幸的是，主流浏览器都使用不同的代码来加载相同的对象类型。<br>而幸运的是，object 对象提供了解决方案。<strong>如果未显示 object 元素，就会执行位于 <code>&lt;object&gt;</code> 和 <code>&lt;/object&gt;</code> 之间的代码。</strong>通过这种方式，我们能够嵌套多个 object 元素（每个对应一个浏览器）。</p>\n</li>\n</ol>\n<p><strong>注释：<param> 标签定义用于对象的 run-time 设置。</strong></p>\n<p>最后综合一下就行了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object id=&quot;&quot; classid=&quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;</span><br><span class=\"line\">        codebase=&quot;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0&quot;</span><br><span class=\"line\">        WIDTH=&quot;740&quot; HEIGHT=&quot;420&quot; id=&quot;myMovieName&quot;&gt;</span><br><span class=\"line\">            &lt;!-- src --&gt;</span><br><span class=\"line\">            &lt;param name=movie value=&quot;http://www.mafengwo.cn/swf/videoPlayer.swf&quot;&gt;</span><br><span class=\"line\">            &lt;param name=quality value=&quot;high&quot;&gt;</span><br><span class=\"line\">            &lt;param name=bgcolor value=&quot;#000&quot;&gt;</span><br><span class=\"line\">            &lt;param name=allowfullscreen value=&quot;true&quot;&gt;</span><br><span class=\"line\">            &lt;param name=wmode value=&quot;transparent&quot;&gt;</span><br><span class=\"line\">            &lt;param name=allowscriptaccess value=&quot;always&quot;&gt;</span><br><span class=\"line\">            &lt;!-- important --&gt;</span><br><span class=\"line\">            &lt;param name=flashvars value=&quot;userid=06232AA4161AAAB6&amp;amp;videoid=E9A575F51098D4C19C33DC5901307461&amp;amp;mode=api&amp;amp;autostart=false&amp;amp;jscontrol=false&quot;&gt;</span><br><span class=\"line\">            &lt;embed src=&quot;http://www.mafengwo.cn/swf/videoPlayer.swf&quot; quality=&quot;high&quot; bgcolor=&quot;#000&quot; width=&quot;740&quot; height=&quot;420&quot;</span><br><span class=\"line\">                        name=&quot;myMovieName&quot; align=&quot;&quot; type=&quot;application/x-shockwave-flash&quot;</span><br><span class=\"line\">                        pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot; allowfullscreen=&quot;true&quot; allowscriptaccess=&quot;always&quot; wmode=&quot;transparent&quot; flashvars=&quot;userid=06232AA4161AAAB6&amp;amp;videoid=E9A575F51098D4C19C33DC5901307461&amp;amp;mode=api&amp;amp;autostart=false&amp;amp;jscontrol=false&quot;&gt;</span><br><span class=\"line\">            &lt;/embed&gt;</span><br><span class=\"line\">&lt;/object&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>“classid”和“codebase”属性必须要精确地按上例所示的写法写，它们告诉浏览器自动下载flash player的地址。如果你没有安装过flash player 那么IE3.0以后的浏览器会跳出一个提示框访问是否要自动安装flash player。</li>\n<li>“pluginspage”属性告诉浏览器下载flash player的地址，如果还没有安装flash player的话，用户安装完后需要重启浏览器才能正常使用。</li>\n</ul>\n<h2 id=\"音频的播放与控制\"><a href=\"#音频的播放与控制\" class=\"headerlink\" title=\"音频的播放与控制\"></a>音频的播放与控制</h2><ol>\n<li><code>&lt;audio&gt;</code> 标签定义声音，比如音乐或其他音频流。</li>\n</ol>\n<p><strong>提示：可以在开始标签和结束标签之间放置文本内容，这样老的浏览器不支持的情况下会显示内部文本。</strong><br>它与<code>&lt;video&gt;</code>是相似的，它也同样不支持IE8及以下浏览器。</p>\n<ol start=\"2\">\n<li><p><code>&lt;audio&gt;</code>+<code>&lt;embed&gt;</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;audio autoplay=&quot;autoplay&quot; id=&quot;audio&quot;&gt;</span><br><span class=\"line\">  &lt;source src=&#123;&#123;audioSrc&#125;&#125; type=&quot;audio/mp3&quot; /&gt;</span><br><span class=\"line\">  &lt;embed id=&quot;embed&quot; height=&quot;0&quot; type=&quot;audio/mp3&quot; src=&#123;&#123;audioSrc&#125;&#125; name=&quot;sound&quot; MASTERSOUND /&gt;</span><br><span class=\"line\">&lt;/audio&gt;</span><br></pre></td></tr></table></figure>\n<p>经检测火狐无法播放，其他浏览器可以完美呈现。</p>\n</li>\n<li><p><code>&lt;object&gt;</code><br>火狐可以完美播放：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">object</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;&#123;audioSrc&#125;&#125;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;application/x-mplayer2&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;object&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;src&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;audioSrc&#125;&#125;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;autostart&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;playcount&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;infinite&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">object</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>现在，我们可以通过浏览器检测的方式，对不同浏览器采用不同的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(navigator.userAgent.indexOf(<span class=\"string\">&quot;Firefox&quot;</span>)!=-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//火狐</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//其他浏览器</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>&lt;audio&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;object&gt;</code>的js控制播放和暂停</p>\n</li>\n</ol>\n<ul>\n<li><code>&lt;audio&gt;</code> : audio.pause() / audio.play();</li>\n<li><code>&lt;embed&gt;</code> : embed.stop() / embed.play();</li>\n<li><code>&lt;object&gt;</code> : obj.controls.stop() / obj.controls.play();</li>\n</ul>\n<p>我的博客:<a href=\"http://bigdots.github.io/\">http://bigdots.github.io</a>、<a href=\"http://www.cnblogs.com/yzg1/\">http://www.cnblogs.com/yzg1/</a></p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>"},{"_content":"","source":"_posts/箭头函数.md","raw":"","slug":"箭头函数","published":1,"date":"2021-12-06T05:35:02.571Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomx005ay4v20ewob5n1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"让页面拥抱语义化","date":"2015-12-29T09:26:11.000Z","description":"语义化标签 语义化","_content":"\nHTML在页面中的作用就是结构和语义，它通过标记符号来标记要显示的网页中的各个部分，就像是页面的骨架。对一个页面来说，提供一个简洁而又结构分明的HTML是非常必要的。HTML应该是完全脱离表现信息的，其中的标签应该都是语义化地定义了文档的结构。\n\n<!-- more -->\n\n## 为什么要语义化\n\n+ 能让页面呈现清晰的结构\n+ 有利于网页在PDA、手机等移动设备上更好的呈现,因为这些设备对CSS的支持较弱,使用语义标记可以确保这些设备以一种有意义的方式来渲染网页\n+ 有利于SEO,使代码被搜索小蜘蛛更容易的读懂。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重\n+ 语义化的代结构更易于阅读，便于团队的开发和维护\n+ 能让你写出更加优雅的代码\n\n\n## 常用的语义化标签\n\n一、语义化页面结构\n1. `<header></header>`\n用来声明整个页面或任意“section”的头部部分\n\n2. `<nav></nav>`\n用于定义页面的**主要导航部分**\n\n3. `<section></section>`\n代表文档中的“节”或“段”\n\n4. `<footer></footer>`\n用来声明整个页面或任意“section”的底部部分；\n\n---\n\n二、语义化页面内容\n\n0. `h1-h6`\n这个不用多说吧；\n\n1. `<hgroup></hgroup>`\n可以用于有连续多个h1-h6标签的情况，比如文档大纲\n\n2. `<aside></aside>`\n用于主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。\n\n3. `<article></article>`\narticle代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的widget小工具。\n\n4. `<time></time>`\n标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的\n\n5. `<mark></mark>`\n标签定义带有记号的文本。请在需要突出显示文本时使用 `<mark>` 标签。\n\n6. `<figure></figure>`\n规定独立的流内容（插图,图标、源码等等）。该元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响\n\n7. `<figcaption></figcaption>`\n定义 figure 元素的标题\n\n8. `<abbr></abbr>`\n标记一个简称或缩写\n\n9. `<address></address>`\n定义文档或文章的作者/拥有者的联系信息。\n如果 `<address>` 元素位于 `<body>` 元素内，则它表示文档联系信息。\n如果 `<address>` 元素位于 `<article>` 元素内，则它表示文章的联系信息。\n\n10. `<strong></strong>`\n强调内容\n\n11. `<cite></cite>>` \n通常表示它所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。\n\n12. ....\n\n## 浏览器支持\n很多语义化标签是html5的规范，当然IE7/IE8是不支持这些新标签的，所以如果项目中是需要兼容到IE8及以下的，就放弃H5标签吧。（仅指语义化这一块）\n","source":"_posts/语义化标签.md","raw":"title: 让页面拥抱语义化\ndate: 2015-12-29 17:26:11\ntags: [H5]\ndescription: 语义化标签 语义化\n\n---\n\nHTML在页面中的作用就是结构和语义，它通过标记符号来标记要显示的网页中的各个部分，就像是页面的骨架。对一个页面来说，提供一个简洁而又结构分明的HTML是非常必要的。HTML应该是完全脱离表现信息的，其中的标签应该都是语义化地定义了文档的结构。\n\n<!-- more -->\n\n## 为什么要语义化\n\n+ 能让页面呈现清晰的结构\n+ 有利于网页在PDA、手机等移动设备上更好的呈现,因为这些设备对CSS的支持较弱,使用语义标记可以确保这些设备以一种有意义的方式来渲染网页\n+ 有利于SEO,使代码被搜索小蜘蛛更容易的读懂。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重\n+ 语义化的代结构更易于阅读，便于团队的开发和维护\n+ 能让你写出更加优雅的代码\n\n\n## 常用的语义化标签\n\n一、语义化页面结构\n1. `<header></header>`\n用来声明整个页面或任意“section”的头部部分\n\n2. `<nav></nav>`\n用于定义页面的**主要导航部分**\n\n3. `<section></section>`\n代表文档中的“节”或“段”\n\n4. `<footer></footer>`\n用来声明整个页面或任意“section”的底部部分；\n\n---\n\n二、语义化页面内容\n\n0. `h1-h6`\n这个不用多说吧；\n\n1. `<hgroup></hgroup>`\n可以用于有连续多个h1-h6标签的情况，比如文档大纲\n\n2. `<aside></aside>`\n用于主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。\n\n3. `<article></article>`\narticle代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的widget小工具。\n\n4. `<time></time>`\n标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的\n\n5. `<mark></mark>`\n标签定义带有记号的文本。请在需要突出显示文本时使用 `<mark>` 标签。\n\n6. `<figure></figure>`\n规定独立的流内容（插图,图标、源码等等）。该元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响\n\n7. `<figcaption></figcaption>`\n定义 figure 元素的标题\n\n8. `<abbr></abbr>`\n标记一个简称或缩写\n\n9. `<address></address>`\n定义文档或文章的作者/拥有者的联系信息。\n如果 `<address>` 元素位于 `<body>` 元素内，则它表示文档联系信息。\n如果 `<address>` 元素位于 `<article>` 元素内，则它表示文章的联系信息。\n\n10. `<strong></strong>`\n强调内容\n\n11. `<cite></cite>>` \n通常表示它所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。\n\n12. ....\n\n## 浏览器支持\n很多语义化标签是html5的规范，当然IE7/IE8是不支持这些新标签的，所以如果项目中是需要兼容到IE8及以下的，就放弃H5标签吧。（仅指语义化这一块）\n","slug":"语义化标签","published":1,"updated":"2021-12-06T06:07:06.386Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomy005cy4v22q9c09ir","content":"<p>HTML在页面中的作用就是结构和语义，它通过标记符号来标记要显示的网页中的各个部分，就像是页面的骨架。对一个页面来说，提供一个简洁而又结构分明的HTML是非常必要的。HTML应该是完全脱离表现信息的，其中的标签应该都是语义化地定义了文档的结构。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"为什么要语义化\"><a href=\"#为什么要语义化\" class=\"headerlink\" title=\"为什么要语义化\"></a>为什么要语义化</h2><ul>\n<li>能让页面呈现清晰的结构</li>\n<li>有利于网页在PDA、手机等移动设备上更好的呈现,因为这些设备对CSS的支持较弱,使用语义标记可以确保这些设备以一种有意义的方式来渲染网页</li>\n<li>有利于SEO,使代码被搜索小蜘蛛更容易的读懂。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重</li>\n<li>语义化的代结构更易于阅读，便于团队的开发和维护</li>\n<li>能让你写出更加优雅的代码</li>\n</ul>\n<h2 id=\"常用的语义化标签\"><a href=\"#常用的语义化标签\" class=\"headerlink\" title=\"常用的语义化标签\"></a>常用的语义化标签</h2><p>一、语义化页面结构</p>\n<ol>\n<li><p><code>&lt;header&gt;&lt;/header&gt;</code><br>用来声明整个页面或任意“section”的头部部分</p>\n</li>\n<li><p><code>&lt;nav&gt;&lt;/nav&gt;</code><br>用于定义页面的<strong>主要导航部分</strong></p>\n</li>\n<li><p><code>&lt;section&gt;&lt;/section&gt;</code><br>代表文档中的“节”或“段”</p>\n</li>\n<li><p><code>&lt;footer&gt;&lt;/footer&gt;</code><br>用来声明整个页面或任意“section”的底部部分；</p>\n</li>\n</ol>\n<hr>\n<p>二、语义化页面内容</p>\n<ol start=\"0\">\n<li><p><code>h1-h6</code><br>这个不用多说吧；</p>\n</li>\n<li><p><code>&lt;hgroup&gt;&lt;/hgroup&gt;</code><br>可以用于有连续多个h1-h6标签的情况，比如文档大纲</p>\n</li>\n<li><p><code>&lt;aside&gt;&lt;/aside&gt;</code><br>用于主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。</p>\n</li>\n<li><p><code>&lt;article&gt;&lt;/article&gt;</code><br>article代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的widget小工具。</p>\n</li>\n<li><p><code>&lt;time&gt;&lt;/time&gt;</code><br>标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的</p>\n</li>\n<li><p><code>&lt;mark&gt;&lt;/mark&gt;</code><br>标签定义带有记号的文本。请在需要突出显示文本时使用 <code>&lt;mark&gt;</code> 标签。</p>\n</li>\n<li><p><code>&lt;figure&gt;&lt;/figure&gt;</code><br>规定独立的流内容（插图,图标、源码等等）。该元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响</p>\n</li>\n<li><p><code>&lt;figcaption&gt;&lt;/figcaption&gt;</code><br>定义 figure 元素的标题</p>\n</li>\n<li><p><code>&lt;abbr&gt;&lt;/abbr&gt;</code><br>标记一个简称或缩写</p>\n</li>\n<li><p><code>&lt;address&gt;&lt;/address&gt;</code><br>定义文档或文章的作者/拥有者的联系信息。<br>如果 <code>&lt;address&gt;</code> 元素位于 <code>&lt;body&gt;</code> 元素内，则它表示文档联系信息。<br>如果 <code>&lt;address&gt;</code> 元素位于 <code>&lt;article&gt;</code> 元素内，则它表示文章的联系信息。</p>\n</li>\n<li><p><code>&lt;strong&gt;&lt;/strong&gt;</code><br>强调内容</p>\n</li>\n<li><p><code>&lt;cite&gt;&lt;/cite&gt;&gt;</code><br>通常表示它所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。</p>\n</li>\n<li><p>….</p>\n</li>\n</ol>\n<h2 id=\"浏览器支持\"><a href=\"#浏览器支持\" class=\"headerlink\" title=\"浏览器支持\"></a>浏览器支持</h2><p>很多语义化标签是html5的规范，当然IE7/IE8是不支持这些新标签的，所以如果项目中是需要兼容到IE8及以下的，就放弃H5标签吧。（仅指语义化这一块）</p>\n","site":{"data":{}},"excerpt":"<p>HTML在页面中的作用就是结构和语义，它通过标记符号来标记要显示的网页中的各个部分，就像是页面的骨架。对一个页面来说，提供一个简洁而又结构分明的HTML是非常必要的。HTML应该是完全脱离表现信息的，其中的标签应该都是语义化地定义了文档的结构。</p>","more":"<h2 id=\"为什么要语义化\"><a href=\"#为什么要语义化\" class=\"headerlink\" title=\"为什么要语义化\"></a>为什么要语义化</h2><ul>\n<li>能让页面呈现清晰的结构</li>\n<li>有利于网页在PDA、手机等移动设备上更好的呈现,因为这些设备对CSS的支持较弱,使用语义标记可以确保这些设备以一种有意义的方式来渲染网页</li>\n<li>有利于SEO,使代码被搜索小蜘蛛更容易的读懂。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重</li>\n<li>语义化的代结构更易于阅读，便于团队的开发和维护</li>\n<li>能让你写出更加优雅的代码</li>\n</ul>\n<h2 id=\"常用的语义化标签\"><a href=\"#常用的语义化标签\" class=\"headerlink\" title=\"常用的语义化标签\"></a>常用的语义化标签</h2><p>一、语义化页面结构</p>\n<ol>\n<li><p><code>&lt;header&gt;&lt;/header&gt;</code><br>用来声明整个页面或任意“section”的头部部分</p>\n</li>\n<li><p><code>&lt;nav&gt;&lt;/nav&gt;</code><br>用于定义页面的<strong>主要导航部分</strong></p>\n</li>\n<li><p><code>&lt;section&gt;&lt;/section&gt;</code><br>代表文档中的“节”或“段”</p>\n</li>\n<li><p><code>&lt;footer&gt;&lt;/footer&gt;</code><br>用来声明整个页面或任意“section”的底部部分；</p>\n</li>\n</ol>\n<hr>\n<p>二、语义化页面内容</p>\n<ol start=\"0\">\n<li><p><code>h1-h6</code><br>这个不用多说吧；</p>\n</li>\n<li><p><code>&lt;hgroup&gt;&lt;/hgroup&gt;</code><br>可以用于有连续多个h1-h6标签的情况，比如文档大纲</p>\n</li>\n<li><p><code>&lt;aside&gt;&lt;/aside&gt;</code><br>用于主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。</p>\n</li>\n<li><p><code>&lt;article&gt;&lt;/article&gt;</code><br>article代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的widget小工具。</p>\n</li>\n<li><p><code>&lt;time&gt;&lt;/time&gt;</code><br>标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的</p>\n</li>\n<li><p><code>&lt;mark&gt;&lt;/mark&gt;</code><br>标签定义带有记号的文本。请在需要突出显示文本时使用 <code>&lt;mark&gt;</code> 标签。</p>\n</li>\n<li><p><code>&lt;figure&gt;&lt;/figure&gt;</code><br>规定独立的流内容（插图,图标、源码等等）。该元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响</p>\n</li>\n<li><p><code>&lt;figcaption&gt;&lt;/figcaption&gt;</code><br>定义 figure 元素的标题</p>\n</li>\n<li><p><code>&lt;abbr&gt;&lt;/abbr&gt;</code><br>标记一个简称或缩写</p>\n</li>\n<li><p><code>&lt;address&gt;&lt;/address&gt;</code><br>定义文档或文章的作者/拥有者的联系信息。<br>如果 <code>&lt;address&gt;</code> 元素位于 <code>&lt;body&gt;</code> 元素内，则它表示文档联系信息。<br>如果 <code>&lt;address&gt;</code> 元素位于 <code>&lt;article&gt;</code> 元素内，则它表示文章的联系信息。</p>\n</li>\n<li><p><code>&lt;strong&gt;&lt;/strong&gt;</code><br>强调内容</p>\n</li>\n<li><p><code>&lt;cite&gt;&lt;/cite&gt;&gt;</code><br>通常表示它所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。</p>\n</li>\n<li><p>….</p>\n</li>\n</ol>\n<h2 id=\"浏览器支持\"><a href=\"#浏览器支持\" class=\"headerlink\" title=\"浏览器支持\"></a>浏览器支持</h2><p>很多语义化标签是html5的规范，当然IE7/IE8是不支持这些新标签的，所以如果项目中是需要兼容到IE8及以下的，就放弃H5标签吧。（仅指语义化这一块）</p>"},{"_content":"# web性能优化——Dom操作\n\n\nDOM TREE  + CSS => RENDER TREE =>  PAINTING\n\n\n\n### render tree 和dom tree\n\nrender tree不包含隐藏的节点(比如display:none的节点，还有head节点),但注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间\n\n\n### 回流(Reflow)\n+ 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(其实我觉得叫重新布局更简单明了些)。每个页面至少需要一次回流，就是在页面第一次加载的时候。\n\n### 重绘(Repaint)\n\n+ 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。\n注：从上面可以看出，回流必将引起重绘，而重绘不一定会引起回流。\n\n\n\n**回流必将引起重绘，而重绘不一定会引起回流**","source":"_posts/重绘和回流.md","raw":"# web性能优化——Dom操作\n\n\nDOM TREE  + CSS => RENDER TREE =>  PAINTING\n\n\n\n### render tree 和dom tree\n\nrender tree不包含隐藏的节点(比如display:none的节点，还有head节点),但注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间\n\n\n### 回流(Reflow)\n+ 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(其实我觉得叫重新布局更简单明了些)。每个页面至少需要一次回流，就是在页面第一次加载的时候。\n\n### 重绘(Repaint)\n\n+ 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。\n注：从上面可以看出，回流必将引起重绘，而重绘不一定会引起回流。\n\n\n\n**回流必将引起重绘，而重绘不一定会引起回流**","slug":"重绘和回流","published":1,"date":"2021-12-06T05:35:02.591Z","updated":"2018-03-16T08:51:05.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomz005dy4v21zl0btbv","content":"<h1 id=\"web性能优化——Dom操作\"><a href=\"#web性能优化——Dom操作\" class=\"headerlink\" title=\"web性能优化——Dom操作\"></a>web性能优化——Dom操作</h1><p>DOM TREE  + CSS =&gt; RENDER TREE =&gt;  PAINTING</p>\n<h3 id=\"render-tree-和dom-tree\"><a href=\"#render-tree-和dom-tree\" class=\"headerlink\" title=\"render tree 和dom tree\"></a>render tree 和dom tree</h3><p>render tree不包含隐藏的节点(比如display:none的节点，还有head节点),但注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间</p>\n<h3 id=\"回流-Reflow\"><a href=\"#回流-Reflow\" class=\"headerlink\" title=\"回流(Reflow)\"></a>回流(Reflow)</h3><ul>\n<li>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(其实我觉得叫重新布局更简单明了些)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</li>\n</ul>\n<h3 id=\"重绘-Repaint\"><a href=\"#重绘-Repaint\" class=\"headerlink\" title=\"重绘(Repaint)\"></a>重绘(Repaint)</h3><ul>\n<li>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。<br>注：从上面可以看出，回流必将引起重绘，而重绘不一定会引起回流。</li>\n</ul>\n<p><strong>回流必将引起重绘，而重绘不一定会引起回流</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"web性能优化——Dom操作\"><a href=\"#web性能优化——Dom操作\" class=\"headerlink\" title=\"web性能优化——Dom操作\"></a>web性能优化——Dom操作</h1><p>DOM TREE  + CSS =&gt; RENDER TREE =&gt;  PAINTING</p>\n<h3 id=\"render-tree-和dom-tree\"><a href=\"#render-tree-和dom-tree\" class=\"headerlink\" title=\"render tree 和dom tree\"></a>render tree 和dom tree</h3><p>render tree不包含隐藏的节点(比如display:none的节点，还有head节点),但注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间</p>\n<h3 id=\"回流-Reflow\"><a href=\"#回流-Reflow\" class=\"headerlink\" title=\"回流(Reflow)\"></a>回流(Reflow)</h3><ul>\n<li>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(其实我觉得叫重新布局更简单明了些)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</li>\n</ul>\n<h3 id=\"重绘-Repaint\"><a href=\"#重绘-Repaint\" class=\"headerlink\" title=\"重绘(Repaint)\"></a>重绘(Repaint)</h3><ul>\n<li>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。<br>注：从上面可以看出，回流必将引起重绘，而重绘不一定会引起回流。</li>\n</ul>\n<p><strong>回流必将引起重绘，而重绘不一定会引起回流</strong></p>\n"},{"_content":"# 面向对象\n\n\n## 一切皆对象\n\n[]/{}/ -> (Array/Function/RegExp/Date)/(Number/String/Boolean) -> Object\n\n\n一开始null；\n衍生出了Object；\nObject进化出了（Array/Function/RegExp/Date)/(Number/String/Boolean）等工厂，哺乳类，鱼类，鸟类等等\n所以，一切皆对象\n\n```js\n//基本包装类型\n\nvar s1 = \"some text\";\nvar s2 = s1.substring(2);\n\n// 等价于\n\nvar s1 = new String(\"some text\");\nvar s2 = s1.substring(2);\ns1 = null;\n\n//引用类型和基本包装类型区别在于对象的生存期，基本包装类型只存在于一行代码的执行瞬间\n```\n\n\n## 类／构造函数\n\n## 原型对象\n\n## 原型链 (prototype chain)\n\ninstanceof 运算符\n\nObject.getPrototypeOf()\n\nObject.setPrototypeOf()\n\nObject.create()\n\nObject.isPrototypeOf()\n\nObject.prototype.hasOwnProperty()\n\n\n参考文献：\n\n[JavaScript的创世神话——一切源于对象](http://www.jianshu.com/p/0ea4c31d5503)","source":"_posts/面向对象.md","raw":"# 面向对象\n\n\n## 一切皆对象\n\n[]/{}/ -> (Array/Function/RegExp/Date)/(Number/String/Boolean) -> Object\n\n\n一开始null；\n衍生出了Object；\nObject进化出了（Array/Function/RegExp/Date)/(Number/String/Boolean）等工厂，哺乳类，鱼类，鸟类等等\n所以，一切皆对象\n\n```js\n//基本包装类型\n\nvar s1 = \"some text\";\nvar s2 = s1.substring(2);\n\n// 等价于\n\nvar s1 = new String(\"some text\");\nvar s2 = s1.substring(2);\ns1 = null;\n\n//引用类型和基本包装类型区别在于对象的生存期，基本包装类型只存在于一行代码的执行瞬间\n```\n\n\n## 类／构造函数\n\n## 原型对象\n\n## 原型链 (prototype chain)\n\ninstanceof 运算符\n\nObject.getPrototypeOf()\n\nObject.setPrototypeOf()\n\nObject.create()\n\nObject.isPrototypeOf()\n\nObject.prototype.hasOwnProperty()\n\n\n参考文献：\n\n[JavaScript的创世神话——一切源于对象](http://www.jianshu.com/p/0ea4c31d5503)","slug":"面向对象","published":1,"date":"2021-12-06T06:07:06.389Z","updated":"2021-12-06T06:07:06.390Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwomz005fy4v22caf68n7","content":"<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><h2 id=\"一切皆对象\"><a href=\"#一切皆对象\" class=\"headerlink\" title=\"一切皆对象\"></a>一切皆对象</h2><p>[]/{}/ -&gt; (Array/Function/RegExp/Date)/(Number/String/Boolean) -&gt; Object</p>\n<p>一开始null；<br>衍生出了Object；<br>Object进化出了（Array/Function/RegExp/Date)/(Number/String/Boolean）等工厂，哺乳类，鱼类，鸟类等等<br>所以，一切皆对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本包装类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">&quot;some text&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = s1.substring(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;some text&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = s1.substring(<span class=\"number\">2</span>);</span><br><span class=\"line\">s1 = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引用类型和基本包装类型区别在于对象的生存期，基本包装类型只存在于一行代码的执行瞬间</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"类／构造函数\"><a href=\"#类／构造函数\" class=\"headerlink\" title=\"类／构造函数\"></a>类／构造函数</h2><h2 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h2><h2 id=\"原型链-prototype-chain\"><a href=\"#原型链-prototype-chain\" class=\"headerlink\" title=\"原型链 (prototype chain)\"></a>原型链 (prototype chain)</h2><p>instanceof 运算符</p>\n<p>Object.getPrototypeOf()</p>\n<p>Object.setPrototypeOf()</p>\n<p>Object.create()</p>\n<p>Object.isPrototypeOf()</p>\n<p>Object.prototype.hasOwnProperty()</p>\n<p>参考文献：</p>\n<p><a href=\"http://www.jianshu.com/p/0ea4c31d5503\">JavaScript的创世神话——一切源于对象</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><h2 id=\"一切皆对象\"><a href=\"#一切皆对象\" class=\"headerlink\" title=\"一切皆对象\"></a>一切皆对象</h2><p>[]/{}/ -&gt; (Array/Function/RegExp/Date)/(Number/String/Boolean) -&gt; Object</p>\n<p>一开始null；<br>衍生出了Object；<br>Object进化出了（Array/Function/RegExp/Date)/(Number/String/Boolean）等工厂，哺乳类，鱼类，鸟类等等<br>所以，一切皆对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本包装类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">&quot;some text&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = s1.substring(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;some text&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = s1.substring(<span class=\"number\">2</span>);</span><br><span class=\"line\">s1 = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引用类型和基本包装类型区别在于对象的生存期，基本包装类型只存在于一行代码的执行瞬间</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"类／构造函数\"><a href=\"#类／构造函数\" class=\"headerlink\" title=\"类／构造函数\"></a>类／构造函数</h2><h2 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h2><h2 id=\"原型链-prototype-chain\"><a href=\"#原型链-prototype-chain\" class=\"headerlink\" title=\"原型链 (prototype chain)\"></a>原型链 (prototype chain)</h2><p>instanceof 运算符</p>\n<p>Object.getPrototypeOf()</p>\n<p>Object.setPrototypeOf()</p>\n<p>Object.create()</p>\n<p>Object.isPrototypeOf()</p>\n<p>Object.prototype.hasOwnProperty()</p>\n<p>参考文献：</p>\n<p><a href=\"http://www.jianshu.com/p/0ea4c31d5503\">JavaScript的创世神话——一切源于对象</a></p>\n"},{"_content":"# 高性能javascript\n\n### 加载和运行\n\nJavaScript 的阻塞特征：大多数浏览器使用单进程处理UI更新和 JavaScript运行等多个任务,而同一时间只能有一个任务被执行，这意味着`<script>`标签的出现使整个页面因脚本解析、运行而出现等待。\n\n由此而得来的几个优化点：\n\n1. 脚本位置\n\t\n\t由于浏览器在遇到`<body>`标签之前,不会渲染页面的任何部分，所以\n\t将脚本放在底部\n\t\n2. 合并脚本\n\n\t将脚本成组打包。页面的`<script>`标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。\n\n3. 非阻塞脚本（推荐使用[lazyLoad库](https://github.com/rgrove/lazyload/)）\n\t- 延迟脚本\n\t\n\t\t为`<script>`标签添加 defer 属性\n\t\t\n\t- 动态脚本\n\t\n\t\t动态创建`<script>`标签,并添加到页面中，用它下载并执行代码\n\t\t\n\t- xhr脚本注入\n\t\t\n\t\t用 XHR 对象下载代码,并注入到页面中\n\n### 数据访问\n\n在 JavaScript 中,数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型:直接量,变 量,数组项,对象成员。\n\n1. 直接量和局部变量访问速度非常快,数组项和对象成员需要更长时间。\n\n2. 局部变量比域外变量快,因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深,访问所需的时间就越长。全局变量总是最慢的,因为它们总是位于作用域链的最后一环。\n\n3. 避免使用 with 表达式,因为它改变了运行期上下文的作用域链。而且应当小心对待 try-catch 表达式的 catch 子句,因为它具有同样效果。\n\n4. 嵌套对象成员会造成重大性能影响,尽量少用\n\n5. 一个属性或方法在原形链中的位置越深,访问它的速度就越慢。\n\n6. 提高 JavaScript 代码的性能:将经常使用的对象成员,数组项,和域外变量存入局部变量中。然后,访问局部变量的速度会快于那些原始变量。（比如document 是一个全局对象。搜索此变量,必须遍历整个作用域链, 直到最后在全局变量对象中找到它，我们就可以使用局部变量代替它）\n\n### DOM 操作\n\n文档对象模型(DOM)是一个独立于语言的，使用 XML 和 HTML 文档操作的应用程序接口(API)。\n\n天生就慢：两个独立的部分以功能接口连接就会带来性能损耗\r\r1. 轻触DOM，最小化DOM操作\n\n\t- 不要使用循环访问和修改 DOM，可以使用局部变量存放需要反复使用的 DOM 引用\n\t\n\t- 使用innerHTML，而不是document.createElement ()［在老的浏览器效果明显，但新的差异不大］\n\t\n\t- 能clone节点就不要新建\n\t- 使用速度更快的api，例如querySelectorAll()和 firstElementChild\n\n2. 重绘和重排\n\n\t- 批量修改 DOM 样式\n\n\t\t使用cssText集中修改样式\n\t\t\n\t- 离线操作 DOM 树\n\n\t\t需要对 DOM 元素进行多次修改时,通过以下步骤减少重绘和重排版的次数：\n\t\t- 从文档流中摘除该元素（隐藏，复制覆盖）\n\t\t- 对其应用多重改变\n\t\t- 将元素带回文档中\n\t- 通过缓存布局信息来减少对 DOM 的访问，例如进行动画时，缓存初始位置\n\t\n3. 动画脱离文档流\n\n\t排版有时只影响渲染树的一小部分,但也可以影响很大的一部分,甚至整个渲染树。浏览器需要重排版的部分越小,应用程序的响应速度就越快。所以将动画提出文档流，减小渲染树重排的部分。\n\t\n4. 使用事件托管\n\t\n\t事件句柄的负担：\n\n\t- 元素与每个句柄的链接增加了页面负担和运行时间（事件挂接过程都发生在onload(或 DOMContentReady)事件中）\n\n\t- 浏览器需要保存每个句柄的记录,占用更多内存\n\n所以，使用事件托管（只需要在一个包装元素上挂接一个句柄,用于处理子元素发生的所有事件）来达到性能优化。\n\t\n### 算法和流程控制\n\n代码整体结构是执行速度的决定因素之一。代码量少不一定运行速度快,代码量多也不一定运行速度慢。 性能损失与代码组织方式和具体问题解决办法直接相关。\n\n1. 循环\n\n\tJavaScript 提供了的四种循环类型:for、while、do-while、for-in，其中for-in 循环比其他循环明显要慢（由于每次迭代操作要搜索实例或原形的属性）。\n\n\t除 for-in 循环外,其他循环类型性能相当,难以确定哪种循环更快。所以选择循环类型应基于需求而不是性能。\n\n\t优化着力点：\n\t\n\t- 每次迭代的工作量\n\t- 迭代的次数\n\n2. 条件表达式\n\n\t条件数量较大,使用 switch，条件数量小则使用if－else：\n\t- 易于阅读，如果条件较少时,if-else 容易阅读,而条件较多时 switch 更容易阅读。\n\t- 性能更佳，多数情况下 switch 表达式比 if-else 更快一点,但只有当条件体数量很大时这种性能差距才明显。\n\t\n\t优化点：\n\t\n\t- 最小化找到正确分支之前所判断条件体的数量\n\n\t\t- 将最常见的条件体放在首位\n\t\t- 使用嵌套表达式缩小查找范围\n\t- 查表法(测试的离散值数量非常大时）\n\t\n\t\t消除所有条件判断。操作转换成一个数组项查询或者一个对象成员查询。\n\t\t\n3. 递归（再学习，表示不懂）\n\t- 调用栈限制\n\t\n\t\tJavaScript 引擎所支持的递归数量与 JavaScript 调用栈大小直接相关。当你使用了太多的递归,超过最大调用栈尺寸时,浏览器会出错\n\t- 递归模式\n\t- 迭代\n\t- 制表\n\n### 字符串和正则表达式（再看）\n1. 字符串链接\n\t- IE7 和它的早期版本上, jion性能更优\n\t- 现代浏览器，使用简单的+和+=性能更优，但是要避免使用临时字符串\n\n\n### 响应接口\n","source":"_posts/高性能javascript.md","raw":"# 高性能javascript\n\n### 加载和运行\n\nJavaScript 的阻塞特征：大多数浏览器使用单进程处理UI更新和 JavaScript运行等多个任务,而同一时间只能有一个任务被执行，这意味着`<script>`标签的出现使整个页面因脚本解析、运行而出现等待。\n\n由此而得来的几个优化点：\n\n1. 脚本位置\n\t\n\t由于浏览器在遇到`<body>`标签之前,不会渲染页面的任何部分，所以\n\t将脚本放在底部\n\t\n2. 合并脚本\n\n\t将脚本成组打包。页面的`<script>`标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。\n\n3. 非阻塞脚本（推荐使用[lazyLoad库](https://github.com/rgrove/lazyload/)）\n\t- 延迟脚本\n\t\n\t\t为`<script>`标签添加 defer 属性\n\t\t\n\t- 动态脚本\n\t\n\t\t动态创建`<script>`标签,并添加到页面中，用它下载并执行代码\n\t\t\n\t- xhr脚本注入\n\t\t\n\t\t用 XHR 对象下载代码,并注入到页面中\n\n### 数据访问\n\n在 JavaScript 中,数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型:直接量,变 量,数组项,对象成员。\n\n1. 直接量和局部变量访问速度非常快,数组项和对象成员需要更长时间。\n\n2. 局部变量比域外变量快,因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深,访问所需的时间就越长。全局变量总是最慢的,因为它们总是位于作用域链的最后一环。\n\n3. 避免使用 with 表达式,因为它改变了运行期上下文的作用域链。而且应当小心对待 try-catch 表达式的 catch 子句,因为它具有同样效果。\n\n4. 嵌套对象成员会造成重大性能影响,尽量少用\n\n5. 一个属性或方法在原形链中的位置越深,访问它的速度就越慢。\n\n6. 提高 JavaScript 代码的性能:将经常使用的对象成员,数组项,和域外变量存入局部变量中。然后,访问局部变量的速度会快于那些原始变量。（比如document 是一个全局对象。搜索此变量,必须遍历整个作用域链, 直到最后在全局变量对象中找到它，我们就可以使用局部变量代替它）\n\n### DOM 操作\n\n文档对象模型(DOM)是一个独立于语言的，使用 XML 和 HTML 文档操作的应用程序接口(API)。\n\n天生就慢：两个独立的部分以功能接口连接就会带来性能损耗\r\r1. 轻触DOM，最小化DOM操作\n\n\t- 不要使用循环访问和修改 DOM，可以使用局部变量存放需要反复使用的 DOM 引用\n\t\n\t- 使用innerHTML，而不是document.createElement ()［在老的浏览器效果明显，但新的差异不大］\n\t\n\t- 能clone节点就不要新建\n\t- 使用速度更快的api，例如querySelectorAll()和 firstElementChild\n\n2. 重绘和重排\n\n\t- 批量修改 DOM 样式\n\n\t\t使用cssText集中修改样式\n\t\t\n\t- 离线操作 DOM 树\n\n\t\t需要对 DOM 元素进行多次修改时,通过以下步骤减少重绘和重排版的次数：\n\t\t- 从文档流中摘除该元素（隐藏，复制覆盖）\n\t\t- 对其应用多重改变\n\t\t- 将元素带回文档中\n\t- 通过缓存布局信息来减少对 DOM 的访问，例如进行动画时，缓存初始位置\n\t\n3. 动画脱离文档流\n\n\t排版有时只影响渲染树的一小部分,但也可以影响很大的一部分,甚至整个渲染树。浏览器需要重排版的部分越小,应用程序的响应速度就越快。所以将动画提出文档流，减小渲染树重排的部分。\n\t\n4. 使用事件托管\n\t\n\t事件句柄的负担：\n\n\t- 元素与每个句柄的链接增加了页面负担和运行时间（事件挂接过程都发生在onload(或 DOMContentReady)事件中）\n\n\t- 浏览器需要保存每个句柄的记录,占用更多内存\n\n所以，使用事件托管（只需要在一个包装元素上挂接一个句柄,用于处理子元素发生的所有事件）来达到性能优化。\n\t\n### 算法和流程控制\n\n代码整体结构是执行速度的决定因素之一。代码量少不一定运行速度快,代码量多也不一定运行速度慢。 性能损失与代码组织方式和具体问题解决办法直接相关。\n\n1. 循环\n\n\tJavaScript 提供了的四种循环类型:for、while、do-while、for-in，其中for-in 循环比其他循环明显要慢（由于每次迭代操作要搜索实例或原形的属性）。\n\n\t除 for-in 循环外,其他循环类型性能相当,难以确定哪种循环更快。所以选择循环类型应基于需求而不是性能。\n\n\t优化着力点：\n\t\n\t- 每次迭代的工作量\n\t- 迭代的次数\n\n2. 条件表达式\n\n\t条件数量较大,使用 switch，条件数量小则使用if－else：\n\t- 易于阅读，如果条件较少时,if-else 容易阅读,而条件较多时 switch 更容易阅读。\n\t- 性能更佳，多数情况下 switch 表达式比 if-else 更快一点,但只有当条件体数量很大时这种性能差距才明显。\n\t\n\t优化点：\n\t\n\t- 最小化找到正确分支之前所判断条件体的数量\n\n\t\t- 将最常见的条件体放在首位\n\t\t- 使用嵌套表达式缩小查找范围\n\t- 查表法(测试的离散值数量非常大时）\n\t\n\t\t消除所有条件判断。操作转换成一个数组项查询或者一个对象成员查询。\n\t\t\n3. 递归（再学习，表示不懂）\n\t- 调用栈限制\n\t\n\t\tJavaScript 引擎所支持的递归数量与 JavaScript 调用栈大小直接相关。当你使用了太多的递归,超过最大调用栈尺寸时,浏览器会出错\n\t- 递归模式\n\t- 迭代\n\t- 制表\n\n### 字符串和正则表达式（再看）\n1. 字符串链接\n\t- IE7 和它的早期版本上, jion性能更优\n\t- 现代浏览器，使用简单的+和+=性能更优，但是要避免使用临时字符串\n\n\n### 响应接口\n","slug":"高性能javascript","published":1,"date":"2021-12-06T06:07:06.393Z","updated":"2021-12-06T06:07:06.394Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwubwon0005gy4v2gp2a6r2a","content":"<h1 id=\"高性能javascript\"><a href=\"#高性能javascript\" class=\"headerlink\" title=\"高性能javascript\"></a>高性能javascript</h1><h3 id=\"加载和运行\"><a href=\"#加载和运行\" class=\"headerlink\" title=\"加载和运行\"></a>加载和运行</h3><p>JavaScript 的阻塞特征：大多数浏览器使用单进程处理UI更新和 JavaScript运行等多个任务,而同一时间只能有一个任务被执行，这意味着<code>&lt;script&gt;</code>标签的出现使整个页面因脚本解析、运行而出现等待。</p>\n<p>由此而得来的几个优化点：</p>\n<ol>\n<li><p>脚本位置</p>\n<p> 由于浏览器在遇到<code>&lt;body&gt;</code>标签之前,不会渲染页面的任何部分，所以<br> 将脚本放在底部</p>\n</li>\n<li><p>合并脚本</p>\n<p> 将脚本成组打包。页面的<code>&lt;script&gt;</code>标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。</p>\n</li>\n<li><p>非阻塞脚本（推荐使用<a href=\"https://github.com/rgrove/lazyload/\">lazyLoad库</a>）</p>\n<ul>\n<li>延迟脚本  为<code>&lt;script&gt;</code>标签添加 defer 属性</li>\n<li>动态脚本  动态创建<code>&lt;script&gt;</code>标签,并添加到页面中，用它下载并执行代码</li>\n<li>xhr脚本注入  用 XHR 对象下载代码,并注入到页面中</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"数据访问\"><a href=\"#数据访问\" class=\"headerlink\" title=\"数据访问\"></a>数据访问</h3><p>在 JavaScript 中,数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型:直接量,变 量,数组项,对象成员。</p>\n<ol>\n<li><p>直接量和局部变量访问速度非常快,数组项和对象成员需要更长时间。</p>\n</li>\n<li><p>局部变量比域外变量快,因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深,访问所需的时间就越长。全局变量总是最慢的,因为它们总是位于作用域链的最后一环。</p>\n</li>\n<li><p>避免使用 with 表达式,因为它改变了运行期上下文的作用域链。而且应当小心对待 try-catch 表达式的 catch 子句,因为它具有同样效果。</p>\n</li>\n<li><p>嵌套对象成员会造成重大性能影响,尽量少用</p>\n</li>\n<li><p>一个属性或方法在原形链中的位置越深,访问它的速度就越慢。</p>\n</li>\n<li><p>提高 JavaScript 代码的性能:将经常使用的对象成员,数组项,和域外变量存入局部变量中。然后,访问局部变量的速度会快于那些原始变量。（比如document 是一个全局对象。搜索此变量,必须遍历整个作用域链, 直到最后在全局变量对象中找到它，我们就可以使用局部变量代替它）</p>\n</li>\n</ol>\n<h3 id=\"DOM-操作\"><a href=\"#DOM-操作\" class=\"headerlink\" title=\"DOM 操作\"></a>DOM 操作</h3><p>文档对象模型(DOM)是一个独立于语言的，使用 XML 和 HTML 文档操作的应用程序接口(API)。</p>\n<p>天生就慢：两个独立的部分以功能接口连接就会带来性能损耗</p>\n<ol>\n<li><p>轻触DOM，最小化DOM操作</p>\n<ul>\n<li>不要使用循环访问和修改 DOM，可以使用局部变量存放需要反复使用的 DOM 引用</li>\n<li>使用innerHTML，而不是document.createElement ()［在老的浏览器效果明显，但新的差异不大］</li>\n<li>能clone节点就不要新建</li>\n<li>使用速度更快的api，例如querySelectorAll()和 firstElementChild</li>\n</ul>\n</li>\n<li><p>重绘和重排</p>\n<ul>\n<li><p>批量修改 DOM 样式</p>\n<p>  使用cssText集中修改样式</p>\n</li>\n<li><p>离线操作 DOM 树</p>\n<p>  需要对 DOM 元素进行多次修改时,通过以下步骤减少重绘和重排版的次数：</p>\n<ul>\n<li>从文档流中摘除该元素（隐藏，复制覆盖）</li>\n<li>对其应用多重改变</li>\n<li>将元素带回文档中</li>\n</ul>\n</li>\n<li><p>通过缓存布局信息来减少对 DOM 的访问，例如进行动画时，缓存初始位置</p>\n</li>\n</ul>\n</li>\n<li><p>动画脱离文档流</p>\n<p> 排版有时只影响渲染树的一小部分,但也可以影响很大的一部分,甚至整个渲染树。浏览器需要重排版的部分越小,应用程序的响应速度就越快。所以将动画提出文档流，减小渲染树重排的部分。</p>\n</li>\n<li><p>使用事件托管</p>\n<p> 事件句柄的负担：</p>\n<ul>\n<li><p>元素与每个句柄的链接增加了页面负担和运行时间（事件挂接过程都发生在onload(或 DOMContentReady)事件中）</p>\n</li>\n<li><p>浏览器需要保存每个句柄的记录,占用更多内存</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>所以，使用事件托管（只需要在一个包装元素上挂接一个句柄,用于处理子元素发生的所有事件）来达到性能优化。</p>\n<h3 id=\"算法和流程控制\"><a href=\"#算法和流程控制\" class=\"headerlink\" title=\"算法和流程控制\"></a>算法和流程控制</h3><p>代码整体结构是执行速度的决定因素之一。代码量少不一定运行速度快,代码量多也不一定运行速度慢。 性能损失与代码组织方式和具体问题解决办法直接相关。</p>\n<ol>\n<li><p>循环</p>\n<p> JavaScript 提供了的四种循环类型:for、while、do-while、for-in，其中for-in 循环比其他循环明显要慢（由于每次迭代操作要搜索实例或原形的属性）。</p>\n<p> 除 for-in 循环外,其他循环类型性能相当,难以确定哪种循环更快。所以选择循环类型应基于需求而不是性能。</p>\n<p> 优化着力点：</p>\n<ul>\n<li>每次迭代的工作量</li>\n<li>迭代的次数</li>\n</ul>\n</li>\n<li><p>条件表达式</p>\n<p> 条件数量较大,使用 switch，条件数量小则使用if－else：</p>\n<ul>\n<li>易于阅读，如果条件较少时,if-else 容易阅读,而条件较多时 switch 更容易阅读。</li>\n<li>性能更佳，多数情况下 switch 表达式比 if-else 更快一点,但只有当条件体数量很大时这种性能差距才明显。</li>\n</ul>\n<p> 优化点：</p>\n<ul>\n<li><p>最小化找到正确分支之前所判断条件体的数量</p>\n<ul>\n<li>将最常见的条件体放在首位</li>\n<li>使用嵌套表达式缩小查找范围</li>\n</ul>\n</li>\n<li><p>查表法(测试的离散值数量非常大时）</p>\n<p>  消除所有条件判断。操作转换成一个数组项查询或者一个对象成员查询。</p>\n</li>\n</ul>\n</li>\n<li><p>递归（再学习，表示不懂）</p>\n<ul>\n<li>调用栈限制  JavaScript 引擎所支持的递归数量与 JavaScript 调用栈大小直接相关。当你使用了太多的递归,超过最大调用栈尺寸时,浏览器会出错</li>\n<li>递归模式</li>\n<li>迭代</li>\n<li>制表</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"字符串和正则表达式（再看）\"><a href=\"#字符串和正则表达式（再看）\" class=\"headerlink\" title=\"字符串和正则表达式（再看）\"></a>字符串和正则表达式（再看）</h3><ol>\n<li>字符串链接<ul>\n<li>IE7 和它的早期版本上, jion性能更优</li>\n<li>现代浏览器，使用简单的+和+=性能更优，但是要避免使用临时字符串</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"响应接口\"><a href=\"#响应接口\" class=\"headerlink\" title=\"响应接口\"></a>响应接口</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"高性能javascript\"><a href=\"#高性能javascript\" class=\"headerlink\" title=\"高性能javascript\"></a>高性能javascript</h1><h3 id=\"加载和运行\"><a href=\"#加载和运行\" class=\"headerlink\" title=\"加载和运行\"></a>加载和运行</h3><p>JavaScript 的阻塞特征：大多数浏览器使用单进程处理UI更新和 JavaScript运行等多个任务,而同一时间只能有一个任务被执行，这意味着<code>&lt;script&gt;</code>标签的出现使整个页面因脚本解析、运行而出现等待。</p>\n<p>由此而得来的几个优化点：</p>\n<ol>\n<li><p>脚本位置</p>\n<p> 由于浏览器在遇到<code>&lt;body&gt;</code>标签之前,不会渲染页面的任何部分，所以<br> 将脚本放在底部</p>\n</li>\n<li><p>合并脚本</p>\n<p> 将脚本成组打包。页面的<code>&lt;script&gt;</code>标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。</p>\n</li>\n<li><p>非阻塞脚本（推荐使用<a href=\"https://github.com/rgrove/lazyload/\">lazyLoad库</a>）</p>\n<ul>\n<li>延迟脚本  为<code>&lt;script&gt;</code>标签添加 defer 属性</li>\n<li>动态脚本  动态创建<code>&lt;script&gt;</code>标签,并添加到页面中，用它下载并执行代码</li>\n<li>xhr脚本注入  用 XHR 对象下载代码,并注入到页面中</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"数据访问\"><a href=\"#数据访问\" class=\"headerlink\" title=\"数据访问\"></a>数据访问</h3><p>在 JavaScript 中,数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型:直接量,变 量,数组项,对象成员。</p>\n<ol>\n<li><p>直接量和局部变量访问速度非常快,数组项和对象成员需要更长时间。</p>\n</li>\n<li><p>局部变量比域外变量快,因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深,访问所需的时间就越长。全局变量总是最慢的,因为它们总是位于作用域链的最后一环。</p>\n</li>\n<li><p>避免使用 with 表达式,因为它改变了运行期上下文的作用域链。而且应当小心对待 try-catch 表达式的 catch 子句,因为它具有同样效果。</p>\n</li>\n<li><p>嵌套对象成员会造成重大性能影响,尽量少用</p>\n</li>\n<li><p>一个属性或方法在原形链中的位置越深,访问它的速度就越慢。</p>\n</li>\n<li><p>提高 JavaScript 代码的性能:将经常使用的对象成员,数组项,和域外变量存入局部变量中。然后,访问局部变量的速度会快于那些原始变量。（比如document 是一个全局对象。搜索此变量,必须遍历整个作用域链, 直到最后在全局变量对象中找到它，我们就可以使用局部变量代替它）</p>\n</li>\n</ol>\n<h3 id=\"DOM-操作\"><a href=\"#DOM-操作\" class=\"headerlink\" title=\"DOM 操作\"></a>DOM 操作</h3><p>文档对象模型(DOM)是一个独立于语言的，使用 XML 和 HTML 文档操作的应用程序接口(API)。</p>\n<p>天生就慢：两个独立的部分以功能接口连接就会带来性能损耗</p>\n<ol>\n<li><p>轻触DOM，最小化DOM操作</p>\n<ul>\n<li>不要使用循环访问和修改 DOM，可以使用局部变量存放需要反复使用的 DOM 引用</li>\n<li>使用innerHTML，而不是document.createElement ()［在老的浏览器效果明显，但新的差异不大］</li>\n<li>能clone节点就不要新建</li>\n<li>使用速度更快的api，例如querySelectorAll()和 firstElementChild</li>\n</ul>\n</li>\n<li><p>重绘和重排</p>\n<ul>\n<li><p>批量修改 DOM 样式</p>\n<p>  使用cssText集中修改样式</p>\n</li>\n<li><p>离线操作 DOM 树</p>\n<p>  需要对 DOM 元素进行多次修改时,通过以下步骤减少重绘和重排版的次数：</p>\n<ul>\n<li>从文档流中摘除该元素（隐藏，复制覆盖）</li>\n<li>对其应用多重改变</li>\n<li>将元素带回文档中</li>\n</ul>\n</li>\n<li><p>通过缓存布局信息来减少对 DOM 的访问，例如进行动画时，缓存初始位置</p>\n</li>\n</ul>\n</li>\n<li><p>动画脱离文档流</p>\n<p> 排版有时只影响渲染树的一小部分,但也可以影响很大的一部分,甚至整个渲染树。浏览器需要重排版的部分越小,应用程序的响应速度就越快。所以将动画提出文档流，减小渲染树重排的部分。</p>\n</li>\n<li><p>使用事件托管</p>\n<p> 事件句柄的负担：</p>\n<ul>\n<li><p>元素与每个句柄的链接增加了页面负担和运行时间（事件挂接过程都发生在onload(或 DOMContentReady)事件中）</p>\n</li>\n<li><p>浏览器需要保存每个句柄的记录,占用更多内存</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>所以，使用事件托管（只需要在一个包装元素上挂接一个句柄,用于处理子元素发生的所有事件）来达到性能优化。</p>\n<h3 id=\"算法和流程控制\"><a href=\"#算法和流程控制\" class=\"headerlink\" title=\"算法和流程控制\"></a>算法和流程控制</h3><p>代码整体结构是执行速度的决定因素之一。代码量少不一定运行速度快,代码量多也不一定运行速度慢。 性能损失与代码组织方式和具体问题解决办法直接相关。</p>\n<ol>\n<li><p>循环</p>\n<p> JavaScript 提供了的四种循环类型:for、while、do-while、for-in，其中for-in 循环比其他循环明显要慢（由于每次迭代操作要搜索实例或原形的属性）。</p>\n<p> 除 for-in 循环外,其他循环类型性能相当,难以确定哪种循环更快。所以选择循环类型应基于需求而不是性能。</p>\n<p> 优化着力点：</p>\n<ul>\n<li>每次迭代的工作量</li>\n<li>迭代的次数</li>\n</ul>\n</li>\n<li><p>条件表达式</p>\n<p> 条件数量较大,使用 switch，条件数量小则使用if－else：</p>\n<ul>\n<li>易于阅读，如果条件较少时,if-else 容易阅读,而条件较多时 switch 更容易阅读。</li>\n<li>性能更佳，多数情况下 switch 表达式比 if-else 更快一点,但只有当条件体数量很大时这种性能差距才明显。</li>\n</ul>\n<p> 优化点：</p>\n<ul>\n<li><p>最小化找到正确分支之前所判断条件体的数量</p>\n<ul>\n<li>将最常见的条件体放在首位</li>\n<li>使用嵌套表达式缩小查找范围</li>\n</ul>\n</li>\n<li><p>查表法(测试的离散值数量非常大时）</p>\n<p>  消除所有条件判断。操作转换成一个数组项查询或者一个对象成员查询。</p>\n</li>\n</ul>\n</li>\n<li><p>递归（再学习，表示不懂）</p>\n<ul>\n<li>调用栈限制  JavaScript 引擎所支持的递归数量与 JavaScript 调用栈大小直接相关。当你使用了太多的递归,超过最大调用栈尺寸时,浏览器会出错</li>\n<li>递归模式</li>\n<li>迭代</li>\n<li>制表</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"字符串和正则表达式（再看）\"><a href=\"#字符串和正则表达式（再看）\" class=\"headerlink\" title=\"字符串和正则表达式（再看）\"></a>字符串和正则表达式（再看）</h3><ol>\n<li>字符串链接<ul>\n<li>IE7 和它的早期版本上, jion性能更优</li>\n<li>现代浏览器，使用简单的+和+=性能更优，但是要避免使用临时字符串</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"响应接口\"><a href=\"#响应接口\" class=\"headerlink\" title=\"响应接口\"></a>响应接口</h3>"},{"_content":"## 类型判断\n\n`typeof`\n\n`Object.prototype.toString`  [object NativeConstructorName]\n\n不能检测非原生构造函数的构造函数名。\n\n## 作用域\n\n\n## 引用传递\n\n- 值传递: 实际参数把它的值传递给对应的形式参数，形参不会改变实参\n- 引用传递: 实际参数与形式参数指向同一个地址，形参会改变实参\n\njavascript 中实际上没有引用传递只是传递引用。直接修改形参不会改变实参，但是修改形参的内部属性则会改变实参。\n\n```javascript\nfunction changeStuff(a, b, c){ // 把10（值）传递给a,把{item: \"unchanged\"}（引用）传递给把b,c\n    a = a * 10; \n    b.item = \"changed\"; // 改变了引用内的属性，所以实参obj1也改变\n    c = {item: \"changed\"};  // 把新的引用传递给了c，所以实参不变\n}\n\nvar num = 10;\nvar obj1 = {item: \"unchanged\"};\nvar obj2 = {item: \"unchanged\"};\n\nchangeStuff(num, obj1, obj2);\n\nconsole.log(num);\nconsole.log(obj1.item);    \nconsole.log(obj2.item); \n```\n\n## 内存释放\n\n> 内存泄露指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放。即一块被分配的内存既不能使用，又不能回收\n\nGC（garbage collection）是一种自动管理应用内存的机制。GC 的工作是回收被未使用的对象所占用的内存。它判断对象不再使用的方式是没有其他的对象引用它们。\n\n1. 易导致内存泄漏的情景：\n\n    + 全局变量\n\n    + 闭包\n        ```javascript\n        var theThing = null  \n        var replaceThing = function () {\n        var originalThing = theThing\n        var unused = function () {\n            if (originalThing)\n            console.log(\"hi\")\n        }\n        theThing = {\n            longStr: new Array(1000000).join('*'),\n            someMethod: function () {\n            console.log(someMessage)\n            }\n        };\n        };\n        setInterval(replaceThing, 1000)\n        ```\n        replaceThing函数的操作是赋予theThing新的值， setInterval每次循环都新建一个作用域对象，theThing的引用地址不断在变化，正常情况下旧的引用对象就应该被垃圾回收了，\n        但由于unused引用了旧的对象originalThing，originalThing又一个私有变量，所以旧的作用域对象无法被垃圾回收，就造成了内存泄露。\n\n\n2. 以下操作是否爆内存：\n\n    ```javascript\n    let arr = [];\n    while(true)\n    arr.push(1);\n    ```\n    会一直执行，数组长度无限增加，内存会爆。\n\n    ```javascript\n    let arr = [];\n    while(true)\n    arr.push();\n    ```\n    待定\n\n    ```javascript\n    let arr = [];\n    while(true)\n    arr.push(new Buffer(1000));\n    ```\n    Buffer 在 V8 堆外分配物理内存。所以内存会在服務器内存被全部占掉的时候爆掉。\n\n## ES6 新特性\n\n1. 新增数据结构：\n\n    + Set： 类似于数组，但是成员的值都是唯一的，没有重复的值。\n\n        内部利用类似于`===`来判断值是否相等（唯一区别是这里NaN等于自身）。\n\n    + Map： 类似于对象，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，提供了“值—值”的对应。\n\n        ```javascript\n            const map = new Map();\n\n            map.set(1, 'aaa');\n            map.get(1) //\"aaa\"\n        ```\n\n2. 扩展运算符\n\n    `...`： 将一个数组转为用逗号分隔的参数序列，主要用于函数调用。\n\n    ```javascript\n        function add(x,y,z){\n            return x+y+z\n        }\n\n        add(...[1,2,3]) //6 会转化成 add(1,2,3)\n    ```\n\n3. 第七种数据类型：\n\n    symbol： 表示独一无二的值。基本上，它是一种类似于字符串的数据类型。\n\n    ```javascript\n    var s1 = Symbol('foo');\n    ```\n\n4. 箭头函数 与 function 的区别：\n\n    + 箭头函数内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n    + 不可以当作构造函数\n    + 不可以使用arguments对象\n    + 不可以使用yield命令\n\n\n实现数据的私有\n\nconst 定义的 Array 中间元素能否被修改? 如果可以, 那 const 修饰对象有什么意义?\n\nclass, \n","source":"_posts/基础.md","raw":"## 类型判断\n\n`typeof`\n\n`Object.prototype.toString`  [object NativeConstructorName]\n\n不能检测非原生构造函数的构造函数名。\n\n## 作用域\n\n\n## 引用传递\n\n- 值传递: 实际参数把它的值传递给对应的形式参数，形参不会改变实参\n- 引用传递: 实际参数与形式参数指向同一个地址，形参会改变实参\n\njavascript 中实际上没有引用传递只是传递引用。直接修改形参不会改变实参，但是修改形参的内部属性则会改变实参。\n\n```javascript\nfunction changeStuff(a, b, c){ // 把10（值）传递给a,把{item: \"unchanged\"}（引用）传递给把b,c\n    a = a * 10; \n    b.item = \"changed\"; // 改变了引用内的属性，所以实参obj1也改变\n    c = {item: \"changed\"};  // 把新的引用传递给了c，所以实参不变\n}\n\nvar num = 10;\nvar obj1 = {item: \"unchanged\"};\nvar obj2 = {item: \"unchanged\"};\n\nchangeStuff(num, obj1, obj2);\n\nconsole.log(num);\nconsole.log(obj1.item);    \nconsole.log(obj2.item); \n```\n\n## 内存释放\n\n> 内存泄露指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放。即一块被分配的内存既不能使用，又不能回收\n\nGC（garbage collection）是一种自动管理应用内存的机制。GC 的工作是回收被未使用的对象所占用的内存。它判断对象不再使用的方式是没有其他的对象引用它们。\n\n1. 易导致内存泄漏的情景：\n\n    + 全局变量\n\n    + 闭包\n        ```javascript\n        var theThing = null  \n        var replaceThing = function () {\n        var originalThing = theThing\n        var unused = function () {\n            if (originalThing)\n            console.log(\"hi\")\n        }\n        theThing = {\n            longStr: new Array(1000000).join('*'),\n            someMethod: function () {\n            console.log(someMessage)\n            }\n        };\n        };\n        setInterval(replaceThing, 1000)\n        ```\n        replaceThing函数的操作是赋予theThing新的值， setInterval每次循环都新建一个作用域对象，theThing的引用地址不断在变化，正常情况下旧的引用对象就应该被垃圾回收了，\n        但由于unused引用了旧的对象originalThing，originalThing又一个私有变量，所以旧的作用域对象无法被垃圾回收，就造成了内存泄露。\n\n\n2. 以下操作是否爆内存：\n\n    ```javascript\n    let arr = [];\n    while(true)\n    arr.push(1);\n    ```\n    会一直执行，数组长度无限增加，内存会爆。\n\n    ```javascript\n    let arr = [];\n    while(true)\n    arr.push();\n    ```\n    待定\n\n    ```javascript\n    let arr = [];\n    while(true)\n    arr.push(new Buffer(1000));\n    ```\n    Buffer 在 V8 堆外分配物理内存。所以内存会在服務器内存被全部占掉的时候爆掉。\n\n## ES6 新特性\n\n1. 新增数据结构：\n\n    + Set： 类似于数组，但是成员的值都是唯一的，没有重复的值。\n\n        内部利用类似于`===`来判断值是否相等（唯一区别是这里NaN等于自身）。\n\n    + Map： 类似于对象，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，提供了“值—值”的对应。\n\n        ```javascript\n            const map = new Map();\n\n            map.set(1, 'aaa');\n            map.get(1) //\"aaa\"\n        ```\n\n2. 扩展运算符\n\n    `...`： 将一个数组转为用逗号分隔的参数序列，主要用于函数调用。\n\n    ```javascript\n        function add(x,y,z){\n            return x+y+z\n        }\n\n        add(...[1,2,3]) //6 会转化成 add(1,2,3)\n    ```\n\n3. 第七种数据类型：\n\n    symbol： 表示独一无二的值。基本上，它是一种类似于字符串的数据类型。\n\n    ```javascript\n    var s1 = Symbol('foo');\n    ```\n\n4. 箭头函数 与 function 的区别：\n\n    + 箭头函数内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n    + 不可以当作构造函数\n    + 不可以使用arguments对象\n    + 不可以使用yield命令\n\n\n实现数据的私有\n\nconst 定义的 Array 中间元素能否被修改? 如果可以, 那 const 修饰对象有什么意义?\n\nclass, \n","slug":"基础","published":1,"date":"2021-12-06T05:35:02.621Z","updated":"2021-12-06T07:05:50.512Z","_id":"ckwubxpsu005hy4v2ewdibtk2","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h2><p><code>typeof</code></p>\n<p><code>Object.prototype.toString</code>  [object NativeConstructorName]</p>\n<p>不能检测非原生构造函数的构造函数名。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><h2 id=\"引用传递\"><a href=\"#引用传递\" class=\"headerlink\" title=\"引用传递\"></a>引用传递</h2><ul>\n<li>值传递: 实际参数把它的值传递给对应的形式参数，形参不会改变实参</li>\n<li>引用传递: 实际参数与形式参数指向同一个地址，形参会改变实参</li>\n</ul>\n<p>javascript 中实际上没有引用传递只是传递引用。直接修改形参不会改变实参，但是修改形参的内部属性则会改变实参。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeStuff</span>(<span class=\"params\">a, b, c</span>)</span>&#123; <span class=\"comment\">// 把10（值）传递给a,把&#123;item: &quot;unchanged&quot;&#125;（引用）传递给把b,c</span></span><br><span class=\"line\">    a = a * <span class=\"number\">10</span>; </span><br><span class=\"line\">    b.item = <span class=\"string\">&quot;changed&quot;</span>; <span class=\"comment\">// 改变了引用内的属性，所以实参obj1也改变</span></span><br><span class=\"line\">    c = &#123;<span class=\"attr\">item</span>: <span class=\"string\">&quot;changed&quot;</span>&#125;;  <span class=\"comment\">// 把新的引用传递给了c，所以实参不变</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;<span class=\"attr\">item</span>: <span class=\"string\">&quot;unchanged&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;<span class=\"attr\">item</span>: <span class=\"string\">&quot;unchanged&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">changeStuff(num, obj1, obj2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.item);    </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.item); </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内存释放\"><a href=\"#内存释放\" class=\"headerlink\" title=\"内存释放\"></a>内存释放</h2><blockquote>\n<p>内存泄露指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放。即一块被分配的内存既不能使用，又不能回收</p>\n</blockquote>\n<p>GC（garbage collection）是一种自动管理应用内存的机制。GC 的工作是回收被未使用的对象所占用的内存。它判断对象不再使用的方式是没有其他的对象引用它们。</p>\n<ol>\n<li><p>易导致内存泄漏的情景：</p>\n<ul>\n<li><p>全局变量</p>\n</li>\n<li><p>闭包</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> theThing = <span class=\"literal\">null</span>  </span><br><span class=\"line\"><span class=\"keyword\">var</span> replaceThing = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> originalThing = theThing</span><br><span class=\"line\"><span class=\"keyword\">var</span> unused = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (originalThing)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;hi&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">theThing = &#123;</span><br><span class=\"line\">    <span class=\"attr\">longStr</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>).join(<span class=\"string\">&#x27;*&#x27;</span>),</span><br><span class=\"line\">    <span class=\"attr\">someMethod</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(someMessage)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">setInterval</span>(replaceThing, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n<p>  replaceThing函数的操作是赋予theThing新的值， setInterval每次循环都新建一个作用域对象，theThing的引用地址不断在变化，正常情况下旧的引用对象就应该被垃圾回收了，<br>  但由于unused引用了旧的对象originalThing，originalThing又一个私有变量，所以旧的作用域对象无法被垃圾回收，就造成了内存泄露。</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>以下操作是否爆内存：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">arr.push(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p> 会一直执行，数组长度无限增加，内存会爆。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">arr.push();</span><br></pre></td></tr></table></figure>\n<p> 待定</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">arr.push(<span class=\"keyword\">new</span> Buffer(<span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<p> Buffer 在 V8 堆外分配物理内存。所以内存会在服務器内存被全部占掉的时候爆掉。</p>\n</li>\n</ol>\n<h2 id=\"ES6-新特性\"><a href=\"#ES6-新特性\" class=\"headerlink\" title=\"ES6 新特性\"></a>ES6 新特性</h2><ol>\n<li><p>新增数据结构：</p>\n<ul>\n<li><p>Set： 类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<p>  内部利用类似于<code>===</code>来判断值是否相等（唯一区别是这里NaN等于自身）。</p>\n</li>\n<li><p>Map： 类似于对象，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，提供了“值—值”的对应。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;aaa&#x27;</span>);</span><br><span class=\"line\">map.get(<span class=\"number\">1</span>) <span class=\"comment\">//&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>扩展运算符</p>\n<p> <code>...</code>： 将一个数组转为用逗号分隔的参数序列，主要用于函数调用。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x,y,z</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y+z</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add(...[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\">//6 会转化成 add(1,2,3)</span></span><br></pre></td></tr></table></figure></li>\n<li><p>第七种数据类型：</p>\n<p> symbol： 表示独一无二的值。基本上，它是一种类似于字符串的数据类型。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p>箭头函数 与 function 的区别：</p>\n<ul>\n<li>箭头函数内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>\n<li>不可以当作构造函数</li>\n<li>不可以使用arguments对象</li>\n<li>不可以使用yield命令</li>\n</ul>\n</li>\n</ol>\n<p>实现数据的私有</p>\n<p>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 修饰对象有什么意义?</p>\n<p>class, </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h2><p><code>typeof</code></p>\n<p><code>Object.prototype.toString</code>  [object NativeConstructorName]</p>\n<p>不能检测非原生构造函数的构造函数名。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><h2 id=\"引用传递\"><a href=\"#引用传递\" class=\"headerlink\" title=\"引用传递\"></a>引用传递</h2><ul>\n<li>值传递: 实际参数把它的值传递给对应的形式参数，形参不会改变实参</li>\n<li>引用传递: 实际参数与形式参数指向同一个地址，形参会改变实参</li>\n</ul>\n<p>javascript 中实际上没有引用传递只是传递引用。直接修改形参不会改变实参，但是修改形参的内部属性则会改变实参。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeStuff</span>(<span class=\"params\">a, b, c</span>)</span>&#123; <span class=\"comment\">// 把10（值）传递给a,把&#123;item: &quot;unchanged&quot;&#125;（引用）传递给把b,c</span></span><br><span class=\"line\">    a = a * <span class=\"number\">10</span>; </span><br><span class=\"line\">    b.item = <span class=\"string\">&quot;changed&quot;</span>; <span class=\"comment\">// 改变了引用内的属性，所以实参obj1也改变</span></span><br><span class=\"line\">    c = &#123;<span class=\"attr\">item</span>: <span class=\"string\">&quot;changed&quot;</span>&#125;;  <span class=\"comment\">// 把新的引用传递给了c，所以实参不变</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;<span class=\"attr\">item</span>: <span class=\"string\">&quot;unchanged&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;<span class=\"attr\">item</span>: <span class=\"string\">&quot;unchanged&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">changeStuff(num, obj1, obj2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.item);    </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.item); </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内存释放\"><a href=\"#内存释放\" class=\"headerlink\" title=\"内存释放\"></a>内存释放</h2><blockquote>\n<p>内存泄露指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放。即一块被分配的内存既不能使用，又不能回收</p>\n</blockquote>\n<p>GC（garbage collection）是一种自动管理应用内存的机制。GC 的工作是回收被未使用的对象所占用的内存。它判断对象不再使用的方式是没有其他的对象引用它们。</p>\n<ol>\n<li><p>易导致内存泄漏的情景：</p>\n<ul>\n<li><p>全局变量</p>\n</li>\n<li><p>闭包</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> theThing = <span class=\"literal\">null</span>  </span><br><span class=\"line\"><span class=\"keyword\">var</span> replaceThing = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> originalThing = theThing</span><br><span class=\"line\"><span class=\"keyword\">var</span> unused = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (originalThing)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;hi&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">theThing = &#123;</span><br><span class=\"line\">    <span class=\"attr\">longStr</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>).join(<span class=\"string\">&#x27;*&#x27;</span>),</span><br><span class=\"line\">    <span class=\"attr\">someMethod</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(someMessage)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">setInterval</span>(replaceThing, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n<p>  replaceThing函数的操作是赋予theThing新的值， setInterval每次循环都新建一个作用域对象，theThing的引用地址不断在变化，正常情况下旧的引用对象就应该被垃圾回收了，<br>  但由于unused引用了旧的对象originalThing，originalThing又一个私有变量，所以旧的作用域对象无法被垃圾回收，就造成了内存泄露。</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>以下操作是否爆内存：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">arr.push(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p> 会一直执行，数组长度无限增加，内存会爆。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">arr.push();</span><br></pre></td></tr></table></figure>\n<p> 待定</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">arr.push(<span class=\"keyword\">new</span> Buffer(<span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<p> Buffer 在 V8 堆外分配物理内存。所以内存会在服務器内存被全部占掉的时候爆掉。</p>\n</li>\n</ol>\n<h2 id=\"ES6-新特性\"><a href=\"#ES6-新特性\" class=\"headerlink\" title=\"ES6 新特性\"></a>ES6 新特性</h2><ol>\n<li><p>新增数据结构：</p>\n<ul>\n<li><p>Set： 类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<p>  内部利用类似于<code>===</code>来判断值是否相等（唯一区别是这里NaN等于自身）。</p>\n</li>\n<li><p>Map： 类似于对象，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，提供了“值—值”的对应。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;aaa&#x27;</span>);</span><br><span class=\"line\">map.get(<span class=\"number\">1</span>) <span class=\"comment\">//&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>扩展运算符</p>\n<p> <code>...</code>： 将一个数组转为用逗号分隔的参数序列，主要用于函数调用。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x,y,z</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y+z</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add(...[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\">//6 会转化成 add(1,2,3)</span></span><br></pre></td></tr></table></figure></li>\n<li><p>第七种数据类型：</p>\n<p> symbol： 表示独一无二的值。基本上，它是一种类似于字符串的数据类型。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p>箭头函数 与 function 的区别：</p>\n<ul>\n<li>箭头函数内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>\n<li>不可以当作构造函数</li>\n<li>不可以使用arguments对象</li>\n<li>不可以使用yield命令</li>\n</ul>\n</li>\n</ol>\n<p>实现数据的私有</p>\n<p>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 修饰对象有什么意义?</p>\n<p>class, </p>\n"},{"_content":"\n\n\nHTTP： 浏览器和服务器之间的传输协议,用于浏览器和服务器的通信\n\n组成： Header和Body两部分（Body是可选项）\n\n","source":"_posts/http.md","raw":"\n\n\nHTTP： 浏览器和服务器之间的传输协议,用于浏览器和服务器的通信\n\n组成： Header和Body两部分（Body是可选项）\n\n","slug":"http","published":1,"date":"2021-12-06T05:35:02.621Z","updated":"2021-12-06T07:05:57.325Z","_id":"ckwubxv25005iy4v2dqge6034","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>HTTP： 浏览器和服务器之间的传输协议,用于浏览器和服务器的通信</p>\n<p>组成： Header和Body两部分（Body是可选项）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP： 浏览器和服务器之间的传输协议,用于浏览器和服务器的通信</p>\n<p>组成： Header和Body两部分（Body是可选项）</p>\n"},{"_content":"\n# IO\n\nI/O： 输入/输出(Input/Output)。\n\n## Buffer\n\n基于 `TypedArray`( ES6 新增) 中 `Uint8Array` 来实现。\n\n特点：\n\n+ 大小固定不变\n+ 在 V8 堆栈外分配原始内存空间\n\n\n使用方法：\n\n+ Buffer.from()\t 根据已有数据生成一个 Buffer 对象\n+ Buffer.alloc()\t创建一个初始化后的 Buffer 对象\n+ Buffer.allocUnsafe()\t创建一个未初始化的 Buffer 对象\n\n\n## 流( Stream )\n\n流 (stream) 是一种很早之前流行的编程方式（C语言）。\n\n应用的场景：拷贝一个 20G 大的文件, 如果你一次性将 20G 的数据读入到内存, 你的内存条可能不够用, 或者严重影响性能。\n但是你如果使用一个 1MB 大小的缓存 (buf) 每次读取 1Mb, 然后写入 1Mb, 那么不论这个文件多大都只会占用 1Mb 的内存.\n\nStream 的类型\n","source":"_posts/IO.md","raw":"\n# IO\n\nI/O： 输入/输出(Input/Output)。\n\n## Buffer\n\n基于 `TypedArray`( ES6 新增) 中 `Uint8Array` 来实现。\n\n特点：\n\n+ 大小固定不变\n+ 在 V8 堆栈外分配原始内存空间\n\n\n使用方法：\n\n+ Buffer.from()\t 根据已有数据生成一个 Buffer 对象\n+ Buffer.alloc()\t创建一个初始化后的 Buffer 对象\n+ Buffer.allocUnsafe()\t创建一个未初始化的 Buffer 对象\n\n\n## 流( Stream )\n\n流 (stream) 是一种很早之前流行的编程方式（C语言）。\n\n应用的场景：拷贝一个 20G 大的文件, 如果你一次性将 20G 的数据读入到内存, 你的内存条可能不够用, 或者严重影响性能。\n但是你如果使用一个 1MB 大小的缓存 (buf) 每次读取 1Mb, 然后写入 1Mb, 那么不论这个文件多大都只会占用 1Mb 的内存.\n\nStream 的类型\n","slug":"IO","published":1,"date":"2021-12-06T05:35:02.611Z","updated":"2021-12-06T07:06:01.095Z","_id":"ckwubxxz0005jy4v262bb26kf","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h1><p>I/O： 输入/输出(Input/Output)。</p>\n<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>基于 <code>TypedArray</code>( ES6 新增) 中 <code>Uint8Array</code> 来实现。</p>\n<p>特点：</p>\n<ul>\n<li>大小固定不变</li>\n<li>在 V8 堆栈外分配原始内存空间</li>\n</ul>\n<p>使用方法：</p>\n<ul>\n<li>Buffer.from()     根据已有数据生成一个 Buffer 对象</li>\n<li>Buffer.alloc()    创建一个初始化后的 Buffer 对象</li>\n<li>Buffer.allocUnsafe()    创建一个未初始化的 Buffer 对象</li>\n</ul>\n<h2 id=\"流-Stream\"><a href=\"#流-Stream\" class=\"headerlink\" title=\"流( Stream )\"></a>流( Stream )</h2><p>流 (stream) 是一种很早之前流行的编程方式（C语言）。</p>\n<p>应用的场景：拷贝一个 20G 大的文件, 如果你一次性将 20G 的数据读入到内存, 你的内存条可能不够用, 或者严重影响性能。<br>但是你如果使用一个 1MB 大小的缓存 (buf) 每次读取 1Mb, 然后写入 1Mb, 那么不论这个文件多大都只会占用 1Mb 的内存.</p>\n<p>Stream 的类型</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h1><p>I/O： 输入/输出(Input/Output)。</p>\n<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>基于 <code>TypedArray</code>( ES6 新增) 中 <code>Uint8Array</code> 来实现。</p>\n<p>特点：</p>\n<ul>\n<li>大小固定不变</li>\n<li>在 V8 堆栈外分配原始内存空间</li>\n</ul>\n<p>使用方法：</p>\n<ul>\n<li>Buffer.from()     根据已有数据生成一个 Buffer 对象</li>\n<li>Buffer.alloc()    创建一个初始化后的 Buffer 对象</li>\n<li>Buffer.allocUnsafe()    创建一个未初始化的 Buffer 对象</li>\n</ul>\n<h2 id=\"流-Stream\"><a href=\"#流-Stream\" class=\"headerlink\" title=\"流( Stream )\"></a>流( Stream )</h2><p>流 (stream) 是一种很早之前流行的编程方式（C语言）。</p>\n<p>应用的场景：拷贝一个 20G 大的文件, 如果你一次性将 20G 的数据读入到内存, 你的内存条可能不够用, 或者严重影响性能。<br>但是你如果使用一个 1MB 大小的缓存 (buf) 每次读取 1Mb, 然后写入 1Mb, 那么不论这个文件多大都只会占用 1Mb 的内存.</p>\n<p>Stream 的类型</p>\n"},{"_content":"\n\n## Net\nTCP/IP\n\n\n## UDP\n\n## HTTP(重点)\n\n### headers\n\n\n## DNS","source":"_posts/Network.md","raw":"\n\n## Net\nTCP/IP\n\n\n## UDP\n\n## HTTP(重点)\n\n### headers\n\n\n## DNS","slug":"Network","published":1,"date":"2021-12-06T05:35:02.611Z","updated":"2021-12-06T07:06:05.799Z","_id":"ckwuby1l6005ky4v280mc2005","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Net\"><a href=\"#Net\" class=\"headerlink\" title=\"Net\"></a>Net</h2><p>TCP/IP</p>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><h2 id=\"HTTP-重点\"><a href=\"#HTTP-重点\" class=\"headerlink\" title=\"HTTP(重点)\"></a>HTTP(重点)</h2><h3 id=\"headers\"><a href=\"#headers\" class=\"headerlink\" title=\"headers\"></a>headers</h3><h2 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Net\"><a href=\"#Net\" class=\"headerlink\" title=\"Net\"></a>Net</h2><p>TCP/IP</p>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><h2 id=\"HTTP-重点\"><a href=\"#HTTP-重点\" class=\"headerlink\" title=\"HTTP(重点)\"></a>HTTP(重点)</h2><h3 id=\"headers\"><a href=\"#headers\" class=\"headerlink\" title=\"headers\"></a>headers</h3><h2 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h2>"},{"_content":"# CSS布局基础——BFC #\n\n## what's BFC? ##\n第一次看到这个名词，我是拒绝的，css什么时候还有这个东西？于是迫不及待的google了一下，才发现原来它无时无刻不在我们的css当中，只不过它并不是一个属性，不需要我们平常使用手写罢了。但是它的重要性确是杠杠的，可以这么说，没有它就就没有什么css布局。\nBFC,全称 Block Formatting Context，翻译成块级格式化上下文，它就是一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。\n\n\n看一大堆文字可能有点抽象，现在拿个js函数来比喻说明一下吧，我们现在有一个叫做bfc的函数，而一个函数就是一个块级作用域，这里面所有的变量申明、运行都在这个块级作用域内进行。理所当然，一个环境中的变量不会影响到其它环境变量。\n\n```js\n\tvar box =1;\n\tfunction bfc(){\n\t\tvar box = \"2\";\n\t\tconsole.log(box);\n\t}\n\tbfc();//2\n\tconsole.log(box)//1\n```\n\n所以，我们是不是可以这样理解：所谓的BFC就是css属性的执行域？\n\n\n## BFC的生成 ##\n\n既然js可以通过函数等方法来实现块级作用域，我想那css肯定也是可以通过一些手段来实现BFC的。\n这里BFC的官方文档写到：\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.\n\n从这段描述可以清楚知道，以下方法可以创建一个新的块级执行上下文（BFC）：\n\n1. 浮动元素、\n2. 绝对定位元素，\n3. 块级元素以及块级容器(比如inline-block、table-cell、table-capation)\n4. overflow值不为visible的块级盒子\n\n*当然，root元素会自动生成一个BFC，这个应该很好理解,毕竟需要一个根BFC来布局*\n\n\n## 执行规则 ##\n既然存在了执行环境，那肯定会存在执行规则。BFC的\n\n**1.在一个块级排版上下文中，盒子是从包含块顶部开始，垂直的一个接一个的排列的。每个盒子的左外边是触碰到包含块的左边的（对于从右向左的排版，则相反）**\n\n这个应该不难理解。就是我们如果在<body></body>里写几个`<div>`，它会依次垂直排列，并且都是在页面的最左边（对于从右向左的排版，则相反）。\n\n**2.相邻两个盒子之间的垂直的间距是被margin属性所决定的，在一个块级排版上下文中相邻的两个块级盒之间的垂直margin是折叠的。**\n\n这句描述是不是超级熟悉，这不是我css常见的边距折叠问题吗？现在知道它出自哪里了吧，就是这里。下面的俩个盒子各有上下20px的间距，加起来应该有40px,但显然，现在只有20px;\n\n```css\n    <style>\n\t.top{\n    \twidth:100px;\n\t\theight:100px;\n\t\tbackground:#000;\n\t\tmargin:20px 0;\n\t}\n\t.bottom{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground:#000;\n\t\tmargin:20px 0;\n\t}\n    </style>\n    <div  class=\"top\"></div>\n    <div  class=\"bottom\"></div>\n\n<style>\n.top{\n\twidth:100px;\n\theight:100px;\n\tbackground:#ADD9E6;\n\tmargin:20px 0;\n}\n.bottom{\n\twidth:100px;\n\theight:100px;\n\tbackground:#FFCCCC;\n\tmargin:20px 0;\n}\n</style>\n<div  class=\"top\"></div>\n<div  class=\"bottom\"></div>\n```\n\t发生边距折叠是因为同一个BFC的关系(根BFC)。既然知道原因，解决就好办了，让他们俩个不在同一个BFC就ok啦。\n**3. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。**\n\n通过这条属性，我们又可以想到哪些呢。对，浮动元素的塌陷问题。我们知道，一个元素中的子元素浮动了，这个父元素就会发生高度塌陷问题。下例中一旦内部的红色元素浮动，蓝色的盒子就无法被撑起，高度会变成0。\n```css\n\t<style>\n\t.wrap{\n\t\twidth:150px;\n\t\tbackground:#ADD9E6;\n\t\tmargin:20px 0;\n\t}\n\t.in{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground:#FFCCCC;\n\t\tmargin:20px 0;\n\t\t//float:left;\n\t}\n\t</style>\n\t<div class=\"wrap\"><div class=\"in\"></div></div>\n\n<style>\n\t.wrap{\n\t\twidth:150px;\n\t\tbackground:#ADD9E6;\n\t\tmargin:20px 0;\n\t}\n\t.in{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground:#FFCCCC;\n\t\tmargin:20px 0;\n\t\t//float:left;\n\t}\n</style>\n<div class=\"wrap\"><div class=\"in\"></div></div>\n```\n现在我们知道了，这是因为浮动元素创建了一个新的BFC，成为了一个独立的容器，不会影响到外面的父元素了。它的定位规则不再受制于这个父元素了。如何解决这一问题？我们知道只要在在父元素加上`overflow:hidden`可以清除浮动。但是这又是为什么？\n\n其实，这就是前面提到的`overflow:hidden`可以生成一个新的BFC，而这个浮动的子元素，被它所包含了，从而成为一个独立容器，它的float外溢不了了，外面的元素不再受其浮动的影响，从而达到了清除浮动的作用。\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！","source":"_posts/BFC.md","raw":"# CSS布局基础——BFC #\n\n## what's BFC? ##\n第一次看到这个名词，我是拒绝的，css什么时候还有这个东西？于是迫不及待的google了一下，才发现原来它无时无刻不在我们的css当中，只不过它并不是一个属性，不需要我们平常使用手写罢了。但是它的重要性确是杠杠的，可以这么说，没有它就就没有什么css布局。\nBFC,全称 Block Formatting Context，翻译成块级格式化上下文，它就是一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。\n\n\n看一大堆文字可能有点抽象，现在拿个js函数来比喻说明一下吧，我们现在有一个叫做bfc的函数，而一个函数就是一个块级作用域，这里面所有的变量申明、运行都在这个块级作用域内进行。理所当然，一个环境中的变量不会影响到其它环境变量。\n\n```js\n\tvar box =1;\n\tfunction bfc(){\n\t\tvar box = \"2\";\n\t\tconsole.log(box);\n\t}\n\tbfc();//2\n\tconsole.log(box)//1\n```\n\n所以，我们是不是可以这样理解：所谓的BFC就是css属性的执行域？\n\n\n## BFC的生成 ##\n\n既然js可以通过函数等方法来实现块级作用域，我想那css肯定也是可以通过一些手段来实现BFC的。\n这里BFC的官方文档写到：\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.\n\n从这段描述可以清楚知道，以下方法可以创建一个新的块级执行上下文（BFC）：\n\n1. 浮动元素、\n2. 绝对定位元素，\n3. 块级元素以及块级容器(比如inline-block、table-cell、table-capation)\n4. overflow值不为visible的块级盒子\n\n*当然，root元素会自动生成一个BFC，这个应该很好理解,毕竟需要一个根BFC来布局*\n\n\n## 执行规则 ##\n既然存在了执行环境，那肯定会存在执行规则。BFC的\n\n**1.在一个块级排版上下文中，盒子是从包含块顶部开始，垂直的一个接一个的排列的。每个盒子的左外边是触碰到包含块的左边的（对于从右向左的排版，则相反）**\n\n这个应该不难理解。就是我们如果在<body></body>里写几个`<div>`，它会依次垂直排列，并且都是在页面的最左边（对于从右向左的排版，则相反）。\n\n**2.相邻两个盒子之间的垂直的间距是被margin属性所决定的，在一个块级排版上下文中相邻的两个块级盒之间的垂直margin是折叠的。**\n\n这句描述是不是超级熟悉，这不是我css常见的边距折叠问题吗？现在知道它出自哪里了吧，就是这里。下面的俩个盒子各有上下20px的间距，加起来应该有40px,但显然，现在只有20px;\n\n```css\n    <style>\n\t.top{\n    \twidth:100px;\n\t\theight:100px;\n\t\tbackground:#000;\n\t\tmargin:20px 0;\n\t}\n\t.bottom{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground:#000;\n\t\tmargin:20px 0;\n\t}\n    </style>\n    <div  class=\"top\"></div>\n    <div  class=\"bottom\"></div>\n\n<style>\n.top{\n\twidth:100px;\n\theight:100px;\n\tbackground:#ADD9E6;\n\tmargin:20px 0;\n}\n.bottom{\n\twidth:100px;\n\theight:100px;\n\tbackground:#FFCCCC;\n\tmargin:20px 0;\n}\n</style>\n<div  class=\"top\"></div>\n<div  class=\"bottom\"></div>\n```\n\t发生边距折叠是因为同一个BFC的关系(根BFC)。既然知道原因，解决就好办了，让他们俩个不在同一个BFC就ok啦。\n**3. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。**\n\n通过这条属性，我们又可以想到哪些呢。对，浮动元素的塌陷问题。我们知道，一个元素中的子元素浮动了，这个父元素就会发生高度塌陷问题。下例中一旦内部的红色元素浮动，蓝色的盒子就无法被撑起，高度会变成0。\n```css\n\t<style>\n\t.wrap{\n\t\twidth:150px;\n\t\tbackground:#ADD9E6;\n\t\tmargin:20px 0;\n\t}\n\t.in{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground:#FFCCCC;\n\t\tmargin:20px 0;\n\t\t//float:left;\n\t}\n\t</style>\n\t<div class=\"wrap\"><div class=\"in\"></div></div>\n\n<style>\n\t.wrap{\n\t\twidth:150px;\n\t\tbackground:#ADD9E6;\n\t\tmargin:20px 0;\n\t}\n\t.in{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground:#FFCCCC;\n\t\tmargin:20px 0;\n\t\t//float:left;\n\t}\n</style>\n<div class=\"wrap\"><div class=\"in\"></div></div>\n```\n现在我们知道了，这是因为浮动元素创建了一个新的BFC，成为了一个独立的容器，不会影响到外面的父元素了。它的定位规则不再受制于这个父元素了。如何解决这一问题？我们知道只要在在父元素加上`overflow:hidden`可以清除浮动。但是这又是为什么？\n\n其实，这就是前面提到的`overflow:hidden`可以生成一个新的BFC，而这个浮动的子元素，被它所包含了，从而成为一个独立容器，它的float外溢不了了，外面的元素不再受其浮动的影响，从而达到了清除浮动的作用。\n\n\n\n如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！","slug":"BFC","published":1,"date":"2021-12-06T05:35:02.581Z","updated":"2021-12-06T07:11:49.508Z","_id":"ckwuc5eta0000dov2881m14fm","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"CSS布局基础——BFC\"><a href=\"#CSS布局基础——BFC\" class=\"headerlink\" title=\"CSS布局基础——BFC\"></a>CSS布局基础——BFC</h1><h2 id=\"what’s-BFC\"><a href=\"#what’s-BFC\" class=\"headerlink\" title=\"what’s BFC?\"></a>what’s BFC?</h2><p>第一次看到这个名词，我是拒绝的，css什么时候还有这个东西？于是迫不及待的google了一下，才发现原来它无时无刻不在我们的css当中，只不过它并不是一个属性，不需要我们平常使用手写罢了。但是它的重要性确是杠杠的，可以这么说，没有它就就没有什么css布局。<br>BFC,全称 Block Formatting Context，翻译成块级格式化上下文，它就是一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。</p>\n<p>看一大堆文字可能有点抽象，现在拿个js函数来比喻说明一下吧，我们现在有一个叫做bfc的函数，而一个函数就是一个块级作用域，这里面所有的变量申明、运行都在这个块级作用域内进行。理所当然，一个环境中的变量不会影响到其它环境变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> box =<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bfc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> box = <span class=\"string\">&quot;2&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(box);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bfc();<span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(box)<span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，我们是不是可以这样理解：所谓的BFC就是css属性的执行域？</p>\n<h2 id=\"BFC的生成\"><a href=\"#BFC的生成\" class=\"headerlink\" title=\"BFC的生成\"></a>BFC的生成</h2><p>既然js可以通过函数等方法来实现块级作用域，我想那css肯定也是可以通过一些手段来实现BFC的。<br>这里BFC的官方文档写到：</p>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p>\n</blockquote>\n<p>从这段描述可以清楚知道，以下方法可以创建一个新的块级执行上下文（BFC）：</p>\n<ol>\n<li>浮动元素、</li>\n<li>绝对定位元素，</li>\n<li>块级元素以及块级容器(比如inline-block、table-cell、table-capation)</li>\n<li>overflow值不为visible的块级盒子</li>\n</ol>\n<p><em>当然，root元素会自动生成一个BFC，这个应该很好理解,毕竟需要一个根BFC来布局</em></p>\n<h2 id=\"执行规则\"><a href=\"#执行规则\" class=\"headerlink\" title=\"执行规则\"></a>执行规则</h2><p>既然存在了执行环境，那肯定会存在执行规则。BFC的</p>\n<p><strong>1.在一个块级排版上下文中，盒子是从包含块顶部开始，垂直的一个接一个的排列的。每个盒子的左外边是触碰到包含块的左边的（对于从右向左的排版，则相反）</strong></p>\n<p>这个应该不难理解。就是我们如果在<body></body>里写几个<code>&lt;div&gt;</code>，它会依次垂直排列，并且都是在页面的最左边（对于从右向左的排版，则相反）。</p>\n<p><strong>2.相邻两个盒子之间的垂直的间距是被margin属性所决定的，在一个块级排版上下文中相邻的两个块级盒之间的垂直margin是折叠的。</strong></p>\n<p>这句描述是不是超级熟悉，这不是我css常见的边距折叠问题吗？现在知道它出自哪里了吧，就是这里。下面的俩个盒子各有上下20px的间距，加起来应该有40px,但显然，现在只有20px;</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">\t<span class=\"selector-class\">.top</span>&#123;</span><br><span class=\"line\">    \t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#000</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"selector-class\">.bottom</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#000</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">    &lt;<span class=\"selector-tag\">div</span>  class=&quot;<span class=\"attribute\">top</span>&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"selector-tag\">div</span>  class=&quot;<span class=\"attribute\">bottom</span>&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\"><span class=\"selector-class\">.top</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">background</span>:<span class=\"number\">#ADD9E6</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.bottom</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">background</span>:<span class=\"number\">#FFCCCC</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span>  class=&quot;<span class=\"attribute\">top</span>&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span>  class=&quot;<span class=\"attribute\">bottom</span>&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<pre><code>发生边距折叠是因为同一个BFC的关系(根BFC)。既然知道原因，解决就好办了，让他们俩个不在同一个BFC就ok啦。\n</code></pre>\n<p><strong>3. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</strong></p>\n<p>通过这条属性，我们又可以想到哪些呢。对，浮动元素的塌陷问题。我们知道，一个元素中的子元素浮动了，这个父元素就会发生高度塌陷问题。下例中一旦内部的红色元素浮动，蓝色的盒子就无法被撑起，高度会变成0。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t&lt;style&gt;</span><br><span class=\"line\">\t<span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>:<span class=\"number\">150px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#ADD9E6</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"selector-class\">.in</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#FFCCCC</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t//<span class=\"attribute\">float</span><span class=\"selector-pseudo\">:left</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&lt;/style&gt;</span><br><span class=\"line\">\t&lt;<span class=\"selector-tag\">div</span> class=&quot;wrap&quot;&gt;&lt;<span class=\"selector-tag\">div</span> class=&quot;in&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">\t<span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>:<span class=\"number\">150px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#ADD9E6</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"selector-class\">.in</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#FFCCCC</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t//<span class=\"attribute\">float</span><span class=\"selector-pseudo\">:left</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=&quot;wrap&quot;&gt;&lt;<span class=\"selector-tag\">div</span> class=&quot;in&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>现在我们知道了，这是因为浮动元素创建了一个新的BFC，成为了一个独立的容器，不会影响到外面的父元素了。它的定位规则不再受制于这个父元素了。如何解决这一问题？我们知道只要在在父元素加上<code>overflow:hidden</code>可以清除浮动。但是这又是为什么？</p>\n<p>其实，这就是前面提到的<code>overflow:hidden</code>可以生成一个新的BFC，而这个浮动的子元素，被它所包含了，从而成为一个独立容器，它的float外溢不了了，外面的元素不再受其浮动的影响，从而达到了清除浮动的作用。</p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS布局基础——BFC\"><a href=\"#CSS布局基础——BFC\" class=\"headerlink\" title=\"CSS布局基础——BFC\"></a>CSS布局基础——BFC</h1><h2 id=\"what’s-BFC\"><a href=\"#what’s-BFC\" class=\"headerlink\" title=\"what’s BFC?\"></a>what’s BFC?</h2><p>第一次看到这个名词，我是拒绝的，css什么时候还有这个东西？于是迫不及待的google了一下，才发现原来它无时无刻不在我们的css当中，只不过它并不是一个属性，不需要我们平常使用手写罢了。但是它的重要性确是杠杠的，可以这么说，没有它就就没有什么css布局。<br>BFC,全称 Block Formatting Context，翻译成块级格式化上下文，它就是一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。</p>\n<p>看一大堆文字可能有点抽象，现在拿个js函数来比喻说明一下吧，我们现在有一个叫做bfc的函数，而一个函数就是一个块级作用域，这里面所有的变量申明、运行都在这个块级作用域内进行。理所当然，一个环境中的变量不会影响到其它环境变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> box =<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bfc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> box = <span class=\"string\">&quot;2&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(box);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bfc();<span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(box)<span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，我们是不是可以这样理解：所谓的BFC就是css属性的执行域？</p>\n<h2 id=\"BFC的生成\"><a href=\"#BFC的生成\" class=\"headerlink\" title=\"BFC的生成\"></a>BFC的生成</h2><p>既然js可以通过函数等方法来实现块级作用域，我想那css肯定也是可以通过一些手段来实现BFC的。<br>这里BFC的官方文档写到：</p>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p>\n</blockquote>\n<p>从这段描述可以清楚知道，以下方法可以创建一个新的块级执行上下文（BFC）：</p>\n<ol>\n<li>浮动元素、</li>\n<li>绝对定位元素，</li>\n<li>块级元素以及块级容器(比如inline-block、table-cell、table-capation)</li>\n<li>overflow值不为visible的块级盒子</li>\n</ol>\n<p><em>当然，root元素会自动生成一个BFC，这个应该很好理解,毕竟需要一个根BFC来布局</em></p>\n<h2 id=\"执行规则\"><a href=\"#执行规则\" class=\"headerlink\" title=\"执行规则\"></a>执行规则</h2><p>既然存在了执行环境，那肯定会存在执行规则。BFC的</p>\n<p><strong>1.在一个块级排版上下文中，盒子是从包含块顶部开始，垂直的一个接一个的排列的。每个盒子的左外边是触碰到包含块的左边的（对于从右向左的排版，则相反）</strong></p>\n<p>这个应该不难理解。就是我们如果在<body></body>里写几个<code>&lt;div&gt;</code>，它会依次垂直排列，并且都是在页面的最左边（对于从右向左的排版，则相反）。</p>\n<p><strong>2.相邻两个盒子之间的垂直的间距是被margin属性所决定的，在一个块级排版上下文中相邻的两个块级盒之间的垂直margin是折叠的。</strong></p>\n<p>这句描述是不是超级熟悉，这不是我css常见的边距折叠问题吗？现在知道它出自哪里了吧，就是这里。下面的俩个盒子各有上下20px的间距，加起来应该有40px,但显然，现在只有20px;</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">\t<span class=\"selector-class\">.top</span>&#123;</span><br><span class=\"line\">    \t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#000</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"selector-class\">.bottom</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#000</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">    &lt;<span class=\"selector-tag\">div</span>  class=&quot;<span class=\"attribute\">top</span>&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"selector-tag\">div</span>  class=&quot;<span class=\"attribute\">bottom</span>&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\"><span class=\"selector-class\">.top</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">background</span>:<span class=\"number\">#ADD9E6</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.bottom</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">background</span>:<span class=\"number\">#FFCCCC</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span>  class=&quot;<span class=\"attribute\">top</span>&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span>  class=&quot;<span class=\"attribute\">bottom</span>&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<pre><code>发生边距折叠是因为同一个BFC的关系(根BFC)。既然知道原因，解决就好办了，让他们俩个不在同一个BFC就ok啦。\n</code></pre>\n<p><strong>3. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</strong></p>\n<p>通过这条属性，我们又可以想到哪些呢。对，浮动元素的塌陷问题。我们知道，一个元素中的子元素浮动了，这个父元素就会发生高度塌陷问题。下例中一旦内部的红色元素浮动，蓝色的盒子就无法被撑起，高度会变成0。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t&lt;style&gt;</span><br><span class=\"line\">\t<span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>:<span class=\"number\">150px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#ADD9E6</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"selector-class\">.in</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#FFCCCC</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t//<span class=\"attribute\">float</span><span class=\"selector-pseudo\">:left</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&lt;/style&gt;</span><br><span class=\"line\">\t&lt;<span class=\"selector-tag\">div</span> class=&quot;wrap&quot;&gt;&lt;<span class=\"selector-tag\">div</span> class=&quot;in&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">\t<span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>:<span class=\"number\">150px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#ADD9E6</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"selector-class\">.in</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>:<span class=\"number\">#FFCCCC</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">margin</span>:<span class=\"number\">20px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t//<span class=\"attribute\">float</span><span class=\"selector-pseudo\">:left</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=&quot;wrap&quot;&gt;&lt;<span class=\"selector-tag\">div</span> class=&quot;in&quot;&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>现在我们知道了，这是因为浮动元素创建了一个新的BFC，成为了一个独立的容器，不会影响到外面的父元素了。它的定位规则不再受制于这个父元素了。如何解决这一问题？我们知道只要在在父元素加上<code>overflow:hidden</code>可以清除浮动。但是这又是为什么？</p>\n<p>其实，这就是前面提到的<code>overflow:hidden</code>可以生成一个新的BFC，而这个浮动的子元素，被它所包含了，从而成为一个独立容器，它的float外溢不了了，外面的元素不再受其浮动的影响，从而达到了清除浮动的作用。</p>\n<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckwuaudr60001wcv22yt06o0c","category_id":"ckwuaudr80002wcv23zkl8o5j","_id":"ckwuaudr90003wcv2gmkm7wu9"},{"post_id":"ckwubce7g0000igv2ghs79vns","category_id":"ckwuaudr80002wcv23zkl8o5j","_id":"ckwubce7p0001igv2ery45x06"}],"PostTag":[{"post_id":"ckwubwok20001y4v2fg7u7gnx","tag_id":"ckwubwok50003y4v29kjzcgih","_id":"ckwubwokd0008y4v2gmjb43np"},{"post_id":"ckwubwok40002y4v28bue8zfs","tag_id":"ckwubwokc0007y4v22lut5pjo","_id":"ckwubwokg000dy4v29s6rfgb6"},{"post_id":"ckwubwoka0004y4v27ea5h26r","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwokk000ky4v2aq6l08dv"},{"post_id":"ckwubwoka0004y4v27ea5h26r","tag_id":"ckwubwokh000fy4v2ay0ogubf","_id":"ckwubwokk000my4v2f0h1btsb"},{"post_id":"ckwubwokk000ly4v26o91g8eh","tag_id":"ckwubwokj000iy4v22zci5zg4","_id":"ckwubwokl000py4v2ec8k29z6"},{"post_id":"ckwubwokg000cy4v2c9m2g21p","tag_id":"ckwubwokj000iy4v22zci5zg4","_id":"ckwubwokm000ry4v2e3cy6tkr"},{"post_id":"ckwubwokl000ny4v25azgd4ge","tag_id":"ckwubwokj000iy4v22zci5zg4","_id":"ckwubwokn000uy4v29jtl1vmx"},{"post_id":"ckwubwokg000ey4v26zzw479g","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwoko000wy4v267848o79"},{"post_id":"ckwubwokm000sy4v2elwd2dj6","tag_id":"ckwubwokj000iy4v22zci5zg4","_id":"ckwubwokp000zy4v28ibberir"},{"post_id":"ckwubwokn000vy4v2gara975u","tag_id":"ckwubwokn000ty4v229fg87lb","_id":"ckwubwoks0011y4v27oz814tz"},{"post_id":"ckwubwoki000hy4v20nyv73kq","tag_id":"ckwubwokn000ty4v229fg87lb","_id":"ckwubwokt0014y4v20d7841se"},{"post_id":"ckwubwokj000jy4v20jr10nhr","tag_id":"ckwubwokn000ty4v229fg87lb","_id":"ckwubwoku0016y4v2dr14500e"},{"post_id":"ckwubwoks0012y4v2afhgbkqb","tag_id":"ckwubwokn000ty4v229fg87lb","_id":"ckwubwokv0019y4v239h7hja4"},{"post_id":"ckwubwokt0015y4v28izw7jj5","tag_id":"ckwubwokn000ty4v229fg87lb","_id":"ckwubwokw001by4v2c0bq6nzh"},{"post_id":"ckwubwokm000qy4v20fl0dm6g","tag_id":"ckwubwokn000ty4v229fg87lb","_id":"ckwubwokx001dy4v29qqubg6e"},{"post_id":"ckwubwoko000xy4v29fqy4gbd","tag_id":"ckwubwokv0018y4v2148ygu5y","_id":"ckwubwoky001fy4v24fvb95jn"},{"post_id":"ckwubwol3001my4v28hqk5apu","tag_id":"ckwubwok50003y4v29kjzcgih","_id":"ckwubwol5001py4v2a044hby8"},{"post_id":"ckwubwol2001ly4v201r0gn99","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwolb001ty4v22rx9ersc"},{"post_id":"ckwubwol2001ly4v201r0gn99","tag_id":"ckwubwol4001ny4v23od9gabh","_id":"ckwubwolb001vy4v2a2m95o8h"},{"post_id":"ckwubwol4001oy4v201zo7q5u","tag_id":"ckwubwola001sy4v25t8ea8ai","_id":"ckwubwole001zy4v212kf9l7k"},{"post_id":"ckwubwolb001wy4v28r1ohfrb","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwolf0021y4v22rr903sx"},{"post_id":"ckwubwolc001yy4v25gld711z","tag_id":"ckwubwokj000iy4v22zci5zg4","_id":"ckwubwolg0024y4v2268ketxk"},{"post_id":"ckwubwole0020y4v2d8othnup","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwolh0026y4v2536y2kk2"},{"post_id":"ckwubwolf0023y4v24943cclj","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwoli0029y4v2bkiqezwn"},{"post_id":"ckwubwolf0023y4v24943cclj","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwolj002by4v2cmrfeih9"},{"post_id":"ckwubwol5001qy4v20yar0nj7","tag_id":"ckwubwolc001xy4v2csrj7p7j","_id":"ckwubwolk002dy4v2du6zg7rs"},{"post_id":"ckwubwol5001qy4v20yar0nj7","tag_id":"ckwubwolf0022y4v23en3adjt","_id":"ckwubwoll002fy4v2e067dk9j"},{"post_id":"ckwubwolg0025y4v2gmm65iaf","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwoll002hy4v28ehkfafv"},{"post_id":"ckwubwola001ry4v2ejeubr98","tag_id":"ckwubwola001sy4v25t8ea8ai","_id":"ckwubwolm002jy4v2hg6ie71o"},{"post_id":"ckwubwoli002ay4v2bnlceilm","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwoln002ly4v2d3kcafqa"},{"post_id":"ckwubwoli002ay4v2bnlceilm","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwolo002ny4v23dj06hid"},{"post_id":"ckwubwolk002ey4v2eazt0ial","tag_id":"ckwubwolc001xy4v2csrj7p7j","_id":"ckwubwolo002py4v2htkt2fz8"},{"post_id":"ckwubwolp002qy4v299e8ef0m","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwolq002sy4v25915bugt"},{"post_id":"ckwubwolq002ty4v257pbgbkw","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwols002vy4v2fa4g9rld"},{"post_id":"ckwubwols002wy4v2g6yq1b5j","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwolx0033y4v28or6f2qz"},{"post_id":"ckwubwols002wy4v2g6yq1b5j","tag_id":"ckwubwolt002yy4v2b9m84q8m","_id":"ckwubwolx0035y4v2eg3lgkf0"},{"post_id":"ckwubwols002xy4v24ijx3lj9","tag_id":"ckwubwolt002yy4v2b9m84q8m","_id":"ckwubwoly0037y4v29cl0166s"},{"post_id":"ckwubwom3003fy4v223xfd8ow","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwom4003hy4v29riw701v"},{"post_id":"ckwubwom6003ly4v20wjngnzk","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwom7003ny4v23fqp1fwj"},{"post_id":"ckwubwom6003ly4v20wjngnzk","tag_id":"ckwubwol4001ny4v23od9gabh","_id":"ckwubwom8003py4v20w0c4j8j"},{"post_id":"ckwubwom6003my4v28azncick","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwom9003ry4v20yvy48zr"},{"post_id":"ckwubwom6003my4v28azncick","tag_id":"ckwubwolt002yy4v2b9m84q8m","_id":"ckwubwoma003ty4v24nbmhak7"},{"post_id":"ckwubwom8003qy4v28oiubzkg","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwoma003vy4v21sxl9aqd"},{"post_id":"ckwubwom8003qy4v28oiubzkg","tag_id":"ckwubwok50003y4v29kjzcgih","_id":"ckwubwomb003xy4v2geq9d66o"},{"post_id":"ckwubwomb003wy4v2dmjuh0y6","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwomc003zy4v2gmzv99fe"},{"post_id":"ckwubwomb003yy4v2cc036lnp","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwomc0041y4v25v2i980p"},{"post_id":"ckwubwomd0042y4v274gmfh4e","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwomg0044y4v22sovd9dr"},{"post_id":"ckwubwomf0043y4v2702c3dgg","tag_id":"ckwubwola001sy4v25t8ea8ai","_id":"ckwubwomg0046y4v2epgwfrpi"},{"post_id":"ckwubwomh0047y4v2binweb2g","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwomi0049y4v26wqkhuq6"},{"post_id":"ckwubwomh0047y4v2binweb2g","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwomj004by4v2b99vhstf"},{"post_id":"ckwubwomh0048y4v2cx6ybhjj","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwomj004dy4v24muqcu9m"},{"post_id":"ckwubwomh0048y4v2cx6ybhjj","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwomk004fy4v22kq121jz"},{"post_id":"ckwubwomi004ay4v22qgmequ8","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwomk004hy4v2fhwhdrw9"},{"post_id":"ckwubwomi004ay4v22qgmequ8","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwoml004jy4v28g9id9n7"},{"post_id":"ckwubwomk004iy4v2hv41f6v3","tag_id":"ckwubwok50003y4v29kjzcgih","_id":"ckwubwomm004ly4v273uv0256"},{"post_id":"ckwubwomn004oy4v28nvtfbvn","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwomo004ry4v21owsaro4"},{"post_id":"ckwubwomn004oy4v28nvtfbvn","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwomp004ty4v2b1nv5gja"},{"post_id":"ckwubwomo004qy4v200q9aqi1","tag_id":"ckwubwokj000iy4v22zci5zg4","_id":"ckwubwomr004vy4v2dnau0z9u"},{"post_id":"ckwubwomm004ny4v2d4u8gqgw","tag_id":"ckwubwomo004py4v2ez6p998g","_id":"ckwubwoms004xy4v27o470sud"},{"post_id":"ckwubwomr004wy4v2aoake1so","tag_id":"ckwubwolt002yy4v2b9m84q8m","_id":"ckwubwomt004zy4v2ekq4fd02"},{"post_id":"ckwubwomt0051y4v2ellx0hh2","tag_id":"ckwubwokl000oy4v26bsx7kpb","_id":"ckwubwomu0053y4v2el63c3ck"},{"post_id":"ckwubwomu0052y4v26w4t144p","tag_id":"ckwubwolt002yy4v2b9m84q8m","_id":"ckwubwomv0055y4v21s1td0nv"},{"post_id":"ckwubwomx0059y4v29vu32442","tag_id":"ckwubwokf000by4v291rx8bpt","_id":"ckwubwomy005by4v2dg7r2q1m"},{"post_id":"ckwubwomy005cy4v22q9c09ir","tag_id":"ckwubwol4001ny4v23od9gabh","_id":"ckwubwomz005ey4v226go199b"}],"Tag":[{"name":"css","_id":"ckwubwok50003y4v29kjzcgih"},{"name":"C语言","_id":"ckwubwokc0007y4v22lut5pjo"},{"name":"web","_id":"ckwubwokf000by4v291rx8bpt"},{"name":"Backbone","_id":"ckwubwokh000fy4v2ay0ogubf"},{"name":"java基础","_id":"ckwubwokj000iy4v22zci5zg4"},{"name":"javascript","_id":"ckwubwokl000oy4v26bsx7kpb"},{"name":"java面向对象","_id":"ckwubwokn000ty4v229fg87lb"},{"name":"Java基础","_id":"ckwubwokv0018y4v2148ygu5y"},{"name":"H5","_id":"ckwubwol4001ny4v23od9gabh"},{"name":"其他","_id":"ckwubwola001sy4v25t8ea8ai"},{"name":"插件","_id":"ckwubwolc001xy4v2csrj7p7j"},{"name":"移动端开发","_id":"ckwubwolf0022y4v23en3adjt"},{"name":"工具","_id":"ckwubwolt002yy4v2b9m84q8m"},{"name":"计算机网络","_id":"ckwubwomo004py4v2ez6p998g"}]}}