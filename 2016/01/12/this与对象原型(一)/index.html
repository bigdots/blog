<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        yzg的个人站
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            YDKJS:this 与对象原型(一)
        </p>
        <hr>
    </div>
    <div class="post-content">
        <!-- TOC -->

<ul>
<li><a href="#this-%E8%BF%98%E6%98%AF-that">this 还是 that</a><ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-this">为什么要使用 this</a></li>
<li><a href="#%E5%9B%B0%E6%83%91">困惑</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-this">什么是 this</a></li>
</ul>
</li>
<li><a href="#this-%E8%B1%81%E7%84%B6%E5%BC%80%E6%9C%97">this 豁然开朗</a><ul>
<li><a href="#%E8%B0%83%E7%94%A8%E7%82%B9">调用点</a></li>
<li><a href="#this-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99">this 绑定规则</a></li>
<li><a href="#%E4%B8%80%E5%88%87%E7%9A%86%E6%9C%89%E9%A1%BA%E5%BA%8F">一切皆有顺序</a></li>
<li><a href="#%E5%88%A4%E5%AE%9A-this">判定 this</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="this-还是-that"><a href="#this-还是-that" class="headerlink" title="this 还是 that"></a>this 还是 that</h2><blockquote>
<p>this 是在每个函数作用域中自动定义的特殊标识符关键字。</p>
</blockquote>
<h3 id="为什么要使用-this"><a href="#为什么要使用-this" class="headerlink" title="为什么要使用 this"></a>为什么要使用 this</h3><ol>
<li><p>目标：</p>
<p> 允许函数对多个环境对象进行复用，而不是针对不同的环境重复定义。</p>
</li>
<li><p>实现：</p>
<ul>
<li><p>明确地将环境对象传递给函数。</p>
</li>
<li><p>通过 this 机制自动引用恰当的执行环境</p>
</li>
</ul>
</li>
<li><p>比较：</p>
<p> this 机制提供了更优雅的方式来隐含地传递一个对象引用。实现了更加干净的 API 设计和更容易的复用。</p>
</li>
</ol>
<h3 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h3><p>开发者在对 this 的理解上往往存在俩种误解：</p>
<ol>
<li><p>this 是函数自身的引用</p>
<p> 第一种常见的错误倾向是认为 this 指向函数自己。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 1,2,3,4,5</span></span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.count); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p> 上面 foo 被执行了五次，但是 foo.count 的值依然为 0，这说明 this 根本就不指向那个函数对象。</p>
</li>
<li><p>this 是函数词法作用域的引用</p>
<p> 第二种常见的对 this 指向的误解是认为它指向当前的函数作用域。这是一种严重的误导，this 不会以任何方式指向函数的词法作用域。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p> 如果 this 指向的是函数的词法作用域，那么执行 foo 的结果应该输出 2，但是显而易见，输出的并不是 3，这说明<strong>this 和词法作用域之间没有桥</strong>，不能使用 this 在词法作用域中查找东西。</p>
</li>
</ol>
<h3 id="什么是-this"><a href="#什么是-this" class="headerlink" title="什么是 this"></a>什么是 this</h3><p><strong>this 实际上是在函数被调用时建立的一个绑定，它指向什么完全是由函数的调用点(call-site)来决定的。</strong></p>
<p>this 不是编写时绑定而是运行时绑定，它依赖于函数调用的上下文条件。this 的绑定和函数声明的位置无关，反而和函数被调用的方式有关。</p>
<p>当一个函数被调用时，会创建一个执行环境（活动记录），它包括函数是从何处(call-stack)被调用的，函数是如何被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的 this 引用。</p>
<h2 id="this-豁然开朗"><a href="#this-豁然开朗" class="headerlink" title="this 豁然开朗"></a>this 豁然开朗</h2><p>this 完全是一个根据<strong>调用点</strong>而为每次函数调用建立的绑定。</p>
<h3 id="调用点"><a href="#调用点" class="headerlink" title="调用点"></a>调用点</h3><blockquote>
<p>调用点就是函数在代码中被调用的位置。</p>
</blockquote>
<p>要弄明白 this 指向，我们必须先寻找到调用点。</p>
<p>调用栈和调用点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈： baz -&gt; bar -&gt; foo</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈： baz -&gt; bar</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    foo(); <span class="comment">// foo的调用点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈： baz</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;baz&quot;</span>);</span><br><span class="line">    bar(); <span class="comment">// bar的调用点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// baz的调用点</span></span><br></pre></td></tr></table></figure>

<p><strong>调用点是影响 this 绑定的唯一因素。</strong></p>
<h3 id="this-绑定规则"><a href="#this-绑定规则" class="headerlink" title="this 绑定规则"></a>this 绑定规则</h3><ol>
<li><p>默认绑定</p>
<p> <strong>独立函数</strong>调用时，适用于这种规则。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p> 上述代码，this 指向了全局对象，这是为什么？</p>
<p> 这是因为对于默认绑定来说：如果没有在严格模式下运行，<strong>全局对象是唯一合法的</strong>。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>

<p>严格模式下，必须指明函数的调用者。</p>
<ol start="2">
<li><p>隐含绑定</p>
<p> 适用于调用者拥有一个环境对象（也称拥有者对象或容器对象）的情况。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p> 在这里，函数 foo 作为属性被添加到对象 obj 上，可以说这个函数被 obj 所“拥有”或“包含”。在函数 foo 调用的位置上，它被冠以一个指向 obj 的对象引用。</p>
<p> 隐含绑定的规则：当一个函数引用一个环境对象时，这个对象应当被用于函数调用的 this 绑定。</p>
<p> <strong>隐含丢失</strong></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>

<p> 尽管 bar 似乎是 obj.foo 的引用，但实际上它只是一个 foo 的 引用而已。另外从调用点看来，是独立函数调用，因此默认绑定规则起了作用。</p>
</li>
<li><p>明确绑定</p>
<ol>
<li><p><code>call</code> 和 <code>apply</code> 提供了一种直接指明函数 this 的方法。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call(obj); <span class="comment">//2</span></span><br><span class="line">foo.apply(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p> 这里使用了<code>call</code> 和 <code>apply</code>强制函数的 this 指向 obj 。</p>
<p> 如果第参数传递的是简单原始类型，那么这个原始类型会被包装在它的对象类型中。</p>
<p> <code>call</code> 和 <code>apply</code> 在绑定 this 的角度上没有任何区别。它们只是在参数的传递上有所区别。</p>
</li>
<li><p>硬绑定</p>
<p> 明确绑定仍存在一个问题：它还是无法解决隐含丢失。而硬绑定正是为了解决这一问题。</p>
<p> <strong>ES5 提供了 bind 这一工具用于硬绑定。</strong></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj);</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p> bind 返回一个硬编码的新函数，它使用你指定的 this 环境来调用原本的函数。</p>
<p> <strong>硬绑定其实是 明确绑定 的变种。</strong></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的bind函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(obj);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>new 绑定</p>
</li>
</ol>
<p>在 JS 中，构造器仅仅是一个函数，它们被前置的 new 操作符调用。它们不依附于类，也不初始化类。</p>
<p>当函数作为 new 表达式的一部分被调用时，它才是一个构造器：初始化这个新创建的对象。</p>
<p><strong>所以实际上，不存在“构造函数”这样的东西，而只有函数的构造期调用。</strong></p>
<p>当 new 表达式调用时：</p>
<ol>
<li>创建一个全新的对象；</li>
<li>将这个对象接入原型链</li>
<li>将这个对象设置为函数调用的 this 绑定</li>
<li>返回这个对象（需要排除函数返回一个它自己的对象的情况）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a);</span><br></pre></td></tr></table></figure>

<p>我们通过 new 来调用 foo，从而创建了一个新的对象，并将这个新对象作为 foo 调用的 this。这种方式实现了 new 绑定。</p>
<h3 id="一切皆有顺序"><a href="#一切皆有顺序" class="headerlink" title="一切皆有顺序"></a>一切皆有顺序</h3><p>new 绑定 &gt; 明确绑定 &gt; 隐含绑定 &gt; 默认绑定</p>
<h3 id="判定-this"><a href="#判定-this" class="headerlink" title="判定 this"></a>判定 this</h3><p>通过上面的顺序，我们可以轻易地判定 this 的指向了：</p>
<ul>
<li>如果使用了 new ，那么 this 就是新构建的对象；</li>
<li>如果使用了 apply／call 和 bind，this 就是明确制定的对象；</li>
<li>如果函数存在调用者，也就是环境对象，那么 this 就是那个环境对象；</li>
<li>否则，使用默认规则。严格模式下为 undefinde,否则则是全局对象。</li>
</ul>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="cbTPc8u7ho07U6TmlFC0RjK7">
<input type="hidden" id="valine_appKey" value="4hH8asmBIHG3iSVSUt8Hu5OP">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>