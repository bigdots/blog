<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        yzg的个人站
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            javascript 基础
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/996671d4dcc4">内存</a></h2><h3 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h3><ol>
<li><p>堆内存类似书架，无关顺序，按地址取。</p>
</li>
<li><p>栈内存类似羽毛球桶，先进后出。</p>
</li>
</ol>
<h3 id="javascript中的内存"><a href="#javascript中的内存" class="headerlink" title="javascript中的内存"></a>javascript中的内存</h3><ol>
<li>严格意义上来说，javascript只有堆内存，基本类型值储存在变量对象中。而变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li>引用类型值： （对象），长度不固定，是按引用访问的。</li>
<li>基本类型值：（Undefined、Null、Boolean、Number、String），长度固定，按值访问。</li>
</ol>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ol>
<li>分配内存  （定义变量时）</li>
<li>使用分配到的内存（数据处理等读、写操作）</li>
<li>不需要时将其释放、归还 （简单方法是将null赋值给变量）</li>
</ol>
<h2 id="垃圾回收："><a href="#垃圾回收：" class="headerlink" title="垃圾回收："></a>垃圾回收：</h2><ol>
<li>在局部作用域中，当函数执行完毕，回收局部变量的值。</li>
<li>在全局作用域中，当一个值不再有变量引用它时，会进行回收。</li>
</ol>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>对象的简单赋值，只是浅拷贝，只是把引用拷贝给了新变量，并没有生成一个全新的对象值。</p>
<h2 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/a6d37c77e8db">执行上下文（Execution Context）</a></h2><p>一个执行上下文会形成一个作用域。一个JavaScript程序中，会有一个全局的执行上下文，并且遇到函数和eval都会生成一个新的执行上下文。</p>
<p>JavaScript引擎以堆栈的方式来处理执行上下文，这个堆栈，我们称其为**函数调用栈(call stack)**。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。每个执行上下文中的代码执行完毕后，这个执行上下文就会从从栈中弹出。</p>
<p>过程： </p>
<ol>
<li>生成全局执行上下文，将其放入栈底</li>
<li>执行栈顶上下文中的代码（一开始是全局执行上下文），遇到函数或者eval从而生成新的执行上下文，放入栈顶，并执行其中代码。</li>
<li>当前执行上下文中的代码执行完毕，当前执行上下文从栈中弹出，继续步骤2，直至栈中只剩下全局上下文</li>
<li>全局上下文只有唯一的一个，在应用关闭时出栈</li>
</ol>
<h3 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h3><ul>
<li>创建阶段<ul>
<li>创建变量对象</li>
<li>建立作用域链</li>
<li>以及确定this的指向</li>
</ul>
</li>
<li>代码执行阶段（此时变量对象成为活动对象）<ul>
<li>变量赋值</li>
<li>函数引用</li>
<li>执行其他代码</li>
</ul>
</li>
</ul>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/330b1505e41d">变量对象</a></h2><ol>
<li>变量对象的创建: （理解变量提升）<ul>
<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>
<li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>
<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。</li>
</ul>
</li>
</ol>
<p>全局执行上下文的变量对象在浏览器中是window对象。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域是引擎根据标识符名称进行变量查找的规则。（标识符，指的是变量名或者函数名）</p>
<blockquote>
<p>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>
</blockquote>
<h3 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h3><p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段<strong>作用域</strong>会确定。执行阶段由引擎完成，主要任务是执行可执行代码，<strong>执行上下文</strong>在这个阶段创建。</p>
<p>作用域在编译阶段生成，执行上下文在执行阶段生成，作用域链是在执行上下文的创建阶段生成的。</p>
<p>当前作用域与上层作用域不是包含关系。作用域链就是一个形似糖葫芦的单方向通道。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的，指向当前执行上下文。</p>
<p>如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p>
<p>call，apply指定this指向的对象。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>通过new操作符调用构造函数，会经历以下4个阶段。</p>
<ul>
<li>创建一个新的对象；</li>
<li>将构造函数的this指向这个新对象；</li>
<li>为这个对象添加属性，方法等；</li>
<li>返回新对象。</li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。</p>
<p>可以通过闭包来实现公有变量和公有方法。</p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString/vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。其中valueOf会比toString后执行</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="cbTPc8u7ho07U6TmlFC0RjK7">
<input type="hidden" id="valine_appKey" value="4hH8asmBIHG3iSVSUt8Hu5OP">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>