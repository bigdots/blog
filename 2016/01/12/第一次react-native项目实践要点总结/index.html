<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        yzg的个人站
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            第一次react-native项目实践要点总结
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>今天完成了我的第一个react-native项目的封包，当然其间各种环境各种坑，同时，成就感也是满满的。这里总结一下使用react-native的一些入门级重要点（不涉及环境）。<strong>注意：阅读需要语法基础： ES6 、react 、JSX</strong></p>
<p>我对react-native的理解简而言之就是 ：<strong>react的语法</strong> ＋ <strong>native的组件</strong></p>
<h2 id="组件的创建声明"><a href="#组件的创建声明" class="headerlink" title="组件的创建声明"></a>组件的创建声明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class HelloWorldApp extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">  	super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Text&gt;Hello world!&lt;/Text&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。当你在其他的组件中调用这个组件时，就会实例化这个“类”（即组件）。</p>
<p><strong>注意：组件名需要大写</strong></p>
<h2 id="组件的导出、引用与注册"><a href="#组件的导出、引用与注册" class="headerlink" title="组件的导出、引用与注册"></a>组件的导出、引用与注册</h2><p>在ES6中，新增了import和export俩个关键字来导入导出模块。react－native的组件也是采用的这俩个关键字。</p>
<p>俩种方式：</p>
<p>第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">导出：</span><br><span class="line">export default class HelloWorldApp extends Component&#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Text&gt;Hello world!&lt;/Text&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line">导入：</span><br><span class="line">import HelloWorldApp from &quot;../..&quot;</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">导出：</span><br><span class="line">class HelloWorldApp extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Text&gt;Hello world!&lt;/Text&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;HelloWorldApp&#125;</span><br><span class="line"></span><br><span class="line">导入：</span><br><span class="line">import ｛ HelloWorldApp ｝ from &quot;../..&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>后缀名自动获取（文件会获取拥有与之相应后缀名的文件）</p>
<p> 在组件模块的导入过程中，如果这个模块是分设备的，也就有俩个文件：xxx.android.js和xxx.ios.js，这些后缀（android和ios）是不需要的，在不同的设备环境中，它自动获取相应后缀名的文件，即ios包会自动获取xxx.ios，android包会自动获取xxx.android。</p>
</li>
<li><p>后缀名自动忽略（文件会自动忽略拥有与之不相应后缀名的文件）</p>
<p> 一个ios和android的公共模块文件，即共用代码模块文件，命名不能加ios和android后缀，否则，ios包取不到有androis后缀的文件，android取不到有ios后缀的文件。</p>
</li>
</ol>
<p>实例解释上述：<br>现在有以下五个文件：</p>
<p>index.ios.js </p>
<p>index.android.js</p>
<p>say.android.js</p>
<p>say.ios.js</p>
<p>HelloWorldApp.android.js   </p>
<p>我们想要分别在index.ios.js 和 index.android.js引入其他三个模块。我们只要在index.ios.js 和 index.android.js文件中如下写法就行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//这里，index.ios.js会自动获取say.ios.js的模块；index.android.js会自动获取say.android.js的模块</span><br><span class="line"></span><br><span class="line">import 模块名 from &quot;./say&quot;;</span><br><span class="line"></span><br><span class="line">//这里，HelloWorldApp.android.js 是一个公共模块，index.android.js能成功获取到./HelloWorldApp；但是index.ios.js则无法获取到HelloWorldApp模块，因为index.ios.js会忽略android后缀名的模块文件</span><br><span class="line"></span><br><span class="line">import 模块名 from &quot;./HelloWorldApp&quot;</span><br></pre></td></tr></table></figure>


<h2 id="react组件的生命周期"><a href="#react组件的生命周期" class="headerlink" title="react组件的生命周期"></a>react组件的生命周期</h2><p><img src="https://raw.githubusercontent.com/bigdots/blog/master/images/201601/react-component.jpg"></p>
<p>项目中使用组件的时候，纠结于componentWillMount,componentDidMount…，直到看到这张图豁然开朗(so，图是盗的)。需要注意的是，这张图应该比较老了，其中的getDefaultProps和<br>getInitialState这俩个函数是ES5的写法了，ES6语法中，constructor方法中代替了getDefaultProps／getInitialState，我们可以在其内直接初始化props和state。</p>
<p>生命周期：</p>
<ol>
<li><p>实例化（初始化）</p>
<ul>
<li><p>constructor</p>
<p>  设置默认的props-&gt;设置默认的state</p>
</li>
<li><p>componentWillMount</p>
<p>  完成渲染之前执行，此时可以设置state</p>
</li>
<li><p>render</p>
<p>  创建虚拟DOM，此时不能修改state</p>
</li>
<li><p>componentDidMount</p>
<p>  真实的DOM渲染完毕，此时可以更改组件props及state</p>
</li>
</ul>
</li>
<li><p>存在期：(这个时候的主要行为是状态的改变导致组件更新)</p>
<ul>
<li><p>componentWillReceiveProps</p>
<p>  组件接收到新的props,此时可以更改组件props及state</p>
</li>
<li><p>shouldComponentUpdate</p>
<p>  操作组件是否应当渲染新的props或state，返回布尔值，首次渲染该方法不会被调用。</p>
</li>
<li><p>componentWillUpdate</p>
<p>  接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。</p>
</li>
<li><p>render</p>
<p>  创建（更新）虚拟DOM</p>
</li>
<li><p>componentDidUpdate<br>组件真实的DOM更新完成</p>
</li>
</ul>
</li>
<li><p>销毁期：</p>
<ul>
<li>componentWillUnmount<br>组件被移除之前，主要用于做一些清理工作，比如事件监听</li>
</ul>
</li>
</ol>
<h2 id="react-的-props-和-state"><a href="#react-的-props-和-state" class="headerlink" title="react 的 props 和 state"></a>react 的 props 和 state</h2><ol>
<li><p>props（属性）</p>
<p> 当我们调用这些组件时，我们如果为每一个组件传递了不同的属性，这个属性就是props。比如下例中，我们调用了HelloWorldApp组件，并为其设置了一个date属性，则我们可以在HelloWorldApp的组件里，通过this.props.date来获取这一属性值。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HelloWorldApp date = &#123;2016&#125;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>state（状态）</p>
<p> <strong>state需要在constructor中初始化，然后通过调用setState方法修改。</strong><br> 通过上面的组件生命周期图，我们可以看出，state是一个状态机，state的改变会引起shouldcomponentupdate、componentwillupdate、rendner…一系列方法的执行，<strong>视图会重新渲染</strong>。所以，如果需要动态地改变组件的数据或试图，请操作state。</p>
</li>
</ol>
<h2 id="react组件之间的通信"><a href="#react组件之间的通信" class="headerlink" title="react组件之间的通信"></a>react组件之间的通信</h2><ol>
<li><p>子组件接收父组件的改变信号</p>
<p> 简单：当父组件改变时，直接向子组件传递props</p>
</li>
<li><p>父组件接收子组件的改变信号<br> 在父组件中定义一个方法，并通过props传递给子组件，子组件改变时，通过调用这个父组件传递过来的方法，从而实现在父组件中执行该方法。</p>
</li>
<li><p>非父子关系组件之间的通信</p>
<p> <code>RCTDeviceEventEmitter</code>模块：它有俩个方法：emit和addListener，一个发送，一个接收。</p>
<p> RCTDeviceEventEmitter.emit(notifName,param);</p>
<p> RCTDeviceEventEmitter.addListener(notifName,callback)</p>
</li>
</ol>
<h2 id="native-事件对象"><a href="#native-事件对象" class="headerlink" title="native 事件对象"></a>native 事件对象</h2><p>在项目中，遇到一个控制scrollview组件滚动的需求，需要获取当前滚动的坐标，当时找了好久的文档，没找到解决方案，后来发现可以通过这样来传入一个事件对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ScrollView ref=&#x27;scrollView&#x27; onScroll = &#123;(e) =&gt; &#123;this.scrollhShow(e);&#125;&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>然后在函数中读取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollhShow(e) &#123;</span><br><span class="line">	console.log(e.nativeEvent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当当当当，我要的滚动视图的坐标值就在里面了。</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="cbTPc8u7ho07U6TmlFC0RjK7">
<input type="hidden" id="valine_appKey" value="4hH8asmBIHG3iSVSUt8Hu5OP">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>