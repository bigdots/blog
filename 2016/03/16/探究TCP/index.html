<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        yzg的个人站
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            探究TCP
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>我的博客:<a target="_blank" rel="noopener" href="http://bigdots.github.io/">http://bigdots.github.io</a>、<a target="_blank" rel="noopener" href="http://www.cnblogs.com/yzg1/">http://www.cnblogs.com/yzg1/</a></p>
<h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><blockquote>
<p>OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
</blockquote>
<span id="more"></span>

<p><img src="/images/201601/osi.jpg"></p>
<p>其中TCP处理transport层，主要是用来建立可靠的连接。 而建立连接的基础</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><blockquote>
<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
</blockquote>
<p>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</p>
<p><img src="/images/201601/TCP.jpg"></p>
<ul>
<li><p>Source Port / Destination Port:这个就是客户端口(源端口)和服务器端口(目的端口).端口就是用来区别主机中的不同进程，通过结合源IP和目的IP结合，得出唯一的TCP连接。</p>
</li>
<li><p>Sequence Number(seqNumber): 一般由客户端发送，用来表示报文段中第一个数据字节在数据流中的序号，主要用来解决网络包乱序的问题。</p>
</li>
<li><p>Acknowledgment Number(ACK): 即就是用来存放客户端发来的seqNumber的下一个信号(seqNumber+1). 只有当TCP flags中的ACK为1时才有效. 主要是用来解决不丢包的问题。</p>
</li>
<li><p>TCP flags: TCP中有6个首部，用来控制TCP连接的状态.取值为0,1.这6个有:URG，ACK，PSH，RST，SYN，FIN.</p>
<ul>
<li><p>URG 当为1时，用来保证TCP连接不被中断, 并且将该次TCP内容数据的紧急程度提升(就是告诉电脑，你丫赶快把这个给resolve了)</p>
</li>
<li><p>ACK 通常是服务器端返回的。 用来表示应答是否有效。 1为有效，0为无效</p>
</li>
<li><p>PSH 表示，当数据包得到后，立马给应用程序使用(PUSH到最顶端)</p>
</li>
<li><p>RST 用来确保TCP连接的安全。 该flag用来表示 一个连接复位的请求。如果发生错误连接，则reset一次，重新连。当然也可以用来拒绝非法数据包。</p>
</li>
<li><p>SYN 同步的意思,通常是由客户端发送，用来建立连接的。第一次握手时: SYN:1 , ACK:0. 第二次握手时: SYN:1 ACK:1</p>
</li>
<li><p>FIN 用来表示是否结束该次TCP连接。 通常当你的数据发送完后，会自动带上FIN 然后断开连接</p>
</li>
</ul>
</li>
</ul>
<h2 id="TCP三次握手——建立链接"><a href="#TCP三次握手——建立链接" class="headerlink" title="TCP三次握手——建立链接"></a>TCP三次握手——建立链接</h2><p><img src="/images/201601/tcp_3.jpg"></p>
<p>(图中flag说明:SYN包表示标志位syn=1,ACK包表示标志位ack=1,SYN+ACK包表示标志位syn=1,ack=1)</p>
<p>现在，我们来正式进入3次握手环节。</p>
<ul>
<li><p>第一次握手. 客户端向服务器发送一个SYN包，并且添加上seqNumber(假设为x),然后进入SYN_SEND状态，并且等待服务器的确认。</p>
</li>
<li><p>第二次握手: 服务器接受SYN包，并且进行确认，如果该请求有效，则将TCP flags中的ACK 标志位置1，然后将AckNumber置为(seqNumber+1)，并且再添加上自己的seqNumber(y),完成后，返回给客户端.服务器进入SYN_RECV状态.(这里服务端是发送SYN+ACK包)</p>
</li>
<li><p>第三次握手 客户端接受ACK+SYN报文后，获取到服务器发送AckNumber(y), 并且将新头部的AckNumber变为(y+1).然后发送给服务器，完成TCP3次连接。此时服务器和客户端都进入ESTABLISHED状态.</p>
</li>
</ul>
<h2 id="为什么只有3次握手，而不是4次，或者2次"><a href="#为什么只有3次握手，而不是4次，或者2次" class="headerlink" title="为什么只有3次握手，而不是4次，或者2次?"></a>为什么只有3次握手，而不是4次，或者2次?</h2><p>假如是2次的话， 可能会出现这样一个情况。</p>
<p>当客户端发送一次请求A后，但是A在网络延迟了很久， 接着客户端又发送了一次B，但是此时A已经无效了。接着服务器相应了B，并返回TCP连接头，建立连接(这里就2次哈)。 然后，A 历经千山万水终于到服务器了，服务器一看有请求来了，则接受，由于一开始A带着的TCP格式都是正确的，那么服务器，理所应当的也返回成功连接的flag，但是，此时客户端已经判断该次请求无效，废弃了。然后服务器，就这么一直挂着(浪费资源)，造成的一个问题是，md, 这个锅是谁的?所以，为了保险起见，再补充一次连接就可以了。所以3次是最合适的。在Chinese中，以3为起称为多，如果你用4，5，6，7，8…次的话，这不更浪费吗?</p>
<h2 id="TCP四次握手——关闭链接"><a href="#TCP四次握手——关闭链接" class="headerlink" title="TCP四次握手——关闭链接"></a>TCP四次握手——关闭链接</h2><p>由于TCP连 接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<ul>
<li>TCP客 户端发送一个FIN，用来关闭客户到服务器的数据传送。</li>
<li>服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器关闭客户端的连接，发送一个FIN给客户端。</li>
<li>客户段发回ACK报文确认，并将确认序号设置为收到序号加1。</li>
</ul>
<p>参考文章：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MjM5OTkwOTA5Mw==&mid=409908127&idx=1&sn=56a1110d6c22571c04ce13e889aeac87&scene=0#wechat_redirect">《让你升级的网络知识》</a></p>
<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="cbTPc8u7ho07U6TmlFC0RjK7">
<input type="hidden" id="valine_appKey" value="4hH8asmBIHG3iSVSUt8Hu5OP">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>