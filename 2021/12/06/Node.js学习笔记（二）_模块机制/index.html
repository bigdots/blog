<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        yzg的个人站
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            Node.js学习笔记（二）_模块
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>模块是 Node.js 应用程序的基本组成部分,文件和模块是一一对应的。一个 Node.js 文件就是一个模块,这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。</p>
<p>由于JavaScript没有模块系统，所以Node.js依靠CommonJS规范自身实现了模块系统。</p>
<h2 id="模块的简单使用——exports-、require-和-module"><a href="#模块的简单使用——exports-、require-和-module" class="headerlink" title="模块的简单使用——exports 、require 和 module"></a>模块的简单使用——exports 、require 和 module</h2><p>在编写和使用每个模块时，Node.js都有require、exports、module三个预先定义好的变量可供使用。</p>
<ol>
<li><p>exports</p>
<p> <code>exports</code>对象是当前模块的导出对象，用于导出模块公有方法和属性。<br> 事实上,exports 本身仅仅是一个普通的空对象,即 {},它专门用来声明接口。例如：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//module.js</span><br><span class="line">exports.sayHello = function(name) &#123; </span><br><span class="line">	console.log(&#x27;Hello &#x27; 	+ name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>require</p>
<p> <code>require</code>函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。例如：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">var myModule = require(&#x27;./module&#x27;);</span><br><span class="line">myModule.sayHello(&quot;node&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>module</p>
<p> 通过module对象可以访问到当前模块的一些相关信息，但最多的用途是覆盖 exports。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//module.js</span><br><span class="line">module.exports = function(name) &#123; </span><br><span class="line">	console.log(&#x27;Hello &#x27; 	+ name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//index.js</span><br><span class="line">var sayHello = require(&#x27;./module&#x27;);</span><br><span class="line">sayHello(&quot;node&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="模块进阶——模块载入策略"><a href="#模块进阶——模块载入策略" class="headerlink" title="模块进阶——模块载入策略"></a>模块进阶——模块载入策略</h2><p>Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。原生模块在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类文件模块是动态加载的，加载速度比原生模块慢。</p>
<h3 id="内部实现机制"><a href="#内部实现机制" class="headerlink" title="内部实现机制"></a>内部实现机制</h3><p>加载文件模块的工作，主要由原生模块module来实现和完成，该原生模块在启动时已经被加载，进程直接调用到runMain静态方法。</p>
<p><strong>Module源码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Module(id, parent) &#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.exports = &#123;&#125;;</span><br><span class="line">  this.parent = parent;</span><br><span class="line">  if (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">    parent.children.push(this);</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  this.filename = null;</span><br><span class="line">  this.loaded = false;</span><br><span class="line">  this.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块解析流程：</p>
<ol>
<li><p>命令行执行主模块</p>
<p> 命令行执行主模块</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// bootstrap main module.</span><br><span class="line">Module.runMain = function() &#123;</span><br><span class="line">  // Load the main module--the command line argument.</span><br><span class="line">  Module._load(process.argv[1], null, true);</span><br><span class="line">  // Handle any nextTicks added in the first tick of the program</span><br><span class="line">  process._tickCallback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理模块</p>
<p> Module.runMain方法会在最后执行_load静态方法，该方法又会在分析文件名之后执行:</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//实例化Module函数</span><br><span class="line">var module = new Module(id, parent);</span><br></pre></td></tr></table></figure>
<p> 并根据文件路径<strong>缓存</strong>当前模块对象，该模块实例对象则根据文件名加载。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.load(filename);</span><br></pre></td></tr></table></figure>
<p> 这时，Node.js会根据不同文件模块类型的后缀名来决定加载方法。</p>
<ul>
<li>js：通过fs模块同步读取js文件并编译执行。</li>
<li>node：通过C/C++进行编写的Addon。通过dlopen方法进行加载。</li>
<li>json：读取文件，调用JSON.parse解析加载。</li>
</ul>
</li>
<li><p>输出结果</p>
<p> 最后js文件形式的模块会变成以下形式的内容：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">   	var circle = require(&#x27;./circle.js&#x27;);</span><br><span class="line">    	console.log(&#x27;The area of a circle of radius 4 is &#x27; +circle.area(4));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 所以此时，主模块内可以使用exports, require, module等变量了，而其他模块又会通过require引进主模块，require方法会同runMain一样调用_load静态方法，以此类推。</p>
<p> <strong>require源码:</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 传入模块路径作为参数. 返回 模块的exports属性.</span><br><span class="line"></span><br><span class="line">Module.prototype.require = function(path) &#123;</span><br><span class="line">  assert(path, &#x27;missing path&#x27;);</span><br><span class="line">  assert(typeof path === &#x27;string&#x27;, &#x27;path must be a string&#x27;);</span><br><span class="line">  return Module._load(path, this, /* isMain */ false);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li><p>console.log(this)在浏览器和Node中分别打印出什么？</p>
<p> 答：显然浏览器中直接打印this指向Window对象，而在Node中，我们编写的文件其实外面都包裹了一层函数，而且该函数执行时强制apply将this指向了module.exports，因此此处打印为{}。</p>
</li>
<li><p>为什么require、__filename、__dirname、module、exports等几个变量并没有定义在app.js 文件中，但是这个方法却存在的原因。</p>
<p> 答：这里提到的所有属性均是_load方法中我们编写的js文件外层包裹函数提供给我们的，因此可以直接调用。</p>
</li>
</ol>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="cbTPc8u7ho07U6TmlFC0RjK7">
<input type="hidden" id="valine_appKey" value="4hH8asmBIHG3iSVSUt8Hu5OP">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>